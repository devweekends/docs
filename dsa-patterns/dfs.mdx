---
title: "Depth-First Search (DFS)"
description: "Master DFS for trees, graphs, and recursive exploration problems"
icon: "arrow-down-long"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/04-dfs.svg"
  alt="DFS Pattern"
/>

## What is DFS?

**Depth-First Search** explores as far as possible along each branch before backtracking. It uses a stack (explicit or via recursion) to track the path and is ideal for problems requiring complete path exploration.

## When to Use

<CardGroup cols={2}>
  <Card title="Tree Traversals" icon="tree">
    Preorder, inorder, postorder traversals
  </Card>
  <Card title="Path Finding" icon="route">
    Finding all paths, checking path existence
  </Card>
  <Card title="Connected Components" icon="circle-nodes">
    Counting islands, detecting cycles
  </Card>
  <Card title="Backtracking" icon="rotate-left">
    Permutations, combinations, subset generation
  </Card>
</CardGroup>

## Pattern Variations

### 1. Tree DFS (Recursive)

<CodeGroup>
```python Python
def tree_dfs(root):
    """Basic tree DFS traversal"""
    if not root:
        return
    
    # Preorder: process before children
    print(root.val)
    
    tree_dfs(root.left)
    
    # Inorder: process between children (BST gives sorted order)
    
    tree_dfs(root.right)
    
    # Postorder: process after children
```

```java Java
public void treeDfs(TreeNode root) {
    // Basic tree DFS traversal
    if (root == null) {
        return;
    }
    
    // Preorder: process before children
    System.out.println(root.val);
    
    treeDfs(root.left);
    
    // Inorder: process between children (BST gives sorted order)
    
    treeDfs(root.right);
    
    // Postorder: process after children
}
```

```cpp C++
void treeDfs(TreeNode* root) {
    // Basic tree DFS traversal
    if (root == nullptr) {
        return;
    }
    
    // Preorder: process before children
    cout << root->val << endl;
    
    treeDfs(root->left);
    
    // Inorder: process between children (BST gives sorted order)
    
    treeDfs(root->right);
    
    // Postorder: process after children
}
```
</CodeGroup>

### 2. Graph DFS with Visited Set

<CodeGroup>
```python Python
def graph_dfs(graph, start):
    """DFS on adjacency list graph"""
    visited = set()
    result = []
    
    def dfs(node):
        if node in visited:
            return
        
        visited.add(node)
        result.append(node)
        
        for neighbor in graph[node]:
            dfs(neighbor)
    
    dfs(start)
    return result
```

```java Java
public List<Integer> graphDfs(Map<Integer, List<Integer>> graph, int start) {
    // DFS on adjacency list graph
    Set<Integer> visited = new HashSet<>();
    List<Integer> result = new ArrayList<>();
    
    dfs(graph, start, visited, result);
    return result;
}

private void dfs(Map<Integer, List<Integer>> graph, int node, 
                 Set<Integer> visited, List<Integer> result) {
    if (visited.contains(node)) {
        return;
    }
    
    visited.add(node);
    result.add(node);
    
    for (int neighbor : graph.getOrDefault(node, new ArrayList<>())) {
        dfs(graph, neighbor, visited, result);
    }
}
```

```cpp C++
vector<int> graphDfs(unordered_map<int, vector<int>>& graph, int start) {
    // DFS on adjacency list graph
    unordered_set<int> visited;
    vector<int> result;
    
    function<void(int)> dfs = [&](int node) {
        if (visited.count(node)) {
            return;
        }
        
        visited.insert(node);
        result.push_back(node);
        
        for (int neighbor : graph[node]) {
            dfs(neighbor);
        }
    };
    
    dfs(start);
    return result;
}
```
</CodeGroup>

### 3. Grid DFS (Island Problems)

<CodeGroup>
```python Python
def count_islands(grid):
    """Count connected components in a grid"""
    if not grid:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    count = 0
    
    def dfs(r, c):
        if r < 0 or r >= rows or c < 0 or c >= cols:
            return
        if grid[r][c] != '1':
            return
        
        grid[r][c] = '0'  # Mark visited
        
        # Explore 4 directions
        dfs(r + 1, c)
        dfs(r - 1, c)
        dfs(r, c + 1)
        dfs(r, c - 1)
    
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':
                count += 1
                dfs(r, c)
    
    return count
```

```java Java
public int countIslands(char[][] grid) {
    // Count connected components in a grid
    if (grid == null || grid.length == 0) {
        return 0;
    }
    
    int rows = grid.length, cols = grid[0].length;
    int count = 0;
    
    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols; c++) {
            if (grid[r][c] == '1') {
                count++;
                dfs(grid, r, c);
            }
        }
    }
    
    return count;
}

private void dfs(char[][] grid, int r, int c) {
    int rows = grid.length, cols = grid[0].length;
    
    if (r < 0 || r >= rows || c < 0 || c >= cols) {
        return;
    }
    if (grid[r][c] != '1') {
        return;
    }
    
    grid[r][c] = '0';  // Mark visited
    
    // Explore 4 directions
    dfs(grid, r + 1, c);
    dfs(grid, r - 1, c);
    dfs(grid, r, c + 1);
    dfs(grid, r, c - 1);
}
```

```cpp C++
int countIslands(vector<vector<char>>& grid) {
    // Count connected components in a grid
    if (grid.empty()) {
        return 0;
    }
    
    int rows = grid.size(), cols = grid[0].size();
    int count = 0;
    
    function<void(int, int)> dfs = [&](int r, int c) {
        if (r < 0 || r >= rows || c < 0 || c >= cols) {
            return;
        }
        if (grid[r][c] != '1') {
            return;
        }
        
        grid[r][c] = '0';  // Mark visited
        
        // Explore 4 directions
        dfs(r + 1, c);
        dfs(r - 1, c);
        dfs(r, c + 1);
        dfs(r, c - 1);
    };
    
    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols; c++) {
            if (grid[r][c] == '1') {
                count++;
                dfs(r, c);
            }
        }
    }
    
    return count;
}
```
</CodeGroup>

### 4. DFS with Path Tracking

<CodeGroup>
```python Python
def find_all_paths(graph, start, end):
    """Find all paths from start to end"""
    all_paths = []
    
    def dfs(node, path):
        if node == end:
            all_paths.append(path[:])
            return
        
        for neighbor in graph[node]:
            if neighbor not in path:  # Avoid cycles
                path.append(neighbor)
                dfs(neighbor, path)
                path.pop()  # Backtrack
    
    dfs(start, [start])
    return all_paths
```

```java Java
public List<List<Integer>> findAllPaths(Map<Integer, List<Integer>> graph, 
                                         int start, int end) {
    // Find all paths from start to end
    List<List<Integer>> allPaths = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    path.add(start);
    
    dfs(graph, start, end, path, allPaths);
    return allPaths;
}

private void dfs(Map<Integer, List<Integer>> graph, int node, int end,
                 List<Integer> path, List<List<Integer>> allPaths) {
    if (node == end) {
        allPaths.add(new ArrayList<>(path));
        return;
    }
    
    for (int neighbor : graph.getOrDefault(node, new ArrayList<>())) {
        if (!path.contains(neighbor)) {  // Avoid cycles
            path.add(neighbor);
            dfs(graph, neighbor, end, path, allPaths);
            path.remove(path.size() - 1);  // Backtrack
        }
    }
}
```

```cpp C++
vector<vector<int>> findAllPaths(unordered_map<int, vector<int>>& graph,
                                  int start, int end) {
    // Find all paths from start to end
    vector<vector<int>> allPaths;
    vector<int> path = {start};
    unordered_set<int> visited = {start};
    
    function<void(int)> dfs = [&](int node) {
        if (node == end) {
            allPaths.push_back(path);
            return;
        }
        
        for (int neighbor : graph[node]) {
            if (!visited.count(neighbor)) {  // Avoid cycles
                visited.insert(neighbor);
                path.push_back(neighbor);
                dfs(neighbor);
                path.pop_back();  // Backtrack
                visited.erase(neighbor);
            }
        }
    };
    
    dfs(start);
    return allPaths;
}
```
</CodeGroup>

### 5. Iterative DFS with Stack

<CodeGroup>
```python Python
def iterative_dfs(graph, start):
    """DFS using explicit stack"""
    visited = set()
    stack = [start]
    result = []
    
    while stack:
        node = stack.pop()
        
        if node in visited:
            continue
        
        visited.add(node)
        result.append(node)
        
        # Add neighbors in reverse order for correct traversal
        for neighbor in reversed(graph[node]):
            if neighbor not in visited:
                stack.append(neighbor)
    
    return result
```

```java Java
public List<Integer> iterativeDfs(Map<Integer, List<Integer>> graph, int start) {
    // DFS using explicit stack
    Set<Integer> visited = new HashSet<>();
    Stack<Integer> stack = new Stack<>();
    List<Integer> result = new ArrayList<>();
    
    stack.push(start);
    
    while (!stack.isEmpty()) {
        int node = stack.pop();
        
        if (visited.contains(node)) {
            continue;
        }
        
        visited.add(node);
        result.add(node);
        
        List<Integer> neighbors = graph.getOrDefault(node, new ArrayList<>());
        for (int i = neighbors.size() - 1; i >= 0; i--) {
            if (!visited.contains(neighbors.get(i))) {
                stack.push(neighbors.get(i));
            }
        }
    }
    
    return result;
}
```

```cpp C++
vector<int> iterativeDfs(unordered_map<int, vector<int>>& graph, int start) {
    // DFS using explicit stack
    unordered_set<int> visited;
    stack<int> stk;
    vector<int> result;
    
    stk.push(start);
    
    while (!stk.empty()) {
        int node = stk.top();
        stk.pop();
        
        if (visited.count(node)) {
            continue;
        }
        
        visited.insert(node);
        result.push_back(node);
        
        // Add neighbors in reverse order
        vector<int>& neighbors = graph[node];
        for (int i = neighbors.size() - 1; i >= 0; i--) {
            if (!visited.count(neighbors[i])) {
                stk.push(neighbors[i]);
            }
        }
    }
    
    return result;
}
```
</CodeGroup>

## Classic Problems

<AccordionGroup>
  <Accordion title="1. Number of Islands" icon="water">
    **Pattern**: Grid DFS marking visited cells
    
    **Key**: Sink the island as you explore it
  </Accordion>
  
  <Accordion title="2. Clone Graph" icon="clone">
    **Pattern**: DFS with HashMap for visited/cloned nodes
    
    **Key**: Create clone first, then connect neighbors
  </Accordion>
  
  <Accordion title="3. Course Schedule" icon="graduation-cap">
    **Pattern**: Cycle detection with coloring (white/gray/black)
    
    **Key**: Gray nodes indicate cycle in current path
  </Accordion>
  
  <Accordion title="4. Word Search" icon="spell-check">
    **Pattern**: Grid DFS with backtracking
    
    **Key**: Mark cell temporarily, restore after exploration
  </Accordion>
</AccordionGroup>

## Cycle Detection

<CodeGroup>
```python Python
def has_cycle_directed(graph, n):
    """Detect cycle in directed graph using DFS coloring"""
    WHITE, GRAY, BLACK = 0, 1, 2
    color = [WHITE] * n
    
    def dfs(node):
        color[node] = GRAY  # Currently exploring
        
        for neighbor in graph[node]:
            if color[neighbor] == GRAY:  # Back edge = cycle
                return True
            if color[neighbor] == WHITE and dfs(neighbor):
                return True
        
        color[node] = BLACK  # Fully explored
        return False
    
    for i in range(n):
        if color[i] == WHITE and dfs(i):
            return True
    
    return False
```

```java Java
public boolean hasCycleDirected(List<List<Integer>> graph, int n) {
    // Detect cycle in directed graph using DFS coloring
    int[] color = new int[n];  // 0=WHITE, 1=GRAY, 2=BLACK
    
    for (int i = 0; i < n; i++) {
        if (color[i] == 0 && dfs(graph, i, color)) {
            return true;
        }
    }
    
    return false;
}

private boolean dfs(List<List<Integer>> graph, int node, int[] color) {
    color[node] = 1;  // GRAY - currently exploring
    
    for (int neighbor : graph.get(node)) {
        if (color[neighbor] == 1) {  // Back edge = cycle
            return true;
        }
        if (color[neighbor] == 0 && dfs(graph, neighbor, color)) {
            return true;
        }
    }
    
    color[node] = 2;  // BLACK - fully explored
    return false;
}
```

```cpp C++
bool hasCycleDirected(vector<vector<int>>& graph, int n) {
    // Detect cycle in directed graph using DFS coloring
    vector<int> color(n, 0);  // 0=WHITE, 1=GRAY, 2=BLACK
    
    function<bool(int)> dfs = [&](int node) -> bool {
        color[node] = 1;  // GRAY - currently exploring
        
        for (int neighbor : graph[node]) {
            if (color[neighbor] == 1) {  // Back edge = cycle
                return true;
            }
            if (color[neighbor] == 0 && dfs(neighbor)) {
                return true;
            }
        }
        
        color[node] = 2;  // BLACK - fully explored
        return false;
    };
    
    for (int i = 0; i < n; i++) {
        if (color[i] == 0 && dfs(i)) {
            return true;
        }
    }
    
    return false;
}
```
</CodeGroup>

## Common Mistakes

<Warning>
**Avoid These Pitfalls:**
1. **Stack overflow**: Use iterative for deep recursion
2. **Forgetting visited check**: Can cause infinite loops
3. **Not restoring state**: Backtracking requires cleanup
4. **Wrong traversal order**: Preorder vs postorder matters
</Warning>

## Practice Problems

| Problem | Difficulty | Link |
|---------|------------|------|
| Number of Islands | Medium | [LeetCode 200](https://leetcode.com/problems/number-of-islands/) |
| Clone Graph | Medium | [LeetCode 133](https://leetcode.com/problems/clone-graph/) |
| Course Schedule | Medium | [LeetCode 207](https://leetcode.com/problems/course-schedule/) |
| Word Search | Medium | [LeetCode 79](https://leetcode.com/problems/word-search/) |
| Surrounded Regions | Medium | [LeetCode 130](https://leetcode.com/problems/surrounded-regions/) |

<Tip>
**Interview Tip**: When exploring all possibilities or finding paths, think DFS. When finding shortest path, think BFS.
</Tip>
