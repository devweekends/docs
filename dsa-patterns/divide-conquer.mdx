---
title: "Divide and Conquer"
description: "Break problems into subproblems, solve recursively, and combine results"
icon: "arrows-split-up-and-left"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/09-divide-conquer.svg"
  alt="Divide and Conquer Pattern"
/>

## What is Divide and Conquer?

**Divide and Conquer** splits a problem into smaller subproblems, solves them recursively, and combines results. Unlike DP, subproblems are typically non-overlapping.

## When to Use

<CardGroup cols={2}>
  <Card title="Sorting" icon="arrow-up-1-9">
    Merge Sort, Quick Sort
  </Card>
  <Card title="Searching" icon="magnifying-glass">
    Binary Search, finding kth element
  </Card>
  <Card title="Tree Problems" icon="tree">
    Height, diameter, subtree queries
  </Card>
  <Card title="Array Problems" icon="table-cells">
    Maximum subarray, closest pair
  </Card>
</CardGroup>

## The D and C Template

<CodeGroup>
```python Python
def divide_and_conquer(problem):
    # Base case
    if is_trivial(problem):
        return solve_directly(problem)
    
    # Divide
    subproblems = split(problem)
    
    # Conquer (recursive calls)
    sub_results = [divide_and_conquer(sub) for sub in subproblems]
    
    # Combine
    return merge(sub_results)
```

```java Java
public Result divideAndConquer(Problem problem) {
    // Base case
    if (isTrivial(problem)) {
        return solveDirectly(problem);
    }
    
    // Divide
    List<Problem> subproblems = split(problem);
    
    // Conquer (recursive calls)
    List<Result> subResults = new ArrayList<>();
    for (Problem sub : subproblems) {
        subResults.add(divideAndConquer(sub));
    }
    
    // Combine
    return merge(subResults);
}
```

```cpp C++
Result divideAndConquer(Problem problem) {
    // Base case
    if (isTrivial(problem)) {
        return solveDirectly(problem);
    }
    
    // Divide
    vector<Problem> subproblems = split(problem);
    
    // Conquer (recursive calls)
    vector<Result> subResults;
    for (auto& sub : subproblems) {
        subResults.push_back(divideAndConquer(sub));
    }
    
    // Combine
    return merge(subResults);
}
```
</CodeGroup>

## Pattern Variations

### 1. Merge Sort

<CodeGroup>
```python Python
def merge_sort(arr):
    """O(n log n) stable sort"""
    if len(arr) <= 1:
        return arr
    
    # Divide
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    # Combine (merge)
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```

```java Java
public class MergeSort {
    public int[] mergeSort(int[] arr) {
        // O(n log n) stable sort
        if (arr.length <= 1) {
            return arr;
        }
        
        // Divide
        int mid = arr.length / 2;
        int[] left = mergeSort(Arrays.copyOfRange(arr, 0, mid));
        int[] right = mergeSort(Arrays.copyOfRange(arr, mid, arr.length));
        
        // Combine (merge)
        return merge(left, right);
    }
    
    private int[] merge(int[] left, int[] right) {
        int[] result = new int[left.length + right.length];
        int i = 0, j = 0, k = 0;
        
        while (i < left.length && j < right.length) {
            if (left[i] <= right[j]) {
                result[k++] = left[i++];
            } else {
                result[k++] = right[j++];
            }
        }
        
        while (i < left.length) result[k++] = left[i++];
        while (j < right.length) result[k++] = right[j++];
        
        return result;
    }
}
```

```cpp C++
class MergeSort {
public:
    vector<int> mergeSort(vector<int>& arr) {
        // O(n log n) stable sort
        if (arr.size() <= 1) {
            return arr;
        }
        
        // Divide
        int mid = arr.size() / 2;
        vector<int> left(arr.begin(), arr.begin() + mid);
        vector<int> right(arr.begin() + mid, arr.end());
        
        left = mergeSort(left);
        right = mergeSort(right);
        
        // Combine (merge)
        return merge(left, right);
    }
    
private:
    vector<int> merge(vector<int>& left, vector<int>& right) {
        vector<int> result;
        int i = 0, j = 0;
        
        while (i < left.size() && j < right.size()) {
            if (left[i] <= right[j]) {
                result.push_back(left[i++]);
            } else {
                result.push_back(right[j++]);
            }
        }
        
        while (i < left.size()) result.push_back(left[i++]);
        while (j < right.size()) result.push_back(right[j++]);
        
        return result;
    }
};
```
</CodeGroup>

### 2. Quick Sort

<CodeGroup>
```python Python
def quick_sort(arr, low, high):
    """O(n log n) average, in-place sort"""
    if low < high:
        # Partition and get pivot position
        pivot_idx = partition(arr, low, high)
        
        # Conquer
        quick_sort(arr, low, pivot_idx - 1)
        quick_sort(arr, pivot_idx + 1, high)

def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    
    for j in range(low, high):
        if arr[j] < pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1
```

```java Java
public class QuickSort {
    public void quickSort(int[] arr, int low, int high) {
        // O(n log n) average, in-place sort
        if (low < high) {
            // Partition and get pivot position
            int pivotIdx = partition(arr, low, high);
            
            // Conquer
            quickSort(arr, low, pivotIdx - 1);
            quickSort(arr, pivotIdx + 1, high);
        }
    }
    
    private int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

```cpp C++
class QuickSort {
public:
    void quickSort(vector<int>& arr, int low, int high) {
        // O(n log n) average, in-place sort
        if (low < high) {
            // Partition and get pivot position
            int pivotIdx = partition(arr, low, high);
            
            // Conquer
            quickSort(arr, low, pivotIdx - 1);
            quickSort(arr, pivotIdx + 1, high);
        }
    }
    
private:
    int partition(vector<int>& arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr[i], arr[j]);
            }
        }
        
        swap(arr[i + 1], arr[high]);
        return i + 1;
    }
};
```
</CodeGroup>

### 3. Maximum Subarray (Kadane Alternative)

<CodeGroup>
```python Python
def max_subarray(nums, left, right):
    """Find max subarray sum using D and C"""
    if left == right:
        return nums[left]
    
    mid = (left + right) // 2
    
    # Max in left half
    left_max = max_subarray(nums, left, mid)
    # Max in right half
    right_max = max_subarray(nums, mid + 1, right)
    # Max crossing middle
    cross_max = max_crossing_sum(nums, left, mid, right)
    
    return max(left_max, right_max, cross_max)

def max_crossing_sum(nums, left, mid, right):
    # Max sum ending at mid
    left_sum = float('-inf')
    total = 0
    for i in range(mid, left - 1, -1):
        total += nums[i]
        left_sum = max(left_sum, total)
    
    # Max sum starting after mid
    right_sum = float('-inf')
    total = 0
    for i in range(mid + 1, right + 1):
        total += nums[i]
        right_sum = max(right_sum, total)
    
    return left_sum + right_sum
```

```java Java
public class MaxSubarray {
    public int maxSubarray(int[] nums, int left, int right) {
        // Find max subarray sum using D and C
        if (left == right) {
            return nums[left];
        }
        
        int mid = (left + right) / 2;
        
        // Max in left half
        int leftMax = maxSubarray(nums, left, mid);
        // Max in right half
        int rightMax = maxSubarray(nums, mid + 1, right);
        // Max crossing middle
        int crossMax = maxCrossingSum(nums, left, mid, right);
        
        return Math.max(Math.max(leftMax, rightMax), crossMax);
    }
    
    private int maxCrossingSum(int[] nums, int left, int mid, int right) {
        // Max sum ending at mid
        int leftSum = Integer.MIN_VALUE;
        int total = 0;
        for (int i = mid; i >= left; i--) {
            total += nums[i];
            leftSum = Math.max(leftSum, total);
        }
        
        // Max sum starting after mid
        int rightSum = Integer.MIN_VALUE;
        total = 0;
        for (int i = mid + 1; i <= right; i++) {
            total += nums[i];
            rightSum = Math.max(rightSum, total);
        }
        
        return leftSum + rightSum;
    }
}
```

```cpp C++
class MaxSubarray {
public:
    int maxSubarray(vector<int>& nums, int left, int right) {
        // Find max subarray sum using D and C
        if (left == right) {
            return nums[left];
        }
        
        int mid = (left + right) / 2;
        
        // Max in left half
        int leftMax = maxSubarray(nums, left, mid);
        // Max in right half
        int rightMax = maxSubarray(nums, mid + 1, right);
        // Max crossing middle
        int crossMax = maxCrossingSum(nums, left, mid, right);
        
        return max({leftMax, rightMax, crossMax});
    }
    
private:
    int maxCrossingSum(vector<int>& nums, int left, int mid, int right) {
        // Max sum ending at mid
        int leftSum = INT_MIN;
        int total = 0;
        for (int i = mid; i >= left; i--) {
            total += nums[i];
            leftSum = max(leftSum, total);
        }
        
        // Max sum starting after mid
        int rightSum = INT_MIN;
        total = 0;
        for (int i = mid + 1; i <= right; i++) {
            total += nums[i];
            rightSum = max(rightSum, total);
        }
        
        return leftSum + rightSum;
    }
};
```
</CodeGroup>

### 4. Binary Tree Maximum Depth

<CodeGroup>
```python Python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def max_depth(root):
    """D and C on tree structure"""
    if not root:
        return 0
    
    # Divide and Conquer
    left_depth = max_depth(root.left)
    right_depth = max_depth(root.right)
    
    # Combine
    return 1 + max(left_depth, right_depth)
```

```java Java
class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) { this.val = val; }
}

public class MaxDepth {
    public int maxDepth(TreeNode root) {
        // D and C on tree structure
        if (root == null) {
            return 0;
        }
        
        // Divide and Conquer
        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);
        
        // Combine
        return 1 + Math.max(leftDepth, rightDepth);
    }
}
```

```cpp C++
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class MaxDepth {
public:
    int maxDepth(TreeNode* root) {
        // D and C on tree structure
        if (root == nullptr) {
            return 0;
        }
        
        // Divide and Conquer
        int leftDepth = maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        
        // Combine
        return 1 + max(leftDepth, rightDepth);
    }
};
```
</CodeGroup>

## Classic Problems

| Problem | Pattern | Key Insight |
|---------|---------|-------------|
| Merge Sort | Classic D and C | Divide array, merge sorted halves |
| Quick Sort | In-place D and C | Partition around pivot |
| Max Subarray | Array D and C | Handle crossing subarray |
| Closest Pair | 2D D and C | Divide plane, check boundary |
| Binary Search | Simple D and C | Eliminate half each time |

## Practice Problems

<CardGroup cols={2}>
  <Card title="Count Inversions" icon="calculator" href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/">
    Modified merge sort
  </Card>
  <Card title="Median of Two Arrays" icon="divide" href="https://leetcode.com/problems/median-of-two-sorted-arrays/">
    Binary search approach
  </Card>
  <Card title="Kth Largest" icon="ranking-star" href="https://leetcode.com/problems/kth-largest-element-in-an-array/">
    Quick select algorithm
  </Card>
  <Card title="Search 2D Matrix II" icon="table" href="https://leetcode.com/problems/search-a-2d-matrix-ii/">
    Eliminate rows/columns
  </Card>
</CardGroup>
