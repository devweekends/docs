---
title: "HashMap Pattern"
description: "Optimize lookup and counting problems with hash-based data structures"
icon: "hashtag"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/10-hashmap.svg"
  alt="HashMap Pattern"
/>

## What is HashMap?

**HashMap** (or HashTable/Dictionary) provides O(1) average-case lookup, insertion, and deletion by mapping keys to values using a hash function.

## When to Use

<CardGroup cols={2}>
  <Card title="Frequency Counting" icon="chart-bar">
    Count occurrences of elements
  </Card>
  <Card title="Two Sum Variants" icon="plus">
    Find pairs/groups with specific properties
  </Card>
  <Card title="Caching/Memoization" icon="brain">
    Store computed results
  </Card>
  <Card title="Grouping/Indexing" icon="layer-group">
    Group elements by property
  </Card>
</CardGroup>

## Pattern Variations

### 1. Two Sum (Classic HashMap)

<CodeGroup>
```python Python
def two_sum(nums, target):
    """Find indices of two numbers that sum to target"""
    seen = {}  # value -> index
    
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    
    return []
```

```java Java
public int[] twoSum(int[] nums, int target) {
    // Find indices of two numbers that sum to target
    Map<Integer, Integer> seen = new HashMap<>();
    
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (seen.containsKey(complement)) {
            return new int[] {seen.get(complement), i};
        }
        seen.put(nums[i], i);
    }
    
    return new int[] {};
}
```

```cpp C++
vector<int> twoSum(vector<int>& nums, int target) {
    // Find indices of two numbers that sum to target
    unordered_map<int, int> seen;
    
    for (int i = 0; i < nums.size(); i++) {
        int complement = target - nums[i];
        if (seen.count(complement)) {
            return {seen[complement], i};
        }
        seen[nums[i]] = i;
    }
    
    return {};
}
```
</CodeGroup>

### 2. Frequency Counter

<CodeGroup>
```python Python
from collections import Counter

def top_k_frequent(nums, k):
    """Return k most frequent elements"""
    count = Counter(nums)
    return [num for num, _ in count.most_common(k)]

def is_anagram(s, t):
    """Check if t is anagram of s"""
    return Counter(s) == Counter(t)
```

```java Java
public int[] topKFrequent(int[] nums, int k) {
    // Return k most frequent elements
    Map<Integer, Integer> count = new HashMap<>();
    for (int num : nums) {
        count.put(num, count.getOrDefault(num, 0) + 1);
    }
    
    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[1] - a[1]);
    for (Map.Entry<Integer, Integer> entry : count.entrySet()) {
        pq.offer(new int[] {entry.getKey(), entry.getValue()});
    }
    
    int[] result = new int[k];
    for (int i = 0; i < k; i++) {
        result[i] = pq.poll()[0];
    }
    return result;
}

public boolean isAnagram(String s, String t) {
    // Check if t is anagram of s
    if (s.length() != t.length()) return false;
    
    int[] count = new int[26];
    for (int i = 0; i < s.length(); i++) {
        count[s.charAt(i) - 'a']++;
        count[t.charAt(i) - 'a']--;
    }
    
    for (int c : count) {
        if (c != 0) return false;
    }
    return true;
}
```

```cpp C++
vector<int> topKFrequent(vector<int>& nums, int k) {
    // Return k most frequent elements
    unordered_map<int, int> count;
    for (int num : nums) {
        count[num]++;
    }
    
    priority_queue<pair<int, int>> pq;
    for (auto& [num, freq] : count) {
        pq.push({freq, num});
    }
    
    vector<int> result;
    for (int i = 0; i < k; i++) {
        result.push_back(pq.top().second);
        pq.pop();
    }
    return result;
}

bool isAnagram(string s, string t) {
    // Check if t is anagram of s
    if (s.length() != t.length()) return false;
    
    vector<int> count(26, 0);
    for (int i = 0; i < s.length(); i++) {
        count[s[i] - 'a']++;
        count[t[i] - 'a']--;
    }
    
    for (int c : count) {
        if (c != 0) return false;
    }
    return true;
}
```
</CodeGroup>

### 3. Group By (Anagrams)

<CodeGroup>
```python Python
from collections import defaultdict

def group_anagrams(strs):
    """Group strings that are anagrams of each other"""
    groups = defaultdict(list)
    
    for s in strs:
        key = tuple(sorted(s))  # or count-based key
        groups[key].append(s)
    
    return list(groups.values())
```

```java Java
public List<List<String>> groupAnagrams(String[] strs) {
    // Group strings that are anagrams of each other
    Map<String, List<String>> groups = new HashMap<>();
    
    for (String s : strs) {
        char[] chars = s.toCharArray();
        Arrays.sort(chars);
        String key = new String(chars);
        
        groups.computeIfAbsent(key, k -> new ArrayList<>()).add(s);
    }
    
    return new ArrayList<>(groups.values());
}
```

```cpp C++
vector<vector<string>> groupAnagrams(vector<string>& strs) {
    // Group strings that are anagrams of each other
    unordered_map<string, vector<string>> groups;
    
    for (string& s : strs) {
        string key = s;
        sort(key.begin(), key.end());
        groups[key].push_back(s);
    }
    
    vector<vector<string>> result;
    for (auto& [key, group] : groups) {
        result.push_back(group);
    }
    return result;
}
```
</CodeGroup>

### 4. Prefix Sum with HashMap

<CodeGroup>
```python Python
def subarray_sum_equals_k(nums, k):
    """Count subarrays with sum exactly k"""
    count = 0
    prefix_sum = 0
    sum_count = {0: 1}  # prefix_sum -> frequency
    
    for num in nums:
        prefix_sum += num
        
        # If (prefix_sum - k) exists, those many subarrays sum to k
        if prefix_sum - k in sum_count:
            count += sum_count[prefix_sum - k]
        
        sum_count[prefix_sum] = sum_count.get(prefix_sum, 0) + 1
    
    return count
```

```java Java
public int subarraySumEqualsK(int[] nums, int k) {
    // Count subarrays with sum exactly k
    int count = 0;
    int prefixSum = 0;
    Map<Integer, Integer> sumCount = new HashMap<>();
    sumCount.put(0, 1);
    
    for (int num : nums) {
        prefixSum += num;
        
        // If (prefixSum - k) exists, those many subarrays sum to k
        if (sumCount.containsKey(prefixSum - k)) {
            count += sumCount.get(prefixSum - k);
        }
        
        sumCount.put(prefixSum, sumCount.getOrDefault(prefixSum, 0) + 1);
    }
    
    return count;
}
```

```cpp C++
int subarraySumEqualsK(vector<int>& nums, int k) {
    // Count subarrays with sum exactly k
    int count = 0;
    int prefixSum = 0;
    unordered_map<int, int> sumCount;
    sumCount[0] = 1;
    
    for (int num : nums) {
        prefixSum += num;
        
        // If (prefixSum - k) exists, those many subarrays sum to k
        if (sumCount.count(prefixSum - k)) {
            count += sumCount[prefixSum - k];
        }
        
        sumCount[prefixSum]++;
    }
    
    return count;
}
```
</CodeGroup>

### 5. Longest Consecutive Sequence

<CodeGroup>
```python Python
def longest_consecutive(nums):
    """Find length of longest consecutive sequence"""
    num_set = set(nums)
    max_length = 0
    
    for num in num_set:
        # Only start counting from sequence start
        if num - 1 not in num_set:
            current = num
            length = 1
            
            while current + 1 in num_set:
                current += 1
                length += 1
            
            max_length = max(max_length, length)
    
    return max_length
```

```java Java
public int longestConsecutive(int[] nums) {
    // Find length of longest consecutive sequence
    Set<Integer> numSet = new HashSet<>();
    for (int num : nums) {
        numSet.add(num);
    }
    
    int maxLength = 0;
    
    for (int num : numSet) {
        // Only start counting from sequence start
        if (!numSet.contains(num - 1)) {
            int current = num;
            int length = 1;
            
            while (numSet.contains(current + 1)) {
                current++;
                length++;
            }
            
            maxLength = Math.max(maxLength, length);
        }
    }
    
    return maxLength;
}
```

```cpp C++
int longestConsecutive(vector<int>& nums) {
    // Find length of longest consecutive sequence
    unordered_set<int> numSet(nums.begin(), nums.end());
    int maxLength = 0;
    
    for (int num : numSet) {
        // Only start counting from sequence start
        if (numSet.find(num - 1) == numSet.end()) {
            int current = num;
            int length = 1;
            
            while (numSet.find(current + 1) != numSet.end()) {
                current++;
                length++;
            }
            
            maxLength = max(maxLength, length);
        }
    }
    
    return maxLength;
}
```
</CodeGroup>

### 6. LRU Cache (HashMap + Doubly Linked List)

<CodeGroup>
```python Python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity):
        self.cache = OrderedDict()
        self.capacity = capacity
    
    def get(self, key):
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]
    
    def put(self, key, value):
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

```java Java
class LRUCache {
    private int capacity;
    private Map<Integer, Node> cache;
    private Node head, tail;
    
    class Node {
        int key, value;
        Node prev, next;
        Node(int k, int v) { key = k; value = v; }
    }
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        cache = new HashMap<>();
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
    }
    
    public int get(int key) {
        if (!cache.containsKey(key)) return -1;
        Node node = cache.get(key);
        remove(node);
        insertAtEnd(node);
        return node.value;
    }
    
    public void put(int key, int value) {
        if (cache.containsKey(key)) {
            remove(cache.get(key));
        }
        Node node = new Node(key, value);
        cache.put(key, node);
        insertAtEnd(node);
        if (cache.size() > capacity) {
            Node lru = head.next;
            remove(lru);
            cache.remove(lru.key);
        }
    }
    
    private void remove(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    
    private void insertAtEnd(Node node) {
        node.prev = tail.prev;
        node.next = tail;
        tail.prev.next = node;
        tail.prev = node;
    }
}
```

```cpp C++
class LRUCache {
private:
    int capacity;
    list<pair<int, int>> cache;  // {key, value}
    unordered_map<int, list<pair<int, int>>::iterator> map;
    
public:
    LRUCache(int capacity) : capacity(capacity) {}
    
    int get(int key) {
        if (map.find(key) == map.end()) return -1;
        
        // Move to front
        cache.splice(cache.begin(), cache, map[key]);
        return map[key]->second;
    }
    
    void put(int key, int value) {
        if (map.find(key) != map.end()) {
            cache.erase(map[key]);
        }
        
        cache.push_front({key, value});
        map[key] = cache.begin();
        
        if (cache.size() > capacity) {
            map.erase(cache.back().first);
            cache.pop_back();
        }
    }
};
```
</CodeGroup>

## Classic Problems

<AccordionGroup>
  <Accordion title="1. Two Sum" icon="plus">
    **Pattern**: Store complement, check on each iteration
    
    **Key**: HashMap trades space for time O(n^2) to O(n)
  </Accordion>
  
  <Accordion title="2. Valid Anagram" icon="spell-check">
    **Pattern**: Compare character frequency counts
    
    **Variants**: Counting sort (26 letters), Counter equality
  </Accordion>
  
  <Accordion title="3. Contains Duplicate" icon="clone">
    **Pattern**: HashSet for seen elements
    
    **Variants**: Within k indices, within t value difference
  </Accordion>
  
  <Accordion title="4. First Unique Character" icon="fingerprint">
    **Pattern**: Count frequency, find first with count 1
    
    **Key**: Two passes - count, then find
  </Accordion>
  
  <Accordion title="5. Subarray Sum Equals K" icon="calculator">
    **Pattern**: Prefix sum with HashMap
    
    **Key**: Store prefix_sum frequencies, look for (current - k)
  </Accordion>
</AccordionGroup>

## Common Mistakes

<Warning>
**Avoid These Pitfalls:**
1. **Unhashable keys**: Lists cannot be dict keys in Python, use tuples
2. **Missing key errors**: Use .get() or check existence before access
3. **Hash collisions**: Know when worst case is O(n) lookup
4. **Mutating keys**: Don't modify objects used as keys
</Warning>

## Practice Problems

| Problem | Difficulty | Link |
|---------|------------|------|
| Two Sum | Easy | [LeetCode 1](https://leetcode.com/problems/two-sum/) |
| Valid Anagram | Easy | [LeetCode 242](https://leetcode.com/problems/valid-anagram/) |
| Group Anagrams | Medium | [LeetCode 49](https://leetcode.com/problems/group-anagrams/) |
| Subarray Sum Equals K | Medium | [LeetCode 560](https://leetcode.com/problems/subarray-sum-equals-k/) |
| LRU Cache | Medium | [LeetCode 146](https://leetcode.com/problems/lru-cache/) |

<Tip>
**Interview Tip**: When you need O(1) lookup or counting frequencies, HashMap is almost always the answer.
</Tip>
