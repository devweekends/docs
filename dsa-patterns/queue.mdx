---
title: "Queue Pattern"
description: "Master FIFO operations for BFS, scheduling, and stream processing"
icon: "timeline"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/12-queue.svg"
  alt="Queue Pattern"
/>

## What is Queue?

**Queue** is a FIFO (First In, First Out) data structure where elements are added at the back and removed from the front. It's essential for level-order processing and scheduling.

## When to Use

<CardGroup cols={2}>
  <Card title="BFS" icon="sitemap">
    Level-order traversal, shortest path
  </Card>
  <Card title="Scheduling" icon="calendar">
    Task queues, round-robin
  </Card>
  <Card title="Sliding Window" icon="window-restore">
    With deque for O(1) operations
  </Card>
  <Card title="Streaming Data" icon="wave-square">
    Moving averages, recent items
  </Card>
</CardGroup>

## Pattern Variations

### 1. Implement Queue using Stacks

<CodeGroup>
```python Python
class MyQueue:
    """FIFO queue using two LIFO stacks"""
    
    def __init__(self):
        self.inbox = []   # For push
        self.outbox = []  # For pop/peek
    
    def push(self, x):
        self.inbox.append(x)
    
    def pop(self):
        self._transfer()
        return self.outbox.pop()
    
    def peek(self):
        self._transfer()
        return self.outbox[-1]
    
    def empty(self):
        return not self.inbox and not self.outbox
    
    def _transfer(self):
        if not self.outbox:
            while self.inbox:
                self.outbox.append(self.inbox.pop())
```

```java Java
class MyQueue {
    // FIFO queue using two LIFO stacks
    private Deque<Integer> inbox;
    private Deque<Integer> outbox;
    
    public MyQueue() {
        inbox = new ArrayDeque<>();  // For push
        outbox = new ArrayDeque<>(); // For pop/peek
    }
    
    public void push(int x) {
        inbox.push(x);
    }
    
    public int pop() {
        transfer();
        return outbox.pop();
    }
    
    public int peek() {
        transfer();
        return outbox.peek();
    }
    
    public boolean empty() {
        return inbox.isEmpty() && outbox.isEmpty();
    }
    
    private void transfer() {
        if (outbox.isEmpty()) {
            while (!inbox.isEmpty()) {
                outbox.push(inbox.pop());
            }
        }
    }
}
```

```cpp C++
class MyQueue {
    // FIFO queue using two LIFO stacks
private:
    stack<int> inbox;  // For push
    stack<int> outbox; // For pop/peek
    
    void transfer() {
        if (outbox.empty()) {
            while (!inbox.empty()) {
                outbox.push(inbox.top());
                inbox.pop();
            }
        }
    }
    
public:
    void push(int x) {
        inbox.push(x);
    }
    
    int pop() {
        transfer();
        int val = outbox.top();
        outbox.pop();
        return val;
    }
    
    int peek() {
        transfer();
        return outbox.top();
    }
    
    bool empty() {
        return inbox.empty() && outbox.empty();
    }
};
```
</CodeGroup>

### 2. Moving Average from Data Stream

<CodeGroup>
```python Python
from collections import deque

class MovingAverage:
    """Calculate moving average of last n elements"""
    
    def __init__(self, size):
        self.size = size
        self.queue = deque()
        self.total = 0
    
    def next(self, val):
        self.queue.append(val)
        self.total += val
        
        if len(self.queue) > self.size:
            self.total -= self.queue.popleft()
        
        return self.total / len(self.queue)
```

```java Java
class MovingAverage {
    // Calculate moving average of last n elements
    private int size;
    private Queue<Integer> queue;
    private double total;
    
    public MovingAverage(int size) {
        this.size = size;
        this.queue = new LinkedList<>();
        this.total = 0;
    }
    
    public double next(int val) {
        queue.offer(val);
        total += val;
        
        if (queue.size() > size) {
            total -= queue.poll();
        }
        
        return total / queue.size();
    }
}
```

```cpp C++
class MovingAverage {
    // Calculate moving average of last n elements
private:
    int size;
    queue<int> q;
    double total;
    
public:
    MovingAverage(int size) : size(size), total(0) {}
    
    double next(int val) {
        q.push(val);
        total += val;
        
        if (q.size() > size) {
            total -= q.front();
            q.pop();
        }
        
        return total / q.size();
    }
};
```
</CodeGroup>

### 3. Sliding Window Maximum (Monotonic Deque)

<CodeGroup>
```python Python
from collections import deque

def max_sliding_window(nums, k):
    """Maximum in each window of size k"""
    result = []
    dq = deque()  # Store indices, values in decreasing order
    
    for i in range(len(nums)):
        # Remove indices out of window
        while dq and dq[0] <= i - k:
            dq.popleft()
        
        # Remove smaller elements
        while dq and nums[dq[-1]] < nums[i]:
            dq.pop()
        
        dq.append(i)
        
        # Add to result once window is formed
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result
```

```java Java
public int[] maxSlidingWindow(int[] nums, int k) {
    // Maximum in each window of size k
    int[] result = new int[nums.length - k + 1];
    Deque<Integer> dq = new ArrayDeque<>(); // Store indices
    
    for (int i = 0; i < nums.length; i++) {
        // Remove indices out of window
        while (!dq.isEmpty() && dq.peekFirst() <= i - k) {
            dq.pollFirst();
        }
        
        // Remove smaller elements
        while (!dq.isEmpty() && nums[dq.peekLast()] < nums[i]) {
            dq.pollLast();
        }
        
        dq.offerLast(i);
        
        // Add to result once window is formed
        if (i >= k - 1) {
            result[i - k + 1] = nums[dq.peekFirst()];
        }
    }
    
    return result;
}
```

```cpp C++
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    // Maximum in each window of size k
    vector<int> result;
    deque<int> dq; // Store indices
    
    for (int i = 0; i < nums.size(); i++) {
        // Remove indices out of window
        while (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }
        
        // Remove smaller elements
        while (!dq.empty() && nums[dq.back()] < nums[i]) {
            dq.pop_back();
        }
        
        dq.push_back(i);
        
        // Add to result once window is formed
        if (i >= k - 1) {
            result.push_back(nums[dq.front()]);
        }
    }
    
    return result;
}
```
</CodeGroup>

### 4. BFS Level Order Traversal

<CodeGroup>
```python Python
from collections import deque

def level_order(root):
    """Binary tree level order traversal"""
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level = []
        level_size = len(queue)
        
        for _ in range(level_size):
            node = queue.popleft()
            level.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(level)
    
    return result
```

```java Java
public List<List<Integer>> levelOrder(TreeNode root) {
    // Binary tree level order traversal
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) return result;
    
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        List<Integer> level = new ArrayList<>();
        int levelSize = queue.size();
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode node = queue.poll();
            level.add(node.val);
            
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        
        result.add(level);
    }
    
    return result;
}
```

```cpp C++
vector<vector<int>> levelOrder(TreeNode* root) {
    // Binary tree level order traversal
    vector<vector<int>> result;
    if (root == nullptr) return result;
    
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        vector<int> level;
        int levelSize = q.size();
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            level.push_back(node->val);
            
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        
        result.push_back(level);
    }
    
    return result;
}
```
</CodeGroup>

## Classic Problems

| Problem | Pattern | Key Insight |
|---------|---------|-------------|
| BFS Traversal | Standard queue | Process level by level |
| Sliding Window Max | Monotonic deque | Keep decreasing order |
| Queue via Stacks | Two stacks | Amortized O(1) operations |
| Moving Average | Fixed-size queue | Running sum optimization |
| Task Scheduler | Priority queue | Cool down management |

## Practice Problems

<CardGroup cols={2}>
  <Card title="Sliding Window Max" icon="chart-line" href="https://leetcode.com/problems/sliding-window-maximum/">
    Monotonic deque technique
  </Card>
  <Card title="Implement Queue" icon="layer-group" href="https://leetcode.com/problems/implement-queue-using-stacks/">
    Two stacks approach
  </Card>
  <Card title="Number of Islands" icon="map" href="https://leetcode.com/problems/number-of-islands/">
    BFS exploration
  </Card>
  <Card title="Rotting Oranges" icon="lemon" href="https://leetcode.com/problems/rotting-oranges/">
    Multi-source BFS
  </Card>
</CardGroup>
