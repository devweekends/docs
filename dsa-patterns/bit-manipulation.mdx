---
title: "Bit Manipulation"
description: "Solve problems efficiently using bitwise operations"
icon: "microchip"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/22-bit-manipulation.svg"
  alt="Bit Manipulation Pattern"
/>

## What is Bit Manipulation?

**Bit Manipulation** uses bitwise operators to solve problems at the binary level. It enables O(1) operations for many tasks and reduces space complexity.

## Essential Operations

<CodeGroup>
```python Python
# Basic operators
a & b   # AND: 1 only if both bits are 1
a | b   # OR: 1 if either bit is 1
a ^ b   # XOR: 1 if bits are different
~a      # NOT: flip all bits
a << n  # Left shift: multiply by 2^n
a >> n  # Right shift: divide by 2^n
```

```java Java
// Basic operators
a & b   // AND: 1 only if both bits are 1
a | b   // OR: 1 if either bit is 1
a ^ b   // XOR: 1 if bits are different
~a      // NOT: flip all bits
a << n  // Left shift: multiply by 2^n
a >> n  // Right shift: divide by 2^n
a >>> n // Unsigned right shift
```

```cpp C++
// Basic operators
a & b   // AND: 1 only if both bits are 1
a | b   // OR: 1 if either bit is 1
a ^ b   // XOR: 1 if bits are different
~a      // NOT: flip all bits
a << n  // Left shift: multiply by 2^n
a >> n  // Right shift: divide by 2^n
```
</CodeGroup>

## Common Tricks

<CodeGroup>
```python Python
# Check if nth bit is set
(num >> n) & 1

# Set nth bit
num | (1 << n)

# Clear nth bit
num & ~(1 << n)

# Toggle nth bit
num ^ (1 << n)

# Check if power of 2
n > 0 and (n & (n - 1)) == 0

# Get lowest set bit
n & (-n)

# Clear lowest set bit
n & (n - 1)

# Count set bits (Brian Kernighan)
count = 0
while n:
    n &= n - 1
    count += 1
```

```java Java
// Check if nth bit is set
(num >> n) & 1

// Set nth bit
num | (1 << n)

// Clear nth bit
num & ~(1 << n)

// Toggle nth bit
num ^ (1 << n)

// Check if power of 2
n > 0 && (n & (n - 1)) == 0

// Get lowest set bit
n & (-n)

// Clear lowest set bit
n & (n - 1)

// Count set bits
Integer.bitCount(n)
```

```cpp C++
// Check if nth bit is set
(num >> n) & 1

// Set nth bit
num | (1 << n)

// Clear nth bit
num & ~(1 << n)

// Toggle nth bit
num ^ (1 << n)

// Check if power of 2
n > 0 && (n & (n - 1)) == 0

// Get lowest set bit
n & (-n)

// Clear lowest set bit
n & (n - 1)

// Count set bits
__builtin_popcount(n)
```
</CodeGroup>

## Pattern Variations

### 1. Single Number

<CodeGroup>
```python Python
def single_number(nums):
    """Find element that appears once (others twice)"""
    result = 0
    for num in nums:
        result ^= num
    return result

# XOR properties: a ^ a = 0, a ^ 0 = a, commutative
```

```java Java
public int singleNumber(int[] nums) {
    // Find element that appears once (others twice)
    int result = 0;
    for (int num : nums) {
        result ^= num;
    }
    return result;
    // XOR properties: a ^ a = 0, a ^ 0 = a, commutative
}
```

```cpp C++
int singleNumber(vector<int>& nums) {
    // Find element that appears once (others twice)
    int result = 0;
    for (int num : nums) {
        result ^= num;
    }
    return result;
    // XOR properties: a ^ a = 0, a ^ 0 = a, commutative
}
```
</CodeGroup>

### 2. Counting Bits

<CodeGroup>
```python Python
def count_bits(n):
    """Count set bits for all numbers 0 to n"""
    result = [0] * (n + 1)
    for i in range(1, n + 1):
        result[i] = result[i >> 1] + (i & 1)
    return result
```

```java Java
public int[] countBits(int n) {
    // Count set bits for all numbers 0 to n
    int[] result = new int[n + 1];
    for (int i = 1; i <= n; i++) {
        result[i] = result[i >> 1] + (i & 1);
    }
    return result;
}
```

```cpp C++
vector<int> countBits(int n) {
    // Count set bits for all numbers 0 to n
    vector<int> result(n + 1, 0);
    for (int i = 1; i <= n; i++) {
        result[i] = result[i >> 1] + (i & 1);
    }
    return result;
}
```
</CodeGroup>

### 3. Subsets Using Bitmask

<CodeGroup>
```python Python
def subsets(nums):
    """Generate all subsets using bitmask"""
    n = len(nums)
    result = []
    
    for mask in range(1 << n):  # 2^n subsets
        subset = []
        for i in range(n):
            if mask & (1 << i):
                subset.append(nums[i])
        result.append(subset)
    
    return result
```

```java Java
public List<List<Integer>> subsets(int[] nums) {
    // Generate all subsets using bitmask
    int n = nums.length;
    List<List<Integer>> result = new ArrayList<>();
    
    for (int mask = 0; mask < (1 << n); mask++) {
        List<Integer> subset = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            if ((mask & (1 << i)) != 0) {
                subset.add(nums[i]);
            }
        }
        result.add(subset);
    }
    return result;
}
```

```cpp C++
vector<vector<int>> subsets(vector<int>& nums) {
    // Generate all subsets using bitmask
    int n = nums.size();
    vector<vector<int>> result;
    
    for (int mask = 0; mask < (1 << n); mask++) {
        vector<int> subset;
        for (int i = 0; i < n; i++) {
            if (mask & (1 << i)) {
                subset.push_back(nums[i]);
            }
        }
        result.push_back(subset);
    }
    return result;
}
```
</CodeGroup>

### 4. Missing Number

<CodeGroup>
```python Python
def missing_number(nums):
    """Find missing number in [0, n]"""
    n = len(nums)
    result = n  # Start with n (might be missing)
    
    for i, num in enumerate(nums):
        result ^= i ^ num
    
    return result
```

```java Java
public int missingNumber(int[] nums) {
    // Find missing number in [0, n]
    int n = nums.length;
    int result = n;  // Start with n (might be missing)
    
    for (int i = 0; i < n; i++) {
        result ^= i ^ nums[i];
    }
    return result;
}
```

```cpp C++
int missingNumber(vector<int>& nums) {
    // Find missing number in [0, n]
    int n = nums.size();
    int result = n;  // Start with n (might be missing)
    
    for (int i = 0; i < n; i++) {
        result ^= i ^ nums[i];
    }
    return result;
}
```
</CodeGroup>

### 5. Reverse Bits

<CodeGroup>
```python Python
def reverse_bits(n):
    """Reverse bits of 32-bit unsigned integer"""
    result = 0
    for _ in range(32):
        result = (result << 1) | (n & 1)
        n >>= 1
    return result
```

```java Java
public int reverseBits(int n) {
    // Reverse bits of 32-bit unsigned integer
    int result = 0;
    for (int i = 0; i < 32; i++) {
        result = (result << 1) | (n & 1);
        n >>>= 1;  // Unsigned right shift
    }
    return result;
}
```

```cpp C++
uint32_t reverseBits(uint32_t n) {
    // Reverse bits of 32-bit unsigned integer
    uint32_t result = 0;
    for (int i = 0; i < 32; i++) {
        result = (result << 1) | (n & 1);
        n >>= 1;
    }
    return result;
}
```
</CodeGroup>

## Classic Problems

<AccordionGroup>
  <Accordion title="1. Power of Two" icon="hashtag">
    **Check**: n greater than 0 and (n & (n-1)) equals 0
    
    **Why**: Power of 2 has exactly one bit set
  </Accordion>
  
  <Accordion title="2. Hamming Distance" icon="ruler">
    **Formula**: count set bits in (x ^ y)
    
    **Why**: XOR gives 1 where bits differ
  </Accordion>
  
  <Accordion title="3. Add Without Plus" icon="plus">
    **Pattern**: sum = a ^ b, carry = (a & b) left-shifted by 1
    
    **Why**: XOR adds without carry, AND gives carry positions
  </Accordion>
  
  <Accordion title="4. Maximum XOR" icon="bolt">
    **Pattern**: Build trie of binary representations
    
    **Why**: Greedily choose opposite bit for maximum XOR
  </Accordion>
</AccordionGroup>

## Bit Manipulation in DP

<CodeGroup>
```python Python
def can_partition(nums):
    """Subset sum using bitset DP"""
    bits = 1  # bits represents reachable sums
    
    for num in nums:
        bits |= bits << num
    
    total = sum(nums)
    return total % 2 == 0 and (bits >> (total // 2)) & 1
```

```java Java
public boolean canPartition(int[] nums) {
    // Subset sum using bitset DP
    int total = 0;
    for (int num : nums) total += num;
    if (total % 2 != 0) return false;
    
    int target = total / 2;
    boolean[] dp = new boolean[target + 1];
    dp[0] = true;
    
    for (int num : nums) {
        for (int j = target; j >= num; j--) {
            dp[j] = dp[j] || dp[j - num];
        }
    }
    return dp[target];
}
```

```cpp C++
bool canPartition(vector<int>& nums) {
    // Subset sum using bitset DP
    int total = accumulate(nums.begin(), nums.end(), 0);
    if (total % 2 != 0) return false;
    
    bitset<20001> bits;
    bits[0] = 1;
    
    for (int num : nums) {
        bits |= bits << num;
    }
    return bits[total / 2];
}
```
</CodeGroup>

## Common Mistakes

<Warning>
**Avoid These Pitfalls:**
1. **Signed vs unsigned**: Python integers are arbitrary precision
2. **Operator precedence**: Use parentheses with bitwise ops
3. **Off-by-one in shifts**: Left shifting 1 by 32 may overflow in other languages
4. **Negative numbers**: Two's complement representation
</Warning>

## Quick Reference

| Operation | Code | Description |
|-----------|------|-------------|
| Get bit | `(n >> i) & 1` | Get ith bit |
| Set bit | `n OR (1 left-shift i)` | Set ith bit to 1 |
| Clear bit | `n & ~(1 left-shift i)` | Set ith bit to 0 |
| Toggle bit | `n ^ (1 left-shift i)` | Flip ith bit |
| Lowest bit | `n & (-n)` | Isolate lowest set bit |
| Clear lowest | `n & (n-1)` | Remove lowest set bit |

## Practice Problems

| Problem | Difficulty | Link |
|---------|------------|------|
| Single Number | Easy | [LeetCode 136](https://leetcode.com/problems/single-number/) |
| Number of 1 Bits | Easy | [LeetCode 191](https://leetcode.com/problems/number-of-1-bits/) |
| Counting Bits | Easy | [LeetCode 338](https://leetcode.com/problems/counting-bits/) |
| Maximum XOR | Medium | [LeetCode 421](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/) |

<Tip>
**Interview Tip**: XOR is your best friend for "find the unique element" problems. Remember: a ^ a = 0 and a ^ 0 = a.
</Tip>
