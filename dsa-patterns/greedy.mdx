---
title: "Greedy Pattern"
description: "Solve optimization problems with locally optimal choices"
icon: "hand-holding-dollar"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/08-greedy.svg"
  alt="Greedy Pattern"
/>

## What is Greedy?

**Greedy** algorithms make the locally optimal choice at each step, hoping to find a global optimum. They work when local choices lead to global solutions (greedy choice property + optimal substructure).

<Note>
**Quick Recognition**: Optimization problems where taking the "best" option at each step leads to the global best. Look for keywords: "minimum number of", "maximum profit", "optimal selection".
</Note>

## Pattern Recognition Checklist

<CardGroup cols={2}>
  <Card title="Use Greedy When" icon="check">
    - Interval scheduling/merging
    - Minimum coins (certain denominations)
    - Jump game style problems
    - Huffman encoding
    - Activity selection
    - Fractional knapsack
  </Card>
  <Card title="Don't Use When" icon="xmark">
    - 0/1 Knapsack (need DP)
    - Coin change (arbitrary denominations)
    - Need to try all possibilities
    - Local optimal may miss global
    - Problem has overlapping subproblems
  </Card>
</CardGroup>

## Greedy vs DP: How to Choose

| Characteristic | Greedy | DP |
|---------------|--------|-----|
| Makes irrevocable choices | Yes | No, tries all |
| Optimal substructure | Required | Required |
| Overlapping subproblems | Not handled | Handled via caching |
| Time complexity | Usually O(n log n) | Usually O(n^2) or more |
| Proof required | Yes (exchange argument) | No, exhaustive |

## Common Greedy Patterns

| Pattern | Greedy Choice | Example |
|---------|---------------|---------|
| Interval Scheduling | Sort by end time | Non-overlapping intervals |
| Interval Partitioning | Sort by start time | Meeting rooms |
| Fractional Knapsack | Best value/weight ratio | Maximize value |
| Job Scheduling | Sort by deadline | Minimize late jobs |
| Huffman Coding | Merge least frequent | Optimal prefix codes |

## When to Use

<CardGroup cols={2}>
  <Card title="Scheduling" icon="calendar">
    Task scheduling, meeting rooms, intervals
  </Card>
  <Card title="Selection" icon="hand-pointer">
    Choosing items to maximize/minimize value
  </Card>
  <Card title="Graph Problems" icon="share-nodes">
    MST (Kruskal, Prim), shortest paths (Dijkstra)
  </Card>
  <Card title="String/Array" icon="text">
    Partition labels, jump game
  </Card>
</CardGroup>

## Pattern Variations

### 1. Interval Scheduling

<CodeGroup>
```python Python
def max_non_overlapping_intervals(intervals):
    """Maximum number of non-overlapping intervals"""
    if not intervals:
        return 0
    
    # Sort by end time (greedy choice: earliest ending first)
    intervals.sort(key=lambda x: x[1])
    
    count = 1
    end = intervals[0][1]
    
    for i in range(1, len(intervals)):
        if intervals[i][0] >= end:  # No overlap
            count += 1
            end = intervals[i][1]
    
    return count
```

```java Java
public int maxNonOverlappingIntervals(int[][] intervals) {
    // Maximum number of non-overlapping intervals
    if (intervals.length == 0) {
        return 0;
    }
    
    // Sort by end time (greedy choice: earliest ending first)
    Arrays.sort(intervals, (a, b) -> a[1] - b[1]);
    
    int count = 1;
    int end = intervals[0][1];
    
    for (int i = 1; i < intervals.length; i++) {
        if (intervals[i][0] >= end) {  // No overlap
            count++;
            end = intervals[i][1];
        }
    }
    
    return count;
}
```

```cpp C++
int maxNonOverlappingIntervals(vector<vector<int>>& intervals) {
    // Maximum number of non-overlapping intervals
    if (intervals.empty()) {
        return 0;
    }
    
    // Sort by end time (greedy choice: earliest ending first)
    sort(intervals.begin(), intervals.end(), 
         [](auto& a, auto& b) { return a[1] < b[1]; });
    
    int count = 1;
    int end = intervals[0][1];
    
    for (int i = 1; i < intervals.size(); i++) {
        if (intervals[i][0] >= end) {  // No overlap
            count++;
            end = intervals[i][1];
        }
    }
    
    return count;
}
```
</CodeGroup>

### 2. Activity Selection (Meeting Rooms)

<CodeGroup>
```python Python
def min_meeting_rooms(intervals):
    """Minimum rooms needed for all meetings"""
    if not intervals:
        return 0
    
    # Track start and end times separately
    starts = sorted([i[0] for i in intervals])
    ends = sorted([i[1] for i in intervals])
    
    rooms = 0
    max_rooms = 0
    s, e = 0, 0
    
    while s < len(starts):
        if starts[s] < ends[e]:
            rooms += 1
            s += 1
        else:
            rooms -= 1
            e += 1
        max_rooms = max(max_rooms, rooms)
    
    return max_rooms
```

```java Java
public int minMeetingRooms(int[][] intervals) {
    // Minimum rooms needed for all meetings
    if (intervals.length == 0) {
        return 0;
    }
    
    int[] starts = new int[intervals.length];
    int[] ends = new int[intervals.length];
    
    for (int i = 0; i < intervals.length; i++) {
        starts[i] = intervals[i][0];
        ends[i] = intervals[i][1];
    }
    
    Arrays.sort(starts);
    Arrays.sort(ends);
    
    int rooms = 0, maxRooms = 0;
    int s = 0, e = 0;
    
    while (s < starts.length) {
        if (starts[s] < ends[e]) {
            rooms++;
            s++;
        } else {
            rooms--;
            e++;
        }
        maxRooms = Math.max(maxRooms, rooms);
    }
    
    return maxRooms;
}
```

```cpp C++
int minMeetingRooms(vector<vector<int>>& intervals) {
    // Minimum rooms needed for all meetings
    if (intervals.empty()) {
        return 0;
    }
    
    vector<int> starts, ends;
    for (auto& interval : intervals) {
        starts.push_back(interval[0]);
        ends.push_back(interval[1]);
    }
    
    sort(starts.begin(), starts.end());
    sort(ends.begin(), ends.end());
    
    int rooms = 0, maxRooms = 0;
    int s = 0, e = 0;
    
    while (s < starts.size()) {
        if (starts[s] < ends[e]) {
            rooms++;
            s++;
        } else {
            rooms--;
            e++;
        }
        maxRooms = max(maxRooms, rooms);
    }
    
    return maxRooms;
}
```
</CodeGroup>

### 3. Jump Game

<CodeGroup>
```python Python
def can_jump(nums):
    """Can we reach the last index?"""
    max_reach = 0
    
    for i in range(len(nums)):
        if i > max_reach:
            return False
        max_reach = max(max_reach, i + nums[i])
    
    return True

def min_jumps(nums):
    """Minimum jumps to reach last index"""
    n = len(nums)
    if n <= 1:
        return 0
    
    jumps = 0
    current_end = 0
    farthest = 0
    
    for i in range(n - 1):
        farthest = max(farthest, i + nums[i])
        
        if i == current_end:
            jumps += 1
            current_end = farthest
    
    return jumps
```

```java Java
public boolean canJump(int[] nums) {
    // Can we reach the last index?
    int maxReach = 0;
    
    for (int i = 0; i < nums.length; i++) {
        if (i > maxReach) {
            return false;
        }
        maxReach = Math.max(maxReach, i + nums[i]);
    }
    
    return true;
}

public int minJumps(int[] nums) {
    // Minimum jumps to reach last index
    int n = nums.length;
    if (n <= 1) {
        return 0;
    }
    
    int jumps = 0;
    int currentEnd = 0;
    int farthest = 0;
    
    for (int i = 0; i < n - 1; i++) {
        farthest = Math.max(farthest, i + nums[i]);
        
        if (i == currentEnd) {
            jumps++;
            currentEnd = farthest;
        }
    }
    
    return jumps;
}
```

```cpp C++
bool canJump(vector<int>& nums) {
    // Can we reach the last index?
    int maxReach = 0;
    
    for (int i = 0; i < nums.size(); i++) {
        if (i > maxReach) {
            return false;
        }
        maxReach = max(maxReach, i + nums[i]);
    }
    
    return true;
}

int minJumps(vector<int>& nums) {
    // Minimum jumps to reach last index
    int n = nums.size();
    if (n <= 1) {
        return 0;
    }
    
    int jumps = 0;
    int currentEnd = 0;
    int farthest = 0;
    
    for (int i = 0; i < n - 1; i++) {
        farthest = max(farthest, i + nums[i]);
        
        if (i == currentEnd) {
            jumps++;
            currentEnd = farthest;
        }
    }
    
    return jumps;
}
```
</CodeGroup>

### 4. Gas Station

<CodeGroup>
```python Python
def can_complete_circuit(gas, cost):
    """Find starting gas station to complete circuit"""
    total_tank = 0
    current_tank = 0
    start = 0
    
    for i in range(len(gas)):
        total_tank += gas[i] - cost[i]
        current_tank += gas[i] - cost[i]
        
        if current_tank < 0:
            start = i + 1
            current_tank = 0
    
    return start if total_tank >= 0 else -1
```

```java Java
public int canCompleteCircuit(int[] gas, int[] cost) {
    // Find starting gas station to complete circuit
    int totalTank = 0;
    int currentTank = 0;
    int start = 0;
    
    for (int i = 0; i < gas.length; i++) {
        totalTank += gas[i] - cost[i];
        currentTank += gas[i] - cost[i];
        
        if (currentTank < 0) {
            start = i + 1;
            currentTank = 0;
        }
    }
    
    return totalTank >= 0 ? start : -1;
}
```

```cpp C++
int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
    // Find starting gas station to complete circuit
    int totalTank = 0;
    int currentTank = 0;
    int start = 0;
    
    for (int i = 0; i < gas.size(); i++) {
        totalTank += gas[i] - cost[i];
        currentTank += gas[i] - cost[i];
        
        if (currentTank < 0) {
            start = i + 1;
            currentTank = 0;
        }
    }
    
    return totalTank >= 0 ? start : -1;
}
```
</CodeGroup>

### 5. Partition Labels

<CodeGroup>
```python Python
def partition_labels(s):
    """Partition string so each letter appears in at most one part"""
    # Find last occurrence of each character
    last = {c: i for i, c in enumerate(s)}
    
    result = []
    start = 0
    end = 0
    
    for i, c in enumerate(s):
        end = max(end, last[c])
        
        if i == end:
            result.append(end - start + 1)
            start = i + 1
    
    return result
```

```java Java
public List<Integer> partitionLabels(String s) {
    // Partition string so each letter appears in at most one part
    int[] last = new int[26];
    for (int i = 0; i < s.length(); i++) {
        last[s.charAt(i) - 'a'] = i;
    }
    
    List<Integer> result = new ArrayList<>();
    int start = 0, end = 0;
    
    for (int i = 0; i < s.length(); i++) {
        end = Math.max(end, last[s.charAt(i) - 'a']);
        
        if (i == end) {
            result.add(end - start + 1);
            start = i + 1;
        }
    }
    
    return result;
}
```

```cpp C++
vector<int> partitionLabels(string s) {
    // Partition string so each letter appears in at most one part
    vector<int> last(26);
    for (int i = 0; i < s.size(); i++) {
        last[s[i] - 'a'] = i;
    }
    
    vector<int> result;
    int start = 0, end = 0;
    
    for (int i = 0; i < s.size(); i++) {
        end = max(end, last[s[i] - 'a']);
        
        if (i == end) {
            result.push_back(end - start + 1);
            start = i + 1;
        }
    }
    
    return result;
}
```
</CodeGroup>

## Classic Problems

<AccordionGroup>
  <Accordion title="1. Interval Scheduling" icon="calendar">
    **Pattern**: Sort by end time, greedily select non-overlapping
    
    **Key**: Earliest end time leaves most room for future
  </Accordion>
  
  <Accordion title="2. Jump Game" icon="person-running">
    **Pattern**: Track maximum reachable index
    
    **Key**: At each position, update farthest reach
  </Accordion>
  
  <Accordion title="3. Task Scheduler" icon="list-check">
    **Pattern**: Process most frequent tasks first
    
    **Key**: Idle time depends on most frequent task
  </Accordion>
  
  <Accordion title="4. Candy Distribution" icon="candy-cane">
    **Pattern**: Two passes (left to right, right to left)
    
    **Key**: Satisfy constraints from both directions
  </Accordion>
</AccordionGroup>

## Common Mistakes

<Warning>
**Avoid These Pitfalls:**
1. **Wrong greedy choice**: Not all locally optimal leads to global optimal
2. **Missing proof**: Greedy needs proof of correctness (exchange argument)
3. **Wrong sorting key**: End time vs start time matters for intervals
4. **Edge cases**: Empty input, single element, all same values
</Warning>

## How to Prove Greedy Works

<Steps>
  <Step title="Greedy Stays Ahead">
    Show that after each step, greedy is at least as good as optimal
  </Step>
  <Step title="Exchange Argument">
    Show that swapping a choice in optimal with greedy's choice doesn't hurt
  </Step>
  <Step title="Structural Induction">
    Prove base case + if true for size k, true for size k+1
  </Step>
</Steps>

## Interview Problems by Company

<Tabs>
  <Tab title="Easy">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Assign Cookies | Amazon | Sort both arrays |
    | Lemonade Change | Google | Track denominations |
    | Best Time to Buy Stock | All FAANG | Track minimum so far |
  </Tab>
  <Tab title="Medium">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Jump Game | Amazon, Meta | Max reachable index |
    | Gas Station | Amazon | Net gain tracking |
    | Non-overlapping Intervals | Google | Sort by end time |
    | Partition Labels | Amazon | Track last occurrence |
    | Task Scheduler | Meta | Most frequent first |
  </Tab>
  <Tab title="Hard">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Candy | Google, Amazon | Two passes |
    | IPO | Amazon | Two heaps |
    | Create Maximum Number | Google | Greedy + merge |
    | Minimum Number of Arrows | Meta | Interval scheduling |
  </Tab>
</Tabs>

## Interview Tips

<AccordionGroup>
  <Accordion title="How to Explain Your Approach" icon="comments">
    **Script for interviews:**
    
    1. "This looks like a greedy problem because local choices lead to global optimum."
    2. "My greedy strategy is: [describe the choice]"
    3. "This works because [brief justification]"
    4. "I'll sort by [criteria] first, then iterate greedily."
    5. "Time is O(n log n) for sorting, O(n) for the greedy pass."
  </Accordion>
  
  <Accordion title="When Interviewer Says..." icon="user-tie">
    | Interviewer Says | You Should Think |
    |-----------------|------------------|
    | "Minimum operations" | Greedy or DP |
    | "Schedule tasks/meetings" | Interval scheduling |
    | "Maximum profit/value" | Greedy or DP |
    | "Prove it's optimal" | Exchange argument |
    | "What if greedy fails?" | Consider DP |
  </Accordion>
  
  <Accordion title="Greedy Template" icon="code">
    ```python
    def solve_greedy(items):
        # Step 1: Sort by greedy criteria
        items.sort(key=lambda x: x.end_time)  # or other criteria
        
        result = 0
        current_state = initial_state
        
        # Step 2: Make greedy choice at each step
        for item in items:
            if can_include(item, current_state):
                result += 1
                current_state = update(current_state, item)
        
        return result
    ```
  </Accordion>
</AccordionGroup>

## Practice Problems

| Problem | Difficulty | Link |
|---------|------------|------|
| Jump Game | Medium | [LeetCode 55](https://leetcode.com/problems/jump-game/) |
| Gas Station | Medium | [LeetCode 134](https://leetcode.com/problems/gas-station/) |
| Partition Labels | Medium | [LeetCode 763](https://leetcode.com/problems/partition-labels/) |
| Task Scheduler | Medium | [LeetCode 621](https://leetcode.com/problems/task-scheduler/) |
| Non-overlapping Intervals | Medium | [LeetCode 435](https://leetcode.com/problems/non-overlapping-intervals/) |

## Practice Roadmap

<Steps>
  <Step title="Day 1: Basic Greedy">
    - Solve: Assign Cookies, Lemonade Change
    - Focus: Simple greedy choices
  </Step>
  <Step title="Day 2: Interval Problems">
    - Solve: Non-overlapping Intervals, Meeting Rooms
    - Focus: Sort by end time pattern
  </Step>
  <Step title="Day 3: Array Greedy">
    - Solve: Jump Game I and II, Gas Station
    - Focus: Tracking reachability
  </Step>
  <Step title="Day 4: Complex Greedy">
    - Solve: Task Scheduler, Candy
    - Focus: Multi-pass greedy
  </Step>
</Steps>

<Tip>
**Interview Tip**: Before applying greedy, ask yourself: "Does taking the best choice now prevent a better overall solution?" If yes, consider DP instead.
</Tip>
