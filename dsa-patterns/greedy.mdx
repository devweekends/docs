---
title: "Greedy Pattern"
description: "Solve optimization problems with locally optimal choices"
icon: "hand-holding-dollar"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/08-greedy.svg"
  alt="Greedy Pattern"
/>

## What is Greedy?

**Greedy** algorithms make the locally optimal choice at each step, hoping to find a global optimum. They work when local choices lead to global solutions (greedy choice property + optimal substructure).

## When to Use

<CardGroup cols={2}>
  <Card title="Scheduling" icon="calendar">
    Task scheduling, meeting rooms, intervals
  </Card>
  <Card title="Selection" icon="hand-pointer">
    Choosing items to maximize/minimize value
  </Card>
  <Card title="Graph Problems" icon="share-nodes">
    MST (Kruskal, Prim), shortest paths (Dijkstra)
  </Card>
  <Card title="String/Array" icon="text">
    Partition labels, jump game
  </Card>
</CardGroup>

## Pattern Variations

### 1. Interval Scheduling

<CodeGroup>
```python Python
def max_non_overlapping_intervals(intervals):
    """Maximum number of non-overlapping intervals"""
    if not intervals:
        return 0
    
    # Sort by end time (greedy choice: earliest ending first)
    intervals.sort(key=lambda x: x[1])
    
    count = 1
    end = intervals[0][1]
    
    for i in range(1, len(intervals)):
        if intervals[i][0] >= end:  # No overlap
            count += 1
            end = intervals[i][1]
    
    return count
```

```java Java
public int maxNonOverlappingIntervals(int[][] intervals) {
    // Maximum number of non-overlapping intervals
    if (intervals.length == 0) {
        return 0;
    }
    
    // Sort by end time (greedy choice: earliest ending first)
    Arrays.sort(intervals, (a, b) -> a[1] - b[1]);
    
    int count = 1;
    int end = intervals[0][1];
    
    for (int i = 1; i < intervals.length; i++) {
        if (intervals[i][0] >= end) {  // No overlap
            count++;
            end = intervals[i][1];
        }
    }
    
    return count;
}
```

```cpp C++
int maxNonOverlappingIntervals(vector<vector<int>>& intervals) {
    // Maximum number of non-overlapping intervals
    if (intervals.empty()) {
        return 0;
    }
    
    // Sort by end time (greedy choice: earliest ending first)
    sort(intervals.begin(), intervals.end(), 
         [](auto& a, auto& b) { return a[1] < b[1]; });
    
    int count = 1;
    int end = intervals[0][1];
    
    for (int i = 1; i < intervals.size(); i++) {
        if (intervals[i][0] >= end) {  // No overlap
            count++;
            end = intervals[i][1];
        }
    }
    
    return count;
}
```
</CodeGroup>

### 2. Activity Selection (Meeting Rooms)

<CodeGroup>
```python Python
def min_meeting_rooms(intervals):
    """Minimum rooms needed for all meetings"""
    if not intervals:
        return 0
    
    # Track start and end times separately
    starts = sorted([i[0] for i in intervals])
    ends = sorted([i[1] for i in intervals])
    
    rooms = 0
    max_rooms = 0
    s, e = 0, 0
    
    while s < len(starts):
        if starts[s] < ends[e]:
            rooms += 1
            s += 1
        else:
            rooms -= 1
            e += 1
        max_rooms = max(max_rooms, rooms)
    
    return max_rooms
```

```java Java
public int minMeetingRooms(int[][] intervals) {
    // Minimum rooms needed for all meetings
    if (intervals.length == 0) {
        return 0;
    }
    
    int[] starts = new int[intervals.length];
    int[] ends = new int[intervals.length];
    
    for (int i = 0; i < intervals.length; i++) {
        starts[i] = intervals[i][0];
        ends[i] = intervals[i][1];
    }
    
    Arrays.sort(starts);
    Arrays.sort(ends);
    
    int rooms = 0, maxRooms = 0;
    int s = 0, e = 0;
    
    while (s < starts.length) {
        if (starts[s] < ends[e]) {
            rooms++;
            s++;
        } else {
            rooms--;
            e++;
        }
        maxRooms = Math.max(maxRooms, rooms);
    }
    
    return maxRooms;
}
```

```cpp C++
int minMeetingRooms(vector<vector<int>>& intervals) {
    // Minimum rooms needed for all meetings
    if (intervals.empty()) {
        return 0;
    }
    
    vector<int> starts, ends;
    for (auto& interval : intervals) {
        starts.push_back(interval[0]);
        ends.push_back(interval[1]);
    }
    
    sort(starts.begin(), starts.end());
    sort(ends.begin(), ends.end());
    
    int rooms = 0, maxRooms = 0;
    int s = 0, e = 0;
    
    while (s < starts.size()) {
        if (starts[s] < ends[e]) {
            rooms++;
            s++;
        } else {
            rooms--;
            e++;
        }
        maxRooms = max(maxRooms, rooms);
    }
    
    return maxRooms;
}
```
</CodeGroup>

### 3. Jump Game

<CodeGroup>
```python Python
def can_jump(nums):
    """Can we reach the last index?"""
    max_reach = 0
    
    for i in range(len(nums)):
        if i > max_reach:
            return False
        max_reach = max(max_reach, i + nums[i])
    
    return True

def min_jumps(nums):
    """Minimum jumps to reach last index"""
    n = len(nums)
    if n <= 1:
        return 0
    
    jumps = 0
    current_end = 0
    farthest = 0
    
    for i in range(n - 1):
        farthest = max(farthest, i + nums[i])
        
        if i == current_end:
            jumps += 1
            current_end = farthest
    
    return jumps
```

```java Java
public boolean canJump(int[] nums) {
    // Can we reach the last index?
    int maxReach = 0;
    
    for (int i = 0; i < nums.length; i++) {
        if (i > maxReach) {
            return false;
        }
        maxReach = Math.max(maxReach, i + nums[i]);
    }
    
    return true;
}

public int minJumps(int[] nums) {
    // Minimum jumps to reach last index
    int n = nums.length;
    if (n <= 1) {
        return 0;
    }
    
    int jumps = 0;
    int currentEnd = 0;
    int farthest = 0;
    
    for (int i = 0; i < n - 1; i++) {
        farthest = Math.max(farthest, i + nums[i]);
        
        if (i == currentEnd) {
            jumps++;
            currentEnd = farthest;
        }
    }
    
    return jumps;
}
```

```cpp C++
bool canJump(vector<int>& nums) {
    // Can we reach the last index?
    int maxReach = 0;
    
    for (int i = 0; i < nums.size(); i++) {
        if (i > maxReach) {
            return false;
        }
        maxReach = max(maxReach, i + nums[i]);
    }
    
    return true;
}

int minJumps(vector<int>& nums) {
    // Minimum jumps to reach last index
    int n = nums.size();
    if (n <= 1) {
        return 0;
    }
    
    int jumps = 0;
    int currentEnd = 0;
    int farthest = 0;
    
    for (int i = 0; i < n - 1; i++) {
        farthest = max(farthest, i + nums[i]);
        
        if (i == currentEnd) {
            jumps++;
            currentEnd = farthest;
        }
    }
    
    return jumps;
}
```
</CodeGroup>

### 4. Gas Station

<CodeGroup>
```python Python
def can_complete_circuit(gas, cost):
    """Find starting gas station to complete circuit"""
    total_tank = 0
    current_tank = 0
    start = 0
    
    for i in range(len(gas)):
        total_tank += gas[i] - cost[i]
        current_tank += gas[i] - cost[i]
        
        if current_tank < 0:
            start = i + 1
            current_tank = 0
    
    return start if total_tank >= 0 else -1
```

```java Java
public int canCompleteCircuit(int[] gas, int[] cost) {
    // Find starting gas station to complete circuit
    int totalTank = 0;
    int currentTank = 0;
    int start = 0;
    
    for (int i = 0; i < gas.length; i++) {
        totalTank += gas[i] - cost[i];
        currentTank += gas[i] - cost[i];
        
        if (currentTank < 0) {
            start = i + 1;
            currentTank = 0;
        }
    }
    
    return totalTank >= 0 ? start : -1;
}
```

```cpp C++
int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
    // Find starting gas station to complete circuit
    int totalTank = 0;
    int currentTank = 0;
    int start = 0;
    
    for (int i = 0; i < gas.size(); i++) {
        totalTank += gas[i] - cost[i];
        currentTank += gas[i] - cost[i];
        
        if (currentTank < 0) {
            start = i + 1;
            currentTank = 0;
        }
    }
    
    return totalTank >= 0 ? start : -1;
}
```
</CodeGroup>

### 5. Partition Labels

<CodeGroup>
```python Python
def partition_labels(s):
    """Partition string so each letter appears in at most one part"""
    # Find last occurrence of each character
    last = {c: i for i, c in enumerate(s)}
    
    result = []
    start = 0
    end = 0
    
    for i, c in enumerate(s):
        end = max(end, last[c])
        
        if i == end:
            result.append(end - start + 1)
            start = i + 1
    
    return result
```

```java Java
public List<Integer> partitionLabels(String s) {
    // Partition string so each letter appears in at most one part
    int[] last = new int[26];
    for (int i = 0; i < s.length(); i++) {
        last[s.charAt(i) - 'a'] = i;
    }
    
    List<Integer> result = new ArrayList<>();
    int start = 0, end = 0;
    
    for (int i = 0; i < s.length(); i++) {
        end = Math.max(end, last[s.charAt(i) - 'a']);
        
        if (i == end) {
            result.add(end - start + 1);
            start = i + 1;
        }
    }
    
    return result;
}
```

```cpp C++
vector<int> partitionLabels(string s) {
    // Partition string so each letter appears in at most one part
    vector<int> last(26);
    for (int i = 0; i < s.size(); i++) {
        last[s[i] - 'a'] = i;
    }
    
    vector<int> result;
    int start = 0, end = 0;
    
    for (int i = 0; i < s.size(); i++) {
        end = max(end, last[s[i] - 'a']);
        
        if (i == end) {
            result.push_back(end - start + 1);
            start = i + 1;
        }
    }
    
    return result;
}
```
</CodeGroup>

## Classic Problems

<AccordionGroup>
  <Accordion title="1. Interval Scheduling" icon="calendar">
    **Pattern**: Sort by end time, greedily select non-overlapping
    
    **Key**: Earliest end time leaves most room for future
  </Accordion>
  
  <Accordion title="2. Jump Game" icon="person-running">
    **Pattern**: Track maximum reachable index
    
    **Key**: At each position, update farthest reach
  </Accordion>
  
  <Accordion title="3. Task Scheduler" icon="list-check">
    **Pattern**: Process most frequent tasks first
    
    **Key**: Idle time depends on most frequent task
  </Accordion>
  
  <Accordion title="4. Candy Distribution" icon="candy-cane">
    **Pattern**: Two passes (left to right, right to left)
    
    **Key**: Satisfy constraints from both directions
  </Accordion>
</AccordionGroup>

## Common Mistakes

<Warning>
**Avoid These Pitfalls:**
1. **Wrong greedy choice**: Not all locally optimal leads to global optimal
2. **Missing proof**: Greedy needs proof of correctness (exchange argument)
3. **Wrong sorting key**: End time vs start time matters for intervals
4. **Edge cases**: Empty input, single element, all same values
</Warning>

## Practice Problems

| Problem | Difficulty | Link |
|---------|------------|------|
| Jump Game | Medium | [LeetCode 55](https://leetcode.com/problems/jump-game/) |
| Gas Station | Medium | [LeetCode 134](https://leetcode.com/problems/gas-station/) |
| Partition Labels | Medium | [LeetCode 763](https://leetcode.com/problems/partition-labels/) |
| Task Scheduler | Medium | [LeetCode 621](https://leetcode.com/problems/task-scheduler/) |
| Non-overlapping Intervals | Medium | [LeetCode 435](https://leetcode.com/problems/non-overlapping-intervals/) |

<Tip>
**Interview Tip**: Before applying greedy, ask yourself: "Does taking the best choice now prevent a better overall solution?" If yes, consider DP instead.
</Tip>
