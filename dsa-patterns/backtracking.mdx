---
title: "Backtracking Pattern"
description: "Solve constraint satisfaction problems with systematic exploration"
icon: "rotate-left"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/07-backtracking.svg"
  alt="Backtracking Pattern"
/>

## What is Backtracking?

**Backtracking** is a systematic way to explore all possible solutions by building candidates incrementally and abandoning a path ("backtracking") as soon as it violates constraints.

<Note>
**Quick Recognition**: If you need to **generate all** possibilities, find **all valid combinations**, or solve **constraint satisfaction** problems, think Backtracking!
</Note>

## Pattern Recognition Checklist

<CardGroup cols={2}>
  <Card title="Use Backtracking When" icon="check">
    - Need **all combinations/permutations**
    - Problem is about **constraint satisfaction**
    - **Generate all** valid solutions
    - Need to explore **decision tree**
    - **Pruning** can reduce search space
  </Card>
  <Card title="Don't Use When" icon="xmark">
    - Only need **one solution** (might use simpler approach)
    - **Optimal solution** needed (use DP instead)
    - **Counting** only (DP often better)
    - No way to **prune** invalid paths
  </Card>
</CardGroup>

## When to Use

<CardGroup cols={2}>
  <Card title="Combinations/Permutations" icon="shuffle">
    Generate all arrangements or selections
  </Card>
  <Card title="Subsets" icon="layer-group">
    Generate all possible subsets
  </Card>
  <Card title="Constraint Satisfaction" icon="puzzle-piece">
    Sudoku, N-Queens, crosswords
  </Card>
  <Card title="Path Finding" icon="route">
    Find all paths, word search
  </Card>
</CardGroup>

## Core Template

<CodeGroup>
```python Python
def backtrack(path, choices):
    if is_solution(path):
        result.append(path[:])  # Save a copy
        return
    
    for choice in choices:
        if is_valid(choice, path):
            # Make choice
            path.append(choice)
            
            # Explore with this choice
            backtrack(path, updated_choices)
            
            # Undo choice (backtrack)
            path.pop()
```

```java Java
void backtrack(List<Integer> path, int[] choices) {
    if (isSolution(path)) {
        result.add(new ArrayList<>(path));  // Save a copy
        return;
    }
    
    for (int choice : choices) {
        if (isValid(choice, path)) {
            // Make choice
            path.add(choice);
            
            // Explore with this choice
            backtrack(path, updatedChoices);
            
            // Undo choice (backtrack)
            path.remove(path.size() - 1);
        }
    }
}
```

```cpp C++
void backtrack(vector<int>& path, vector<int>& choices) {
    if (isSolution(path)) {
        result.push_back(path);  // Save a copy
        return;
    }
    
    for (int choice : choices) {
        if (isValid(choice, path)) {
            // Make choice
            path.push_back(choice);
            
            // Explore with this choice
            backtrack(path, updatedChoices);
            
            // Undo choice (backtrack)
            path.pop_back();
        }
    }
}
```
</CodeGroup>

## Pattern Variations

### 1. Subsets (All Combinations)

<CodeGroup>
```python Python
def subsets(nums):
    """Generate all subsets of nums"""
    result = []
    
    def backtrack(start, current):
        result.append(current[:])  # Every path is valid
        
        for i in range(start, len(nums)):
            current.append(nums[i])
            backtrack(i + 1, current)  # Move forward only
            current.pop()
    
    backtrack(0, [])
    return result

# Example: [1,2,3] -> [[], [1], [1,2], [1,2,3], [1,3], [2], [2,3], [3]]
```

```java Java
public List<List<Integer>> subsets(int[] nums) {
    // Generate all subsets of nums
    List<List<Integer>> result = new ArrayList<>();
    backtrack(nums, 0, new ArrayList<>(), result);
    return result;
}

private void backtrack(int[] nums, int start, List<Integer> current, 
                       List<List<Integer>> result) {
    result.add(new ArrayList<>(current));  // Every path is valid
    
    for (int i = start; i < nums.length; i++) {
        current.add(nums[i]);
        backtrack(nums, i + 1, current, result);  // Move forward only
        current.remove(current.size() - 1);
    }
}
```

```cpp C++
vector<vector<int>> subsets(vector<int>& nums) {
    // Generate all subsets of nums
    vector<vector<int>> result;
    vector<int> current;
    
    function<void(int)> backtrack = [&](int start) {
        result.push_back(current);  // Every path is valid
        
        for (int i = start; i < nums.size(); i++) {
            current.push_back(nums[i]);
            backtrack(i + 1);  // Move forward only
            current.pop_back();
        }
    };
    
    backtrack(0);
    return result;
}
```
</CodeGroup>

### 2. Permutations

<CodeGroup>
```python Python
def permutations(nums):
    """Generate all permutations of nums"""
    result = []
    used = [False] * len(nums)
    
    def backtrack(current):
        if len(current) == len(nums):
            result.append(current[:])
            return
        
        for i in range(len(nums)):
            if used[i]:
                continue
            
            used[i] = True
            current.append(nums[i])
            
            backtrack(current)
            
            current.pop()
            used[i] = False
    
    backtrack([])
    return result
```

```java Java
public List<List<Integer>> permutations(int[] nums) {
    // Generate all permutations of nums
    List<List<Integer>> result = new ArrayList<>();
    boolean[] used = new boolean[nums.length];
    backtrack(nums, new ArrayList<>(), used, result);
    return result;
}

private void backtrack(int[] nums, List<Integer> current, 
                       boolean[] used, List<List<Integer>> result) {
    if (current.size() == nums.length) {
        result.add(new ArrayList<>(current));
        return;
    }
    
    for (int i = 0; i < nums.length; i++) {
        if (used[i]) {
            continue;
        }
        
        used[i] = true;
        current.add(nums[i]);
        
        backtrack(nums, current, used, result);
        
        current.remove(current.size() - 1);
        used[i] = false;
    }
}
```

```cpp C++
vector<vector<int>> permutations(vector<int>& nums) {
    // Generate all permutations of nums
    vector<vector<int>> result;
    vector<int> current;
    vector<bool> used(nums.size(), false);
    
    function<void()> backtrack = [&]() {
        if (current.size() == nums.size()) {
            result.push_back(current);
            return;
        }
        
        for (int i = 0; i < nums.size(); i++) {
            if (used[i]) {
                continue;
            }
            
            used[i] = true;
            current.push_back(nums[i]);
            
            backtrack();
            
            current.pop_back();
            used[i] = false;
        }
    };
    
    backtrack();
    return result;
}
```
</CodeGroup>

### 3. Combinations (Choose K)

<CodeGroup>
```python Python
def combinations(n, k):
    """Choose k numbers from 1 to n"""
    result = []
    
    def backtrack(start, current):
        if len(current) == k:
            result.append(current[:])
            return
        
        # Pruning: need k - len(current) more numbers
        remaining_needed = k - len(current)
        for i in range(start, n - remaining_needed + 2):
            current.append(i)
            backtrack(i + 1, current)
            current.pop()
    
    backtrack(1, [])
    return result
```

```java Java
public List<List<Integer>> combinations(int n, int k) {
    // Choose k numbers from 1 to n
    List<List<Integer>> result = new ArrayList<>();
    backtrack(n, k, 1, new ArrayList<>(), result);
    return result;
}

private void backtrack(int n, int k, int start, List<Integer> current,
                       List<List<Integer>> result) {
    if (current.size() == k) {
        result.add(new ArrayList<>(current));
        return;
    }
    
    // Pruning: need k - current.size() more numbers
    int remainingNeeded = k - current.size();
    for (int i = start; i <= n - remainingNeeded + 1; i++) {
        current.add(i);
        backtrack(n, k, i + 1, current, result);
        current.remove(current.size() - 1);
    }
}
```

```cpp C++
vector<vector<int>> combinations(int n, int k) {
    // Choose k numbers from 1 to n
    vector<vector<int>> result;
    vector<int> current;
    
    function<void(int)> backtrack = [&](int start) {
        if (current.size() == k) {
            result.push_back(current);
            return;
        }
        
        // Pruning: need k - current.size() more numbers
        int remainingNeeded = k - current.size();
        for (int i = start; i <= n - remainingNeeded + 1; i++) {
            current.push_back(i);
            backtrack(i + 1);
            current.pop_back();
        }
    };
    
    backtrack(1);
    return result;
}
```
</CodeGroup>

### 4. N-Queens

<CodeGroup>
```python Python
def solve_n_queens(n):
    """Place n queens on n x n board so no two attack each other"""
    result = []
    board = [['.'] * n for _ in range(n)]
    
    def is_safe(row, col):
        # Check column
        for i in range(row):
            if board[i][col] == 'Q':
                return False
        
        # Check upper-left diagonal
        i, j = row - 1, col - 1
        while i >= 0 and j >= 0:
            if board[i][j] == 'Q':
                return False
            i -= 1
            j -= 1
        
        # Check upper-right diagonal
        i, j = row - 1, col + 1
        while i >= 0 and j < n:
            if board[i][j] == 'Q':
                return False
            i -= 1
            j += 1
        
        return True
    
    def backtrack(row):
        if row == n:
            result.append([''.join(r) for r in board])
            return
        
        for col in range(n):
            if is_safe(row, col):
                board[row][col] = 'Q'
                backtrack(row + 1)
                board[row][col] = '.'
    
    backtrack(0)
    return result
```

```java Java
public List<List<String>> solveNQueens(int n) {
    // Place n queens on n x n board so no two attack each other
    List<List<String>> result = new ArrayList<>();
    char[][] board = new char[n][n];
    for (char[] row : board) {
        Arrays.fill(row, '.');
    }
    
    backtrack(board, 0, result);
    return result;
}

private void backtrack(char[][] board, int row, List<List<String>> result) {
    if (row == board.length) {
        List<String> solution = new ArrayList<>();
        for (char[] r : board) {
            solution.add(new String(r));
        }
        result.add(solution);
        return;
    }
    
    for (int col = 0; col < board.length; col++) {
        if (isSafe(board, row, col)) {
            board[row][col] = 'Q';
            backtrack(board, row + 1, result);
            board[row][col] = '.';
        }
    }
}

private boolean isSafe(char[][] board, int row, int col) {
    int n = board.length;
    
    // Check column
    for (int i = 0; i < row; i++) {
        if (board[i][col] == 'Q') return false;
    }
    
    // Check upper-left diagonal
    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
        if (board[i][j] == 'Q') return false;
    }
    
    // Check upper-right diagonal
    for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
        if (board[i][j] == 'Q') return false;
    }
    
    return true;
}
```

```cpp C++
vector<vector<string>> solveNQueens(int n) {
    // Place n queens on n x n board so no two attack each other
    vector<vector<string>> result;
    vector<string> board(n, string(n, '.'));
    
    function<bool(int, int)> isSafe = [&](int row, int col) {
        // Check column
        for (int i = 0; i < row; i++) {
            if (board[i][col] == 'Q') return false;
        }
        
        // Check upper-left diagonal
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 'Q') return false;
        }
        
        // Check upper-right diagonal
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (board[i][j] == 'Q') return false;
        }
        
        return true;
    };
    
    function<void(int)> backtrack = [&](int row) {
        if (row == n) {
            result.push_back(board);
            return;
        }
        
        for (int col = 0; col < n; col++) {
            if (isSafe(row, col)) {
                board[row][col] = 'Q';
                backtrack(row + 1);
                board[row][col] = '.';
            }
        }
    };
    
    backtrack(0);
    return result;
}
```
</CodeGroup>

## Classic Problems

<AccordionGroup>
  <Accordion title="1. Subsets" icon="layer-group">
    **Pattern**: Include or exclude each element
    
    **Key**: Every path is a valid subset
  </Accordion>
  
  <Accordion title="2. Permutations" icon="shuffle">
    **Pattern**: Use boolean array to track used elements
    
    **Key**: All positions are valid choices
  </Accordion>
  
  <Accordion title="3. Combination Sum" icon="plus">
    **Pattern**: Subsets with target sum, elements reusable
    
    **Key**: Start from same index (not i+1) for reuse
  </Accordion>
  
  <Accordion title="4. Word Search" icon="spell-check">
    **Pattern**: Grid DFS with backtracking
    
    **Key**: Mark visited, restore after exploration
  </Accordion>
</AccordionGroup>

## Common Mistakes

<Warning>
**Avoid These Pitfalls:**
1. **Not copying path**: Use `path[:]` or `new ArrayList(path)` when saving
2. **Forgetting to backtrack**: Always undo the choice after exploring
3. **Duplicate results**: Skip same values at same level for unique results
4. **Infinite loops**: Ensure progress by moving start index forward
</Warning>

## The Backtracking Template

Every backtracking solution follows this structure:

```
function backtrack(path, choices):
    if is_solution(path):
        save(path)
        return
    
    for choice in choices:
        if is_valid(choice):
            make_choice(path, choice)
            backtrack(path, remaining_choices)
            undo_choice(path, choice)  # BACKTRACK!
```

## Problem Type Quick Reference

| Problem Type | Include/Exclude | Start Index | Reuse Elements |
|-------------|-----------------|-------------|----------------|
| Subsets | Every node is result | i + 1 | No |
| Combinations | Leaf nodes only | i + 1 | No |
| Combination Sum | Leaf nodes only | i (same) | Yes |
| Permutations | Leaf nodes only | 0 (use visited) | No |
| Unique Results | Skip duplicates at same level | i + 1 | No |

## Interview Problems by Company

<Tabs>
  <Tab title="Medium">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Subsets | All FAANG | Basic include/exclude |
    | Permutations | All FAANG | Used array tracking |
    | Combination Sum | Amazon, Meta | Reusable elements |
    | Letter Combinations | Meta | Phone keypad mapping |
    | Word Search | Amazon, Meta | Grid backtracking |
  </Tab>
  <Tab title="Hard">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | N-Queens | Google, Meta | Constraint validation |
    | Sudoku Solver | Amazon | Complex constraints |
    | Palindrome Partition | Google | All valid partitions |
    | Word Search II | Amazon | Trie + backtracking |
    | Expression Add Operators | Meta | String manipulation |
  </Tab>
</Tabs>

## Interview Tips

<AccordionGroup>
  <Accordion title="How to Explain Your Approach" icon="comments">
    **Script for interviews:**
    
    1. "This requires generating all possibilities, so I'll use backtracking."
    2. "I'll build solutions incrementally, making one choice at a time."
    3. "At each step, I'll check if the current path is valid."
    4. "After exploring a choice, I'll undo it (backtrack) and try the next."
    5. "I'll prune invalid paths early to optimize."
  </Accordion>
  
  <Accordion title="When Interviewer Says..." icon="user-tie">
    | Interviewer Says | You Should Think |
    |-----------------|------------------|
    | "Generate all combinations" | Backtracking |
    | "Find all permutations" | Backtracking with used array |
    | "All valid configurations" | Backtracking with constraints |
    | "Can you prune?" | Early termination conditions |
    | "Handle duplicates" | Sort + skip same at same level |
  </Accordion>
  
  <Accordion title="Avoiding Duplicates" icon="clone">
    When input has duplicates but you need unique results:
    
    1. **Sort the input** first
    2. **Skip duplicates at same level**: `if i > start and nums[i] == nums[i-1]: continue`
    3. This ensures same value isn't used twice at same position in recursion tree
  </Accordion>
</AccordionGroup>

## Practice Problems

| Problem | Difficulty | Link |
|---------|------------|------|
| Subsets | Medium | [LeetCode 78](https://leetcode.com/problems/subsets/) |
| Permutations | Medium | [LeetCode 46](https://leetcode.com/problems/permutations/) |
| Combination Sum | Medium | [LeetCode 39](https://leetcode.com/problems/combination-sum/) |
| N-Queens | Hard | [LeetCode 51](https://leetcode.com/problems/n-queens/) |
| Word Search | Medium | [LeetCode 79](https://leetcode.com/problems/word-search/) |

## Practice Roadmap

<Steps>
  <Step title="Day 1: Subsets">
    - Solve: Subsets, Subsets II
    - Focus: Include/exclude pattern
  </Step>
  <Step title="Day 2: Combinations">
    - Solve: Combinations, Combination Sum
    - Focus: Target constraints
  </Step>
  <Step title="Day 3: Permutations">
    - Solve: Permutations, Permutations II
    - Focus: Used array tracking
  </Step>
  <Step title="Day 4: Grid Problems">
    - Solve: Word Search, N-Queens
    - Focus: 2D backtracking
  </Step>
</Steps>

<Tip>
**Interview Tip**: Draw the decision tree to visualize choices at each step. This helps identify the base case and pruning conditions.
</Tip>
