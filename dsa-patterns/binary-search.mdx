---
title: "Binary Search Pattern"
description: "Master binary search for sorted arrays and optimization problems"
icon: "magnifying-glass"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/03-binary-search.svg"
  alt="Binary Search Pattern"
/>

## What is Binary Search?

**Binary Search** is a divide-and-conquer algorithm that repeatedly halves the search space. It reduces O(n) linear search to O(log n) by eliminating half the possibilities at each step.

## When to Use

<CardGroup cols={2}>
  <Card title="Sorted Arrays" icon="arrow-up-1-9">
    Finding elements, insertion points, or bounds
  </Card>
  <Card title="Monotonic Functions" icon="chart-line">
    Finding transition points where condition changes
  </Card>
  <Card title="Optimization Problems" icon="bullseye">
    Minimizing/maximizing values with feasibility check
  </Card>
  <Card title="Hidden Sorted Space" icon="eye">
    Rotated arrays, peak finding, matrix search
  </Card>
</CardGroup>

## Pattern Variations

### 1. Standard Binary Search

Find exact target in sorted array.

<CodeGroup>
```python Python
def binary_search(arr, target):
    """Find target in sorted array, return index or -1"""
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2  # Avoid overflow
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1
```

```java Java
public int binarySearch(int[] arr, int target) {
    // Find target in sorted array, return index or -1
    int left = 0, right = arr.length - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;  // Avoid overflow
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}
```

```cpp C++
int binarySearch(vector<int>& arr, int target) {
    // Find target in sorted array, return index or -1
    int left = 0, right = arr.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;  // Avoid overflow
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}
```
</CodeGroup>

### 2. Lower Bound (First Occurrence)

Find first element greater than or equal to target.

<CodeGroup>
```python Python
def lower_bound(arr, target):
    """Find first index where arr[i] >= target"""
    left, right = 0, len(arr)
    
    while left < right:
        mid = left + (right - left) // 2
        
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid  # Don't exclude mid, it could be answer
    
    return left
```

```java Java
public int lowerBound(int[] arr, int target) {
    // Find first index where arr[i] >= target
    int left = 0, right = arr.length;
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;  // Don't exclude mid, it could be answer
        }
    }
    
    return left;
}
```

```cpp C++
int lowerBound(vector<int>& arr, int target) {
    // Find first index where arr[i] >= target
    int left = 0, right = arr.size();
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;  // Don't exclude mid, it could be answer
        }
    }
    
    return left;
}
```
</CodeGroup>

### 3. Upper Bound (Last Occurrence)

Find first element greater than target.

<CodeGroup>
```python Python
def upper_bound(arr, target):
    """Find first index where arr[i] > target"""
    left, right = 0, len(arr)
    
    while left < right:
        mid = left + (right - left) // 2
        
        if arr[mid] <= target:
            left = mid + 1
        else:
            right = mid
    
    return left
```

```java Java
public int upperBound(int[] arr, int target) {
    // Find first index where arr[i] > target
    int left = 0, right = arr.length;
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] <= target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    
    return left;
}
```

```cpp C++
int upperBound(vector<int>& arr, int target) {
    // Find first index where arr[i] > target
    int left = 0, right = arr.size();
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] <= target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    
    return left;
}
```
</CodeGroup>

### 4. Binary Search on Answer

When searching for optimal value, not index.

<CodeGroup>
```python Python
def min_capacity_to_ship(weights, days):
    """Minimum ship capacity to ship all packages in given days"""
    
    def can_ship(capacity):
        current_weight = 0
        days_needed = 1
        
        for weight in weights:
            if current_weight + weight > capacity:
                days_needed += 1
                current_weight = 0
            current_weight += weight
        
        return days_needed <= days
    
    # Search space: [max single weight, sum of all weights]
    left = max(weights)
    right = sum(weights)
    
    while left < right:
        mid = left + (right - left) // 2
        
        if can_ship(mid):
            right = mid  # Try smaller capacity
        else:
            left = mid + 1  # Need more capacity
    
    return left
```

```java Java
public int minCapacityToShip(int[] weights, int days) {
    // Minimum ship capacity to ship all packages in given days
    int left = 0, right = 0;
    for (int w : weights) {
        left = Math.max(left, w);
        right += w;
    }
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (canShip(weights, mid, days)) {
            right = mid;  // Try smaller capacity
        } else {
            left = mid + 1;  // Need more capacity
        }
    }
    
    return left;
}

private boolean canShip(int[] weights, int capacity, int days) {
    int currentWeight = 0;
    int daysNeeded = 1;
    
    for (int weight : weights) {
        if (currentWeight + weight > capacity) {
            daysNeeded++;
            currentWeight = 0;
        }
        currentWeight += weight;
    }
    
    return daysNeeded <= days;
}
```

```cpp C++
bool canShip(vector<int>& weights, int capacity, int days) {
    int currentWeight = 0;
    int daysNeeded = 1;
    
    for (int weight : weights) {
        if (currentWeight + weight > capacity) {
            daysNeeded++;
            currentWeight = 0;
        }
        currentWeight += weight;
    }
    
    return daysNeeded <= days;
}

int minCapacityToShip(vector<int>& weights, int days) {
    // Minimum ship capacity to ship all packages in given days
    int left = *max_element(weights.begin(), weights.end());
    int right = accumulate(weights.begin(), weights.end(), 0);
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (canShip(weights, mid, days)) {
            right = mid;  // Try smaller capacity
        } else {
            left = mid + 1;  // Need more capacity
        }
    }
    
    return left;
}
```
</CodeGroup>

## Classic Problems

<AccordionGroup>
  <Accordion title="1. Search in Rotated Sorted Array" icon="rotate">
    **Problem**: Search for target in rotated sorted array.
    
    **Approach**: Find which half is sorted, determine if target is in that half.
    
    **Time**: O(log n) | **Space**: O(1)
  </Accordion>
  
  <Accordion title="2. Find Peak Element" icon="mountain">
    **Problem**: Find any peak element (greater than neighbors).
    
    **Approach**: Compare mid with mid+1, move towards the larger side.
    
    **Time**: O(log n) | **Space**: O(1)
  </Accordion>
  
  <Accordion title="3. Search 2D Matrix" icon="table">
    **Problem**: Search in row-wise and column-wise sorted matrix.
    
    **Approach**: Treat as 1D array or start from top-right corner.
    
    **Time**: O(log(m*n)) or O(m+n) | **Space**: O(1)
  </Accordion>
  
  <Accordion title="4. Koko Eating Bananas" icon="apple-whole">
    **Problem**: Minimum eating speed to finish all bananas in h hours.
    
    **Approach**: Binary search on answer with feasibility check.
    
    **Time**: O(n log m) | **Space**: O(1)
  </Accordion>
  
  <Accordion title="5. Median of Two Sorted Arrays" icon="chart-simple">
    **Problem**: Find median of two sorted arrays in O(log(m+n)).
    
    **Approach**: Binary search on partition point of smaller array.
    
    **Time**: O(log(min(m,n))) | **Space**: O(1)
  </Accordion>
</AccordionGroup>

## Search in Rotated Sorted Array

<CodeGroup>
```python Python
def search_rotated(nums, target):
    """Search for target in rotated sorted array"""
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if nums[mid] == target:
            return mid
        
        # Left half is sorted
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        # Right half is sorted
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    
    return -1
```

```java Java
public int searchRotated(int[] nums, int target) {
    // Search for target in rotated sorted array
    int left = 0, right = nums.length - 1;
    
    while (left <= right) {
        int mid = (left + right) / 2;
        
        if (nums[mid] == target) {
            return mid;
        }
        
        // Left half is sorted
        if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        // Right half is sorted
        } else {
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    
    return -1;
}
```

```cpp C++
int searchRotated(vector<int>& nums, int target) {
    // Search for target in rotated sorted array
    int left = 0, right = nums.size() - 1;
    
    while (left <= right) {
        int mid = (left + right) / 2;
        
        if (nums[mid] == target) {
            return mid;
        }
        
        // Left half is sorted
        if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        // Right half is sorted
        } else {
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    
    return -1;
}
```
</CodeGroup>

## Template Code

<CodeGroup>
```python Python
# Template 1: Standard (find exact match)
def binary_search_standard(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

# Template 2: Lower bound (first >= target)
def binary_search_lower(arr, target):
    left, right = 0, len(arr)
    while left < right:
        mid = left + (right - left) // 2
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid
    return left

# Template 3: Binary search on answer
def binary_search_answer(low, high, is_valid):
    while low < high:
        mid = low + (high - low) // 2
        if is_valid(mid):
            high = mid
        else:
            low = mid + 1
    return low
```

```java Java
// Template 1: Standard (find exact match)
public int binarySearchStandard(int[] arr, int target) {
    int left = 0, right = arr.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}

// Template 2: Lower bound (first >= target)
public int binarySearchLower(int[] arr, int target) {
    int left = 0, right = arr.length;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}

// Template 3: Binary search on answer
public int binarySearchAnswer(int low, int high, Predicate<Integer> isValid) {
    while (low < high) {
        int mid = low + (high - low) / 2;
        if (isValid.test(mid)) {
            high = mid;
        } else {
            low = mid + 1;
        }
    }
    return low;
}
```

```cpp C++
// Template 1: Standard (find exact match)
int binarySearchStandard(vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}

// Template 2: Lower bound (first >= target)
int binarySearchLower(vector<int>& arr, int target) {
    int left = 0, right = arr.size();
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}

// Template 3: Binary search on answer
int binarySearchAnswer(int low, int high, function<bool(int)> isValid) {
    while (low < high) {
        int mid = low + (high - low) / 2;
        if (isValid(mid)) {
            high = mid;
        } else {
            low = mid + 1;
        }
    }
    return low;
}
```
</CodeGroup>

## Common Mistakes

<Warning>
**Avoid These Pitfalls:**
1. **Integer Overflow**: Use `mid = left + (right - left) / 2` instead of `(left + right) / 2`
2. **Infinite Loop**: Ensure left or right changes every iteration
3. **Off-by-one**: Know when to use `left <= right` vs `left < right`
4. **Wrong boundary**: Include or exclude mid based on problem type
</Warning>

## Practice Problems

| Problem | Difficulty | Link |
|---------|------------|------|
| Binary Search | Easy | [LeetCode 704](https://leetcode.com/problems/binary-search/) |
| Search Insert Position | Easy | [LeetCode 35](https://leetcode.com/problems/search-insert-position/) |
| Search in Rotated Sorted Array | Medium | [LeetCode 33](https://leetcode.com/problems/search-in-rotated-sorted-array/) |
| Find Peak Element | Medium | [LeetCode 162](https://leetcode.com/problems/find-peak-element/) |
| Median of Two Sorted Arrays | Hard | [LeetCode 4](https://leetcode.com/problems/median-of-two-sorted-arrays/) |

<Tip>
**Interview Tip**: When you see "sorted array" or "minimize/maximize" with a feasibility check, think Binary Search immediately.
</Tip>
