---
title: "Binary Search Pattern"
description: "Master binary search for sorted arrays and optimization problems"
icon: "magnifying-glass"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/03-binary-search.svg"
  alt="Binary Search Pattern"
/>

## What is Binary Search?

**Binary Search** is a divide-and-conquer algorithm that repeatedly halves the search space. It reduces O(n) linear search to O(log n) by eliminating half the possibilities at each step.

<Note>
**Quick Recognition**: If you see **"sorted array"** or need to **minimize/maximize** something with a feasibility check, Binary Search is likely the answer!
</Note>

## Pattern Recognition Checklist

<CardGroup cols={2}>
  <Card title="Use Binary Search When" icon="check">
    - Array is **sorted** (or has monotonic property)
    - Need O(log n) instead of O(n)
    - **Minimize/maximize** with feasibility check
    - Finding **transition point** where condition changes
    - Search space can be **halved** each step
  </Card>
  <Card title="Don't Use When" icon="xmark">
    - Array is **unsorted** with no order
    - Need to find **all occurrences**
    - **Linear scan** is already O(n) and sufficient
    - No clear way to **eliminate half**
  </Card>
</CardGroup>

## When to Use

<CardGroup cols={2}>
  <Card title="Sorted Arrays" icon="arrow-up-1-9">
    Finding elements, insertion points, or bounds
  </Card>
  <Card title="Monotonic Functions" icon="chart-line">
    Finding transition points where condition changes
  </Card>
  <Card title="Optimization Problems" icon="bullseye">
    Minimizing/maximizing values with feasibility check
  </Card>
  <Card title="Hidden Sorted Space" icon="eye">
    Rotated arrays, peak finding, matrix search
  </Card>
</CardGroup>

## Pattern Variations

### 1. Standard Binary Search

Find exact target in sorted array.

<CodeGroup>
```python Python
def binary_search(arr, target):
    """Find target in sorted array, return index or -1"""
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2  # Avoid overflow
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1
```

```java Java
public int binarySearch(int[] arr, int target) {
    // Find target in sorted array, return index or -1
    int left = 0, right = arr.length - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;  // Avoid overflow
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}
```

```cpp C++
int binarySearch(vector<int>& arr, int target) {
    // Find target in sorted array, return index or -1
    int left = 0, right = arr.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;  // Avoid overflow
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}
```
</CodeGroup>

### 2. Lower Bound (First Occurrence)

Find first element greater than or equal to target.

<CodeGroup>
```python Python
def lower_bound(arr, target):
    """Find first index where arr[i] >= target"""
    left, right = 0, len(arr)
    
    while left < right:
        mid = left + (right - left) // 2
        
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid  # Don't exclude mid, it could be answer
    
    return left
```

```java Java
public int lowerBound(int[] arr, int target) {
    // Find first index where arr[i] >= target
    int left = 0, right = arr.length;
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;  // Don't exclude mid, it could be answer
        }
    }
    
    return left;
}
```

```cpp C++
int lowerBound(vector<int>& arr, int target) {
    // Find first index where arr[i] >= target
    int left = 0, right = arr.size();
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;  // Don't exclude mid, it could be answer
        }
    }
    
    return left;
}
```
</CodeGroup>

### 3. Upper Bound (Last Occurrence)

Find first element greater than target.

<CodeGroup>
```python Python
def upper_bound(arr, target):
    """Find first index where arr[i] > target"""
    left, right = 0, len(arr)
    
    while left < right:
        mid = left + (right - left) // 2
        
        if arr[mid] <= target:
            left = mid + 1
        else:
            right = mid
    
    return left
```

```java Java
public int upperBound(int[] arr, int target) {
    // Find first index where arr[i] > target
    int left = 0, right = arr.length;
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] <= target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    
    return left;
}
```

```cpp C++
int upperBound(vector<int>& arr, int target) {
    // Find first index where arr[i] > target
    int left = 0, right = arr.size();
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] <= target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    
    return left;
}
```
</CodeGroup>

### 4. Binary Search on Answer

When searching for optimal value, not index.

<CodeGroup>
```python Python
def min_capacity_to_ship(weights, days):
    """Minimum ship capacity to ship all packages in given days"""
    
    def can_ship(capacity):
        current_weight = 0
        days_needed = 1
        
        for weight in weights:
            if current_weight + weight > capacity:
                days_needed += 1
                current_weight = 0
            current_weight += weight
        
        return days_needed <= days
    
    # Search space: [max single weight, sum of all weights]
    left = max(weights)
    right = sum(weights)
    
    while left < right:
        mid = left + (right - left) // 2
        
        if can_ship(mid):
            right = mid  # Try smaller capacity
        else:
            left = mid + 1  # Need more capacity
    
    return left
```

```java Java
public int minCapacityToShip(int[] weights, int days) {
    // Minimum ship capacity to ship all packages in given days
    int left = 0, right = 0;
    for (int w : weights) {
        left = Math.max(left, w);
        right += w;
    }
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (canShip(weights, mid, days)) {
            right = mid;  // Try smaller capacity
        } else {
            left = mid + 1;  // Need more capacity
        }
    }
    
    return left;
}

private boolean canShip(int[] weights, int capacity, int days) {
    int currentWeight = 0;
    int daysNeeded = 1;
    
    for (int weight : weights) {
        if (currentWeight + weight > capacity) {
            daysNeeded++;
            currentWeight = 0;
        }
        currentWeight += weight;
    }
    
    return daysNeeded <= days;
}
```

```cpp C++
bool canShip(vector<int>& weights, int capacity, int days) {
    int currentWeight = 0;
    int daysNeeded = 1;
    
    for (int weight : weights) {
        if (currentWeight + weight > capacity) {
            daysNeeded++;
            currentWeight = 0;
        }
        currentWeight += weight;
    }
    
    return daysNeeded <= days;
}

int minCapacityToShip(vector<int>& weights, int days) {
    // Minimum ship capacity to ship all packages in given days
    int left = *max_element(weights.begin(), weights.end());
    int right = accumulate(weights.begin(), weights.end(), 0);
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (canShip(weights, mid, days)) {
            right = mid;  // Try smaller capacity
        } else {
            left = mid + 1;  // Need more capacity
        }
    }
    
    return left;
}
```
</CodeGroup>

## Classic Problems

<AccordionGroup>
  <Accordion title="1. Search in Rotated Sorted Array" icon="rotate">
    **Problem**: Search for target in rotated sorted array.
    
    **Approach**: Find which half is sorted, determine if target is in that half.
    
    **Time**: O(log n) | **Space**: O(1)
  </Accordion>
  
  <Accordion title="2. Find Peak Element" icon="mountain">
    **Problem**: Find any peak element (greater than neighbors).
    
    **Approach**: Compare mid with mid+1, move towards the larger side.
    
    **Time**: O(log n) | **Space**: O(1)
  </Accordion>
  
  <Accordion title="3. Search 2D Matrix" icon="table">
    **Problem**: Search in row-wise and column-wise sorted matrix.
    
    **Approach**: Treat as 1D array or start from top-right corner.
    
    **Time**: O(log(m*n)) or O(m+n) | **Space**: O(1)
  </Accordion>
  
  <Accordion title="4. Koko Eating Bananas" icon="apple-whole">
    **Problem**: Minimum eating speed to finish all bananas in h hours.
    
    **Approach**: Binary search on answer with feasibility check.
    
    **Time**: O(n log m) | **Space**: O(1)
  </Accordion>
  
  <Accordion title="5. Median of Two Sorted Arrays" icon="chart-simple">
    **Problem**: Find median of two sorted arrays in O(log(m+n)).
    
    **Approach**: Binary search on partition point of smaller array.
    
    **Time**: O(log(min(m,n))) | **Space**: O(1)
  </Accordion>
</AccordionGroup>

## Search in Rotated Sorted Array

<CodeGroup>
```python Python
def search_rotated(nums, target):
    """Search for target in rotated sorted array"""
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if nums[mid] == target:
            return mid
        
        # Left half is sorted
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        # Right half is sorted
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    
    return -1
```

```java Java
public int searchRotated(int[] nums, int target) {
    // Search for target in rotated sorted array
    int left = 0, right = nums.length - 1;
    
    while (left <= right) {
        int mid = (left + right) / 2;
        
        if (nums[mid] == target) {
            return mid;
        }
        
        // Left half is sorted
        if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        // Right half is sorted
        } else {
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    
    return -1;
}
```

```cpp C++
int searchRotated(vector<int>& nums, int target) {
    // Search for target in rotated sorted array
    int left = 0, right = nums.size() - 1;
    
    while (left <= right) {
        int mid = (left + right) / 2;
        
        if (nums[mid] == target) {
            return mid;
        }
        
        // Left half is sorted
        if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        // Right half is sorted
        } else {
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    
    return -1;
}
```
</CodeGroup>

## Template Code

<CodeGroup>
```python Python
# Template 1: Standard (find exact match)
def binary_search_standard(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

# Template 2: Lower bound (first >= target)
def binary_search_lower(arr, target):
    left, right = 0, len(arr)
    while left < right:
        mid = left + (right - left) // 2
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid
    return left

# Template 3: Binary search on answer
def binary_search_answer(low, high, is_valid):
    while low < high:
        mid = low + (high - low) // 2
        if is_valid(mid):
            high = mid
        else:
            low = mid + 1
    return low
```

```java Java
// Template 1: Standard (find exact match)
public int binarySearchStandard(int[] arr, int target) {
    int left = 0, right = arr.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}

// Template 2: Lower bound (first >= target)
public int binarySearchLower(int[] arr, int target) {
    int left = 0, right = arr.length;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}

// Template 3: Binary search on answer
public int binarySearchAnswer(int low, int high, Predicate<Integer> isValid) {
    while (low < high) {
        int mid = low + (high - low) / 2;
        if (isValid.test(mid)) {
            high = mid;
        } else {
            low = mid + 1;
        }
    }
    return low;
}
```

```cpp C++
// Template 1: Standard (find exact match)
int binarySearchStandard(vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}

// Template 2: Lower bound (first >= target)
int binarySearchLower(vector<int>& arr, int target) {
    int left = 0, right = arr.size();
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}

// Template 3: Binary search on answer
int binarySearchAnswer(int low, int high, function<bool(int)> isValid) {
    while (low < high) {
        int mid = low + (high - low) / 2;
        if (isValid(mid)) {
            high = mid;
        } else {
            low = mid + 1;
        }
    }
    return low;
}
```
</CodeGroup>

## Common Mistakes

<Warning>
**Avoid These Pitfalls:**
1. **Integer Overflow**: Use `mid = left + (right - left) / 2` instead of `(left + right) / 2`
2. **Infinite Loop**: Ensure left or right changes every iteration
3. **Off-by-one**: Know when to use `left <= right` vs `left < right`
4. **Wrong boundary**: Include or exclude mid based on problem type
</Warning>

## Debugging Checklist

When your Binary Search solution fails:

<Steps>
  <Step title="Check Initial Bounds">
    Is `left = 0` and `right = len - 1` or `right = len`?
  </Step>
  <Step title="Check Loop Condition">
    Use `left <= right` for exact match, `left < right` for bounds.
  </Step>
  <Step title="Check Mid Calculation">
    Use `left + (right - left) / 2` to avoid overflow.
  </Step>
  <Step title="Check Movement">
    Is `mid` included or excluded? (`right = mid` vs `right = mid - 1`)
  </Step>
  <Step title="Check Return Value">
    What should be returned when element is not found?
  </Step>
</Steps>

## The Three Templates

Understanding which template to use is crucial:

| Template | Loop Condition | Use Case | After Loop |
|----------|---------------|----------|------------|
| Standard | `left <= right` | Find exact match | Return -1 if not found |
| Lower Bound | `left < right` | First >= target | `left` is answer |
| Upper Bound | `left < right` | First > target | `left` is answer |

## Complexity Quick Reference

| Problem Type | Time | Space | Key Insight |
|-------------|------|-------|-------------|
| Standard search | O(log n) | O(1) | Exact match |
| Lower/Upper bound | O(log n) | O(1) | First occurrence |
| Search on answer | O(n log range) | O(1) | Feasibility check |
| Rotated array | O(log n) | O(1) | Find sorted half |
| Peak finding | O(log n) | O(1) | Compare with neighbor |

## Interview Problems by Company

<Tabs>
  <Tab title="Easy">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Binary Search | All | Basic template |
    | Search Insert Position | Amazon, Google | Lower bound |
    | First Bad Version | Meta, Microsoft | Boolean search |
    | Sqrt(x) | Amazon | Search on answer |
    | Valid Perfect Square | Google | Search on answer |
  </Tab>
  <Tab title="Medium">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Search Rotated Array | All FAANG | Modified search |
    | Find Peak Element | Meta, Microsoft | Monotonic property |
    | Find First and Last Position | Amazon | Double binary search |
    | Search 2D Matrix | Google | Flattened search |
    | Koko Eating Bananas | Google | Search on answer |
  </Tab>
  <Tab title="Hard">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Median of Two Sorted Arrays | Google, Amazon | Partition search |
    | Split Array Largest Sum | Google | Search on answer |
    | Find in Mountain Array | Google | Peak + two searches |
    | Smallest Good Base | Google | Math + binary search |
  </Tab>
</Tabs>

## Interview Tips

<AccordionGroup>
  <Accordion title="How to Explain Your Approach" icon="comments">
    **Script for interviews:**
    
    1. "Since the array is sorted, I can use Binary Search for O(log n) time."
    2. "I'll maintain two pointers, left and right, representing the search space."
    3. "At each step, I calculate mid and compare with target."
    4. "Based on comparison, I eliminate half the search space."
    5. "I repeat until I find the target or the space is exhausted."
  </Accordion>
  
  <Accordion title="When Interviewer Says..." icon="user-tie">
    | Interviewer Says | You Should Think |
    |-----------------|------------------|
    | "Array is sorted" | Binary Search! |
    | "Can you do better than O(n)?" | Binary Search might work |
    | "Find minimum/maximum that satisfies..." | Binary Search on answer |
    | "Array is rotated" | Modified Binary Search |
    | "Find first/last occurrence" | Lower/Upper bound |
  </Accordion>
  
  <Accordion title="Common Follow-ups" icon="puzzle-piece">
    Be ready for these follow-ups:
    
    - "What if there are duplicates?" → Use lower/upper bound
    - "What if array is rotated?" → Find sorted half first
    - "Can you do it without extra space?" → Binary Search is already O(1) space
    - "What about very large arrays?" → Binary Search scales well
  </Accordion>
</AccordionGroup>

## Practice Problems

| Problem | Difficulty | Link |
|---------|------------|------|
| Binary Search | Easy | [LeetCode 704](https://leetcode.com/problems/binary-search/) |
| Search Insert Position | Easy | [LeetCode 35](https://leetcode.com/problems/search-insert-position/) |
| Search in Rotated Sorted Array | Medium | [LeetCode 33](https://leetcode.com/problems/search-in-rotated-sorted-array/) |
| Find Peak Element | Medium | [LeetCode 162](https://leetcode.com/problems/find-peak-element/) |
| Median of Two Sorted Arrays | Hard | [LeetCode 4](https://leetcode.com/problems/median-of-two-sorted-arrays/) |

## Practice Roadmap

<Steps>
  <Step title="Day 1: Standard Search">
    - Solve: Binary Search, Search Insert Position
    - Focus: Master the basic template perfectly
  </Step>
  <Step title="Day 2: Bounds">
    - Solve: Find First and Last Position, First Bad Version
    - Focus: Lower bound vs upper bound
  </Step>
  <Step title="Day 3: Modified Arrays">
    - Solve: Search in Rotated Array, Find Peak Element
    - Focus: Finding the sorted half
  </Step>
  <Step title="Day 4: Search on Answer">
    - Solve: Koko Eating Bananas, Capacity To Ship
    - Focus: Binary search on the result space
  </Step>
</Steps>

<Tip>
**Interview Tip**: When you see "sorted array" or "minimize/maximize" with a feasibility check, think Binary Search immediately.
</Tip>
