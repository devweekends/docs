---
title: "Graph Algorithms"
description: "Essential graph algorithms for interviews and competitive programming"
icon: "share-nodes"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/21-graph-algorithms.svg"
  alt="Graph Algorithms"
/>

## Overview

**Graph algorithms** solve problems involving nodes and edges. Master these core algorithms to tackle most graph problems.

## When to Use

<CardGroup cols={2}>
  <Card title="Shortest Path" icon="route">
    Dijkstra, Bellman-Ford, Floyd-Warshall
  </Card>
  <Card title="MST" icon="tree">
    Kruskal, Prim for minimum spanning tree
  </Card>
  <Card title="Topological Sort" icon="layer-group">
    Task ordering, course prerequisites
  </Card>
  <Card title="Cycle Detection" icon="arrows-spin">
    DFS colors or Union Find
  </Card>
</CardGroup>

## Key Algorithms

### 1. Dijkstra's Algorithm

<CodeGroup>
```python Python
import heapq
from collections import defaultdict

def dijkstra(graph, start):
    """Shortest paths from start to all nodes - O((V+E) log V)"""
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    pq = [(0, start)]
    
    while pq:
        dist, node = heapq.heappop(pq)
        
        if dist > distances[node]:
            continue
        
        for neighbor, weight in graph[node]:
            new_dist = dist + weight
            if new_dist < distances[neighbor]:
                distances[neighbor] = new_dist
                heapq.heappush(pq, (new_dist, neighbor))
    
    return distances
```

```java Java
import java.util.*;

public class Dijkstra {
    public Map<Integer, Integer> dijkstra(Map<Integer, List<int[]>> graph, int start) {
        // Shortest paths from start to all nodes - O((V+E) log V)
        Map<Integer, Integer> distances = new HashMap<>();
        for (int node : graph.keySet()) {
            distances.put(node, Integer.MAX_VALUE);
        }
        distances.put(start, 0);
        
        // Priority queue: [distance, node]
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        pq.offer(new int[]{0, start});
        
        while (!pq.isEmpty()) {
            int[] curr = pq.poll();
            int dist = curr[0], node = curr[1];
            
            if (dist > distances.get(node)) continue;
            
            if (graph.containsKey(node)) {
                for (int[] edge : graph.get(node)) {
                    int neighbor = edge[0], weight = edge[1];
                    int newDist = dist + weight;
                    if (newDist < distances.get(neighbor)) {
                        distances.put(neighbor, newDist);
                        pq.offer(new int[]{newDist, neighbor});
                    }
                }
            }
        }
        
        return distances;
    }
}
```

```cpp C++
#include <queue>
#include <unordered_map>
#include <vector>

class Dijkstra {
public:
    unordered_map<int, int> dijkstra(
        unordered_map<int, vector<pair<int, int>>>& graph, int start) {
        // Shortest paths from start to all nodes - O((V+E) log V)
        unordered_map<int, int> distances;
        for (auto& [node, _] : graph) {
            distances[node] = INT_MAX;
        }
        distances[start] = 0;
        
        // Priority queue: {distance, node}
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
        pq.push({0, start});
        
        while (!pq.empty()) {
            auto [dist, node] = pq.top();
            pq.pop();
            
            if (dist > distances[node]) continue;
            
            for (auto& [neighbor, weight] : graph[node]) {
                int newDist = dist + weight;
                if (newDist < distances[neighbor]) {
                    distances[neighbor] = newDist;
                    pq.push({newDist, neighbor});
                }
            }
        }
        
        return distances;
    }
};
```
</CodeGroup>

### 2. Bellman-Ford

<CodeGroup>
```python Python
def bellman_ford(n, edges, start):
    """Handles negative weights, detects negative cycles - O(VE)"""
    distances = [float('inf')] * n
    distances[start] = 0
    
    # Relax all edges V-1 times
    for _ in range(n - 1):
        for u, v, w in edges:
            if distances[u] + w < distances[v]:
                distances[v] = distances[u] + w
    
    # Check for negative cycle
    for u, v, w in edges:
        if distances[u] + w < distances[v]:
            return None  # Negative cycle exists
    
    return distances
```

```java Java
public class BellmanFord {
    public int[] bellmanFord(int n, int[][] edges, int start) {
        // Handles negative weights, detects negative cycles - O(VE)
        int[] distances = new int[n];
        Arrays.fill(distances, Integer.MAX_VALUE);
        distances[start] = 0;
        
        // Relax all edges V-1 times
        for (int i = 0; i < n - 1; i++) {
            for (int[] edge : edges) {
                int u = edge[0], v = edge[1], w = edge[2];
                if (distances[u] != Integer.MAX_VALUE 
                    && distances[u] + w < distances[v]) {
                    distances[v] = distances[u] + w;
                }
            }
        }
        
        // Check for negative cycle
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1], w = edge[2];
            if (distances[u] != Integer.MAX_VALUE 
                && distances[u] + w < distances[v]) {
                return null; // Negative cycle exists
            }
        }
        
        return distances;
    }
}
```

```cpp C++
class BellmanFord {
public:
    vector<int> bellmanFord(int n, vector<vector<int>>& edges, int start) {
        // Handles negative weights, detects negative cycles - O(VE)
        vector<int> distances(n, INT_MAX);
        distances[start] = 0;
        
        // Relax all edges V-1 times
        for (int i = 0; i < n - 1; i++) {
            for (auto& edge : edges) {
                int u = edge[0], v = edge[1], w = edge[2];
                if (distances[u] != INT_MAX 
                    && distances[u] + w < distances[v]) {
                    distances[v] = distances[u] + w;
                }
            }
        }
        
        // Check for negative cycle
        for (auto& edge : edges) {
            int u = edge[0], v = edge[1], w = edge[2];
            if (distances[u] != INT_MAX 
                && distances[u] + w < distances[v]) {
                return {}; // Negative cycle exists
            }
        }
        
        return distances;
    }
};
```
</CodeGroup>

### 3. Topological Sort (Kahn's BFS)

<CodeGroup>
```python Python
from collections import deque, defaultdict

def topological_sort(n, prerequisites):
    """Return valid ordering or empty if cycle exists"""
    graph = defaultdict(list)
    in_degree = [0] * n
    
    for course, prereq in prerequisites:
        graph[prereq].append(course)
        in_degree[course] += 1
    
    queue = deque([i for i in range(n) if in_degree[i] == 0])
    result = []
    
    while queue:
        node = queue.popleft()
        result.append(node)
        
        for neighbor in graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    return result if len(result) == n else []
```

```java Java
import java.util.*;

public class TopologicalSort {
    public List<Integer> topologicalSort(int n, int[][] prerequisites) {
        // Return valid ordering or empty if cycle exists
        Map<Integer, List<Integer>> graph = new HashMap<>();
        int[] inDegree = new int[n];
        
        for (int i = 0; i < n; i++) {
            graph.put(i, new ArrayList<>());
        }
        
        for (int[] prereq : prerequisites) {
            int course = prereq[0], pre = prereq[1];
            graph.get(pre).add(course);
            inDegree[course]++;
        }
        
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            if (inDegree[i] == 0) {
                queue.offer(i);
            }
        }
        
        List<Integer> result = new ArrayList<>();
        while (!queue.isEmpty()) {
            int node = queue.poll();
            result.add(node);
            
            for (int neighbor : graph.get(node)) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0) {
                    queue.offer(neighbor);
                }
            }
        }
        
        return result.size() == n ? result : new ArrayList<>();
    }
}
```

```cpp C++
#include <queue>
#include <vector>

class TopologicalSort {
public:
    vector<int> topologicalSort(int n, vector<vector<int>>& prerequisites) {
        // Return valid ordering or empty if cycle exists
        vector<vector<int>> graph(n);
        vector<int> inDegree(n, 0);
        
        for (auto& prereq : prerequisites) {
            int course = prereq[0], pre = prereq[1];
            graph[pre].push_back(course);
            inDegree[course]++;
        }
        
        queue<int> q;
        for (int i = 0; i < n; i++) {
            if (inDegree[i] == 0) {
                q.push(i);
            }
        }
        
        vector<int> result;
        while (!q.empty()) {
            int node = q.front();
            q.pop();
            result.push_back(node);
            
            for (int neighbor : graph[node]) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0) {
                    q.push(neighbor);
                }
            }
        }
        
        return result.size() == n ? result : vector<int>();
    }
};
```
</CodeGroup>

### 4. Kruskal's MST

<CodeGroup>
```python Python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return False
        if self.rank[px] < self.rank[py]:
            px, py = py, px
        self.parent[py] = px
        if self.rank[px] == self.rank[py]:
            self.rank[px] += 1
        return True

def kruskal(n, edges):
    """Find minimum spanning tree - O(E log E)"""
    # Sort edges by weight
    edges.sort(key=lambda x: x[2])
    
    uf = UnionFind(n)
    mst = []
    total_weight = 0
    
    for u, v, weight in edges:
        if uf.union(u, v):
            mst.append((u, v, weight))
            total_weight += weight
            if len(mst) == n - 1:
                break
    
    return mst, total_weight
```

```java Java
public class Kruskal {
    private int[] parent, rank;
    
    private int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    private boolean union(int x, int y) {
        int px = find(x), py = find(y);
        if (px == py) return false;
        if (rank[px] < rank[py]) {
            int temp = px; px = py; py = temp;
        }
        parent[py] = px;
        if (rank[px] == rank[py]) rank[px]++;
        return true;
    }
    
    public int kruskal(int n, int[][] edges) {
        // Find minimum spanning tree - O(E log E)
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++) parent[i] = i;
        
        // Sort edges by weight
        Arrays.sort(edges, (a, b) -> a[2] - b[2]);
        
        int totalWeight = 0;
        int edgeCount = 0;
        
        for (int[] edge : edges) {
            if (union(edge[0], edge[1])) {
                totalWeight += edge[2];
                edgeCount++;
                if (edgeCount == n - 1) break;
            }
        }
        
        return totalWeight;
    }
}
```

```cpp C++
class Kruskal {
private:
    vector<int> parent, rank_;
    
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    bool unionSets(int x, int y) {
        int px = find(x), py = find(y);
        if (px == py) return false;
        if (rank_[px] < rank_[py]) swap(px, py);
        parent[py] = px;
        if (rank_[px] == rank_[py]) rank_[px]++;
        return true;
    }
    
public:
    int kruskal(int n, vector<vector<int>>& edges) {
        // Find minimum spanning tree - O(E log E)
        parent.resize(n);
        rank_.resize(n, 0);
        for (int i = 0; i < n; i++) parent[i] = i;
        
        // Sort edges by weight
        sort(edges.begin(), edges.end(), 
             [](auto& a, auto& b) { return a[2] < b[2]; });
        
        int totalWeight = 0;
        int edgeCount = 0;
        
        for (auto& edge : edges) {
            if (unionSets(edge[0], edge[1])) {
                totalWeight += edge[2];
                edgeCount++;
                if (edgeCount == n - 1) break;
            }
        }
        
        return totalWeight;
    }
};
```
</CodeGroup>

## Complexity Comparison

| Algorithm | Time | Space | Use Case |
|-----------|------|-------|----------|
| Dijkstra | O((V+E) log V) | O(V) | Non-negative weights |
| Bellman-Ford | O(VE) | O(V) | Negative weights |
| Floyd-Warshall | O(V^3) | O(V^2) | All pairs shortest |
| Kruskal | O(E log E) | O(V) | Sparse graphs MST |
| Prim | O(E log V) | O(V) | Dense graphs MST |

## Practice Problems

<CardGroup cols={2}>
  <Card title="Network Delay Time" icon="clock" href="https://leetcode.com/problems/network-delay-time/">
    Dijkstra application
  </Card>
  <Card title="Course Schedule" icon="calendar" href="https://leetcode.com/problems/course-schedule/">
    Topological sort
  </Card>
  <Card title="Min Cost to Connect" icon="link" href="https://leetcode.com/problems/min-cost-to-connect-all-points/">
    Kruskal or Prim
  </Card>
  <Card title="Cheapest Flights" icon="plane" href="https://leetcode.com/problems/cheapest-flights-within-k-stops/">
    Modified Bellman-Ford
  </Card>
</CardGroup>
