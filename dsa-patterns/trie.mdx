---
title: "Trie (Prefix Tree)"
description: "Efficiently store and search strings by prefix"
icon: "keyboard"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/18-trie.svg"
  alt="Trie Pattern"
/>

## What is Trie?

**Trie** (prefix tree) is a tree-like data structure for storing strings where each node represents a character. It enables O(m) search/insert where m is string length.

<Note>
**Quick Recognition**: Problems involving prefix matching, autocomplete, word dictionaries, or searching multiple words efficiently. Keywords: "prefix", "dictionary", "word search", "autocomplete".
</Note>

## Pattern Recognition Checklist

<CardGroup cols={2}>
  <Card title="Use Trie When" icon="check">
    - Prefix-based search (autocomplete)
    - Word dictionary with wildcard search
    - Word search in 2D grid (multiple words)
    - Longest common prefix
    - Spell checking
    - IP routing (binary tries)
  </Card>
  <Card title="Don't Use When" icon="xmark">
    - Exact match only (use HashSet)
    - Single word search (use HashMap)
    - Memory is very constrained
    - Small dictionary (overhead not worth it)
  </Card>
</CardGroup>

## Trie Complexity Reference

| Operation | Time | Space |
|-----------|------|-------|
| Insert | O(m) | O(m) per word |
| Search | O(m) | - |
| Prefix search | O(m) | - |
| Delete | O(m) | - |
| Build trie | O(n * m) | O(n * m * 26) worst case |

Where m = word length, n = number of words

## When to Use

<CardGroup cols={2}>
  <Card title="Autocomplete" icon="keyboard">
    Suggest words by prefix
  </Card>
  <Card title="Spell Checker" icon="spell-check">
    Find words with similar prefixes
  </Card>
  <Card title="Word Search" icon="magnifying-glass">
    Search word in grid
  </Card>
  <Card title="Longest Prefix" icon="text">
    Find longest common prefix
  </Card>
</CardGroup>

## Basic Implementation

<CodeGroup>
```python Python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end = False

class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word):
        """Insert word into trie - O(m)"""
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True
    
    def search(self, word):
        """Check if word exists - O(m)"""
        node = self._traverse(word)
        return node is not None and node.is_end
    
    def startsWith(self, prefix):
        """Check if any word has prefix - O(m)"""
        return self._traverse(prefix) is not None
    
    def _traverse(self, s):
        """Helper to traverse trie"""
        node = self.root
        for char in s:
            if char not in node.children:
                return None
            node = node.children[char]
        return node
```

```java Java
class TrieNode {
    Map<Character, TrieNode> children;
    boolean isEnd;
    
    TrieNode() {
        children = new HashMap<>();
        isEnd = false;
    }
}

class Trie {
    private TrieNode root;
    
    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) {
        // Insert word into trie - O(m)
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            node.children.putIfAbsent(c, new TrieNode());
            node = node.children.get(c);
        }
        node.isEnd = true;
    }
    
    public boolean search(String word) {
        // Check if word exists - O(m)
        TrieNode node = traverse(word);
        return node != null && node.isEnd;
    }
    
    public boolean startsWith(String prefix) {
        // Check if any word has prefix - O(m)
        return traverse(prefix) != null;
    }
    
    private TrieNode traverse(String s) {
        // Helper to traverse trie
        TrieNode node = root;
        for (char c : s.toCharArray()) {
            if (!node.children.containsKey(c)) {
                return null;
            }
            node = node.children.get(c);
        }
        return node;
    }
}
```

```cpp C++
class TrieNode {
public:
    unordered_map<char, TrieNode*> children;
    bool isEnd;
    
    TrieNode() : isEnd(false) {}
};

class Trie {
private:
    TrieNode* root;
    
    TrieNode* traverse(const string& s) {
        // Helper to traverse trie
        TrieNode* node = root;
        for (char c : s) {
            if (node->children.find(c) == node->children.end()) {
                return nullptr;
            }
            node = node->children[c];
        }
        return node;
    }
    
public:
    Trie() {
        root = new TrieNode();
    }
    
    void insert(const string& word) {
        // Insert word into trie - O(m)
        TrieNode* node = root;
        for (char c : word) {
            if (node->children.find(c) == node->children.end()) {
                node->children[c] = new TrieNode();
            }
            node = node->children[c];
        }
        node->isEnd = true;
    }
    
    bool search(const string& word) {
        // Check if word exists - O(m)
        TrieNode* node = traverse(word);
        return node != nullptr && node->isEnd;
    }
    
    bool startsWith(const string& prefix) {
        // Check if any word has prefix - O(m)
        return traverse(prefix) != nullptr;
    }
};
```
</CodeGroup>

## Pattern Variations

### 1. Word Search II (Backtracking + Trie)

<CodeGroup>
```python Python
def find_words(board, words):
    """Find all words from dictionary in grid"""
    # Build trie from words
    trie = Trie()
    for word in words:
        trie.insert(word)
    
    rows, cols = len(board), len(board[0])
    result = set()
    
    def dfs(r, c, node, path):
        char = board[r][c]
        if char not in node.children:
            return
        
        node = node.children[char]
        path += char
        
        if node.is_end:
            result.add(path)
        
        board[r][c] = '#'  # Mark visited
        
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols and board[nr][nc] != '#':
                dfs(nr, nc, node, path)
        
        board[r][c] = char  # Restore
    
    for r in range(rows):
        for c in range(cols):
            dfs(r, c, trie.root, "")
    
    return list(result)
```

```java Java
public List<String> findWords(char[][] board, String[] words) {
    // Find all words from dictionary in grid
    Trie trie = new Trie();
    for (String word : words) {
        trie.insert(word);
    }
    
    int rows = board.length, cols = board[0].length;
    Set<String> result = new HashSet<>();
    
    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols; c++) {
            dfs(board, r, c, trie.root, "", result);
        }
    }
    
    return new ArrayList<>(result);
}

private void dfs(char[][] board, int r, int c, TrieNode node, 
                 String path, Set<String> result) {
    char ch = board[r][c];
    if (!node.children.containsKey(ch)) return;
    
    node = node.children.get(ch);
    path += ch;
    
    if (node.isEnd) {
        result.add(path);
    }
    
    board[r][c] = '#'; // Mark visited
    
    int[][] dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}};
    for (int[] d : dirs) {
        int nr = r + d[0], nc = c + d[1];
        if (nr >= 0 && nr < board.length && 
            nc >= 0 && nc < board[0].length && 
            board[nr][nc] != '#') {
            dfs(board, nr, nc, node, path, result);
        }
    }
    
    board[r][c] = ch; // Restore
}
```

```cpp C++
class WordSearch {
public:
    vector<string> findWords(vector<vector<char>>& board, 
                             vector<string>& words) {
        // Find all words from dictionary in grid
        Trie trie;
        for (const string& word : words) {
            trie.insert(word);
        }
        
        int rows = board.size(), cols = board[0].size();
        set<string> result;
        
        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < cols; c++) {
                dfs(board, r, c, trie.root, "", result);
            }
        }
        
        return vector<string>(result.begin(), result.end());
    }
    
private:
    void dfs(vector<vector<char>>& board, int r, int c, 
             TrieNode* node, string path, set<string>& result) {
        char ch = board[r][c];
        if (node->children.find(ch) == node->children.end()) return;
        
        node = node->children[ch];
        path += ch;
        
        if (node->isEnd) {
            result.insert(path);
        }
        
        board[r][c] = '#'; // Mark visited
        
        vector<pair<int,int>> dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}};
        for (auto& [dr, dc] : dirs) {
            int nr = r + dr, nc = c + dc;
            if (nr >= 0 && nr < board.size() && 
                nc >= 0 && nc < board[0].size() && 
                board[nr][nc] != '#') {
                dfs(board, nr, nc, node, path, result);
            }
        }
        
        board[r][c] = ch; // Restore
    }
};
```
</CodeGroup>

### 2. Autocomplete System

<CodeGroup>
```python Python
class AutocompleteSystem:
    def __init__(self, sentences, times):
        self.root = TrieNode()
        self.current_input = ""
        
        for sentence, count in zip(sentences, times):
            self._insert(sentence, count)
    
    def _insert(self, sentence, count):
        node = self.root
        for char in sentence:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True
        node.count = getattr(node, 'count', 0) + count
    
    def input(self, c):
        if c == '#':
            self._insert(self.current_input, 1)
            self.current_input = ""
            return []
        
        self.current_input += c
        return self._search(self.current_input)
    
    def _search(self, prefix):
        node = self.root
        for char in prefix:
            if char not in node.children:
                return []
            node = node.children[char]
        
        # DFS to find all sentences with this prefix
        results = []
        self._dfs(node, prefix, results)
        
        # Sort by count (desc), then lexicographically
        results.sort(key=lambda x: (-x[1], x[0]))
        return [s for s, _ in results[:3]]
    
    def _dfs(self, node, path, results):
        if node.is_end:
            results.append((path, node.count))
        for char, child in node.children.items():
            self._dfs(child, path + char, results)
```

```java Java
class AutocompleteSystem {
    private TrieNode root;
    private StringBuilder currentInput;
    
    public AutocompleteSystem(String[] sentences, int[] times) {
        root = new TrieNode();
        currentInput = new StringBuilder();
        
        for (int i = 0; i < sentences.length; i++) {
            insert(sentences[i], times[i]);
        }
    }
    
    private void insert(String sentence, int count) {
        TrieNode node = root;
        for (char c : sentence.toCharArray()) {
            node.children.putIfAbsent(c, new TrieNode());
            node = node.children.get(c);
        }
        node.isEnd = true;
        node.count += count;
    }
    
    public List<String> input(char c) {
        if (c == '#') {
            insert(currentInput.toString(), 1);
            currentInput = new StringBuilder();
            return new ArrayList<>();
        }
        
        currentInput.append(c);
        return search(currentInput.toString());
    }
    
    private List<String> search(String prefix) {
        TrieNode node = root;
        for (char c : prefix.toCharArray()) {
            if (!node.children.containsKey(c)) {
                return new ArrayList<>();
            }
            node = node.children.get(c);
        }
        
        List<int[]> results = new ArrayList<>(); // [index, count]
        List<String> sentences = new ArrayList<>();
        dfs(node, prefix, sentences, results);
        
        // Sort by count desc, then lexicographically
        results.sort((a, b) -> a[1] != b[1] ? b[1] - a[1] : 
            sentences.get(a[0]).compareTo(sentences.get(b[0])));
        
        List<String> topResults = new ArrayList<>();
        for (int i = 0; i < Math.min(3, results.size()); i++) {
            topResults.add(sentences.get(results.get(i)[0]));
        }
        return topResults;
    }
}
```

```cpp C++
class AutocompleteSystem {
private:
    TrieNode* root;
    string currentInput;
    
    void insert(const string& sentence, int count) {
        TrieNode* node = root;
        for (char c : sentence) {
            if (node->children.find(c) == node->children.end()) {
                node->children[c] = new TrieNode();
            }
            node = node->children[c];
        }
        node->isEnd = true;
        node->count += count;
    }
    
    void dfs(TrieNode* node, string& path, 
             vector<pair<string, int>>& results) {
        if (node->isEnd) {
            results.push_back({path, node->count});
        }
        for (auto& [c, child] : node->children) {
            path += c;
            dfs(child, path, results);
            path.pop_back();
        }
    }
    
public:
    AutocompleteSystem(vector<string>& sentences, vector<int>& times) {
        root = new TrieNode();
        currentInput = "";
        
        for (int i = 0; i < sentences.size(); i++) {
            insert(sentences[i], times[i]);
        }
    }
    
    vector<string> input(char c) {
        if (c == '#') {
            insert(currentInput, 1);
            currentInput = "";
            return {};
        }
        
        currentInput += c;
        
        TrieNode* node = root;
        for (char ch : currentInput) {
            if (node->children.find(ch) == node->children.end()) {
                return {};
            }
            node = node->children[ch];
        }
        
        vector<pair<string, int>> results;
        string path = currentInput;
        dfs(node, path, results);
        
        // Sort by count desc, then lexicographically
        sort(results.begin(), results.end(), 
             [](auto& a, auto& b) {
                 return a.second != b.second ? 
                        a.second > b.second : a.first < b.first;
             });
        
        vector<string> topResults;
        for (int i = 0; i < min(3, (int)results.size()); i++) {
            topResults.push_back(results[i].first);
        }
        return topResults;
    }
};
```
</CodeGroup>

## Classic Problems

| Problem | Pattern | Key Insight |
|---------|---------|-------------|
| Implement Trie | Basic ops | HashMap children |
| Word Search II | Trie + DFS | Prune with trie |
| Autocomplete | Trie + Heap | Top-k by frequency |
| Longest Word | BFS/DFS | Check prefixes exist |
| Word Dictionary | Trie + '.' | DFS for wildcards |

## Interview Problems by Company

<Tabs>
  <Tab title="Medium">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Implement Trie | All FAANG | Basic trie ops |
    | Word Dictionary | Meta, Amazon | Wildcard DFS |
    | Replace Words | Amazon | Prefix replacement |
    | Map Sum Pairs | Google | Trie with values |
  </Tab>
  <Tab title="Hard">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Word Search II | Amazon, Google | Trie + backtracking |
    | Autocomplete System | Google, Meta | Trie + ranking |
    | Concatenated Words | Amazon | Trie + DP |
    | Palindrome Pairs | Airbnb | Trie + palindrome |
  </Tab>
</Tabs>

## Interview Tips

<AccordionGroup>
  <Accordion title="How to Explain Your Approach" icon="comments">
    **Script for interviews:**
    
    1. "I'll use a Trie for efficient prefix-based operations."
    2. "Each node has children (HashMap or array of 26)."
    3. "I'll mark end-of-word with a boolean flag."
    4. "Insert and search are both O(word length)."
    5. "For Word Search II, I'll combine Trie with DFS backtracking."
  </Accordion>
  
  <Accordion title="Trie Node Choices" icon="sitemap">
    | Implementation | Pros | Cons |
    |----------------|------|------|
    | HashMap children | Flexible, sparse-friendly | Slightly slower |
    | Array[26] | Faster access | Wastes memory for sparse |
    | With count | Supports frequency | Extra space |
    | With word | Store full word at end | Easier retrieval |
  </Accordion>
  
  <Accordion title="Common Optimizations" icon="bolt">
    1. **Remove word from trie** after finding (Word Search II)
    2. **Store word at end node** instead of just boolean
    3. **Track count** for frequency-based problems
    4. **Prune empty branches** after deletion
  </Accordion>
</AccordionGroup>

## Practice Problems

<CardGroup cols={2}>
  <Card title="Implement Trie" icon="keyboard" href="https://leetcode.com/problems/implement-trie-prefix-tree/">
    Basic trie operations
  </Card>
  <Card title="Word Search II" icon="magnifying-glass" href="https://leetcode.com/problems/word-search-ii/">
    Backtracking with trie
  </Card>
  <Card title="Design Search Autocomplete" icon="wand-magic-sparkles" href="https://leetcode.com/problems/design-search-autocomplete-system/">
    Trie with frequency
  </Card>
  <Card title="Replace Words" icon="repeat" href="https://leetcode.com/problems/replace-words/">
    Prefix replacement
  </Card>
</CardGroup>

## Practice Roadmap

<Steps>
  <Step title="Day 1: Basic Trie">
    - Solve: Implement Trie, Longest Common Prefix
    - Focus: Insert, search, startsWith operations
  </Step>
  <Step title="Day 2: Pattern Matching">
    - Solve: Word Dictionary, Replace Words
    - Focus: Wildcard handling, prefix matching
  </Step>
  <Step title="Day 3: Trie + DFS">
    - Solve: Word Search II
    - Focus: Combining trie with backtracking
  </Step>
  <Step title="Day 4: Advanced Trie">
    - Solve: Autocomplete System, Palindrome Pairs
    - Focus: Ranking, complex traversals
  </Step>
</Steps>

<Tip>
**Interview Tip**: When you see multiple string searches or prefix operations, think Trie. It's especially powerful when combined with DFS for grid problems.
</Tip>
