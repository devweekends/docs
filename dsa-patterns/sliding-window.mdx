---
title: "Sliding Window Pattern"
description: "Optimize subarray and substring problems with the sliding window technique"
icon: "window-restore"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/02-sliding-window.svg"
  alt="Sliding Window Pattern"
/>

## What is Sliding Window?

The **Sliding Window** pattern maintains a dynamic window over a sequence to find optimal subarrays or substrings. It reduces nested loops from O(nÂ²) to O(n) by reusing computations.

<Note>
**Quick Recognition**: If you see **"contiguous subarray"** or **"substring"** + need to find **max/min/count**, Sliding Window is likely the answer!
</Note>

## Pattern Recognition Checklist

<CardGroup cols={2}>
  <Card title="Use Sliding Window When" icon="check">
    - Problem mentions **contiguous** elements
    - Need **subarray** or **substring**
    - Looking for **maximum/minimum** length
    - Constraint on window (**at most K**, **exactly K**)
    - Can solve by **expanding** and **shrinking**
  </Card>
  <Card title="Don't Use When" icon="xmark">
    - Elements don't need to be **contiguous**
    - Need **all subsets** (use Backtracking)
    - **Sorted** array hints (use Two Pointers)
    - Need **position of elements** (use HashMap)
  </Card>
</CardGroup>

## Three Types of Sliding Window

```mermaid
flowchart TD
    A[Sliding Window Problem] --> B{Window Type?}
    B -->|Fixed Size| C[Fixed Window]
    B -->|Shrinkable| D{Goal?}
    D -->|Find Max Valid| E[Expand + Shrink]
    D -->|Find Min Valid| F[Expand until Valid + Shrink]
    D -->|Exactly K| G[AtMost K - AtMost K-1]
    
    C --> H["Sum/Avg of K elements"]
    E --> I["Max substring with constraint"]
    F --> J["Min window containing..."]
    G --> K["Count with exactly K distinct"]
```

## When to Use

<CardGroup cols={2}>
  <Card title="Contiguous Subarrays" icon="grip-lines">
    Finding max/min sum, average, or product of k elements
  </Card>
  <Card title="Substring Problems" icon="text">
    Longest/shortest substring with certain properties
  </Card>
  <Card title="Fixed Size Window" icon="arrows-left-right-to-line">
    Problems asking about "exactly k" or "window of size k"
  </Card>
  <Card title="Variable Size Window" icon="arrows-maximize">
    Problems with "at most k" or "minimum length"
  </Card>
</CardGroup>

## Pattern Variations

### 1. Fixed Size Window

Window size remains constant throughout.

<CodeGroup>
```python Python
def max_sum_subarray_k(arr, k):
    """Find maximum sum of subarray with exactly k elements"""
    if len(arr) < k:
        return -1
    
    # Calculate sum of first window
    window_sum = sum(arr[:k])
    max_sum = window_sum
    
    # Slide the window
    for i in range(k, len(arr)):
        window_sum += arr[i] - arr[i - k]  # Add new, remove old
        max_sum = max(max_sum, window_sum)
    
    return max_sum
```

```java Java
public int maxSumSubarrayK(int[] arr, int k) {
    // Find maximum sum of subarray with exactly k elements
    if (arr.length < k) {
        return -1;
    }
    
    // Calculate sum of first window
    int windowSum = 0;
    for (int i = 0; i < k; i++) {
        windowSum += arr[i];
    }
    int maxSum = windowSum;
    
    // Slide the window
    for (int i = k; i < arr.length; i++) {
        windowSum += arr[i] - arr[i - k];  // Add new, remove old
        maxSum = Math.max(maxSum, windowSum);
    }
    
    return maxSum;
}
```

```cpp C++
int maxSumSubarrayK(vector<int>& arr, int k) {
    // Find maximum sum of subarray with exactly k elements
    if (arr.size() < k) {
        return -1;
    }
    
    // Calculate sum of first window
    int windowSum = 0;
    for (int i = 0; i < k; i++) {
        windowSum += arr[i];
    }
    int maxSum = windowSum;
    
    // Slide the window
    for (int i = k; i < arr.size(); i++) {
        windowSum += arr[i] - arr[i - k];  // Add new, remove old
        maxSum = max(maxSum, windowSum);
    }
    
    return maxSum;
}
```
</CodeGroup>

### 2. Variable Size Window (Expand and Shrink)

Window grows and shrinks based on conditions.

<CodeGroup>
```python Python
def min_subarray_sum(arr, target):
    """Find minimum length subarray with sum >= target"""
    left = 0
    current_sum = 0
    min_length = float('inf')
    
    for right in range(len(arr)):
        current_sum += arr[right]  # Expand window
        
        while current_sum >= target:  # Shrink while valid
            min_length = min(min_length, right - left + 1)
            current_sum -= arr[left]
            left += 1
    
    return min_length if min_length != float('inf') else 0
```

```java Java
public int minSubarraySum(int[] arr, int target) {
    // Find minimum length subarray with sum >= target
    int left = 0;
    int currentSum = 0;
    int minLength = Integer.MAX_VALUE;
    
    for (int right = 0; right < arr.length; right++) {
        currentSum += arr[right];  // Expand window
        
        while (currentSum >= target) {  // Shrink while valid
            minLength = Math.min(minLength, right - left + 1);
            currentSum -= arr[left];
            left++;
        }
    }
    
    return minLength != Integer.MAX_VALUE ? minLength : 0;
}
```

```cpp C++
int minSubarraySum(vector<int>& arr, int target) {
    // Find minimum length subarray with sum >= target
    int left = 0;
    int currentSum = 0;
    int minLength = INT_MAX;
    
    for (int right = 0; right < arr.size(); right++) {
        currentSum += arr[right];  // Expand window
        
        while (currentSum >= target) {  // Shrink while valid
            minLength = min(minLength, right - left + 1);
            currentSum -= arr[left];
            left++;
        }
    }
    
    return minLength != INT_MAX ? minLength : 0;
}
```
</CodeGroup>

### 3. Window with HashMap/Counter

Track element frequencies within the window.

<CodeGroup>
```python Python
def longest_substring_k_unique(s, k):
    """Longest substring with exactly k unique characters"""
    from collections import defaultdict
    
    if k == 0:
        return 0
    
    left = 0
    char_count = defaultdict(int)
    max_length = 0
    
    for right in range(len(s)):
        char_count[s[right]] += 1
        
        while len(char_count) > k:
            char_count[s[left]] -= 1
            if char_count[s[left]] == 0:
                del char_count[s[left]]
            left += 1
        
        if len(char_count) == k:
            max_length = max(max_length, right - left + 1)
    
    return max_length
```

```java Java
public int longestSubstringKUnique(String s, int k) {
    // Longest substring with exactly k unique characters
    if (k == 0) {
        return 0;
    }
    
    int left = 0;
    Map<Character, Integer> charCount = new HashMap<>();
    int maxLength = 0;
    
    for (int right = 0; right < s.length(); right++) {
        char c = s.charAt(right);
        charCount.put(c, charCount.getOrDefault(c, 0) + 1);
        
        while (charCount.size() > k) {
            char leftChar = s.charAt(left);
            charCount.put(leftChar, charCount.get(leftChar) - 1);
            if (charCount.get(leftChar) == 0) {
                charCount.remove(leftChar);
            }
            left++;
        }
        
        if (charCount.size() == k) {
            maxLength = Math.max(maxLength, right - left + 1);
        }
    }
    
    return maxLength;
}
```

```cpp C++
int longestSubstringKUnique(string s, int k) {
    // Longest substring with exactly k unique characters
    if (k == 0) {
        return 0;
    }
    
    int left = 0;
    unordered_map<char, int> charCount;
    int maxLength = 0;
    
    for (int right = 0; right < s.size(); right++) {
        charCount[s[right]]++;
        
        while (charCount.size() > k) {
            charCount[s[left]]--;
            if (charCount[s[left]] == 0) {
                charCount.erase(s[left]);
            }
            left++;
        }
        
        if (charCount.size() == k) {
            maxLength = max(maxLength, right - left + 1);
        }
    }
    
    return maxLength;
}
```
</CodeGroup>

## Classic Problems

<AccordionGroup>
  <Accordion title="1. Maximum Sum Subarray of Size K" icon="arrow-up">
    **Problem**: Find the maximum sum of any contiguous subarray of size k.
    
    **Approach**: Fixed window - slide and update sum by adding new element and removing old.
    
    **Time**: O(n) | **Space**: O(1)
  </Accordion>
  
  <Accordion title="2. Longest Substring Without Repeating Characters" icon="text">
    **Problem**: Find length of longest substring without duplicate characters.
    
    **Approach**: Variable window with HashSet. Shrink when duplicate found.
    
    **Time**: O(n) | **Space**: O(min(n, m)) where m is charset size
  </Accordion>
  
  <Accordion title="3. Minimum Window Substring" icon="minimize">
    **Problem**: Find smallest substring containing all characters of another string.
    
    **Approach**: Variable window with character frequency tracking. Expand to include all, shrink to minimize.
    
    **Time**: O(n + m) | **Space**: O(m)
  </Accordion>
  
  <Accordion title="4. Fruit Into Baskets" icon="apple-whole">
    **Problem**: Maximum fruits you can collect with only 2 baskets (2 types).
    
    **Approach**: Longest subarray with at most 2 distinct elements.
    
    **Time**: O(n) | **Space**: O(1)
  </Accordion>
  
  <Accordion title="5. Permutation in String" icon="shuffle">
    **Problem**: Check if s2 contains a permutation of s1.
    
    **Approach**: Fixed window of size len(s1), compare character frequencies.
    
    **Time**: O(n) | **Space**: O(1)
  </Accordion>
</AccordionGroup>

## Template Code

<CodeGroup>
```python Python
# Template 1: Fixed Window
def fixed_window_template(arr, k):
    # Initialize first window
    window_result = sum(arr[:k])
    best = window_result
    
    for i in range(k, len(arr)):
        # Slide: remove arr[i-k], add arr[i]
        window_result = window_result - arr[i-k] + arr[i]
        best = max(best, window_result)
    
    return best

# Template 2: Variable Window (At Most K Pattern)
def variable_window_template(arr, k):
    left = 0
    count = {}
    result = 0
    
    for right in range(len(arr)):
        # Expand: add arr[right] to state
        count[arr[right]] = count.get(arr[right], 0) + 1
        
        # Shrink while invalid
        while len(count) > k:
            count[arr[left]] -= 1
            if count[arr[left]] == 0:
                del count[arr[left]]
            left += 1
        
        # Update result
        result = max(result, right - left + 1)
    
    return result

# Template 3: Minimum Window (Find Smallest Valid)
def min_window_template(arr, target):
    left = 0
    current_sum = 0
    min_length = float('inf')
    
    for right in range(len(arr)):
        current_sum += arr[right]
        
        while current_sum >= target:  # While window is valid
            min_length = min(min_length, right - left + 1)
            current_sum -= arr[left]
            left += 1
    
    return min_length if min_length != float('inf') else 0
```

```java Java
// Template 1: Fixed Window
public int fixedWindowTemplate(int[] arr, int k) {
    // Initialize first window
    int windowResult = 0;
    for (int i = 0; i < k; i++) {
        windowResult += arr[i];
    }
    int best = windowResult;
    
    for (int i = k; i < arr.length; i++) {
        // Slide: remove arr[i-k], add arr[i]
        windowResult = windowResult - arr[i - k] + arr[i];
        best = Math.max(best, windowResult);
    }
    
    return best;
}

// Template 2: Variable Window (At Most K Pattern)
public int variableWindowTemplate(int[] arr, int k) {
    int left = 0;
    Map<Integer, Integer> count = new HashMap<>();
    int result = 0;
    
    for (int right = 0; right < arr.length; right++) {
        // Expand: add arr[right] to state
        count.put(arr[right], count.getOrDefault(arr[right], 0) + 1);
        
        // Shrink while invalid
        while (count.size() > k) {
            count.put(arr[left], count.get(arr[left]) - 1);
            if (count.get(arr[left]) == 0) {
                count.remove(arr[left]);
            }
            left++;
        }
        
        // Update result
        result = Math.max(result, right - left + 1);
    }
    
    return result;
}

// Template 3: Minimum Window (Find Smallest Valid)
public int minWindowTemplate(int[] arr, int target) {
    int left = 0;
    int currentSum = 0;
    int minLength = Integer.MAX_VALUE;
    
    for (int right = 0; right < arr.length; right++) {
        currentSum += arr[right];
        
        while (currentSum >= target) {
            minLength = Math.min(minLength, right - left + 1);
            currentSum -= arr[left];
            left++;
        }
    }
    
    return minLength != Integer.MAX_VALUE ? minLength : 0;
}
```

```cpp C++
// Template 1: Fixed Window
int fixedWindowTemplate(vector<int>& arr, int k) {
    // Initialize first window
    int windowResult = 0;
    for (int i = 0; i < k; i++) {
        windowResult += arr[i];
    }
    int best = windowResult;
    
    for (int i = k; i < arr.size(); i++) {
        // Slide: remove arr[i-k], add arr[i]
        windowResult = windowResult - arr[i - k] + arr[i];
        best = max(best, windowResult);
    }
    
    return best;
}

// Template 2: Variable Window (At Most K Pattern)
int variableWindowTemplate(vector<int>& arr, int k) {
    int left = 0;
    unordered_map<int, int> count;
    int result = 0;
    
    for (int right = 0; right < arr.size(); right++) {
        // Expand: add arr[right] to state
        count[arr[right]]++;
        
        // Shrink while invalid
        while (count.size() > k) {
            count[arr[left]]--;
            if (count[arr[left]] == 0) {
                count.erase(arr[left]);
            }
            left++;
        }
        
        // Update result
        result = max(result, right - left + 1);
    }
    
    return result;
}

// Template 3: Minimum Window (Find Smallest Valid)
int minWindowTemplate(vector<int>& arr, int target) {
    int left = 0;
    int currentSum = 0;
    int minLength = INT_MAX;
    
    for (int right = 0; right < arr.size(); right++) {
        currentSum += arr[right];
        
        while (currentSum >= target) {
            minLength = min(minLength, right - left + 1);
            currentSum -= arr[left];
            left++;
        }
    }
    
    return minLength != INT_MAX ? minLength : 0;
}
```
</CodeGroup>

## Sliding Window Decision Tree

```
Is it about subarray/substring?
|
+-- YES --> Is it asking for min/max/count?
|           |
|           +-- Fixed size k? --> Fixed Window
|           |
|           +-- Variable size? 
|               |
|               +-- "At most K" --> Expand + Shrink when > K
|               |
|               +-- "At least K" --> Expand + Count valid extensions
|               |
|               +-- "Exactly K" --> AtMost(K) - AtMost(K-1)
|
+-- NO --> Consider other patterns
```

## Common Mistakes

<Warning>
**Avoid These Pitfalls:**
1. **Forgetting to shrink**: Always shrink when window becomes invalid
2. **Wrong window update order**: Expand first, then shrink, then update result
3. **Not handling empty result**: Check for edge cases like empty input
4. **Counting exactly K wrong**: Use AtMost(K) - AtMost(K-1) trick
</Warning>

## Debugging Checklist

When your Sliding Window solution fails:

<Steps>
  <Step title="Check Expand Logic">
    Are you correctly adding the new element to your window state?
  </Step>
  <Step title="Check Shrink Condition">
    Is the while condition correct? (`> k` vs `>= k` matters!)
  </Step>
  <Step title="Check Shrink Logic">
    Are you correctly removing the left element from state?
  </Step>
  <Step title="Check Result Update">
    Are you updating result at the right time? (Usually after shrink)
  </Step>
  <Step title="Check Edge Cases">
    Empty string? K = 0? All same characters?
  </Step>
</Steps>

## Complexity Quick Reference

| Problem Type | Time | Space | Window Type |
|-------------|------|-------|-------------|
| Max sum of K elements | O(n) | O(1) | Fixed |
| Longest substring no repeat | O(n) | O(min(n,m)) | Variable |
| Min window substring | O(n+m) | O(m) | Variable |
| Subarrays with K distinct | O(n) | O(K) | Variable |
| Max consecutive ones with K flips | O(n) | O(1) | Variable |

## Interview Problems by Company

<Tabs>
  <Tab title="Easy">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Max Average Subarray I | Amazon | Fixed window basics |
    | Contains Duplicate II | Meta | Fixed window + set |
    | Max Consecutive Ones | Google | Simple sliding |
    | Find All Anagrams | Amazon, Meta | Fixed window + frequency |
  </Tab>
  <Tab title="Medium">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Longest Substring No Repeat | All FAANG | Variable + HashMap |
    | Longest Repeating Replacement | Google | Variable + count |
    | Max Ones with K Flips | Meta | Variable window |
    | Permutation in String | Microsoft | Fixed + frequency |
    | Fruit Into Baskets | Google | At most 2 distinct |
  </Tab>
  <Tab title="Hard">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Minimum Window Substring | All FAANG | Classic min window |
    | Sliding Window Maximum | Amazon, Google | Window + Deque |
    | Subarrays K Different | Google | Exactly K trick |
    | Substring Concatenation | Amazon | Complex fixed window |
  </Tab>
</Tabs>

## Interview Tips

<AccordionGroup>
  <Accordion title="How to Explain Your Approach" icon="comments">
    **Script for interviews:**
    
    1. "I see this is about contiguous subarrays, so I'll use Sliding Window."
    2. "I'll maintain a window with two pointers: left and right."
    3. "Right pointer expands the window, left pointer shrinks it."
    4. "I'll track [state] to know when window is valid/invalid."
    5. "This gives us O(n) time since each element is visited at most twice."
  </Accordion>
  
  <Accordion title="When Interviewer Says..." icon="user-tie">
    | Interviewer Says | You Should Think |
    |-----------------|------------------|
    | "Find contiguous subarray" | Sliding Window! |
    | "Longest/shortest substring" | Sliding Window! |
    | "At most K distinct" | Variable window + shrink when > K |
    | "Exactly K" | AtMost(K) - AtMost(K-1) |
    | "All subarrays of size K" | Fixed window |
    | "Contains permutation" | Fixed window + frequency match |
  </Accordion>
  
  <Accordion title="The AtMost Trick Explained" icon="wand-magic-sparkles">
    **Why "Exactly K = AtMost(K) - AtMost(K-1)"?**
    
    - `AtMost(K)` counts all windows with 0, 1, 2, ... K distinct elements
    - `AtMost(K-1)` counts all windows with 0, 1, 2, ... K-1 distinct elements
    - Subtracting gives us ONLY windows with exactly K distinct elements
    
    This trick works because directly counting "exactly K" is hard, but "at most K" is easy!
  </Accordion>
</AccordionGroup>

## The "Exactly K" Trick

<CodeGroup>
```python Python
from collections import defaultdict

def subarrays_exactly_k_distinct(arr, k):
    """Count subarrays with exactly k distinct elements"""
    def at_most_k(arr, k):
        left = 0
        count = defaultdict(int)
        result = 0
        
        for right in range(len(arr)):
            count[arr[right]] += 1
            
            while len(count) > k:
                count[arr[left]] -= 1
                if count[arr[left]] == 0:
                    del count[arr[left]]
                left += 1
            
            result += right - left + 1
        
        return result
    
    return at_most_k(arr, k) - at_most_k(arr, k - 1)
```

```java Java
public int subarraysExactlyKDistinct(int[] arr, int k) {
    // Count subarrays with exactly k distinct elements
    return atMostK(arr, k) - atMostK(arr, k - 1);
}

private int atMostK(int[] arr, int k) {
    int left = 0;
    Map<Integer, Integer> count = new HashMap<>();
    int result = 0;
    
    for (int right = 0; right < arr.length; right++) {
        count.put(arr[right], count.getOrDefault(arr[right], 0) + 1);
        
        while (count.size() > k) {
            count.put(arr[left], count.get(arr[left]) - 1);
            if (count.get(arr[left]) == 0) {
                count.remove(arr[left]);
            }
            left++;
        }
        
        result += right - left + 1;
    }
    
    return result;
}
```

```cpp C++
int atMostK(vector<int>& arr, int k) {
    int left = 0;
    unordered_map<int, int> count;
    int result = 0;
    
    for (int right = 0; right < arr.size(); right++) {
        count[arr[right]]++;
        
        while (count.size() > k) {
            count[arr[left]]--;
            if (count[arr[left]] == 0) {
                count.erase(arr[left]);
            }
            left++;
        }
        
        result += right - left + 1;
    }
    
    return result;
}

int subarraysExactlyKDistinct(vector<int>& arr, int k) {
    // Count subarrays with exactly k distinct elements
    return atMostK(arr, k) - atMostK(arr, k - 1);
}
```
</CodeGroup>

## Practice Problems

| Problem | Difficulty | Link |
|---------|------------|------|
| Maximum Average Subarray I | Easy | [LeetCode 643](https://leetcode.com/problems/maximum-average-subarray-i/) |
| Longest Substring Without Repeating | Medium | [LeetCode 3](https://leetcode.com/problems/longest-substring-without-repeating-characters/) |
| Minimum Window Substring | Hard | [LeetCode 76](https://leetcode.com/problems/minimum-window-substring/) |
| Sliding Window Maximum | Hard | [LeetCode 239](https://leetcode.com/problems/sliding-window-maximum/) |
| Subarrays with K Different Integers | Hard | [LeetCode 992](https://leetcode.com/problems/subarrays-with-k-different-integers/) |

## Practice Roadmap

<Steps>
  <Step title="Day 1: Fixed Window">
    - Solve: Max Average Subarray, Contains Duplicate II
    - Focus: Understanding the slide (add new, remove old)
  </Step>
  <Step title="Day 2: Variable Window - Max">
    - Solve: Longest Substring Without Repeat, Longest Repeating Replacement
    - Focus: Expand + shrink when invalid
  </Step>
  <Step title="Day 3: Variable Window - Min">
    - Solve: Minimum Size Subarray Sum, Minimum Window Substring
    - Focus: Shrink while valid (opposite of max)
  </Step>
  <Step title="Day 4: Exactly K Problems">
    - Solve: Subarrays with K Different Integers
    - Focus: The AtMost(K) - AtMost(K-1) trick
  </Step>
</Steps>

## Memory Trick: SLIDE

Remember **SLIDE** for Sliding Window:

- **S**ubarray/Substring problem?
- **L**ength constraints?
- **I**terate with two pointers?
- **D**ynamic window size?
- **E**xpand and shrink?

<Tip>
**Interview Tip**: When you see "contiguous", "subarray", or "substring" with an optimization goal, Sliding Window should be your first thought.
</Tip>
