---
title: "Sliding Window Pattern"
description: "Optimize subarray and substring problems with the sliding window technique"
icon: "window-restore"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/02-sliding-window.svg"
  alt="Sliding Window Pattern"
/>

## What is Sliding Window?

The **Sliding Window** pattern maintains a dynamic window over a sequence to find optimal subarrays or substrings. It reduces nested loops from O(n^2) to O(n) by reusing computations.

## When to Use

<CardGroup cols={2}>
  <Card title="Contiguous Subarrays" icon="grip-lines">
    Finding max/min sum, average, or product of k elements
  </Card>
  <Card title="Substring Problems" icon="text">
    Longest/shortest substring with certain properties
  </Card>
  <Card title="Fixed Size Window" icon="arrows-left-right-to-line">
    Problems asking about "exactly k" or "window of size k"
  </Card>
  <Card title="Variable Size Window" icon="arrows-maximize">
    Problems with "at most k" or "minimum length"
  </Card>
</CardGroup>

## Pattern Variations

### 1. Fixed Size Window

Window size remains constant throughout.

<CodeGroup>
```python Python
def max_sum_subarray_k(arr, k):
    """Find maximum sum of subarray with exactly k elements"""
    if len(arr) < k:
        return -1
    
    # Calculate sum of first window
    window_sum = sum(arr[:k])
    max_sum = window_sum
    
    # Slide the window
    for i in range(k, len(arr)):
        window_sum += arr[i] - arr[i - k]  # Add new, remove old
        max_sum = max(max_sum, window_sum)
    
    return max_sum
```

```java Java
public int maxSumSubarrayK(int[] arr, int k) {
    // Find maximum sum of subarray with exactly k elements
    if (arr.length < k) {
        return -1;
    }
    
    // Calculate sum of first window
    int windowSum = 0;
    for (int i = 0; i < k; i++) {
        windowSum += arr[i];
    }
    int maxSum = windowSum;
    
    // Slide the window
    for (int i = k; i < arr.length; i++) {
        windowSum += arr[i] - arr[i - k];  // Add new, remove old
        maxSum = Math.max(maxSum, windowSum);
    }
    
    return maxSum;
}
```

```cpp C++
int maxSumSubarrayK(vector<int>& arr, int k) {
    // Find maximum sum of subarray with exactly k elements
    if (arr.size() < k) {
        return -1;
    }
    
    // Calculate sum of first window
    int windowSum = 0;
    for (int i = 0; i < k; i++) {
        windowSum += arr[i];
    }
    int maxSum = windowSum;
    
    // Slide the window
    for (int i = k; i < arr.size(); i++) {
        windowSum += arr[i] - arr[i - k];  // Add new, remove old
        maxSum = max(maxSum, windowSum);
    }
    
    return maxSum;
}
```
</CodeGroup>

### 2. Variable Size Window (Expand and Shrink)

Window grows and shrinks based on conditions.

<CodeGroup>
```python Python
def min_subarray_sum(arr, target):
    """Find minimum length subarray with sum >= target"""
    left = 0
    current_sum = 0
    min_length = float('inf')
    
    for right in range(len(arr)):
        current_sum += arr[right]  # Expand window
        
        while current_sum >= target:  # Shrink while valid
            min_length = min(min_length, right - left + 1)
            current_sum -= arr[left]
            left += 1
    
    return min_length if min_length != float('inf') else 0
```

```java Java
public int minSubarraySum(int[] arr, int target) {
    // Find minimum length subarray with sum >= target
    int left = 0;
    int currentSum = 0;
    int minLength = Integer.MAX_VALUE;
    
    for (int right = 0; right < arr.length; right++) {
        currentSum += arr[right];  // Expand window
        
        while (currentSum >= target) {  // Shrink while valid
            minLength = Math.min(minLength, right - left + 1);
            currentSum -= arr[left];
            left++;
        }
    }
    
    return minLength != Integer.MAX_VALUE ? minLength : 0;
}
```

```cpp C++
int minSubarraySum(vector<int>& arr, int target) {
    // Find minimum length subarray with sum >= target
    int left = 0;
    int currentSum = 0;
    int minLength = INT_MAX;
    
    for (int right = 0; right < arr.size(); right++) {
        currentSum += arr[right];  // Expand window
        
        while (currentSum >= target) {  // Shrink while valid
            minLength = min(minLength, right - left + 1);
            currentSum -= arr[left];
            left++;
        }
    }
    
    return minLength != INT_MAX ? minLength : 0;
}
```
</CodeGroup>

### 3. Window with HashMap/Counter

Track element frequencies within the window.

<CodeGroup>
```python Python
def longest_substring_k_unique(s, k):
    """Longest substring with exactly k unique characters"""
    from collections import defaultdict
    
    if k == 0:
        return 0
    
    left = 0
    char_count = defaultdict(int)
    max_length = 0
    
    for right in range(len(s)):
        char_count[s[right]] += 1
        
        while len(char_count) > k:
            char_count[s[left]] -= 1
            if char_count[s[left]] == 0:
                del char_count[s[left]]
            left += 1
        
        if len(char_count) == k:
            max_length = max(max_length, right - left + 1)
    
    return max_length
```

```java Java
public int longestSubstringKUnique(String s, int k) {
    // Longest substring with exactly k unique characters
    if (k == 0) {
        return 0;
    }
    
    int left = 0;
    Map<Character, Integer> charCount = new HashMap<>();
    int maxLength = 0;
    
    for (int right = 0; right < s.length(); right++) {
        char c = s.charAt(right);
        charCount.put(c, charCount.getOrDefault(c, 0) + 1);
        
        while (charCount.size() > k) {
            char leftChar = s.charAt(left);
            charCount.put(leftChar, charCount.get(leftChar) - 1);
            if (charCount.get(leftChar) == 0) {
                charCount.remove(leftChar);
            }
            left++;
        }
        
        if (charCount.size() == k) {
            maxLength = Math.max(maxLength, right - left + 1);
        }
    }
    
    return maxLength;
}
```

```cpp C++
int longestSubstringKUnique(string s, int k) {
    // Longest substring with exactly k unique characters
    if (k == 0) {
        return 0;
    }
    
    int left = 0;
    unordered_map<char, int> charCount;
    int maxLength = 0;
    
    for (int right = 0; right < s.size(); right++) {
        charCount[s[right]]++;
        
        while (charCount.size() > k) {
            charCount[s[left]]--;
            if (charCount[s[left]] == 0) {
                charCount.erase(s[left]);
            }
            left++;
        }
        
        if (charCount.size() == k) {
            maxLength = max(maxLength, right - left + 1);
        }
    }
    
    return maxLength;
}
```
</CodeGroup>

## Classic Problems

<AccordionGroup>
  <Accordion title="1. Maximum Sum Subarray of Size K" icon="arrow-up">
    **Problem**: Find the maximum sum of any contiguous subarray of size k.
    
    **Approach**: Fixed window - slide and update sum by adding new element and removing old.
    
    **Time**: O(n) | **Space**: O(1)
  </Accordion>
  
  <Accordion title="2. Longest Substring Without Repeating Characters" icon="text">
    **Problem**: Find length of longest substring without duplicate characters.
    
    **Approach**: Variable window with HashSet. Shrink when duplicate found.
    
    **Time**: O(n) | **Space**: O(min(n, m)) where m is charset size
  </Accordion>
  
  <Accordion title="3. Minimum Window Substring" icon="minimize">
    **Problem**: Find smallest substring containing all characters of another string.
    
    **Approach**: Variable window with character frequency tracking. Expand to include all, shrink to minimize.
    
    **Time**: O(n + m) | **Space**: O(m)
  </Accordion>
  
  <Accordion title="4. Fruit Into Baskets" icon="apple-whole">
    **Problem**: Maximum fruits you can collect with only 2 baskets (2 types).
    
    **Approach**: Longest subarray with at most 2 distinct elements.
    
    **Time**: O(n) | **Space**: O(1)
  </Accordion>
  
  <Accordion title="5. Permutation in String" icon="shuffle">
    **Problem**: Check if s2 contains a permutation of s1.
    
    **Approach**: Fixed window of size len(s1), compare character frequencies.
    
    **Time**: O(n) | **Space**: O(1)
  </Accordion>
</AccordionGroup>

## Template Code

<CodeGroup>
```python Python
# Template 1: Fixed Window
def fixed_window_template(arr, k):
    # Initialize first window
    window_result = sum(arr[:k])
    best = window_result
    
    for i in range(k, len(arr)):
        # Slide: remove arr[i-k], add arr[i]
        window_result = window_result - arr[i-k] + arr[i]
        best = max(best, window_result)
    
    return best

# Template 2: Variable Window (At Most K Pattern)
def variable_window_template(arr, k):
    left = 0
    count = {}
    result = 0
    
    for right in range(len(arr)):
        # Expand: add arr[right] to state
        count[arr[right]] = count.get(arr[right], 0) + 1
        
        # Shrink while invalid
        while len(count) > k:
            count[arr[left]] -= 1
            if count[arr[left]] == 0:
                del count[arr[left]]
            left += 1
        
        # Update result
        result = max(result, right - left + 1)
    
    return result

# Template 3: Minimum Window (Find Smallest Valid)
def min_window_template(arr, target):
    left = 0
    current_sum = 0
    min_length = float('inf')
    
    for right in range(len(arr)):
        current_sum += arr[right]
        
        while current_sum >= target:  # While window is valid
            min_length = min(min_length, right - left + 1)
            current_sum -= arr[left]
            left += 1
    
    return min_length if min_length != float('inf') else 0
```

```java Java
// Template 1: Fixed Window
public int fixedWindowTemplate(int[] arr, int k) {
    // Initialize first window
    int windowResult = 0;
    for (int i = 0; i < k; i++) {
        windowResult += arr[i];
    }
    int best = windowResult;
    
    for (int i = k; i < arr.length; i++) {
        // Slide: remove arr[i-k], add arr[i]
        windowResult = windowResult - arr[i - k] + arr[i];
        best = Math.max(best, windowResult);
    }
    
    return best;
}

// Template 2: Variable Window (At Most K Pattern)
public int variableWindowTemplate(int[] arr, int k) {
    int left = 0;
    Map<Integer, Integer> count = new HashMap<>();
    int result = 0;
    
    for (int right = 0; right < arr.length; right++) {
        // Expand: add arr[right] to state
        count.put(arr[right], count.getOrDefault(arr[right], 0) + 1);
        
        // Shrink while invalid
        while (count.size() > k) {
            count.put(arr[left], count.get(arr[left]) - 1);
            if (count.get(arr[left]) == 0) {
                count.remove(arr[left]);
            }
            left++;
        }
        
        // Update result
        result = Math.max(result, right - left + 1);
    }
    
    return result;
}

// Template 3: Minimum Window (Find Smallest Valid)
public int minWindowTemplate(int[] arr, int target) {
    int left = 0;
    int currentSum = 0;
    int minLength = Integer.MAX_VALUE;
    
    for (int right = 0; right < arr.length; right++) {
        currentSum += arr[right];
        
        while (currentSum >= target) {
            minLength = Math.min(minLength, right - left + 1);
            currentSum -= arr[left];
            left++;
        }
    }
    
    return minLength != Integer.MAX_VALUE ? minLength : 0;
}
```

```cpp C++
// Template 1: Fixed Window
int fixedWindowTemplate(vector<int>& arr, int k) {
    // Initialize first window
    int windowResult = 0;
    for (int i = 0; i < k; i++) {
        windowResult += arr[i];
    }
    int best = windowResult;
    
    for (int i = k; i < arr.size(); i++) {
        // Slide: remove arr[i-k], add arr[i]
        windowResult = windowResult - arr[i - k] + arr[i];
        best = max(best, windowResult);
    }
    
    return best;
}

// Template 2: Variable Window (At Most K Pattern)
int variableWindowTemplate(vector<int>& arr, int k) {
    int left = 0;
    unordered_map<int, int> count;
    int result = 0;
    
    for (int right = 0; right < arr.size(); right++) {
        // Expand: add arr[right] to state
        count[arr[right]]++;
        
        // Shrink while invalid
        while (count.size() > k) {
            count[arr[left]]--;
            if (count[arr[left]] == 0) {
                count.erase(arr[left]);
            }
            left++;
        }
        
        // Update result
        result = max(result, right - left + 1);
    }
    
    return result;
}

// Template 3: Minimum Window (Find Smallest Valid)
int minWindowTemplate(vector<int>& arr, int target) {
    int left = 0;
    int currentSum = 0;
    int minLength = INT_MAX;
    
    for (int right = 0; right < arr.size(); right++) {
        currentSum += arr[right];
        
        while (currentSum >= target) {
            minLength = min(minLength, right - left + 1);
            currentSum -= arr[left];
            left++;
        }
    }
    
    return minLength != INT_MAX ? minLength : 0;
}
```
</CodeGroup>

## Sliding Window Decision Tree

```
Is it about subarray/substring?
|
+-- YES --> Is it asking for min/max/count?
|           |
|           +-- Fixed size k? --> Fixed Window
|           |
|           +-- Variable size? 
|               |
|               +-- "At most K" --> Expand + Shrink when > K
|               |
|               +-- "At least K" --> Expand + Count valid extensions
|               |
|               +-- "Exactly K" --> AtMost(K) - AtMost(K-1)
|
+-- NO --> Consider other patterns
```

## Common Mistakes

<Warning>
**Avoid These Pitfalls:**
1. **Forgetting to shrink**: Always shrink when window becomes invalid
2. **Wrong window update order**: Expand first, then shrink, then update result
3. **Not handling empty result**: Check for edge cases like empty input
4. **Counting exactly K wrong**: Use AtMost(K) - AtMost(K-1) trick
</Warning>

## The "Exactly K" Trick

<CodeGroup>
```python Python
from collections import defaultdict

def subarrays_exactly_k_distinct(arr, k):
    """Count subarrays with exactly k distinct elements"""
    def at_most_k(arr, k):
        left = 0
        count = defaultdict(int)
        result = 0
        
        for right in range(len(arr)):
            count[arr[right]] += 1
            
            while len(count) > k:
                count[arr[left]] -= 1
                if count[arr[left]] == 0:
                    del count[arr[left]]
                left += 1
            
            result += right - left + 1
        
        return result
    
    return at_most_k(arr, k) - at_most_k(arr, k - 1)
```

```java Java
public int subarraysExactlyKDistinct(int[] arr, int k) {
    // Count subarrays with exactly k distinct elements
    return atMostK(arr, k) - atMostK(arr, k - 1);
}

private int atMostK(int[] arr, int k) {
    int left = 0;
    Map<Integer, Integer> count = new HashMap<>();
    int result = 0;
    
    for (int right = 0; right < arr.length; right++) {
        count.put(arr[right], count.getOrDefault(arr[right], 0) + 1);
        
        while (count.size() > k) {
            count.put(arr[left], count.get(arr[left]) - 1);
            if (count.get(arr[left]) == 0) {
                count.remove(arr[left]);
            }
            left++;
        }
        
        result += right - left + 1;
    }
    
    return result;
}
```

```cpp C++
int atMostK(vector<int>& arr, int k) {
    int left = 0;
    unordered_map<int, int> count;
    int result = 0;
    
    for (int right = 0; right < arr.size(); right++) {
        count[arr[right]]++;
        
        while (count.size() > k) {
            count[arr[left]]--;
            if (count[arr[left]] == 0) {
                count.erase(arr[left]);
            }
            left++;
        }
        
        result += right - left + 1;
    }
    
    return result;
}

int subarraysExactlyKDistinct(vector<int>& arr, int k) {
    // Count subarrays with exactly k distinct elements
    return atMostK(arr, k) - atMostK(arr, k - 1);
}
```
</CodeGroup>

## Practice Problems

| Problem | Difficulty | Link |
|---------|------------|------|
| Maximum Average Subarray I | Easy | [LeetCode 643](https://leetcode.com/problems/maximum-average-subarray-i/) |
| Longest Substring Without Repeating | Medium | [LeetCode 3](https://leetcode.com/problems/longest-substring-without-repeating-characters/) |
| Minimum Window Substring | Hard | [LeetCode 76](https://leetcode.com/problems/minimum-window-substring/) |
| Sliding Window Maximum | Hard | [LeetCode 239](https://leetcode.com/problems/sliding-window-maximum/) |
| Subarrays with K Different Integers | Hard | [LeetCode 992](https://leetcode.com/problems/subarrays-with-k-different-integers/) |

<Tip>
**Interview Tip**: When you see "contiguous", "subarray", or "substring" with an optimization goal, Sliding Window should be your first thought.
</Tip>
