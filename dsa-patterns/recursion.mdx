---
title: "Recursion Pattern"
description: "Solve problems by breaking them into smaller self-similar subproblems"
icon: "arrow-rotate-right"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/15-recursion.svg"
  alt="Recursion Pattern"
/>

## What is Recursion?

**Recursion** is when a function calls itself to solve smaller instances of the same problem. Every recursive solution has a base case (termination) and a recursive case (breakdown).

## When to Use

<CardGroup cols={2}>
  <Card title="Tree/Graph Traversal" icon="tree">
    DFS, preorder, inorder, postorder
  </Card>
  <Card title="Divide and Conquer" icon="arrows-split-up-and-left">
    Merge sort, quick sort
  </Card>
  <Card title="Backtracking" icon="rotate-left">
    Permutations, combinations
  </Card>
  <Card title="Dynamic Programming" icon="layer-group">
    Top-down memoization
  </Card>
</CardGroup>

## The Recursive Template

<CodeGroup>
```python Python
def recursive_function(problem):
    # Base case(s) - when to stop
    if is_base_case(problem):
        return base_solution
    
    # Recursive case - break down and solve
    smaller_problem = reduce(problem)
    sub_result = recursive_function(smaller_problem)
    
    # Combine results
    return combine(sub_result, current_work)
```

```java Java
public Result recursiveFunction(Problem problem) {
    // Base case(s) - when to stop
    if (isBaseCase(problem)) {
        return baseSolution;
    }
    
    // Recursive case - break down and solve
    Problem smallerProblem = reduce(problem);
    Result subResult = recursiveFunction(smallerProblem);
    
    // Combine results
    return combine(subResult, currentWork);
}
```

```cpp C++
Result recursiveFunction(Problem problem) {
    // Base case(s) - when to stop
    if (isBaseCase(problem)) {
        return baseSolution;
    }
    
    // Recursive case - break down and solve
    Problem smallerProblem = reduce(problem);
    Result subResult = recursiveFunction(smallerProblem);
    
    // Combine results
    return combine(subResult, currentWork);
}
```
</CodeGroup>

## Pattern Variations

### 1. Simple Recursion (Factorial)

<CodeGroup>
```python Python
def factorial(n):
    """Base case + single recursive call"""
    if n <= 1:
        return 1
    return n * factorial(n - 1)
```

```java Java
public long factorial(int n) {
    // Base case + single recursive call
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}
```

```cpp C++
long long factorial(int n) {
    // Base case + single recursive call
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}
```
</CodeGroup>

### 2. Tree Recursion (Fibonacci)

<CodeGroup>
```python Python
def fibonacci(n, memo={}):
    """Multiple recursive calls (memoized)"""
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)
    return memo[n]
```

```java Java
import java.util.HashMap;
import java.util.Map;

public class Fibonacci {
    private Map<Integer, Long> memo = new HashMap<>();
    
    public long fibonacci(int n) {
        // Multiple recursive calls (memoized)
        if (memo.containsKey(n)) {
            return memo.get(n);
        }
        if (n <= 1) {
            return n;
        }
        long result = fibonacci(n - 1) + fibonacci(n - 2);
        memo.put(n, result);
        return result;
    }
}
```

```cpp C++
#include <unordered_map>

class Fibonacci {
private:
    std::unordered_map<int, long long> memo;
    
public:
    long long fibonacci(int n) {
        // Multiple recursive calls (memoized)
        if (memo.find(n) != memo.end()) {
            return memo[n];
        }
        if (n <= 1) {
            return n;
        }
        memo[n] = fibonacci(n - 1) + fibonacci(n - 2);
        return memo[n];
    }
};
```
</CodeGroup>

### 3. Tail Recursion

<CodeGroup>
```python Python
def factorial_tail(n, acc=1):
    """Last operation is recursive call - can be optimized"""
    if n <= 1:
        return acc
    return factorial_tail(n - 1, n * acc)
```

```java Java
public long factorialTail(int n, long acc) {
    // Last operation is recursive call - can be optimized
    if (n <= 1) {
        return acc;
    }
    return factorialTail(n - 1, n * acc);
}

// Call with: factorialTail(5, 1)
```

```cpp C++
long long factorialTail(int n, long long acc = 1) {
    // Last operation is recursive call - can be optimized
    if (n <= 1) {
        return acc;
    }
    return factorialTail(n - 1, n * acc);
}
```
</CodeGroup>

### 4. Helper Function Pattern

<CodeGroup>
```python Python
def solve_problem(input_data):
    """Public API, calls recursive helper"""
    result = []
    
    def helper(state, index):
        if is_complete(state):
            result.append(state[:])
            return
        
        for choice in get_choices(index):
            state.append(choice)
            helper(state, index + 1)
            state.pop()
    
    helper([], 0)
    return result
```

```java Java
public class SolveProblem {
    private List<List<Integer>> result = new ArrayList<>();
    
    public List<List<Integer>> solveProblem(int[] input) {
        // Public API, calls recursive helper
        helper(new ArrayList<>(), 0, input);
        return result;
    }
    
    private void helper(List<Integer> state, int index, int[] input) {
        if (isComplete(state, input)) {
            result.add(new ArrayList<>(state));
            return;
        }
        
        for (int choice : getChoices(index, input)) {
            state.add(choice);
            helper(state, index + 1, input);
            state.remove(state.size() - 1);
        }
    }
}
```

```cpp C++
class SolveProblem {
private:
    vector<vector<int>> result;
    
    void helper(vector<int>& state, int index, vector<int>& input) {
        if (isComplete(state, input)) {
            result.push_back(state);
            return;
        }
        
        for (int choice : getChoices(index, input)) {
            state.push_back(choice);
            helper(state, index + 1, input);
            state.pop_back();
        }
    }
    
public:
    vector<vector<int>> solveProblem(vector<int>& input) {
        // Public API, calls recursive helper
        vector<int> state;
        helper(state, 0, input);
        return result;
    }
};
```
</CodeGroup>

### 5. Binary Tree Traversal

<CodeGroup>
```python Python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def inorder_traversal(root):
    """Left -> Root -> Right"""
    if not root:
        return []
    return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right)

def max_depth(root):
    """Height of binary tree"""
    if not root:
        return 0
    return 1 + max(max_depth(root.left), max_depth(root.right))
```

```java Java
class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) { this.val = val; }
}

public class TreeTraversal {
    public List<Integer> inorderTraversal(TreeNode root) {
        // Left -> Root -> Right
        List<Integer> result = new ArrayList<>();
        if (root == null) return result;
        
        result.addAll(inorderTraversal(root.left));
        result.add(root.val);
        result.addAll(inorderTraversal(root.right));
        return result;
    }
    
    public int maxDepth(TreeNode root) {
        // Height of binary tree
        if (root == null) return 0;
        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
    }
}
```

```cpp C++
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class TreeTraversal {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        // Left -> Root -> Right
        vector<int> result;
        if (root == nullptr) return result;
        
        vector<int> left = inorderTraversal(root->left);
        result.insert(result.end(), left.begin(), left.end());
        result.push_back(root->val);
        vector<int> right = inorderTraversal(root->right);
        result.insert(result.end(), right.begin(), right.end());
        return result;
    }
    
    int maxDepth(TreeNode* root) {
        // Height of binary tree
        if (root == nullptr) return 0;
        return 1 + max(maxDepth(root->left), maxDepth(root->right));
    }
};
```
</CodeGroup>

## Classic Problems

| Problem | Pattern | Key Insight |
|---------|---------|-------------|
| Factorial | Simple | One recursive call |
| Fibonacci | Tree + Memo | Multiple calls, cache results |
| Tower of Hanoi | Mutual | Move n-1, move 1, move n-1 |
| Tree Traversal | Binary | Left subtree, root, right |
| Permutations | Backtrack | Choose, explore, unchoose |

## Practice Problems

<CardGroup cols={2}>
  <Card title="Pow(x, n)" icon="superscript" href="https://leetcode.com/problems/powx-n/">
    Fast exponentiation recursion
  </Card>
  <Card title="K-th Symbol" icon="1" href="https://leetcode.com/problems/k-th-symbol-in-grammar/">
    Pattern recognition recursion
  </Card>
  <Card title="Flatten Nested List" icon="list" href="https://leetcode.com/problems/flatten-nested-list-iterator/">
    Recursive flattening
  </Card>
  <Card title="Decode String" icon="lock-open" href="https://leetcode.com/problems/decode-string/">
    Nested structure recursion
  </Card>
</CardGroup>
