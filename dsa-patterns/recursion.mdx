---
title: "Recursion Pattern"
description: "Solve problems by breaking them into smaller self-similar subproblems"
icon: "arrow-rotate-right"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/15-recursion.svg"
  alt="Recursion Pattern"
/>

## What is Recursion?

**Recursion** is when a function calls itself to solve smaller instances of the same problem. Every recursive solution has a base case (termination) and a recursive case (breakdown).

<Note>
**Quick Recognition**: Problems that can be broken into smaller self-similar subproblems. Look for: tree/graph traversal, nested structures, divide and conquer.
</Note>

## Pattern Recognition Checklist

<CardGroup cols={2}>
  <Card title="Use Recursion When" icon="check">
    - Tree/graph traversal (DFS)
    - Nested or hierarchical structures
    - Divide and conquer algorithms
    - Backtracking problems
    - Mathematical sequences (factorial, fibonacci)
    - Subproblems have same structure as original
  </Card>
  <Card title="Don't Use When" icon="xmark">
    - Simple iteration suffices
    - Large input (stack overflow risk)
    - No natural subproblem structure
    - Tail recursion can be converted to loop
  </Card>
</CardGroup>

## Recursion Types

| Type | Description | Example |
|------|-------------|---------|
| Linear | One recursive call | Factorial, sum of array |
| Binary | Two recursive calls | Fibonacci, binary tree |
| Multiple | Many recursive calls | N-ary tree traversal |
| Mutual | Functions call each other | Even/odd check |
| Nested | Recursive call in argument | Ackermann function |
| Tail | Recursive call is last operation | Optimizable to iteration |

## The Three Laws of Recursion

1. **A recursive function must have a base case**
2. **A recursive function must change state toward the base case**
3. **A recursive function must call itself**

## When to Use

<CardGroup cols={2}>
  <Card title="Tree/Graph Traversal" icon="tree">
    DFS, preorder, inorder, postorder
  </Card>
  <Card title="Divide and Conquer" icon="arrows-split-up-and-left">
    Merge sort, quick sort
  </Card>
  <Card title="Backtracking" icon="rotate-left">
    Permutations, combinations
  </Card>
  <Card title="Dynamic Programming" icon="layer-group">
    Top-down memoization
  </Card>
</CardGroup>

## The Recursive Template

<CodeGroup>
```python Python
def recursive_function(problem):
    # Base case(s) - when to stop
    if is_base_case(problem):
        return base_solution
    
    # Recursive case - break down and solve
    smaller_problem = reduce(problem)
    sub_result = recursive_function(smaller_problem)
    
    # Combine results
    return combine(sub_result, current_work)
```

```java Java
public Result recursiveFunction(Problem problem) {
    // Base case(s) - when to stop
    if (isBaseCase(problem)) {
        return baseSolution;
    }
    
    // Recursive case - break down and solve
    Problem smallerProblem = reduce(problem);
    Result subResult = recursiveFunction(smallerProblem);
    
    // Combine results
    return combine(subResult, currentWork);
}
```

```cpp C++
Result recursiveFunction(Problem problem) {
    // Base case(s) - when to stop
    if (isBaseCase(problem)) {
        return baseSolution;
    }
    
    // Recursive case - break down and solve
    Problem smallerProblem = reduce(problem);
    Result subResult = recursiveFunction(smallerProblem);
    
    // Combine results
    return combine(subResult, currentWork);
}
```
</CodeGroup>

## Pattern Variations

### 1. Simple Recursion (Factorial)

<CodeGroup>
```python Python
def factorial(n):
    """Base case + single recursive call"""
    if n <= 1:
        return 1
    return n * factorial(n - 1)
```

```java Java
public long factorial(int n) {
    // Base case + single recursive call
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}
```

```cpp C++
long long factorial(int n) {
    // Base case + single recursive call
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}
```
</CodeGroup>

### 2. Tree Recursion (Fibonacci)

<CodeGroup>
```python Python
def fibonacci(n, memo={}):
    """Multiple recursive calls (memoized)"""
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)
    return memo[n]
```

```java Java
import java.util.HashMap;
import java.util.Map;

public class Fibonacci {
    private Map<Integer, Long> memo = new HashMap<>();
    
    public long fibonacci(int n) {
        // Multiple recursive calls (memoized)
        if (memo.containsKey(n)) {
            return memo.get(n);
        }
        if (n <= 1) {
            return n;
        }
        long result = fibonacci(n - 1) + fibonacci(n - 2);
        memo.put(n, result);
        return result;
    }
}
```

```cpp C++
#include <unordered_map>

class Fibonacci {
private:
    std::unordered_map<int, long long> memo;
    
public:
    long long fibonacci(int n) {
        // Multiple recursive calls (memoized)
        if (memo.find(n) != memo.end()) {
            return memo[n];
        }
        if (n <= 1) {
            return n;
        }
        memo[n] = fibonacci(n - 1) + fibonacci(n - 2);
        return memo[n];
    }
};
```
</CodeGroup>

### 3. Tail Recursion

<CodeGroup>
```python Python
def factorial_tail(n, acc=1):
    """Last operation is recursive call - can be optimized"""
    if n <= 1:
        return acc
    return factorial_tail(n - 1, n * acc)
```

```java Java
public long factorialTail(int n, long acc) {
    // Last operation is recursive call - can be optimized
    if (n <= 1) {
        return acc;
    }
    return factorialTail(n - 1, n * acc);
}

// Call with: factorialTail(5, 1)
```

```cpp C++
long long factorialTail(int n, long long acc = 1) {
    // Last operation is recursive call - can be optimized
    if (n <= 1) {
        return acc;
    }
    return factorialTail(n - 1, n * acc);
}
```
</CodeGroup>

### 4. Helper Function Pattern

<CodeGroup>
```python Python
def solve_problem(input_data):
    """Public API, calls recursive helper"""
    result = []
    
    def helper(state, index):
        if is_complete(state):
            result.append(state[:])
            return
        
        for choice in get_choices(index):
            state.append(choice)
            helper(state, index + 1)
            state.pop()
    
    helper([], 0)
    return result
```

```java Java
public class SolveProblem {
    private List<List<Integer>> result = new ArrayList<>();
    
    public List<List<Integer>> solveProblem(int[] input) {
        // Public API, calls recursive helper
        helper(new ArrayList<>(), 0, input);
        return result;
    }
    
    private void helper(List<Integer> state, int index, int[] input) {
        if (isComplete(state, input)) {
            result.add(new ArrayList<>(state));
            return;
        }
        
        for (int choice : getChoices(index, input)) {
            state.add(choice);
            helper(state, index + 1, input);
            state.remove(state.size() - 1);
        }
    }
}
```

```cpp C++
class SolveProblem {
private:
    vector<vector<int>> result;
    
    void helper(vector<int>& state, int index, vector<int>& input) {
        if (isComplete(state, input)) {
            result.push_back(state);
            return;
        }
        
        for (int choice : getChoices(index, input)) {
            state.push_back(choice);
            helper(state, index + 1, input);
            state.pop_back();
        }
    }
    
public:
    vector<vector<int>> solveProblem(vector<int>& input) {
        // Public API, calls recursive helper
        vector<int> state;
        helper(state, 0, input);
        return result;
    }
};
```
</CodeGroup>

### 5. Binary Tree Traversal

<CodeGroup>
```python Python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def inorder_traversal(root):
    """Left -> Root -> Right"""
    if not root:
        return []
    return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right)

def max_depth(root):
    """Height of binary tree"""
    if not root:
        return 0
    return 1 + max(max_depth(root.left), max_depth(root.right))
```

```java Java
class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) { this.val = val; }
}

public class TreeTraversal {
    public List<Integer> inorderTraversal(TreeNode root) {
        // Left -> Root -> Right
        List<Integer> result = new ArrayList<>();
        if (root == null) return result;
        
        result.addAll(inorderTraversal(root.left));
        result.add(root.val);
        result.addAll(inorderTraversal(root.right));
        return result;
    }
    
    public int maxDepth(TreeNode root) {
        // Height of binary tree
        if (root == null) return 0;
        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
    }
}
```

```cpp C++
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class TreeTraversal {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        // Left -> Root -> Right
        vector<int> result;
        if (root == nullptr) return result;
        
        vector<int> left = inorderTraversal(root->left);
        result.insert(result.end(), left.begin(), left.end());
        result.push_back(root->val);
        vector<int> right = inorderTraversal(root->right);
        result.insert(result.end(), right.begin(), right.end());
        return result;
    }
    
    int maxDepth(TreeNode* root) {
        // Height of binary tree
        if (root == nullptr) return 0;
        return 1 + max(maxDepth(root->left), maxDepth(root->right));
    }
};
```
</CodeGroup>

## Classic Problems

| Problem | Pattern | Key Insight |
|---------|---------|-------------|
| Factorial | Simple | One recursive call |
| Fibonacci | Tree + Memo | Multiple calls, cache results |
| Tower of Hanoi | Mutual | Move n-1, move 1, move n-1 |
| Tree Traversal | Binary | Left subtree, root, right |
| Permutations | Backtrack | Choose, explore, unchoose |

## Common Mistakes

<Warning>
**Avoid These Pitfalls:**
1. **Missing base case**: Leads to infinite recursion and stack overflow
2. **Base case never reached**: State doesn't progress toward termination
3. **Wrong return value**: Not combining subproblem results correctly
4. **Modifying shared state**: Forgetting to backtrack in backtracking
5. **Stack overflow**: Too deep recursion without memoization or tail call
</Warning>

## Debugging Recursion

<Steps>
  <Step title="Verify Base Case">
    Is there at least one base case? Does it return correct value?
  </Step>
  <Step title="Check Progress">
    Does each recursive call move toward the base case?
  </Step>
  <Step title="Trace Small Input">
    Manually trace with n=0, n=1, n=2 to verify logic
  </Step>
  <Step title="Add Print Statements">
    Print entry/exit to visualize call stack
  </Step>
  <Step title="Consider Memoization">
    If same subproblems repeat, add caching
  </Step>
</Steps>

## Interview Problems by Company

<Tabs>
  <Tab title="Easy">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Fibonacci | All | Binary recursion + memo |
    | Reverse String | Amazon | Two-pointer recursion |
    | Merge Two Lists | All FAANG | Linked list recursion |
    | Maximum Depth of Tree | All | Binary tree recursion |
  </Tab>
  <Tab title="Medium">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Pow(x, n) | Meta, Google | Fast exponentiation |
    | Decode String | Google, Amazon | Nested recursion |
    | Flatten Nested List | Meta | Iterator + recursion |
    | Letter Combinations | All FAANG | Backtracking |
  </Tab>
  <Tab title="Hard">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Regular Expression | Google, Meta | Two-branch recursion |
    | Wildcard Matching | Google | Recursion + memo |
    | Parse Boolean Expr | Amazon | Nested expression |
  </Tab>
</Tabs>

## Interview Tips

<AccordionGroup>
  <Accordion title="How to Explain Your Approach" icon="comments">
    **Script for interviews:**
    
    1. "I'll solve this recursively because it breaks into smaller self-similar subproblems."
    2. "My base case is [describe when to stop]."
    3. "My recursive case [describe how to break down]."
    4. "I combine results by [describe combination]."
    5. "Time complexity is O(X) because [reasoning]."
  </Accordion>
  
  <Accordion title="Recursion vs Iteration" icon="arrows-rotate">
    | Aspect | Recursion | Iteration |
    |--------|-----------|-----------|
    | Readability | Often cleaner for trees | Better for simple loops |
    | Memory | Stack frames | Usually O(1) |
    | Performance | Function call overhead | Generally faster |
    | When to choose | Complex branching | Simple linear process |
  </Accordion>
  
  <Accordion title="Converting to Iteration" icon="code">
    Many recursive solutions can use explicit stack:
    
    ```python
    # Recursive
    def preorder(root):
        if not root:
            return []
        return [root.val] + preorder(root.left) + preorder(root.right)
    
    # Iterative with stack
    def preorder_iterative(root):
        if not root:
            return []
        result, stack = [], [root]
        while stack:
            node = stack.pop()
            result.append(node.val)
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        return result
    ```
  </Accordion>
</AccordionGroup>

## Practice Problems

<CardGroup cols={2}>
  <Card title="Pow(x, n)" icon="superscript" href="https://leetcode.com/problems/powx-n/">
    Fast exponentiation recursion
  </Card>
  <Card title="K-th Symbol" icon="1" href="https://leetcode.com/problems/k-th-symbol-in-grammar/">
    Pattern recognition recursion
  </Card>
  <Card title="Flatten Nested List" icon="list" href="https://leetcode.com/problems/flatten-nested-list-iterator/">
    Recursive flattening
  </Card>
  <Card title="Decode String" icon="lock-open" href="https://leetcode.com/problems/decode-string/">
    Nested structure recursion
  </Card>
</CardGroup>

## Practice Roadmap

<Steps>
  <Step title="Day 1: Basic Recursion">
    - Solve: Fibonacci, Factorial, Sum of Array
    - Focus: Base case + recursive case pattern
  </Step>
  <Step title="Day 2: Tree Recursion">
    - Solve: Max Depth, Same Tree, Invert Tree
    - Focus: Binary tree traversal patterns
  </Step>
  <Step title="Day 3: Divide and Conquer">
    - Solve: Pow(x, n), Merge Sort
    - Focus: Splitting and combining
  </Step>
  <Step title="Day 4: Advanced Recursion">
    - Solve: Decode String, Regular Expression
    - Focus: Complex nested structures
  </Step>
</Steps>

<Tip>
**Interview Tip**: If you're stuck on recursion, start by asking: "What's the smallest version of this problem I can solve directly?" That's your base case.
</Tip>
