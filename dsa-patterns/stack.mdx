---
title: "Stack Pattern"
description: "Master LIFO operations for parsing, matching, and monotonic problems"
icon: "layer-group"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/11-stack.svg"
  alt="Stack Pattern"
/>

## What is Stack?

**Stack** is a LIFO (Last In, First Out) data structure where elements are added and removed from the same end. It's perfect for tracking "most recent" state.

<Note>
**Quick Recognition**: Problems involving matching pairs, nested structures, "previous/next greater element", or undo operations.
</Note>

## Pattern Recognition Checklist

<CardGroup cols={2}>
  <Card title="Use Stack When" icon="check">
    - Matching parentheses/brackets/tags
    - Evaluating expressions (postfix/infix)
    - Finding next/previous greater/smaller
    - Processing nested structures
    - Implementing undo/back operations
  </Card>
  <Card title="Don't Use When" icon="xmark">
    - Need random access to elements
    - FIFO ordering needed (use Queue)
    - Need to process from both ends
    - Simple array traversal suffices
  </Card>
</CardGroup>

## Stack Type Quick Reference

| Problem Type | Stack Type | Direction |
|--------------|-----------|-----------|
| Next Greater Element | Monotonic Decreasing | Left to Right |
| Previous Greater Element | Monotonic Decreasing | Left to Right |
| Next Smaller Element | Monotonic Increasing | Left to Right |
| Largest Rectangle | Monotonic Increasing | Left to Right |
| Trapping Rain Water | Either | Two-pointer or stack |

## When to Use

<CardGroup cols={2}>
  <Card title="Matching Problems" icon="brackets-curly">
    Parentheses, tags, nested structures
  </Card>
  <Card title="Expression Evaluation" icon="calculator">
    Infix, postfix, prefix expressions
  </Card>
  <Card title="Monotonic Stack" icon="arrow-trend-up">
    Next greater/smaller element
  </Card>
  <Card title="Undo Operations" icon="rotate-left">
    Browser history, text editors
  </Card>
</CardGroup>

## Pattern Variations

### 1. Valid Parentheses

<CodeGroup>
```python Python
def is_valid(s):
    """Check if parentheses are balanced and properly nested"""
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    
    for char in s:
        if char in mapping:  # Closing bracket
            if not stack or stack[-1] != mapping[char]:
                return False
            stack.pop()
        else:  # Opening bracket
            stack.append(char)
    
    return len(stack) == 0
```

```java Java
public boolean isValid(String s) {
    // Check if parentheses are balanced and properly nested
    Stack<Character> stack = new Stack<>();
    Map<Character, Character> mapping = new HashMap<>();
    mapping.put(')', '(');
    mapping.put('}', '{');
    mapping.put(']', '[');
    
    for (char c : s.toCharArray()) {
        if (mapping.containsKey(c)) {  // Closing bracket
            if (stack.isEmpty() || stack.peek() != mapping.get(c)) {
                return false;
            }
            stack.pop();
        } else {  // Opening bracket
            stack.push(c);
        }
    }
    
    return stack.isEmpty();
}
```

```cpp C++
bool isValid(string s) {
    // Check if parentheses are balanced and properly nested
    stack<char> stk;
    unordered_map<char, char> mapping = {
        {')', '('},
        {'}', '{'},
        {']', '['}
    };
    
    for (char c : s) {
        if (mapping.count(c)) {  // Closing bracket
            if (stk.empty() || stk.top() != mapping[c]) {
                return false;
            }
            stk.pop();
        } else {  // Opening bracket
            stk.push(c);
        }
    }
    
    return stk.empty();
}
```
</CodeGroup>

### 2. Decode String

<CodeGroup>
```python Python
def decode_string(s):
    """Decode strings like '3[a2[c]]' -> 'accaccacc'"""
    stack = []
    current_num = 0
    current_str = ""
    
    for char in s:
        if char.isdigit():
            current_num = current_num * 10 + int(char)
        elif char == '[':
            stack.append((current_str, current_num))
            current_str = ""
            current_num = 0
        elif char == ']':
            prev_str, num = stack.pop()
            current_str = prev_str + current_str * num
        else:
            current_str += char
    
    return current_str
```

```java Java
public String decodeString(String s) {
    // Decode strings like '3[a2[c]]' -> 'accaccacc'
    Stack<String> strStack = new Stack<>();
    Stack<Integer> numStack = new Stack<>();
    StringBuilder current = new StringBuilder();
    int num = 0;
    
    for (char c : s.toCharArray()) {
        if (Character.isDigit(c)) {
            num = num * 10 + (c - '0');
        } else if (c == '[') {
            strStack.push(current.toString());
            numStack.push(num);
            current = new StringBuilder();
            num = 0;
        } else if (c == ']') {
            String prev = strStack.pop();
            int repeat = numStack.pop();
            StringBuilder temp = new StringBuilder(prev);
            for (int i = 0; i < repeat; i++) {
                temp.append(current);
            }
            current = temp;
        } else {
            current.append(c);
        }
    }
    
    return current.toString();
}
```

```cpp C++
string decodeString(string s) {
    // Decode strings like '3[a2[c]]' -> 'accaccacc'
    stack<string> strStack;
    stack<int> numStack;
    string current = "";
    int num = 0;
    
    for (char c : s) {
        if (isdigit(c)) {
            num = num * 10 + (c - '0');
        } else if (c == '[') {
            strStack.push(current);
            numStack.push(num);
            current = "";
            num = 0;
        } else if (c == ']') {
            string prev = strStack.top(); strStack.pop();
            int repeat = numStack.top(); numStack.pop();
            string temp = prev;
            for (int i = 0; i < repeat; i++) {
                temp += current;
            }
            current = temp;
        } else {
            current += c;
        }
    }
    
    return current;
}
```
</CodeGroup>

### 3. Basic Calculator

<CodeGroup>
```python Python
def calculate(s):
    """Evaluate expression with +, -, (, )"""
    stack = []
    result = 0
    number = 0
    sign = 1
    
    for char in s:
        if char.isdigit():
            number = number * 10 + int(char)
        elif char == '+':
            result += sign * number
            number = 0
            sign = 1
        elif char == '-':
            result += sign * number
            number = 0
            sign = -1
        elif char == '(':
            stack.append(result)
            stack.append(sign)
            result = 0
            sign = 1
        elif char == ')':
            result += sign * number
            number = 0
            result *= stack.pop()  # sign
            result += stack.pop()  # previous result
    
    return result + sign * number
```

```java Java
public int calculate(String s) {
    // Evaluate expression with +, -, (, )
    Stack<Integer> stack = new Stack<>();
    int result = 0;
    int number = 0;
    int sign = 1;
    
    for (char c : s.toCharArray()) {
        if (Character.isDigit(c)) {
            number = number * 10 + (c - '0');
        } else if (c == '+') {
            result += sign * number;
            number = 0;
            sign = 1;
        } else if (c == '-') {
            result += sign * number;
            number = 0;
            sign = -1;
        } else if (c == '(') {
            stack.push(result);
            stack.push(sign);
            result = 0;
            sign = 1;
        } else if (c == ')') {
            result += sign * number;
            number = 0;
            result *= stack.pop();  // sign
            result += stack.pop();  // previous result
        }
    }
    
    return result + sign * number;
}
```

```cpp C++
int calculate(string s) {
    // Evaluate expression with +, -, (, )
    stack<int> stk;
    int result = 0;
    int number = 0;
    int sign = 1;
    
    for (char c : s) {
        if (isdigit(c)) {
            number = number * 10 + (c - '0');
        } else if (c == '+') {
            result += sign * number;
            number = 0;
            sign = 1;
        } else if (c == '-') {
            result += sign * number;
            number = 0;
            sign = -1;
        } else if (c == '(') {
            stk.push(result);
            stk.push(sign);
            result = 0;
            sign = 1;
        } else if (c == ')') {
            result += sign * number;
            number = 0;
            result *= stk.top(); stk.pop();  // sign
            result += stk.top(); stk.pop();  // previous result
        }
    }
    
    return result + sign * number;
}
```
</CodeGroup>

### 4. Min Stack

<CodeGroup>
```python Python
class MinStack:
    """Stack that supports O(1) getMin()"""
    
    def __init__(self):
        self.stack = []
        self.min_stack = []
    
    def push(self, val):
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)
    
    def pop(self):
        if self.stack[-1] == self.min_stack[-1]:
            self.min_stack.pop()
        return self.stack.pop()
    
    def top(self):
        return self.stack[-1]
    
    def getMin(self):
        return self.min_stack[-1]
```

```java Java
class MinStack {
    // Stack that supports O(1) getMin()
    private Stack<Integer> stack;
    private Stack<Integer> minStack;
    
    public MinStack() {
        stack = new Stack<>();
        minStack = new Stack<>();
    }
    
    public void push(int val) {
        stack.push(val);
        if (minStack.isEmpty() || val <= minStack.peek()) {
            minStack.push(val);
        }
    }
    
    public void pop() {
        if (stack.peek().equals(minStack.peek())) {
            minStack.pop();
        }
        stack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}
```

```cpp C++
class MinStack {
    // Stack that supports O(1) getMin()
private:
    stack<int> stk;
    stack<int> minStk;
    
public:
    MinStack() {}
    
    void push(int val) {
        stk.push(val);
        if (minStk.empty() || val <= minStk.top()) {
            minStk.push(val);
        }
    }
    
    void pop() {
        if (stk.top() == minStk.top()) {
            minStk.pop();
        }
        stk.pop();
    }
    
    int top() {
        return stk.top();
    }
    
    int getMin() {
        return minStk.top();
    }
};
```
</CodeGroup>

### 5. Daily Temperatures (Monotonic Stack)

<CodeGroup>
```python Python
def daily_temperatures(temperatures):
    """Days until warmer temperature for each day"""
    n = len(temperatures)
    result = [0] * n
    stack = []  # indices of temperatures waiting for warmer day
    
    for i in range(n):
        while stack and temperatures[i] > temperatures[stack[-1]]:
            prev_idx = stack.pop()
            result[prev_idx] = i - prev_idx
        stack.append(i)
    
    return result
```

```java Java
public int[] dailyTemperatures(int[] temperatures) {
    // Days until warmer temperature for each day
    int n = temperatures.length;
    int[] result = new int[n];
    Stack<Integer> stack = new Stack<>();
    
    for (int i = 0; i < n; i++) {
        while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
            int prevIdx = stack.pop();
            result[prevIdx] = i - prevIdx;
        }
        stack.push(i);
    }
    
    return result;
}
```

```cpp C++
vector<int> dailyTemperatures(vector<int>& temperatures) {
    // Days until warmer temperature for each day
    int n = temperatures.size();
    vector<int> result(n, 0);
    stack<int> stk;
    
    for (int i = 0; i < n; i++) {
        while (!stk.empty() && temperatures[i] > temperatures[stk.top()]) {
            int prevIdx = stk.top();
            stk.pop();
            result[prevIdx] = i - prevIdx;
        }
        stk.push(i);
    }
    
    return result;
}
```
</CodeGroup>

## Classic Problems

<AccordionGroup>
  <Accordion title="1. Valid Parentheses" icon="brackets-curly">
    **Pattern**: Push opening, pop and match closing
    
    **Key**: Stack should be empty at end for valid input
  </Accordion>
  
  <Accordion title="2. Largest Rectangle in Histogram" icon="chart-bar">
    **Pattern**: Monotonic increasing stack
    
    **Key**: Pop and calculate area when current bar is shorter
  </Accordion>
  
  <Accordion title="3. Evaluate Reverse Polish Notation" icon="calculator">
    **Pattern**: Push numbers, pop two on operator
    
    **Key**: Order matters for subtraction/division
  </Accordion>
  
  <Accordion title="4. Simplify Path" icon="folder-tree">
    **Pattern**: Split by '/', stack for directory navigation
    
    **Key**: '..' pops, '.' and '' are ignored
  </Accordion>
</AccordionGroup>

## Monotonic Stack Deep Dive

<CodeGroup>
```python Python
def next_greater_element(nums):
    """For each element, find next greater element or -1"""
    result = [-1] * len(nums)
    stack = []  # Stack of indices
    
    for i in range(len(nums)):
        # Pop elements smaller than current
        while stack and nums[i] > nums[stack[-1]]:
            idx = stack.pop()
            result[idx] = nums[i]
        stack.append(i)
    
    return result

def largest_rectangle_histogram(heights):
    """Find largest rectangle in histogram"""
    stack = []  # indices
    max_area = 0
    heights.append(0)  # Sentinel
    
    for i, h in enumerate(heights):
        while stack and heights[stack[-1]] > h:
            height = heights[stack.pop()]
            width = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, height * width)
        stack.append(i)
    
    return max_area
```

```java Java
public int[] nextGreaterElement(int[] nums) {
    // For each element, find next greater element or -1
    int[] result = new int[nums.length];
    Arrays.fill(result, -1);
    Stack<Integer> stack = new Stack<>();
    
    for (int i = 0; i < nums.length; i++) {
        while (!stack.isEmpty() && nums[i] > nums[stack.peek()]) {
            int idx = stack.pop();
            result[idx] = nums[i];
        }
        stack.push(i);
    }
    
    return result;
}

public int largestRectangleHistogram(int[] heights) {
    // Find largest rectangle in histogram
    Stack<Integer> stack = new Stack<>();
    int maxArea = 0;
    int n = heights.length;
    
    for (int i = 0; i <= n; i++) {
        int h = (i == n) ? 0 : heights[i];
        while (!stack.isEmpty() && heights[stack.peek()] > h) {
            int height = heights[stack.pop()];
            int width = stack.isEmpty() ? i : i - stack.peek() - 1;
            maxArea = Math.max(maxArea, height * width);
        }
        stack.push(i);
    }
    
    return maxArea;
}
```

```cpp C++
vector<int> nextGreaterElement(vector<int>& nums) {
    // For each element, find next greater element or -1
    vector<int> result(nums.size(), -1);
    stack<int> stk;
    
    for (int i = 0; i < nums.size(); i++) {
        while (!stk.empty() && nums[i] > nums[stk.top()]) {
            int idx = stk.top();
            stk.pop();
            result[idx] = nums[i];
        }
        stk.push(i);
    }
    
    return result;
}

int largestRectangleHistogram(vector<int>& heights) {
    // Find largest rectangle in histogram
    stack<int> stk;
    int maxArea = 0;
    heights.push_back(0);  // Sentinel
    
    for (int i = 0; i < heights.size(); i++) {
        while (!stk.empty() && heights[stk.top()] > heights[i]) {
            int height = heights[stk.top()];
            stk.pop();
            int width = stk.empty() ? i : i - stk.top() - 1;
            maxArea = max(maxArea, height * width);
        }
        stk.push(i);
    }
    
    return maxArea;
}
```
</CodeGroup>

## Common Mistakes

<Warning>
**Avoid These Pitfalls:**
1. **Empty stack access**: Always check if stack is empty before peek/pop
2. **Forgetting to process remaining**: Stack may still have elements after loop
3. **Wrong monotonic direction**: Know when to use increasing vs decreasing stack
4. **Not storing indices**: Often need index for distance calculations
</Warning>

## Debugging Checklist

<Steps>
  <Step title="Check Empty Stack">
    Always verify `!stack.empty()` before `peek()` or `pop()`
  </Step>
  <Step title="Verify Matching Logic">
    For parentheses: opening pushes, closing pops and compares
  </Step>
  <Step title="Check Remaining Elements">
    After loop, stack may still have unprocessed elements
  </Step>
  <Step title="Validate Monotonic Direction">
    Increasing: pop smaller, Decreasing: pop larger
  </Step>
  <Step title="Track Indices vs Values">
    For distance calculations, store indices not values
  </Step>
</Steps>

## Interview Problems by Company

<Tabs>
  <Tab title="Easy">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Valid Parentheses | All FAANG | Push open, pop close |
    | Baseball Game | Amazon | Stack operations |
    | Remove Outer Parens | Google | Counter or stack |
    | Backspace String | Google | Stack simulation |
  </Tab>
  <Tab title="Medium">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Min Stack | Amazon, Bloomberg | Two stacks |
    | Daily Temperatures | Meta, Amazon | Monotonic stack |
    | Decode String | Google, Meta | Nested processing |
    | Asteroid Collision | Amazon | Simulation |
    | Evaluate RPN | Amazon | Operand stack |
  </Tab>
  <Tab title="Hard">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Largest Rectangle | All FAANG | Monotonic increasing |
    | Basic Calculator | Meta, Google | Two stacks |
    | Maximal Rectangle | Google | DP + monotonic |
    | Trapping Rain Water | All FAANG | Stack or two-pointer |
  </Tab>
</Tabs>

## Interview Tips

<AccordionGroup>
  <Accordion title="How to Explain Your Approach" icon="comments">
    **Script for interviews:**
    
    1. "This is a matching problem, so I'll use a stack."
    2. "Opening brackets push, closing brackets pop and compare."
    3. "If match fails or stack has leftovers, it's invalid."
    4. "For monotonic: I maintain a stack where elements are always sorted."
  </Accordion>
  
  <Accordion title="When Interviewer Says..." icon="user-tie">
    | Interviewer Says | You Should Think |
    |-----------------|------------------|
    | "Valid parentheses/brackets" | Basic stack push/pop |
    | "Next greater element" | Monotonic decreasing stack |
    | "Largest rectangle" | Monotonic increasing stack |
    | "Evaluate expression" | Two stacks (operand + operator) |
    | "Simplify path" | Stack for directory navigation |
  </Accordion>
  
  <Accordion title="Monotonic Stack Template" icon="code">
    ```python
    def next_greater(arr):
        result = [-1] * len(arr)
        stack = []  # stores indices
        
        for i in range(len(arr)):
            # Pop while current is greater than stack top
            while stack and arr[i] > arr[stack[-1]]:
                idx = stack.pop()
                result[idx] = arr[i]
            stack.append(i)
        
        return result
    ```
  </Accordion>
</AccordionGroup>

## Practice Problems

| Problem | Difficulty | Link |
|---------|------------|------|
| Valid Parentheses | Easy | [LeetCode 20](https://leetcode.com/problems/valid-parentheses/) |
| Min Stack | Medium | [LeetCode 155](https://leetcode.com/problems/min-stack/) |
| Daily Temperatures | Medium | [LeetCode 739](https://leetcode.com/problems/daily-temperatures/) |
| Largest Rectangle in Histogram | Hard | [LeetCode 84](https://leetcode.com/problems/largest-rectangle-in-histogram/) |
| Basic Calculator | Hard | [LeetCode 224](https://leetcode.com/problems/basic-calculator/) |

## Practice Roadmap

<Steps>
  <Step title="Day 1: Basic Stack">
    - Solve: Valid Parentheses, Min Stack
    - Focus: Push, pop, peek operations
  </Step>
  <Step title="Day 2: Expression Evaluation">
    - Solve: Evaluate RPN, Decode String
    - Focus: Operand vs operator stacks
  </Step>
  <Step title="Day 3: Monotonic Stack">
    - Solve: Next Greater Element, Daily Temperatures
    - Focus: When to pop from stack
  </Step>
  <Step title="Day 4: Hard Problems">
    - Solve: Largest Rectangle, Basic Calculator
    - Focus: Complex monotonic patterns
  </Step>
</Steps>

<Tip>
**Interview Tip**: When you need to track "previous" or "next" elements with certain properties, think Monotonic Stack.
</Tip>
