---
title: "Monotonic Stack Pattern"
description: "Find next/previous greater/smaller elements efficiently"
icon: "bars-staggered"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/17-monotonic-stack.svg"
  alt="Monotonic Stack Pattern"
/>

## What is Monotonic Stack?

**Monotonic Stack** maintains elements in sorted order (either increasing or decreasing). It efficiently solves "next greater/smaller" problems in O(n).

## When to Use

<CardGroup cols={2}>
  <Card title="Next Greater Element" icon="arrow-right">
    Find next larger element for each position
  </Card>
  <Card title="Previous Smaller" icon="arrow-left">
    Find previous smaller element
  </Card>
  <Card title="Histogram Problems" icon="chart-bar">
    Largest rectangle, trapping water
  </Card>
  <Card title="Stock Span" icon="chart-line">
    Days since last higher price
  </Card>
</CardGroup>

## Pattern Variations

### 1. Next Greater Element

<CodeGroup>
```python Python
def next_greater_element(nums):
    """For each element, find next greater or -1"""
    n = len(nums)
    result = [-1] * n
    stack = []  # Stores indices
    
    for i in range(n):
        while stack and nums[i] > nums[stack[-1]]:
            idx = stack.pop()
            result[idx] = nums[i]
        stack.append(i)
    
    return result

# Example: [2,1,2,4,3] returns [4,2,4,-1,-1]
```

```java Java
public class NextGreater {
    public int[] nextGreaterElement(int[] nums) {
        // For each element, find next greater or -1
        int n = nums.length;
        int[] result = new int[n];
        Arrays.fill(result, -1);
        Deque<Integer> stack = new ArrayDeque<>(); // Stores indices
        
        for (int i = 0; i < n; i++) {
            while (!stack.isEmpty() && nums[i] > nums[stack.peek()]) {
                int idx = stack.pop();
                result[idx] = nums[i];
            }
            stack.push(i);
        }
        
        return result;
    }
}
// Example: [2,1,2,4,3] returns [4,2,4,-1,-1]
```

```cpp C++
class NextGreater {
public:
    vector<int> nextGreaterElement(vector<int>& nums) {
        // For each element, find next greater or -1
        int n = nums.size();
        vector<int> result(n, -1);
        stack<int> stk; // Stores indices
        
        for (int i = 0; i < n; i++) {
            while (!stk.empty() && nums[i] > nums[stk.top()]) {
                int idx = stk.top();
                stk.pop();
                result[idx] = nums[i];
            }
            stk.push(i);
        }
        
        return result;
    }
};
// Example: [2,1,2,4,3] returns [4,2,4,-1,-1]
```
</CodeGroup>

### 2. Previous Smaller Element

<CodeGroup>
```python Python
def previous_smaller(nums):
    """For each element, find previous smaller or -1"""
    n = len(nums)
    result = [-1] * n
    stack = []
    
    for i in range(n):
        while stack and nums[stack[-1]] >= nums[i]:
            stack.pop()
        
        if stack:
            result[i] = nums[stack[-1]]
        
        stack.append(i)
    
    return result
```

```java Java
public int[] previousSmaller(int[] nums) {
    // For each element, find previous smaller or -1
    int n = nums.length;
    int[] result = new int[n];
    Arrays.fill(result, -1);
    Deque<Integer> stack = new ArrayDeque<>();
    
    for (int i = 0; i < n; i++) {
        while (!stack.isEmpty() && nums[stack.peek()] >= nums[i]) {
            stack.pop();
        }
        
        if (!stack.isEmpty()) {
            result[i] = nums[stack.peek()];
        }
        
        stack.push(i);
    }
    
    return result;
}
```

```cpp C++
vector<int> previousSmaller(vector<int>& nums) {
    // For each element, find previous smaller or -1
    int n = nums.size();
    vector<int> result(n, -1);
    stack<int> stk;
    
    for (int i = 0; i < n; i++) {
        while (!stk.empty() && nums[stk.top()] >= nums[i]) {
            stk.pop();
        }
        
        if (!stk.empty()) {
            result[i] = nums[stk.top()];
        }
        
        stk.push(i);
    }
    
    return result;
}
```
</CodeGroup>

### 3. Largest Rectangle in Histogram

<CodeGroup>
```python Python
def largest_rectangle_area(heights):
    """Find largest rectangle in histogram"""
    stack = []  # (index, height)
    max_area = 0
    
    for i, h in enumerate(heights):
        start = i
        while stack and stack[-1][1] > h:
            idx, height = stack.pop()
            max_area = max(max_area, height * (i - idx))
            start = idx
        stack.append((start, h))
    
    # Process remaining
    for idx, height in stack:
        max_area = max(max_area, height * (len(heights) - idx))
    
    return max_area
```

```java Java
public int largestRectangleArea(int[] heights) {
    // Find largest rectangle in histogram
    Deque<int[]> stack = new ArrayDeque<>(); // [index, height]
    int maxArea = 0;
    
    for (int i = 0; i < heights.length; i++) {
        int start = i;
        while (!stack.isEmpty() && stack.peek()[1] > heights[i]) {
            int[] top = stack.pop();
            int idx = top[0], height = top[1];
            maxArea = Math.max(maxArea, height * (i - idx));
            start = idx;
        }
        stack.push(new int[]{start, heights[i]});
    }
    
    // Process remaining
    while (!stack.isEmpty()) {
        int[] top = stack.pop();
        maxArea = Math.max(maxArea, top[1] * (heights.length - top[0]));
    }
    
    return maxArea;
}
```

```cpp C++
int largestRectangleArea(vector<int>& heights) {
    // Find largest rectangle in histogram
    stack<pair<int, int>> stk; // {index, height}
    int maxArea = 0;
    
    for (int i = 0; i < heights.size(); i++) {
        int start = i;
        while (!stk.empty() && stk.top().second > heights[i]) {
            auto [idx, height] = stk.top();
            stk.pop();
            maxArea = max(maxArea, height * (i - idx));
            start = idx;
        }
        stk.push({start, heights[i]});
    }
    
    // Process remaining
    while (!stk.empty()) {
        auto [idx, height] = stk.top();
        stk.pop();
        maxArea = max(maxArea, height * (int)(heights.size() - idx));
    }
    
    return maxArea;
}
```
</CodeGroup>

### 4. Daily Temperatures

<CodeGroup>
```python Python
def daily_temperatures(temperatures):
    """Days until warmer temperature"""
    n = len(temperatures)
    result = [0] * n
    stack = []  # Stores indices
    
    for i in range(n):
        while stack and temperatures[i] > temperatures[stack[-1]]:
            idx = stack.pop()
            result[idx] = i - idx
        stack.append(i)
    
    return result
```

```java Java
public int[] dailyTemperatures(int[] temperatures) {
    // Days until warmer temperature
    int n = temperatures.length;
    int[] result = new int[n];
    Deque<Integer> stack = new ArrayDeque<>(); // Stores indices
    
    for (int i = 0; i < n; i++) {
        while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
            int idx = stack.pop();
            result[idx] = i - idx;
        }
        stack.push(i);
    }
    
    return result;
}
```

```cpp C++
vector<int> dailyTemperatures(vector<int>& temperatures) {
    // Days until warmer temperature
    int n = temperatures.size();
    vector<int> result(n, 0);
    stack<int> stk; // Stores indices
    
    for (int i = 0; i < n; i++) {
        while (!stk.empty() && temperatures[i] > temperatures[stk.top()]) {
            int idx = stk.top();
            stk.pop();
            result[idx] = i - idx;
        }
        stk.push(i);
    }
    
    return result;
}
```
</CodeGroup>

### 5. Trapping Rain Water

<CodeGroup>
```python Python
def trap(height):
    """Calculate trapped water using monotonic stack"""
    stack = []  # Stores indices
    water = 0
    
    for i, h in enumerate(height):
        while stack and h > height[stack[-1]]:
            bottom = stack.pop()
            if not stack:
                break
            
            width = i - stack[-1] - 1
            bounded_height = min(h, height[stack[-1]]) - height[bottom]
            water += width * bounded_height
        
        stack.append(i)
    
    return water
```

```java Java
public int trap(int[] height) {
    // Calculate trapped water using monotonic stack
    Deque<Integer> stack = new ArrayDeque<>(); // Stores indices
    int water = 0;
    
    for (int i = 0; i < height.length; i++) {
        while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
            int bottom = stack.pop();
            if (stack.isEmpty()) break;
            
            int width = i - stack.peek() - 1;
            int boundedHeight = Math.min(height[i], height[stack.peek()]) 
                               - height[bottom];
            water += width * boundedHeight;
        }
        stack.push(i);
    }
    
    return water;
}
```

```cpp C++
int trap(vector<int>& height) {
    // Calculate trapped water using monotonic stack
    stack<int> stk; // Stores indices
    int water = 0;
    
    for (int i = 0; i < height.size(); i++) {
        while (!stk.empty() && height[i] > height[stk.top()]) {
            int bottom = stk.top();
            stk.pop();
            if (stk.empty()) break;
            
            int width = i - stk.top() - 1;
            int boundedHeight = min(height[i], height[stk.top()]) 
                               - height[bottom];
            water += width * boundedHeight;
        }
        stk.push(i);
    }
    
    return water;
}
```
</CodeGroup>

## Classic Problems

| Problem | Stack Type | Key Insight |
|---------|------------|-------------|
| Next Greater | Decreasing | Pop smaller, push current |
| Previous Smaller | Increasing | Pop larger or equal |
| Histogram | Decreasing | Calculate area on pop |
| Daily Temperatures | Decreasing | Store indices, compute diff |
| Stock Span | Decreasing | Count days with smaller price |

## Practice Problems

<CardGroup cols={2}>
  <Card title="Next Greater Element I" icon="arrow-right" href="https://leetcode.com/problems/next-greater-element-i/">
    Basic monotonic stack
  </Card>
  <Card title="Largest Rectangle" icon="square" href="https://leetcode.com/problems/largest-rectangle-in-histogram/">
    Classic histogram problem
  </Card>
  <Card title="Trapping Rain Water" icon="droplet" href="https://leetcode.com/problems/trapping-rain-water/">
    Multi-approach problem
  </Card>
  <Card title="Sum of Subarray Mins" icon="calculator" href="https://leetcode.com/problems/sum-of-subarray-minimums/">
    Contribution technique
  </Card>
</CardGroup>
