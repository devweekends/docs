---
title: "Two Pointers Pattern"
description: "Master the two pointers technique for array and string problems"
icon: "arrows-left-right"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/01-two-pointers.svg"
  alt="Two Pointers Pattern"
/>

## What is Two Pointers?

The **Two Pointers** pattern uses two pointers to traverse an array or string, typically moving towards each other or in the same direction. It transforms O(n²) brute force solutions into O(n) optimal ones.

<Note>
**Quick Recognition**: If you see a **sorted array** + need to find **pairs/triplets** + want **O(1) space**, Two Pointers is likely the answer!
</Note>

## Pattern Recognition Checklist

Before using Two Pointers, ask yourself:

<CardGroup cols={2}>
  <Card title="Use Two Pointers When" icon="check">
    - Array is **sorted** (or can be sorted)
    - Need to find **pairs** with a property
    - **In-place** modification required
    - Need to **compare elements** from ends
    - Want to avoid **O(n²)** nested loops
  </Card>
  <Card title="Don't Use When" icon="xmark">
    - Need to preserve **original order**
    - Array is **unsorted** and sorting changes answer
    - Need to find **subarrays** (use Sliding Window)
    - Need **lookup by value** (use HashMap)
  </Card>
</CardGroup>

## When to Use

<CardGroup cols={2}>
  <Card title="Sorted Arrays" icon="arrow-up-1-9">
    Finding pairs, triplets, or elements with specific sum
  </Card>
  <Card title="Palindrome Problems" icon="rotate-left">
    Checking or creating palindromes
  </Card>
  <Card title="Merging Arrays" icon="code-merge">
    Merging sorted arrays or linked lists
  </Card>
  <Card title="Removing Duplicates" icon="filter">
    In-place array modifications
  </Card>
</CardGroup>

## Pattern Variations

### 1. Opposite Direction (Converging)

Pointers start at both ends and move towards the center.

<CodeGroup>
```python Python
def two_sum_sorted(arr, target):
    """Find two numbers in sorted array that sum to target"""
    left, right = 0, len(arr) - 1
    
    while left < right:
        current_sum = arr[left] + arr[right]
        
        if current_sum == target:
            return [left, right]
        elif current_sum < target:
            left += 1  # Need larger sum
        else:
            right -= 1  # Need smaller sum
    
    return [-1, -1]  # Not found
```

```java Java
public int[] twoSumSorted(int[] arr, int target) {
    // Find two numbers in sorted array that sum to target
    int left = 0, right = arr.length - 1;
    
    while (left < right) {
        int currentSum = arr[left] + arr[right];
        
        if (currentSum == target) {
            return new int[]{left, right};
        } else if (currentSum < target) {
            left++;  // Need larger sum
        } else {
            right--;  // Need smaller sum
        }
    }
    
    return new int[]{-1, -1};  // Not found
}
```

```cpp C++
vector<int> twoSumSorted(vector<int>& arr, int target) {
    // Find two numbers in sorted array that sum to target
    int left = 0, right = arr.size() - 1;
    
    while (left < right) {
        int currentSum = arr[left] + arr[right];
        
        if (currentSum == target) {
            return {left, right};
        } else if (currentSum < target) {
            left++;  // Need larger sum
        } else {
            right--;  // Need smaller sum
        }
    }
    
    return {-1, -1};  // Not found
}
```
</CodeGroup>

### 2. Same Direction (Fast & Slow)

Both pointers move in the same direction at different speeds.

<CodeGroup>
```python Python
def remove_duplicates(arr):
    """Remove duplicates from sorted array in-place"""
    if not arr:
        return 0
    
    slow = 0  # Points to last unique element
    
    for fast in range(1, len(arr)):
        if arr[fast] != arr[slow]:
            slow += 1
            arr[slow] = arr[fast]
    
    return slow + 1  # Length of unique elements
```

```java Java
public int removeDuplicates(int[] arr) {
    // Remove duplicates from sorted array in-place
    if (arr.length == 0) return 0;
    
    int slow = 0;  // Points to last unique element
    
    for (int fast = 1; fast < arr.length; fast++) {
        if (arr[fast] != arr[slow]) {
            slow++;
            arr[slow] = arr[fast];
        }
    }
    
    return slow + 1;  // Length of unique elements
}
```

```cpp C++
int removeDuplicates(vector<int>& arr) {
    // Remove duplicates from sorted array in-place
    if (arr.empty()) return 0;
    
    int slow = 0;  // Points to last unique element
    
    for (int fast = 1; fast < arr.size(); fast++) {
        if (arr[fast] != arr[slow]) {
            slow++;
            arr[slow] = arr[fast];
        }
    }
    
    return slow + 1;  // Length of unique elements
}
```
</CodeGroup>

### 3. Container With Most Water

<CodeGroup>
```python Python
def max_area(height):
    """Find two lines that form container with most water"""
    left, right = 0, len(height) - 1
    max_water = 0
    
    while left < right:
        width = right - left
        h = min(height[left], height[right])
        max_water = max(max_water, width * h)
        
        # Move the shorter line inward
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    
    return max_water
```

```java Java
public int maxArea(int[] height) {
    // Find two lines that form container with most water
    int left = 0, right = height.length - 1;
    int maxWater = 0;
    
    while (left < right) {
        int width = right - left;
        int h = Math.min(height[left], height[right]);
        maxWater = Math.max(maxWater, width * h);
        
        // Move the shorter line inward
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }
    
    return maxWater;
}
```

```cpp C++
int maxArea(vector<int>& height) {
    // Find two lines that form container with most water
    int left = 0, right = height.size() - 1;
    int maxWater = 0;
    
    while (left < right) {
        int width = right - left;
        int h = min(height[left], height[right]);
        maxWater = max(maxWater, width * h);
        
        // Move the shorter line inward
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }
    
    return maxWater;
}
```
</CodeGroup>

### 4. Valid Palindrome

<CodeGroup>
```python Python
def is_palindrome(s):
    """Check if string is palindrome (alphanumeric only)"""
    left, right = 0, len(s) - 1
    
    while left < right:
        # Skip non-alphanumeric characters
        while left < right and not s[left].isalnum():
            left += 1
        while left < right and not s[right].isalnum():
            right -= 1
        
        if s[left].lower() != s[right].lower():
            return False
        
        left += 1
        right -= 1
    
    return True
```

```java Java
public boolean isPalindrome(String s) {
    // Check if string is palindrome (alphanumeric only)
    int left = 0, right = s.length() - 1;
    
    while (left < right) {
        // Skip non-alphanumeric characters
        while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {
            left++;
        }
        while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {
            right--;
        }
        
        if (Character.toLowerCase(s.charAt(left)) != 
            Character.toLowerCase(s.charAt(right))) {
            return false;
        }
        
        left++;
        right--;
    }
    
    return true;
}
```

```cpp C++
bool isPalindrome(string s) {
    // Check if string is palindrome (alphanumeric only)
    int left = 0, right = s.length() - 1;
    
    while (left < right) {
        // Skip non-alphanumeric characters
        while (left < right && !isalnum(s[left])) {
            left++;
        }
        while (left < right && !isalnum(s[right])) {
            right--;
        }
        
        if (tolower(s[left]) != tolower(s[right])) {
            return false;
        }
        
        left++;
        right--;
    }
    
    return true;
}
```
</CodeGroup>

### 5. 3Sum

<CodeGroup>
```python Python
def three_sum(nums):
    """Find all unique triplets that sum to zero"""
    nums.sort()
    result = []
    
    for i in range(len(nums) - 2):
        # Skip duplicates for first element
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        
        left, right = i + 1, len(nums) - 1
        
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            
            if total == 0:
                result.append([nums[i], nums[left], nums[right]])
                # Skip duplicates
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif total < 0:
                left += 1
            else:
                right -= 1
    
    return result
```

```java Java
public List<List<Integer>> threeSum(int[] nums) {
    // Find all unique triplets that sum to zero
    Arrays.sort(nums);
    List<List<Integer>> result = new ArrayList<>();
    
    for (int i = 0; i < nums.length - 2; i++) {
        // Skip duplicates for first element
        if (i > 0 && nums[i] == nums[i - 1]) continue;
        
        int left = i + 1, right = nums.length - 1;
        
        while (left < right) {
            int total = nums[i] + nums[left] + nums[right];
            
            if (total == 0) {
                result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                // Skip duplicates
                while (left < right && nums[left] == nums[left + 1]) left++;
                while (left < right && nums[right] == nums[right - 1]) right--;
                left++;
                right--;
            } else if (total < 0) {
                left++;
            } else {
                right--;
            }
        }
    }
    
    return result;
}
```

```cpp C++
vector<vector<int>> threeSum(vector<int>& nums) {
    // Find all unique triplets that sum to zero
    sort(nums.begin(), nums.end());
    vector<vector<int>> result;
    
    for (int i = 0; i < (int)nums.size() - 2; i++) {
        // Skip duplicates for first element
        if (i > 0 && nums[i] == nums[i - 1]) continue;
        
        int left = i + 1, right = nums.size() - 1;
        
        while (left < right) {
            int total = nums[i] + nums[left] + nums[right];
            
            if (total == 0) {
                result.push_back({nums[i], nums[left], nums[right]});
                // Skip duplicates
                while (left < right && nums[left] == nums[left + 1]) left++;
                while (left < right && nums[right] == nums[right - 1]) right--;
                left++;
                right--;
            } else if (total < 0) {
                left++;
            } else {
                right--;
            }
        }
    }
    
    return result;
}
```
</CodeGroup>

### 6. Trapping Rain Water

<CodeGroup>
```python Python
def trap(height):
    """Calculate trapped water between elevation bars"""
    if not height:
        return 0
    
    left, right = 0, len(height) - 1
    left_max, right_max = height[left], height[right]
    water = 0
    
    while left < right:
        if left_max < right_max:
            left += 1
            left_max = max(left_max, height[left])
            water += left_max - height[left]
        else:
            right -= 1
            right_max = max(right_max, height[right])
            water += right_max - height[right]
    
    return water
```

```java Java
public int trap(int[] height) {
    // Calculate trapped water between elevation bars
    if (height.length == 0) return 0;
    
    int left = 0, right = height.length - 1;
    int leftMax = height[left], rightMax = height[right];
    int water = 0;
    
    while (left < right) {
        if (leftMax < rightMax) {
            left++;
            leftMax = Math.max(leftMax, height[left]);
            water += leftMax - height[left];
        } else {
            right--;
            rightMax = Math.max(rightMax, height[right]);
            water += rightMax - height[right];
        }
    }
    
    return water;
}
```

```cpp C++
int trap(vector<int>& height) {
    // Calculate trapped water between elevation bars
    if (height.empty()) return 0;
    
    int left = 0, right = height.size() - 1;
    int leftMax = height[left], rightMax = height[right];
    int water = 0;
    
    while (left < right) {
        if (leftMax < rightMax) {
            left++;
            leftMax = max(leftMax, height[left]);
            water += leftMax - height[left];
        } else {
            right--;
            rightMax = max(rightMax, height[right]);
            water += rightMax - height[right];
        }
    }
    
    return water;
}
```
</CodeGroup>

### 7. Move Zeroes

<CodeGroup>
```python Python
def move_zeroes(nums):
    """Move all zeroes to end while maintaining order"""
    slow = 0  # Position for next non-zero element
    
    for fast in range(len(nums)):
        if nums[fast] != 0:
            nums[slow], nums[fast] = nums[fast], nums[slow]
            slow += 1
```

```java Java
public void moveZeroes(int[] nums) {
    // Move all zeroes to end while maintaining order
    int slow = 0;  // Position for next non-zero element
    
    for (int fast = 0; fast < nums.length; fast++) {
        if (nums[fast] != 0) {
            int temp = nums[slow];
            nums[slow] = nums[fast];
            nums[fast] = temp;
            slow++;
        }
    }
}
```

```cpp C++
void moveZeroes(vector<int>& nums) {
    // Move all zeroes to end while maintaining order
    int slow = 0;  // Position for next non-zero element
    
    for (int fast = 0; fast < nums.size(); fast++) {
        if (nums[fast] != 0) {
            swap(nums[slow], nums[fast]);
            slow++;
        }
    }
}
```
</CodeGroup>

### 8. Sort Colors (Dutch National Flag)

<CodeGroup>
```python Python
def sort_colors(nums):
    """Sort array of 0s, 1s, and 2s in-place"""
    low, mid, high = 0, 0, len(nums) - 1
    
    while mid <= high:
        if nums[mid] == 0:
            nums[low], nums[mid] = nums[mid], nums[low]
            low += 1
            mid += 1
        elif nums[mid] == 1:
            mid += 1
        else:  # nums[mid] == 2
            nums[mid], nums[high] = nums[high], nums[mid]
            high -= 1
```

```java Java
public void sortColors(int[] nums) {
    // Sort array of 0s, 1s, and 2s in-place
    int low = 0, mid = 0, high = nums.length - 1;
    
    while (mid <= high) {
        if (nums[mid] == 0) {
            int temp = nums[low];
            nums[low] = nums[mid];
            nums[mid] = temp;
            low++;
            mid++;
        } else if (nums[mid] == 1) {
            mid++;
        } else {  // nums[mid] == 2
            int temp = nums[mid];
            nums[mid] = nums[high];
            nums[high] = temp;
            high--;
        }
    }
}
```

```cpp C++
void sortColors(vector<int>& nums) {
    // Sort array of 0s, 1s, and 2s in-place
    int low = 0, mid = 0, high = nums.size() - 1;
    
    while (mid <= high) {
        if (nums[mid] == 0) {
            swap(nums[low], nums[mid]);
            low++;
            mid++;
        } else if (nums[mid] == 1) {
            mid++;
        } else {  // nums[mid] == 2
            swap(nums[mid], nums[high]);
            high--;
        }
    }
}
```
</CodeGroup>

## Classic Problems

<AccordionGroup>
  <Accordion title="1. Two Sum II (Sorted Array)" icon="plus">
    **Problem**: Find two numbers in a sorted array that add up to target.
    
    **Approach**: Use converging pointers. If sum is too small, move left pointer right. If too large, move right pointer left.
    
    **Time**: O(n) | **Space**: O(1)
  </Accordion>
  
  <Accordion title="2. Container With Most Water" icon="droplet">
    **Problem**: Find two lines that form a container holding the most water.
    
    **Approach**: Start from both ends. Move the pointer with the shorter line inward (greedy choice).
    
    **Time**: O(n) | **Space**: O(1)
  </Accordion>
  
  <Accordion title="3. Valid Palindrome" icon="rotate-left">
    **Problem**: Check if a string is a palindrome (ignoring non-alphanumeric).
    
    **Approach**: Compare characters from both ends, skip non-alphanumeric.
    
    **Time**: O(n) | **Space**: O(1)
  </Accordion>
  
  <Accordion title="4. 3Sum" icon="hashtag">
    **Problem**: Find all unique triplets that sum to zero.
    
    **Approach**: Sort array, fix one element, use two pointers for remaining two.
    
    **Time**: O(n^2) | **Space**: O(1) excluding output
  </Accordion>
  
  <Accordion title="5. Trapping Rain Water" icon="water">
    **Problem**: Calculate trapped water between elevation bars.
    
    **Approach**: Two pointers with max height tracking from both sides.
    
    **Time**: O(n) | **Space**: O(1)
  </Accordion>
</AccordionGroup>

## Template Code

<CodeGroup>
```python Python
# Template 1: Converging Pointers
def converging_template(arr):
    left, right = 0, len(arr) - 1
    result = None
    
    while left < right:
        # Process current pair
        # Update result if needed
        
        if condition_move_left:
            left += 1
        else:
            right -= 1
    
    return result

# Template 2: Fast-Slow Pointers
def fast_slow_template(arr):
    slow = 0
    
    for fast in range(len(arr)):
        if some_condition(arr[fast]):
            arr[slow] = arr[fast]
            slow += 1
    
    return slow
```

```java Java
// Template 1: Converging Pointers
public Object convergingTemplate(int[] arr) {
    int left = 0, right = arr.length - 1;
    Object result = null;
    
    while (left < right) {
        // Process current pair
        // Update result if needed
        
        if (conditionMoveLeft) {
            left++;
        } else {
            right--;
        }
    }
    
    return result;
}

// Template 2: Fast-Slow Pointers
public int fastSlowTemplate(int[] arr) {
    int slow = 0;
    
    for (int fast = 0; fast < arr.length; fast++) {
        if (someCondition(arr[fast])) {
            arr[slow] = arr[fast];
            slow++;
        }
    }
    
    return slow;
}
```

```cpp C++
// Template 1: Converging Pointers
auto convergingTemplate(vector<int>& arr) {
    int left = 0, right = arr.size() - 1;
    
    while (left < right) {
        // Process current pair
        // Update result if needed
        
        if (conditionMoveLeft) {
            left++;
        } else {
            right--;
        }
    }
    
    return result;
}

// Template 2: Fast-Slow Pointers
int fastSlowTemplate(vector<int>& arr) {
    int slow = 0;
    
    for (int fast = 0; fast < arr.size(); fast++) {
        if (someCondition(arr[fast])) {
            arr[slow] = arr[fast];
            slow++;
        }
    }
    
    return slow;
}
```
</CodeGroup>

## Common Mistakes

<Warning>
**Avoid These Pitfalls:**
1. **Off-by-one errors**: Be careful with `left < right` vs `left <= right`
2. **Infinite loops**: Ensure pointers always move towards termination
3. **Missing edge cases**: Empty arrays, single elements, all duplicates
4. **Modifying while iterating**: Be careful when removing elements in-place
</Warning>

## Debugging Checklist

When your Two Pointers solution fails, check:

<Steps>
  <Step title="Initialization">
    Are `left` and `right` starting at correct positions?
  </Step>
  <Step title="Loop Condition">
    Should it be `left < right` or `left <= right`?
  </Step>
  <Step title="Pointer Movement">
    Is at least one pointer moving in each iteration?
  </Step>
  <Step title="Edge Cases">
    Did you handle empty array, single element, all same elements?
  </Step>
  <Step title="Duplicates">
    Are you skipping duplicates correctly (for unique results)?
  </Step>
</Steps>

## Complexity Quick Reference

| Problem Type | Time | Space | Key Insight |
|-------------|------|-------|-------------|
| Two Sum (sorted) | O(n) | O(1) | Move based on sum comparison |
| 3Sum | O(n²) | O(1) | Fix one, two-pointer on rest |
| Remove Duplicates | O(n) | O(1) | Slow = write position |
| Container Water | O(n) | O(1) | Move shorter side inward |
| Trap Rain Water | O(n) | O(1) | Track max from both sides |
| Valid Palindrome | O(n) | O(1) | Skip non-alphanumeric |

## Interview Problems by Company

<Tabs>
  <Tab title="Easy">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Two Sum II | Amazon, Google | Basic converging |
    | Valid Palindrome | Meta, Microsoft | Character comparison |
    | Move Zeroes | Meta, Amazon | Fast-slow technique |
    | Remove Duplicates | All FAANG | In-place modification |
    | Squares of Sorted Array | Amazon | Converging with squares |
  </Tab>
  <Tab title="Medium">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | 3Sum | All FAANG | Fix + two pointers |
    | Container With Water | Amazon, Google | Greedy + converging |
    | Sort Colors | Microsoft, Meta | Dutch flag (3 pointers) |
    | 3Sum Closest | Google, Meta | Tracking closest sum |
    | Partition Labels | Amazon | Multiple passes |
  </Tab>
  <Tab title="Hard">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Trapping Rain Water | Google, Amazon | Track max from both sides |
    | 4Sum | Google | Nested two pointers |
    | Minimum Window Sort | Meta | Find unsorted subarray |
  </Tab>
</Tabs>

## Interview Tips

<AccordionGroup>
  <Accordion title="How to Explain Your Approach" icon="comments">
    **Script for interviews:**
    
    1. "I notice the array is sorted, which suggests Two Pointers might work here."
    2. "I'll use two pointers starting at opposite ends."
    3. "If the sum is too small, I move left pointer right to increase it."
    4. "If too large, I move right pointer left to decrease it."
    5. "This gives us O(n) time and O(1) space."
  </Accordion>
  
  <Accordion title="When Interviewer Says..." icon="user-tie">
    | Interviewer Says | You Should Think |
    |-----------------|------------------|
    | "Can you do better than O(n²)?" | Two Pointers or HashMap |
    | "Can you do it in O(1) space?" | Two Pointers (not HashMap) |
    | "The array is sorted" | Definitely Two Pointers! |
    | "Find a pair/triplet" | Two Pointers likely |
    | "Modify array in-place" | Fast-slow pointers |
  </Accordion>
  
  <Accordion title="Common Follow-ups" icon="puzzle-piece">
    Be ready for these follow-ups:
    
    - "What if there are duplicates?" → Skip duplicates in loop
    - "What if no solution exists?" → Return appropriate default
    - "Can you handle negative numbers?" → Usually yes, same logic
    - "What if array is not sorted?" → Sort first, or use HashMap
  </Accordion>
</AccordionGroup>

## Practice Problems

| Problem | Difficulty | Link |
|---------|------------|------|
| Two Sum II | Easy | [LeetCode 167](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) |
| Valid Palindrome | Easy | [LeetCode 125](https://leetcode.com/problems/valid-palindrome/) |
| 3Sum | Medium | [LeetCode 15](https://leetcode.com/problems/3sum/) |
| Container With Most Water | Medium | [LeetCode 11](https://leetcode.com/problems/container-with-most-water/) |
| Trapping Rain Water | Hard | [LeetCode 42](https://leetcode.com/problems/trapping-rain-water/) |

## Practice Roadmap

<Steps>
  <Step title="Day 1: Basics">
    - Solve: Two Sum II, Valid Palindrome
    - Focus: Understanding when to move which pointer
  </Step>
  <Step title="Day 2: Fast-Slow">
    - Solve: Move Zeroes, Remove Duplicates
    - Focus: In-place modifications
  </Step>
  <Step title="Day 3: Multi-pointer">
    - Solve: 3Sum, Sort Colors
    - Focus: Managing multiple pointers
  </Step>
  <Step title="Day 4: Advanced">
    - Solve: Container With Water, Trapping Rain Water
    - Focus: Greedy decisions with pointers
  </Step>
</Steps>

<Tip>
**Interview Tip**: When you see a sorted array or need to find pairs/triplets, immediately consider Two Pointers before jumping to HashMap.
</Tip>
