---
title: "Dynamic Programming"
description: "Master DP through state definition, transitions, and optimization"
icon: "layer-group"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/06-dynamic-programming.svg"
  alt="Dynamic Programming Pattern"
/>

## What is Dynamic Programming?

**Dynamic Programming** solves complex problems by breaking them into overlapping subproblems and storing results to avoid redundant computation. It transforms exponential solutions into polynomial ones.

<Note>
**Quick Recognition**: If you see **"optimal"** (min/max), **"number of ways"**, or **"can we achieve"** combined with **choices at each step**, think DP!
</Note>

## Pattern Recognition Checklist

<CardGroup cols={2}>
  <Card title="Use DP When" icon="check">
    - Problem has **optimal substructure**
    - Same **subproblems solved repeatedly**
    - Need to find **min/max/count**
    - **Choices** at each step affect result
    - Can break into **smaller similar problems**
  </Card>
  <Card title="Don't Use When" icon="xmark">
    - **Greedy** choice works (no need to try all)
    - No **overlapping subproblems**
    - Need **all solutions** (use Backtracking)
    - Simple **iteration** is sufficient
  </Card>
</CardGroup>

## When to Use

<CardGroup cols={2}>
  <Card title="Optimal Substructure" icon="sitemap">
    Optimal solution contains optimal solutions to subproblems
  </Card>
  <Card title="Overlapping Subproblems" icon="clone">
    Same subproblems are solved multiple times
  </Card>
  <Card title="Counting Problems" icon="calculator">
    Number of ways to achieve something
  </Card>
  <Card title="Optimization" icon="bullseye">
    Minimize/maximize under constraints
  </Card>
</CardGroup>

## The IDEAL Framework

<Steps>
  <Step title="Identify">
    Recognize it's a DP problem (optimal/count + choices + constraints)
  </Step>
  <Step title="Define">
    Define what dp[i] or dp[i][j] represents
  </Step>
  <Step title="Express">
    Write the recurrence relation (transition equation)
  </Step>
  <Step title="Analyze">
    Determine base cases and computation order
  </Step>
  <Step title="Look back">
    Optimize space if possible
  </Step>
</Steps>

## Pattern Variations

### 1. 1D DP (Linear)

<CodeGroup>
```python Python
def climb_stairs(n):
    """Number of ways to climb n stairs (1 or 2 steps)"""
    if n <= 2:
        return n
    
    # dp[i] = ways to reach step i
    dp = [0] * (n + 1)
    dp[1] = 1
    dp[2] = 2
    
    for i in range(3, n + 1):
        dp[i] = dp[i-1] + dp[i-2]  # Come from i-1 or i-2
    
    return dp[n]

# Space optimized
def climb_stairs_optimized(n):
    if n <= 2:
        return n
    
    prev2, prev1 = 1, 2
    for i in range(3, n + 1):
        prev2, prev1 = prev1, prev2 + prev1
    
    return prev1
```

```java Java
public int climbStairs(int n) {
    // Number of ways to climb n stairs (1 or 2 steps)
    if (n <= 2) {
        return n;
    }
    
    // dp[i] = ways to reach step i
    int[] dp = new int[n + 1];
    dp[1] = 1;
    dp[2] = 2;
    
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];  // Come from i-1 or i-2
    }
    
    return dp[n];
}

// Space optimized
public int climbStairsOptimized(int n) {
    if (n <= 2) {
        return n;
    }
    
    int prev2 = 1, prev1 = 2;
    for (int i = 3; i <= n; i++) {
        int curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    
    return prev1;
}
```

```cpp C++
int climbStairs(int n) {
    // Number of ways to climb n stairs (1 or 2 steps)
    if (n <= 2) {
        return n;
    }
    
    // dp[i] = ways to reach step i
    vector<int> dp(n + 1);
    dp[1] = 1;
    dp[2] = 2;
    
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];  // Come from i-1 or i-2
    }
    
    return dp[n];
}

// Space optimized
int climbStairsOptimized(int n) {
    if (n <= 2) {
        return n;
    }
    
    int prev2 = 1, prev1 = 2;
    for (int i = 3; i <= n; i++) {
        int curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    
    return prev1;
}
```
</CodeGroup>

### 2. 2D DP (Grid/Sequence)

<CodeGroup>
```python Python
def unique_paths(m, n):
    """Count paths from top-left to bottom-right (right/down only)"""
    # dp[i][j] = paths to reach cell (i, j)
    dp = [[1] * n for _ in range(m)]
    
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    
    return dp[m-1][n-1]

# Space optimized to O(n)
def unique_paths_optimized(m, n):
    dp = [1] * n
    
    for i in range(1, m):
        for j in range(1, n):
            dp[j] += dp[j-1]
    
    return dp[n-1]
```

```java Java
public int uniquePaths(int m, int n) {
    // Count paths from top-left to bottom-right (right/down only)
    // dp[i][j] = paths to reach cell (i, j)
    int[][] dp = new int[m][n];
    
    // Initialize first row and column
    for (int i = 0; i < m; i++) dp[i][0] = 1;
    for (int j = 0; j < n; j++) dp[0][j] = 1;
    
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }
    
    return dp[m-1][n-1];
}

// Space optimized to O(n)
public int uniquePathsOptimized(int m, int n) {
    int[] dp = new int[n];
    Arrays.fill(dp, 1);
    
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[j] += dp[j-1];
        }
    }
    
    return dp[n-1];
}
```

```cpp C++
int uniquePaths(int m, int n) {
    // Count paths from top-left to bottom-right (right/down only)
    // dp[i][j] = paths to reach cell (i, j)
    vector<vector<int>> dp(m, vector<int>(n, 1));
    
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }
    
    return dp[m-1][n-1];
}

// Space optimized to O(n)
int uniquePathsOptimized(int m, int n) {
    vector<int> dp(n, 1);
    
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[j] += dp[j-1];
        }
    }
    
    return dp[n-1];
}
```
</CodeGroup>

### 3. Knapsack Pattern

<CodeGroup>
```python Python
def knapsack_01(weights, values, capacity):
    """Maximum value within capacity (each item once)"""
    n = len(weights)
    # dp[i][w] = max value using first i items with capacity w
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for w in range(capacity + 1):
            # Don't take item i
            dp[i][w] = dp[i-1][w]
            
            # Take item i if it fits
            if weights[i-1] <= w:
                dp[i][w] = max(dp[i][w], 
                              dp[i-1][w - weights[i-1]] + values[i-1])
    
    return dp[n][capacity]

# Space optimized
def knapsack_01_optimized(weights, values, capacity):
    dp = [0] * (capacity + 1)
    
    for i in range(len(weights)):
        # Traverse backwards to avoid using same item twice
        for w in range(capacity, weights[i] - 1, -1):
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
    
    return dp[capacity]
```

```java Java
public int knapsack01(int[] weights, int[] values, int capacity) {
    // Maximum value within capacity (each item once)
    int n = weights.length;
    // dp[i][w] = max value using first i items with capacity w
    int[][] dp = new int[n + 1][capacity + 1];
    
    for (int i = 1; i <= n; i++) {
        for (int w = 0; w <= capacity; w++) {
            // Don't take item i
            dp[i][w] = dp[i-1][w];
            
            // Take item i if it fits
            if (weights[i-1] <= w) {
                dp[i][w] = Math.max(dp[i][w], 
                    dp[i-1][w - weights[i-1]] + values[i-1]);
            }
        }
    }
    
    return dp[n][capacity];
}

// Space optimized
public int knapsack01Optimized(int[] weights, int[] values, int capacity) {
    int[] dp = new int[capacity + 1];
    
    for (int i = 0; i < weights.length; i++) {
        // Traverse backwards to avoid using same item twice
        for (int w = capacity; w >= weights[i]; w--) {
            dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);
        }
    }
    
    return dp[capacity];
}
```

```cpp C++
int knapsack01(vector<int>& weights, vector<int>& values, int capacity) {
    // Maximum value within capacity (each item once)
    int n = weights.size();
    // dp[i][w] = max value using first i items with capacity w
    vector<vector<int>> dp(n + 1, vector<int>(capacity + 1, 0));
    
    for (int i = 1; i <= n; i++) {
        for (int w = 0; w <= capacity; w++) {
            // Don't take item i
            dp[i][w] = dp[i-1][w];
            
            // Take item i if it fits
            if (weights[i-1] <= w) {
                dp[i][w] = max(dp[i][w], 
                    dp[i-1][w - weights[i-1]] + values[i-1]);
            }
        }
    }
    
    return dp[n][capacity];
}

// Space optimized
int knapsack01Optimized(vector<int>& weights, vector<int>& values, int capacity) {
    vector<int> dp(capacity + 1, 0);
    
    for (int i = 0; i < weights.size(); i++) {
        // Traverse backwards to avoid using same item twice
        for (int w = capacity; w >= weights[i]; w--) {
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i]);
        }
    }
    
    return dp[capacity];
}
```
</CodeGroup>

### 4. LCS Pattern (Two Strings)

<CodeGroup>
```python Python
def longest_common_subsequence(text1, text2):
    """Find LCS length of two strings"""
    m, n = len(text1), len(text2)
    # dp[i][j] = LCS of text1[:i] and text2[:j]
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]
```

```java Java
public int longestCommonSubsequence(String text1, String text2) {
    // Find LCS length of two strings
    int m = text1.length(), n = text2.length();
    // dp[i][j] = LCS of text1[:i] and text2[:j]
    int[][] dp = new int[m + 1][n + 1];
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1.charAt(i-1) == text2.charAt(j-1)) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    
    return dp[m][n];
}
```

```cpp C++
int longestCommonSubsequence(string text1, string text2) {
    // Find LCS length of two strings
    int m = text1.size(), n = text2.size();
    // dp[i][j] = LCS of text1[:i] and text2[:j]
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1[i-1] == text2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    
    return dp[m][n];
}
```
</CodeGroup>

### 5. House Robber (Cannot Take Adjacent)

<CodeGroup>
```python Python
def house_robber(nums):
    """Maximum sum without taking adjacent elements"""
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    
    # dp[i] = max money robbing houses 0..i
    # Either rob house i (dp[i-2] + nums[i]) or skip it (dp[i-1])
    dp = [0] * len(nums)
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])
    
    for i in range(2, len(nums)):
        dp[i] = max(dp[i-1], dp[i-2] + nums[i])
    
    return dp[-1]

# Space optimized
def house_robber_optimized(nums):
    prev2, prev1 = 0, 0
    
    for num in nums:
        prev2, prev1 = prev1, max(prev1, prev2 + num)
    
    return prev1
```

```java Java
public int houseRobber(int[] nums) {
    // Maximum sum without taking adjacent elements
    if (nums.length == 0) return 0;
    if (nums.length == 1) return nums[0];
    
    // dp[i] = max money robbing houses 0..i
    int[] dp = new int[nums.length];
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);
    
    for (int i = 2; i < nums.length; i++) {
        dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);
    }
    
    return dp[nums.length - 1];
}

// Space optimized
public int houseRobberOptimized(int[] nums) {
    int prev2 = 0, prev1 = 0;
    
    for (int num : nums) {
        int curr = Math.max(prev1, prev2 + num);
        prev2 = prev1;
        prev1 = curr;
    }
    
    return prev1;
}
```

```cpp C++
int houseRobber(vector<int>& nums) {
    // Maximum sum without taking adjacent elements
    if (nums.empty()) return 0;
    if (nums.size() == 1) return nums[0];
    
    // dp[i] = max money robbing houses 0..i
    vector<int> dp(nums.size());
    dp[0] = nums[0];
    dp[1] = max(nums[0], nums[1]);
    
    for (int i = 2; i < nums.size(); i++) {
        dp[i] = max(dp[i-1], dp[i-2] + nums[i]);
    }
    
    return dp.back();
}

// Space optimized
int houseRobberOptimized(vector<int>& nums) {
    int prev2 = 0, prev1 = 0;
    
    for (int num : nums) {
        int curr = max(prev1, prev2 + num);
        prev2 = prev1;
        prev1 = curr;
    }
    
    return prev1;
}
```
</CodeGroup>

### 6. Coin Change

<CodeGroup>
```python Python
def coin_change(coins, amount):
    """Minimum coins to make amount"""
    # dp[i] = min coins to make amount i
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    
    for i in range(1, amount + 1):
        for coin in coins:
            if coin <= i and dp[i - coin] != float('inf'):
                dp[i] = min(dp[i], dp[i - coin] + 1)
    
    return dp[amount] if dp[amount] != float('inf') else -1
```

```java Java
public int coinChange(int[] coins, int amount) {
    // Minimum coins to make amount
    // dp[i] = min coins to make amount i
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, amount + 1);
    dp[0] = 0;
    
    for (int i = 1; i <= amount; i++) {
        for (int coin : coins) {
            if (coin <= i) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    
    return dp[amount] > amount ? -1 : dp[amount];
}
```

```cpp C++
int coinChange(vector<int>& coins, int amount) {
    // Minimum coins to make amount
    // dp[i] = min coins to make amount i
    vector<int> dp(amount + 1, amount + 1);
    dp[0] = 0;
    
    for (int i = 1; i <= amount; i++) {
        for (int coin : coins) {
            if (coin <= i) {
                dp[i] = min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    
    return dp[amount] > amount ? -1 : dp[amount];
}
```
</CodeGroup>

## Classic Problems

<AccordionGroup>
  <Accordion title="1. Climbing Stairs" icon="stairs">
    **Pattern**: 1D DP (Fibonacci-like)
    
    **State**: dp[i] = ways to reach step i
  </Accordion>
  
  <Accordion title="2. Longest Increasing Subsequence" icon="arrow-up">
    **Pattern**: 1D DP with O(n^2) or binary search O(n log n)
    
    **State**: dp[i] = LIS ending at index i
  </Accordion>
  
  <Accordion title="3. Edit Distance" icon="pen">
    **Pattern**: 2D DP on two strings
    
    **State**: dp[i][j] = min operations to convert s1[:i] to s2[:j]
  </Accordion>
  
  <Accordion title="4. Partition Equal Subset Sum" icon="scale-balanced">
    **Pattern**: 0/1 Knapsack variant
    
    **State**: dp[i][sum] = can we make sum using first i elements?
  </Accordion>
</AccordionGroup>

## Common Mistakes

<Warning>
**Avoid These Pitfalls:**
1. **Wrong state definition**: Be precise about what dp[i] represents
2. **Missing base cases**: Initialize dp[0] or dp[0][0] correctly
3. **Wrong iteration order**: Depends on dependencies in recurrence
4. **Integer overflow**: Use long or modular arithmetic when needed
</Warning>

## Debugging Checklist

When your DP solution fails:

<Steps>
  <Step title="Check State Definition">
    Is dp[i] clearly defined? Can you explain what it represents?
  </Step>
  <Step title="Check Base Cases">
    Have you initialized all necessary base cases correctly?
  </Step>
  <Step title="Check Recurrence">
    Does your transition cover all cases? Any edge cases missed?
  </Step>
  <Step title="Check Iteration Order">
    Are you computing dp[i] only after dp[i-1], dp[i-2], etc.?
  </Step>
  <Step title="Check Return Value">
    Are you returning the right cell? dp[n] vs dp[n-1]?
  </Step>
</Steps>

## DP Pattern Categories

| Category | Examples | State Definition |
|----------|----------|------------------|
| **Linear DP** | Climbing Stairs, House Robber | dp[i] = answer for first i elements |
| **Grid DP** | Unique Paths, Min Path Sum | dp[i][j] = answer reaching (i,j) |
| **String DP** | LCS, Edit Distance | dp[i][j] = answer for s1[:i], s2[:j] |
| **Knapsack** | 0/1 Knapsack, Coin Change | dp[i][w] = answer using i items, capacity w |
| **Interval DP** | Matrix Chain, Burst Balloons | dp[i][j] = answer for interval [i,j] |
| **Tree DP** | House Robber III | dp[node] = answer for subtree at node |

## Complexity Quick Reference

| Problem Type | Time | Space | Optimization |
|-------------|------|-------|--------------|
| 1D DP | O(n) | O(n) → O(1) | Keep only last 2 values |
| 2D Grid DP | O(mn) | O(mn) → O(n) | Keep only previous row |
| String DP (LCS) | O(mn) | O(mn) → O(n) | Keep only previous row |
| Knapsack | O(nW) | O(nW) → O(W) | Single row iteration |
| Interval DP | O(n³) | O(n²) | Usually not optimizable |

## Interview Problems by Company

<Tabs>
  <Tab title="Easy">
    | Problem | Company | DP Type |
    |---------|---------|---------|
    | Climbing Stairs | All | 1D Linear |
    | Min Cost Climbing Stairs | Amazon | 1D Linear |
    | Maximum Subarray | All | 1D (Kadane's) |
    | Best Time to Buy Stock | Amazon | 1D State Machine |
    | House Robber | Google, Meta | 1D Linear |
  </Tab>
  <Tab title="Medium">
    | Problem | Company | DP Type |
    |---------|---------|---------|
    | Unique Paths | All FAANG | 2D Grid |
    | Coin Change | Amazon, Google | Unbounded Knapsack |
    | LCS | Microsoft, Google | 2D String |
    | Word Break | Meta, Amazon | 1D with Dictionary |
    | Longest Increasing Subseq | Google | 1D + Binary Search |
  </Tab>
  <Tab title="Hard">
    | Problem | Company | DP Type |
    |---------|---------|---------|
    | Edit Distance | Google | 2D String |
    | Regular Expression | Meta, Google | 2D String |
    | Burst Balloons | Google | Interval DP |
    | Longest Valid Parens | Meta | 1D Stack/DP |
    | Interleaving String | Amazon | 2D String |
  </Tab>
</Tabs>

## Interview Tips

<AccordionGroup>
  <Accordion title="How to Explain Your Approach" icon="comments">
    **Script for interviews:**
    
    1. "I notice this is asking for [optimal/count], which suggests DP."
    2. "Let me define the state: dp[i] represents..."
    3. "The recurrence is: dp[i] = ... because..."
    4. "Base case is dp[0] = ... because..."
    5. "Time is O(...) and space is O(...), which I can optimize to..."
  </Accordion>
  
  <Accordion title="When Interviewer Says..." icon="user-tie">
    | Interviewer Says | You Should Think |
    |-----------------|------------------|
    | "Find minimum/maximum" | Optimization DP |
    | "Count the number of ways" | Counting DP |
    | "Can you achieve X?" | Boolean DP (true/false) |
    | "Optimize your recursion" | Add memoization |
    | "Reduce space complexity" | Rolling array technique |
  </Accordion>
  
  <Accordion title="Top-Down vs Bottom-Up" icon="arrows-up-down">
    **Top-Down (Memoization)**:
    - Easier to write (natural recursion)
    - Only computes needed subproblems
    - Can have stack overflow for large inputs
    
    **Bottom-Up (Tabulation)**:
    - Usually faster (no recursion overhead)
    - Easier to optimize space
    - Must compute all subproblems
    
    **Recommendation**: Start with top-down, convert to bottom-up if needed.
  </Accordion>
</AccordionGroup>

## Practice Problems

| Problem | Difficulty | Link |
|---------|------------|------|
| Climbing Stairs | Easy | [LeetCode 70](https://leetcode.com/problems/climbing-stairs/) |
| House Robber | Medium | [LeetCode 198](https://leetcode.com/problems/house-robber/) |
| Coin Change | Medium | [LeetCode 322](https://leetcode.com/problems/coin-change/) |
| Longest Common Subsequence | Medium | [LeetCode 1143](https://leetcode.com/problems/longest-common-subsequence/) |
| Edit Distance | Medium | [LeetCode 72](https://leetcode.com/problems/edit-distance/) |

## Practice Roadmap

<Steps>
  <Step title="Week 1: 1D DP">
    - Solve: Climbing Stairs, House Robber, Max Subarray
    - Focus: State definition and transitions
  </Step>
  <Step title="Week 2: 2D Grid DP">
    - Solve: Unique Paths, Min Path Sum, Triangle
    - Focus: Grid traversal patterns
  </Step>
  <Step title="Week 3: String DP">
    - Solve: LCS, Edit Distance, Palindrome Substring
    - Focus: Two-string state definition
  </Step>
  <Step title="Week 4: Advanced">
    - Solve: Coin Change, Knapsack, Word Break
    - Focus: Recognizing DP variants
  </Step>
</Steps>

<Tip>
**Interview Tip**: Start with brute force recursion, add memoization, then convert to bottom-up DP, finally optimize space.
</Tip>
