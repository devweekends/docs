---
title: "Dynamic Programming"
description: "Master DP through state definition, transitions, and optimization"
icon: "layer-group"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/06-dynamic-programming.svg"
  alt="Dynamic Programming Pattern"
/>

## What is Dynamic Programming?

**Dynamic Programming** solves complex problems by breaking them into overlapping subproblems and storing results to avoid redundant computation. It transforms exponential solutions into polynomial ones.

## When to Use

<CardGroup cols={2}>
  <Card title="Optimal Substructure" icon="sitemap">
    Optimal solution contains optimal solutions to subproblems
  </Card>
  <Card title="Overlapping Subproblems" icon="clone">
    Same subproblems are solved multiple times
  </Card>
  <Card title="Counting Problems" icon="calculator">
    Number of ways to achieve something
  </Card>
  <Card title="Optimization" icon="bullseye">
    Minimize/maximize under constraints
  </Card>
</CardGroup>

## The IDEAL Framework

<Steps>
  <Step title="Identify">
    Recognize it's a DP problem (optimal/count + choices + constraints)
  </Step>
  <Step title="Define">
    Define what dp[i] or dp[i][j] represents
  </Step>
  <Step title="Express">
    Write the recurrence relation (transition equation)
  </Step>
  <Step title="Analyze">
    Determine base cases and computation order
  </Step>
  <Step title="Look back">
    Optimize space if possible
  </Step>
</Steps>

## Pattern Variations

### 1. 1D DP (Linear)

<CodeGroup>
```python Python
def climb_stairs(n):
    """Number of ways to climb n stairs (1 or 2 steps)"""
    if n <= 2:
        return n
    
    # dp[i] = ways to reach step i
    dp = [0] * (n + 1)
    dp[1] = 1
    dp[2] = 2
    
    for i in range(3, n + 1):
        dp[i] = dp[i-1] + dp[i-2]  # Come from i-1 or i-2
    
    return dp[n]

# Space optimized
def climb_stairs_optimized(n):
    if n <= 2:
        return n
    
    prev2, prev1 = 1, 2
    for i in range(3, n + 1):
        prev2, prev1 = prev1, prev2 + prev1
    
    return prev1
```

```java Java
public int climbStairs(int n) {
    // Number of ways to climb n stairs (1 or 2 steps)
    if (n <= 2) {
        return n;
    }
    
    // dp[i] = ways to reach step i
    int[] dp = new int[n + 1];
    dp[1] = 1;
    dp[2] = 2;
    
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];  // Come from i-1 or i-2
    }
    
    return dp[n];
}

// Space optimized
public int climbStairsOptimized(int n) {
    if (n <= 2) {
        return n;
    }
    
    int prev2 = 1, prev1 = 2;
    for (int i = 3; i <= n; i++) {
        int curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    
    return prev1;
}
```

```cpp C++
int climbStairs(int n) {
    // Number of ways to climb n stairs (1 or 2 steps)
    if (n <= 2) {
        return n;
    }
    
    // dp[i] = ways to reach step i
    vector<int> dp(n + 1);
    dp[1] = 1;
    dp[2] = 2;
    
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];  // Come from i-1 or i-2
    }
    
    return dp[n];
}

// Space optimized
int climbStairsOptimized(int n) {
    if (n <= 2) {
        return n;
    }
    
    int prev2 = 1, prev1 = 2;
    for (int i = 3; i <= n; i++) {
        int curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    
    return prev1;
}
```
</CodeGroup>

### 2. 2D DP (Grid/Sequence)

<CodeGroup>
```python Python
def unique_paths(m, n):
    """Count paths from top-left to bottom-right (right/down only)"""
    # dp[i][j] = paths to reach cell (i, j)
    dp = [[1] * n for _ in range(m)]
    
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    
    return dp[m-1][n-1]

# Space optimized to O(n)
def unique_paths_optimized(m, n):
    dp = [1] * n
    
    for i in range(1, m):
        for j in range(1, n):
            dp[j] += dp[j-1]
    
    return dp[n-1]
```

```java Java
public int uniquePaths(int m, int n) {
    // Count paths from top-left to bottom-right (right/down only)
    // dp[i][j] = paths to reach cell (i, j)
    int[][] dp = new int[m][n];
    
    // Initialize first row and column
    for (int i = 0; i < m; i++) dp[i][0] = 1;
    for (int j = 0; j < n; j++) dp[0][j] = 1;
    
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }
    
    return dp[m-1][n-1];
}

// Space optimized to O(n)
public int uniquePathsOptimized(int m, int n) {
    int[] dp = new int[n];
    Arrays.fill(dp, 1);
    
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[j] += dp[j-1];
        }
    }
    
    return dp[n-1];
}
```

```cpp C++
int uniquePaths(int m, int n) {
    // Count paths from top-left to bottom-right (right/down only)
    // dp[i][j] = paths to reach cell (i, j)
    vector<vector<int>> dp(m, vector<int>(n, 1));
    
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }
    
    return dp[m-1][n-1];
}

// Space optimized to O(n)
int uniquePathsOptimized(int m, int n) {
    vector<int> dp(n, 1);
    
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[j] += dp[j-1];
        }
    }
    
    return dp[n-1];
}
```
</CodeGroup>

### 3. Knapsack Pattern

<CodeGroup>
```python Python
def knapsack_01(weights, values, capacity):
    """Maximum value within capacity (each item once)"""
    n = len(weights)
    # dp[i][w] = max value using first i items with capacity w
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for w in range(capacity + 1):
            # Don't take item i
            dp[i][w] = dp[i-1][w]
            
            # Take item i if it fits
            if weights[i-1] <= w:
                dp[i][w] = max(dp[i][w], 
                              dp[i-1][w - weights[i-1]] + values[i-1])
    
    return dp[n][capacity]

# Space optimized
def knapsack_01_optimized(weights, values, capacity):
    dp = [0] * (capacity + 1)
    
    for i in range(len(weights)):
        # Traverse backwards to avoid using same item twice
        for w in range(capacity, weights[i] - 1, -1):
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
    
    return dp[capacity]
```

```java Java
public int knapsack01(int[] weights, int[] values, int capacity) {
    // Maximum value within capacity (each item once)
    int n = weights.length;
    // dp[i][w] = max value using first i items with capacity w
    int[][] dp = new int[n + 1][capacity + 1];
    
    for (int i = 1; i <= n; i++) {
        for (int w = 0; w <= capacity; w++) {
            // Don't take item i
            dp[i][w] = dp[i-1][w];
            
            // Take item i if it fits
            if (weights[i-1] <= w) {
                dp[i][w] = Math.max(dp[i][w], 
                    dp[i-1][w - weights[i-1]] + values[i-1]);
            }
        }
    }
    
    return dp[n][capacity];
}

// Space optimized
public int knapsack01Optimized(int[] weights, int[] values, int capacity) {
    int[] dp = new int[capacity + 1];
    
    for (int i = 0; i < weights.length; i++) {
        // Traverse backwards to avoid using same item twice
        for (int w = capacity; w >= weights[i]; w--) {
            dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);
        }
    }
    
    return dp[capacity];
}
```

```cpp C++
int knapsack01(vector<int>& weights, vector<int>& values, int capacity) {
    // Maximum value within capacity (each item once)
    int n = weights.size();
    // dp[i][w] = max value using first i items with capacity w
    vector<vector<int>> dp(n + 1, vector<int>(capacity + 1, 0));
    
    for (int i = 1; i <= n; i++) {
        for (int w = 0; w <= capacity; w++) {
            // Don't take item i
            dp[i][w] = dp[i-1][w];
            
            // Take item i if it fits
            if (weights[i-1] <= w) {
                dp[i][w] = max(dp[i][w], 
                    dp[i-1][w - weights[i-1]] + values[i-1]);
            }
        }
    }
    
    return dp[n][capacity];
}

// Space optimized
int knapsack01Optimized(vector<int>& weights, vector<int>& values, int capacity) {
    vector<int> dp(capacity + 1, 0);
    
    for (int i = 0; i < weights.size(); i++) {
        // Traverse backwards to avoid using same item twice
        for (int w = capacity; w >= weights[i]; w--) {
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i]);
        }
    }
    
    return dp[capacity];
}
```
</CodeGroup>

### 4. LCS Pattern (Two Strings)

<CodeGroup>
```python Python
def longest_common_subsequence(text1, text2):
    """Find LCS length of two strings"""
    m, n = len(text1), len(text2)
    # dp[i][j] = LCS of text1[:i] and text2[:j]
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]
```

```java Java
public int longestCommonSubsequence(String text1, String text2) {
    // Find LCS length of two strings
    int m = text1.length(), n = text2.length();
    // dp[i][j] = LCS of text1[:i] and text2[:j]
    int[][] dp = new int[m + 1][n + 1];
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1.charAt(i-1) == text2.charAt(j-1)) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    
    return dp[m][n];
}
```

```cpp C++
int longestCommonSubsequence(string text1, string text2) {
    // Find LCS length of two strings
    int m = text1.size(), n = text2.size();
    // dp[i][j] = LCS of text1[:i] and text2[:j]
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1[i-1] == text2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    
    return dp[m][n];
}
```
</CodeGroup>

### 5. House Robber (Cannot Take Adjacent)

<CodeGroup>
```python Python
def house_robber(nums):
    """Maximum sum without taking adjacent elements"""
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    
    # dp[i] = max money robbing houses 0..i
    # Either rob house i (dp[i-2] + nums[i]) or skip it (dp[i-1])
    dp = [0] * len(nums)
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])
    
    for i in range(2, len(nums)):
        dp[i] = max(dp[i-1], dp[i-2] + nums[i])
    
    return dp[-1]

# Space optimized
def house_robber_optimized(nums):
    prev2, prev1 = 0, 0
    
    for num in nums:
        prev2, prev1 = prev1, max(prev1, prev2 + num)
    
    return prev1
```

```java Java
public int houseRobber(int[] nums) {
    // Maximum sum without taking adjacent elements
    if (nums.length == 0) return 0;
    if (nums.length == 1) return nums[0];
    
    // dp[i] = max money robbing houses 0..i
    int[] dp = new int[nums.length];
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);
    
    for (int i = 2; i < nums.length; i++) {
        dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);
    }
    
    return dp[nums.length - 1];
}

// Space optimized
public int houseRobberOptimized(int[] nums) {
    int prev2 = 0, prev1 = 0;
    
    for (int num : nums) {
        int curr = Math.max(prev1, prev2 + num);
        prev2 = prev1;
        prev1 = curr;
    }
    
    return prev1;
}
```

```cpp C++
int houseRobber(vector<int>& nums) {
    // Maximum sum without taking adjacent elements
    if (nums.empty()) return 0;
    if (nums.size() == 1) return nums[0];
    
    // dp[i] = max money robbing houses 0..i
    vector<int> dp(nums.size());
    dp[0] = nums[0];
    dp[1] = max(nums[0], nums[1]);
    
    for (int i = 2; i < nums.size(); i++) {
        dp[i] = max(dp[i-1], dp[i-2] + nums[i]);
    }
    
    return dp.back();
}

// Space optimized
int houseRobberOptimized(vector<int>& nums) {
    int prev2 = 0, prev1 = 0;
    
    for (int num : nums) {
        int curr = max(prev1, prev2 + num);
        prev2 = prev1;
        prev1 = curr;
    }
    
    return prev1;
}
```
</CodeGroup>

### 6. Coin Change

<CodeGroup>
```python Python
def coin_change(coins, amount):
    """Minimum coins to make amount"""
    # dp[i] = min coins to make amount i
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    
    for i in range(1, amount + 1):
        for coin in coins:
            if coin <= i and dp[i - coin] != float('inf'):
                dp[i] = min(dp[i], dp[i - coin] + 1)
    
    return dp[amount] if dp[amount] != float('inf') else -1
```

```java Java
public int coinChange(int[] coins, int amount) {
    // Minimum coins to make amount
    // dp[i] = min coins to make amount i
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, amount + 1);
    dp[0] = 0;
    
    for (int i = 1; i <= amount; i++) {
        for (int coin : coins) {
            if (coin <= i) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    
    return dp[amount] > amount ? -1 : dp[amount];
}
```

```cpp C++
int coinChange(vector<int>& coins, int amount) {
    // Minimum coins to make amount
    // dp[i] = min coins to make amount i
    vector<int> dp(amount + 1, amount + 1);
    dp[0] = 0;
    
    for (int i = 1; i <= amount; i++) {
        for (int coin : coins) {
            if (coin <= i) {
                dp[i] = min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    
    return dp[amount] > amount ? -1 : dp[amount];
}
```
</CodeGroup>

## Classic Problems

<AccordionGroup>
  <Accordion title="1. Climbing Stairs" icon="stairs">
    **Pattern**: 1D DP (Fibonacci-like)
    
    **State**: dp[i] = ways to reach step i
  </Accordion>
  
  <Accordion title="2. Longest Increasing Subsequence" icon="arrow-up">
    **Pattern**: 1D DP with O(n^2) or binary search O(n log n)
    
    **State**: dp[i] = LIS ending at index i
  </Accordion>
  
  <Accordion title="3. Edit Distance" icon="pen">
    **Pattern**: 2D DP on two strings
    
    **State**: dp[i][j] = min operations to convert s1[:i] to s2[:j]
  </Accordion>
  
  <Accordion title="4. Partition Equal Subset Sum" icon="scale-balanced">
    **Pattern**: 0/1 Knapsack variant
    
    **State**: dp[i][sum] = can we make sum using first i elements?
  </Accordion>
</AccordionGroup>

## Common Mistakes

<Warning>
**Avoid These Pitfalls:**
1. **Wrong state definition**: Be precise about what dp[i] represents
2. **Missing base cases**: Initialize dp[0] or dp[0][0] correctly
3. **Wrong iteration order**: Depends on dependencies in recurrence
4. **Integer overflow**: Use long or modular arithmetic when needed
</Warning>

## Practice Problems

| Problem | Difficulty | Link |
|---------|------------|------|
| Climbing Stairs | Easy | [LeetCode 70](https://leetcode.com/problems/climbing-stairs/) |
| House Robber | Medium | [LeetCode 198](https://leetcode.com/problems/house-robber/) |
| Coin Change | Medium | [LeetCode 322](https://leetcode.com/problems/coin-change/) |
| Longest Common Subsequence | Medium | [LeetCode 1143](https://leetcode.com/problems/longest-common-subsequence/) |
| Edit Distance | Medium | [LeetCode 72](https://leetcode.com/problems/edit-distance/) |

<Tip>
**Interview Tip**: Start with brute force recursion, add memoization, then convert to bottom-up DP, finally optimize space.
</Tip>
