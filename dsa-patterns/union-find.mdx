---
title: "Union Find (Disjoint Set)"
description: "Efficiently track connected components with union-find operations"
icon: "circle-nodes"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/19-union-find.svg"
  alt="Union Find Pattern"
/>

## What is Union Find?

**Union Find** (Disjoint Set Union) tracks elements partitioned into disjoint sets. It supports near O(1) operations for finding which set an element belongs to and merging sets.

## When to Use

<CardGroup cols={2}>
  <Card title="Connected Components" icon="circle-nodes">
    Counting groups, checking connectivity
  </Card>
  <Card title="Cycle Detection" icon="arrows-spin">
    Detect cycles in undirected graphs
  </Card>
  <Card title="Dynamic Connectivity" icon="link">
    Online queries about connectivity
  </Card>
  <Card title="MST Algorithms" icon="share-nodes">
    Kruskal's algorithm
  </Card>
</CardGroup>

## Implementation

<CodeGroup>
```python Python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.count = n  # Number of components
    
    def find(self, x):
        """Find root with path compression"""
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        """Union by rank"""
        root_x, root_y = self.find(x), self.find(y)
        
        if root_x == root_y:
            return False  # Already connected
        
        # Attach smaller tree under larger
        if self.rank[root_x] < self.rank[root_y]:
            root_x, root_y = root_y, root_x
        
        self.parent[root_y] = root_x
        if self.rank[root_x] == self.rank[root_y]:
            self.rank[root_x] += 1
        
        self.count -= 1
        return True
    
    def connected(self, x, y):
        """Check if in same component"""
        return self.find(x) == self.find(y)
```

```java Java
class UnionFind {
    private int[] parent;
    private int[] rank;
    private int count; // Number of components
    
    public UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];
        count = n;
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    public int find(int x) {
        // Find root with path compression
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    public boolean union(int x, int y) {
        // Union by rank
        int rootX = find(x), rootY = find(y);
        
        if (rootX == rootY) {
            return false; // Already connected
        }
        
        // Attach smaller tree under larger
        if (rank[rootX] < rank[rootY]) {
            int temp = rootX;
            rootX = rootY;
            rootY = temp;
        }
        
        parent[rootY] = rootX;
        if (rank[rootX] == rank[rootY]) {
            rank[rootX]++;
        }
        
        count--;
        return true;
    }
    
    public boolean connected(int x, int y) {
        // Check if in same component
        return find(x) == find(y);
    }
    
    public int getCount() {
        return count;
    }
}
```

```cpp C++
class UnionFind {
private:
    vector<int> parent;
    vector<int> rank_;
    int count; // Number of components
    
public:
    UnionFind(int n) : count(n) {
        parent.resize(n);
        rank_.resize(n, 0);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    int find(int x) {
        // Find root with path compression
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    bool unite(int x, int y) {
        // Union by rank
        int rootX = find(x), rootY = find(y);
        
        if (rootX == rootY) {
            return false; // Already connected
        }
        
        // Attach smaller tree under larger
        if (rank_[rootX] < rank_[rootY]) {
            swap(rootX, rootY);
        }
        
        parent[rootY] = rootX;
        if (rank_[rootX] == rank_[rootY]) {
            rank_[rootX]++;
        }
        
        count--;
        return true;
    }
    
    bool connected(int x, int y) {
        // Check if in same component
        return find(x) == find(y);
    }
    
    int getCount() {
        return count;
    }
};
```
</CodeGroup>

## Pattern Variations

### 1. Number of Islands (Union Find approach)

<CodeGroup>
```python Python
def num_islands(grid):
    """Count islands using Union Find"""
    if not grid:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    
    def index(r, c):
        return r * cols + c
    
    uf = UnionFind(rows * cols)
    land_count = 0
    
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':
                land_count += 1
                
                # Union with adjacent land
                for dr, dc in [(0, 1), (1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == '1':
                        if uf.union(index(r, c), index(nr, nc)):
                            land_count -= 1
    
    return land_count
```

```java Java
public int numIslands(char[][] grid) {
    // Count islands using Union Find
    if (grid.length == 0) return 0;
    
    int rows = grid.length, cols = grid[0].length;
    UnionFind uf = new UnionFind(rows * cols);
    int landCount = 0;
    
    int[][] dirs = {{0, 1}, {1, 0}};
    
    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols; c++) {
            if (grid[r][c] == '1') {
                landCount++;
                
                // Union with adjacent land
                for (int[] d : dirs) {
                    int nr = r + d[0], nc = c + d[1];
                    if (nr < rows && nc < cols && grid[nr][nc] == '1') {
                        if (uf.union(r * cols + c, nr * cols + nc)) {
                            landCount--;
                        }
                    }
                }
            }
        }
    }
    
    return landCount;
}
```

```cpp C++
int numIslands(vector<vector<char>>& grid) {
    // Count islands using Union Find
    if (grid.empty()) return 0;
    
    int rows = grid.size(), cols = grid[0].size();
    UnionFind uf(rows * cols);
    int landCount = 0;
    
    vector<pair<int, int>> dirs = {{0, 1}, {1, 0}};
    
    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols; c++) {
            if (grid[r][c] == '1') {
                landCount++;
                
                // Union with adjacent land
                for (auto& [dr, dc] : dirs) {
                    int nr = r + dr, nc = c + dc;
                    if (nr < rows && nc < cols && grid[nr][nc] == '1') {
                        if (uf.unite(r * cols + c, nr * cols + nc)) {
                            landCount--;
                        }
                    }
                }
            }
        }
    }
    
    return landCount;
}
```
</CodeGroup>

### 2. Accounts Merge

<CodeGroup>
```python Python
def accounts_merge(accounts):
    """Merge accounts with common emails"""
    from collections import defaultdict
    
    email_to_id = {}
    email_to_name = {}
    
    # Map emails to indices
    for account in accounts:
        name = account[0]
        for email in account[1:]:
            if email not in email_to_id:
                email_to_id[email] = len(email_to_id)
            email_to_name[email] = name
    
    uf = UnionFind(len(email_to_id))
    
    # Union emails in same account
    for account in accounts:
        first_email = account[1]
        for email in account[2:]:
            uf.union(email_to_id[first_email], email_to_id[email])
    
    # Group emails by root
    root_to_emails = defaultdict(list)
    for email, idx in email_to_id.items():
        root = uf.find(idx)
        root_to_emails[root].append(email)
    
    # Build result
    result = []
    for emails in root_to_emails.values():
        emails.sort()
        name = email_to_name[emails[0]]
        result.append([name] + emails)
    
    return result
```

```java Java
public List<List<String>> accountsMerge(List<List<String>> accounts) {
    // Merge accounts with common emails
    Map<String, Integer> emailToId = new HashMap<>();
    Map<String, String> emailToName = new HashMap<>();
    
    // Map emails to indices
    int id = 0;
    for (List<String> account : accounts) {
        String name = account.get(0);
        for (int i = 1; i < account.size(); i++) {
            String email = account.get(i);
            if (!emailToId.containsKey(email)) {
                emailToId.put(email, id++);
            }
            emailToName.put(email, name);
        }
    }
    
    UnionFind uf = new UnionFind(emailToId.size());
    
    // Union emails in same account
    for (List<String> account : accounts) {
        String firstEmail = account.get(1);
        for (int i = 2; i < account.size(); i++) {
            uf.union(emailToId.get(firstEmail), emailToId.get(account.get(i)));
        }
    }
    
    // Group emails by root
    Map<Integer, List<String>> rootToEmails = new HashMap<>();
    for (String email : emailToId.keySet()) {
        int root = uf.find(emailToId.get(email));
        rootToEmails.computeIfAbsent(root, k -> new ArrayList<>()).add(email);
    }
    
    // Build result
    List<List<String>> result = new ArrayList<>();
    for (List<String> emails : rootToEmails.values()) {
        Collections.sort(emails);
        String name = emailToName.get(emails.get(0));
        List<String> merged = new ArrayList<>();
        merged.add(name);
        merged.addAll(emails);
        result.add(merged);
    }
    
    return result;
}
```

```cpp C++
vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
    // Merge accounts with common emails
    unordered_map<string, int> emailToId;
    unordered_map<string, string> emailToName;
    
    // Map emails to indices
    int id = 0;
    for (auto& account : accounts) {
        string name = account[0];
        for (int i = 1; i < account.size(); i++) {
            string email = account[i];
            if (emailToId.find(email) == emailToId.end()) {
                emailToId[email] = id++;
            }
            emailToName[email] = name;
        }
    }
    
    UnionFind uf(emailToId.size());
    
    // Union emails in same account
    for (auto& account : accounts) {
        string firstEmail = account[1];
        for (int i = 2; i < account.size(); i++) {
            uf.unite(emailToId[firstEmail], emailToId[account[i]]);
        }
    }
    
    // Group emails by root
    unordered_map<int, vector<string>> rootToEmails;
    for (auto& [email, idx] : emailToId) {
        int root = uf.find(idx);
        rootToEmails[root].push_back(email);
    }
    
    // Build result
    vector<vector<string>> result;
    for (auto& [root, emails] : rootToEmails) {
        sort(emails.begin(), emails.end());
        string name = emailToName[emails[0]];
        vector<string> merged = {name};
        merged.insert(merged.end(), emails.begin(), emails.end());
        result.push_back(merged);
    }
    
    return result;
}
```
</CodeGroup>

### 3. Redundant Connection (Cycle Detection)

<CodeGroup>
```python Python
def find_redundant_connection(edges):
    """Find edge that creates cycle"""
    n = len(edges)
    uf = UnionFind(n + 1)
    
    for u, v in edges:
        if not uf.union(u, v):
            return [u, v]  # This edge creates cycle
    
    return []
```

```java Java
public int[] findRedundantConnection(int[][] edges) {
    // Find edge that creates cycle
    int n = edges.length;
    UnionFind uf = new UnionFind(n + 1);
    
    for (int[] edge : edges) {
        if (!uf.union(edge[0], edge[1])) {
            return edge; // This edge creates cycle
        }
    }
    
    return new int[0];
}
```

```cpp C++
vector<int> findRedundantConnection(vector<vector<int>>& edges) {
    // Find edge that creates cycle
    int n = edges.size();
    UnionFind uf(n + 1);
    
    for (auto& edge : edges) {
        if (!uf.unite(edge[0], edge[1])) {
            return edge; // This edge creates cycle
        }
    }
    
    return {};
}
```
</CodeGroup>

## Classic Problems

| Problem | Pattern | Key Insight |
|---------|---------|-------------|
| Number of Islands | Grid connectivity | 2D to 1D mapping |
| Accounts Merge | Email grouping | Union emails, group by root |
| Redundant Connection | Cycle detection | Edge creating cycle |
| Longest Consecutive | Value connectivity | Union consecutive numbers |
| Kruskal's MST | Edge processing | Union in weight order |

## Practice Problems

<CardGroup cols={2}>
  <Card title="Number of Provinces" icon="circle-nodes" href="https://leetcode.com/problems/number-of-provinces/">
    Connected components
  </Card>
  <Card title="Accounts Merge" icon="users" href="https://leetcode.com/problems/accounts-merge/">
    Email grouping
  </Card>
  <Card title="Redundant Connection" icon="link-slash" href="https://leetcode.com/problems/redundant-connection/">
    Cycle detection
  </Card>
  <Card title="Longest Consecutive" icon="arrow-right-long" href="https://leetcode.com/problems/longest-consecutive-sequence/">
    Value connectivity
  </Card>
</CardGroup>
