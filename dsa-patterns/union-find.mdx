---
title: "Union Find (Disjoint Set)"
description: "Efficiently track connected components with union-find operations"
icon: "circle-nodes"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/19-union-find.svg"
  alt="Union Find Pattern"
/>

## What is Union Find?

**Union Find** (Disjoint Set Union) tracks elements partitioned into disjoint sets. It supports near O(1) operations for finding which set an element belongs to and merging sets.

<Note>
**Quick Recognition**: Problems involving grouping, connectivity, or dynamic component counting. Keywords: "connected components", "group together", "same group", "cycle detection".
</Note>

## Pattern Recognition Checklist

<CardGroup cols={2}>
  <Card title="Use Union Find When" icon="check">
    - Counting connected components
    - Checking if two nodes are connected
    - Cycle detection in undirected graphs
    - Dynamic connectivity queries
    - Kruskal's MST algorithm
    - Grouping elements by some relation
  </Card>
  <Card title="Don't Use When" icon="xmark">
    - Need shortest path (use BFS/Dijkstra)
    - Directed graph cycle detection (use DFS)
    - Need to traverse paths
    - Static graph (BFS/DFS might be simpler)
  </Card>
</CardGroup>

## Complexity Reference

| Operation | Without Optimization | With Path Compression + Union by Rank |
|-----------|---------------------|--------------------------------------|
| Find | O(n) | O(alpha(n)) nearly O(1) |
| Union | O(n) | O(alpha(n)) nearly O(1) |
| Connected | O(n) | O(alpha(n)) nearly O(1) |

alpha(n) = inverse Ackermann function, grows extremely slowly

## When to Use

<CardGroup cols={2}>
  <Card title="Connected Components" icon="circle-nodes">
    Counting groups, checking connectivity
  </Card>
  <Card title="Cycle Detection" icon="arrows-spin">
    Detect cycles in undirected graphs
  </Card>
  <Card title="Dynamic Connectivity" icon="link">
    Online queries about connectivity
  </Card>
  <Card title="MST Algorithms" icon="share-nodes">
    Kruskal's algorithm
  </Card>
</CardGroup>

## Implementation

<CodeGroup>
```python Python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.count = n  # Number of components
    
    def find(self, x):
        """Find root with path compression"""
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        """Union by rank"""
        root_x, root_y = self.find(x), self.find(y)
        
        if root_x == root_y:
            return False  # Already connected
        
        # Attach smaller tree under larger
        if self.rank[root_x] < self.rank[root_y]:
            root_x, root_y = root_y, root_x
        
        self.parent[root_y] = root_x
        if self.rank[root_x] == self.rank[root_y]:
            self.rank[root_x] += 1
        
        self.count -= 1
        return True
    
    def connected(self, x, y):
        """Check if in same component"""
        return self.find(x) == self.find(y)
```

```java Java
class UnionFind {
    private int[] parent;
    private int[] rank;
    private int count; // Number of components
    
    public UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];
        count = n;
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    public int find(int x) {
        // Find root with path compression
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    public boolean union(int x, int y) {
        // Union by rank
        int rootX = find(x), rootY = find(y);
        
        if (rootX == rootY) {
            return false; // Already connected
        }
        
        // Attach smaller tree under larger
        if (rank[rootX] < rank[rootY]) {
            int temp = rootX;
            rootX = rootY;
            rootY = temp;
        }
        
        parent[rootY] = rootX;
        if (rank[rootX] == rank[rootY]) {
            rank[rootX]++;
        }
        
        count--;
        return true;
    }
    
    public boolean connected(int x, int y) {
        // Check if in same component
        return find(x) == find(y);
    }
    
    public int getCount() {
        return count;
    }
}
```

```cpp C++
class UnionFind {
private:
    vector<int> parent;
    vector<int> rank_;
    int count; // Number of components
    
public:
    UnionFind(int n) : count(n) {
        parent.resize(n);
        rank_.resize(n, 0);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    int find(int x) {
        // Find root with path compression
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    bool unite(int x, int y) {
        // Union by rank
        int rootX = find(x), rootY = find(y);
        
        if (rootX == rootY) {
            return false; // Already connected
        }
        
        // Attach smaller tree under larger
        if (rank_[rootX] < rank_[rootY]) {
            swap(rootX, rootY);
        }
        
        parent[rootY] = rootX;
        if (rank_[rootX] == rank_[rootY]) {
            rank_[rootX]++;
        }
        
        count--;
        return true;
    }
    
    bool connected(int x, int y) {
        // Check if in same component
        return find(x) == find(y);
    }
    
    int getCount() {
        return count;
    }
};
```
</CodeGroup>

## Pattern Variations

### 1. Number of Islands (Union Find approach)

<CodeGroup>
```python Python
def num_islands(grid):
    """Count islands using Union Find"""
    if not grid:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    
    def index(r, c):
        return r * cols + c
    
    uf = UnionFind(rows * cols)
    land_count = 0
    
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':
                land_count += 1
                
                # Union with adjacent land
                for dr, dc in [(0, 1), (1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == '1':
                        if uf.union(index(r, c), index(nr, nc)):
                            land_count -= 1
    
    return land_count
```

```java Java
public int numIslands(char[][] grid) {
    // Count islands using Union Find
    if (grid.length == 0) return 0;
    
    int rows = grid.length, cols = grid[0].length;
    UnionFind uf = new UnionFind(rows * cols);
    int landCount = 0;
    
    int[][] dirs = {{0, 1}, {1, 0}};
    
    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols; c++) {
            if (grid[r][c] == '1') {
                landCount++;
                
                // Union with adjacent land
                for (int[] d : dirs) {
                    int nr = r + d[0], nc = c + d[1];
                    if (nr < rows && nc < cols && grid[nr][nc] == '1') {
                        if (uf.union(r * cols + c, nr * cols + nc)) {
                            landCount--;
                        }
                    }
                }
            }
        }
    }
    
    return landCount;
}
```

```cpp C++
int numIslands(vector<vector<char>>& grid) {
    // Count islands using Union Find
    if (grid.empty()) return 0;
    
    int rows = grid.size(), cols = grid[0].size();
    UnionFind uf(rows * cols);
    int landCount = 0;
    
    vector<pair<int, int>> dirs = {{0, 1}, {1, 0}};
    
    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols; c++) {
            if (grid[r][c] == '1') {
                landCount++;
                
                // Union with adjacent land
                for (auto& [dr, dc] : dirs) {
                    int nr = r + dr, nc = c + dc;
                    if (nr < rows && nc < cols && grid[nr][nc] == '1') {
                        if (uf.unite(r * cols + c, nr * cols + nc)) {
                            landCount--;
                        }
                    }
                }
            }
        }
    }
    
    return landCount;
}
```
</CodeGroup>

### 2. Accounts Merge

<CodeGroup>
```python Python
def accounts_merge(accounts):
    """Merge accounts with common emails"""
    from collections import defaultdict
    
    email_to_id = {}
    email_to_name = {}
    
    # Map emails to indices
    for account in accounts:
        name = account[0]
        for email in account[1:]:
            if email not in email_to_id:
                email_to_id[email] = len(email_to_id)
            email_to_name[email] = name
    
    uf = UnionFind(len(email_to_id))
    
    # Union emails in same account
    for account in accounts:
        first_email = account[1]
        for email in account[2:]:
            uf.union(email_to_id[first_email], email_to_id[email])
    
    # Group emails by root
    root_to_emails = defaultdict(list)
    for email, idx in email_to_id.items():
        root = uf.find(idx)
        root_to_emails[root].append(email)
    
    # Build result
    result = []
    for emails in root_to_emails.values():
        emails.sort()
        name = email_to_name[emails[0]]
        result.append([name] + emails)
    
    return result
```

```java Java
public List<List<String>> accountsMerge(List<List<String>> accounts) {
    // Merge accounts with common emails
    Map<String, Integer> emailToId = new HashMap<>();
    Map<String, String> emailToName = new HashMap<>();
    
    // Map emails to indices
    int id = 0;
    for (List<String> account : accounts) {
        String name = account.get(0);
        for (int i = 1; i < account.size(); i++) {
            String email = account.get(i);
            if (!emailToId.containsKey(email)) {
                emailToId.put(email, id++);
            }
            emailToName.put(email, name);
        }
    }
    
    UnionFind uf = new UnionFind(emailToId.size());
    
    // Union emails in same account
    for (List<String> account : accounts) {
        String firstEmail = account.get(1);
        for (int i = 2; i < account.size(); i++) {
            uf.union(emailToId.get(firstEmail), emailToId.get(account.get(i)));
        }
    }
    
    // Group emails by root
    Map<Integer, List<String>> rootToEmails = new HashMap<>();
    for (String email : emailToId.keySet()) {
        int root = uf.find(emailToId.get(email));
        rootToEmails.computeIfAbsent(root, k -> new ArrayList<>()).add(email);
    }
    
    // Build result
    List<List<String>> result = new ArrayList<>();
    for (List<String> emails : rootToEmails.values()) {
        Collections.sort(emails);
        String name = emailToName.get(emails.get(0));
        List<String> merged = new ArrayList<>();
        merged.add(name);
        merged.addAll(emails);
        result.add(merged);
    }
    
    return result;
}
```

```cpp C++
vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
    // Merge accounts with common emails
    unordered_map<string, int> emailToId;
    unordered_map<string, string> emailToName;
    
    // Map emails to indices
    int id = 0;
    for (auto& account : accounts) {
        string name = account[0];
        for (int i = 1; i < account.size(); i++) {
            string email = account[i];
            if (emailToId.find(email) == emailToId.end()) {
                emailToId[email] = id++;
            }
            emailToName[email] = name;
        }
    }
    
    UnionFind uf(emailToId.size());
    
    // Union emails in same account
    for (auto& account : accounts) {
        string firstEmail = account[1];
        for (int i = 2; i < account.size(); i++) {
            uf.unite(emailToId[firstEmail], emailToId[account[i]]);
        }
    }
    
    // Group emails by root
    unordered_map<int, vector<string>> rootToEmails;
    for (auto& [email, idx] : emailToId) {
        int root = uf.find(idx);
        rootToEmails[root].push_back(email);
    }
    
    // Build result
    vector<vector<string>> result;
    for (auto& [root, emails] : rootToEmails) {
        sort(emails.begin(), emails.end());
        string name = emailToName[emails[0]];
        vector<string> merged = {name};
        merged.insert(merged.end(), emails.begin(), emails.end());
        result.push_back(merged);
    }
    
    return result;
}
```
</CodeGroup>

### 3. Redundant Connection (Cycle Detection)

<CodeGroup>
```python Python
def find_redundant_connection(edges):
    """Find edge that creates cycle"""
    n = len(edges)
    uf = UnionFind(n + 1)
    
    for u, v in edges:
        if not uf.union(u, v):
            return [u, v]  # This edge creates cycle
    
    return []
```

```java Java
public int[] findRedundantConnection(int[][] edges) {
    // Find edge that creates cycle
    int n = edges.length;
    UnionFind uf = new UnionFind(n + 1);
    
    for (int[] edge : edges) {
        if (!uf.union(edge[0], edge[1])) {
            return edge; // This edge creates cycle
        }
    }
    
    return new int[0];
}
```

```cpp C++
vector<int> findRedundantConnection(vector<vector<int>>& edges) {
    // Find edge that creates cycle
    int n = edges.size();
    UnionFind uf(n + 1);
    
    for (auto& edge : edges) {
        if (!uf.unite(edge[0], edge[1])) {
            return edge; // This edge creates cycle
        }
    }
    
    return {};
}
```
</CodeGroup>

## Classic Problems

| Problem | Pattern | Key Insight |
|---------|---------|-------------|
| Number of Islands | Grid connectivity | 2D to 1D mapping |
| Accounts Merge | Email grouping | Union emails, group by root |
| Redundant Connection | Cycle detection | Edge creating cycle |
| Longest Consecutive | Value connectivity | Union consecutive numbers |
| Kruskal's MST | Edge processing | Union in weight order |

## Interview Problems by Company

<Tabs>
  <Tab title="Medium">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Number of Provinces | All FAANG | Basic connectivity |
    | Redundant Connection | Google, Amazon | Cycle detection |
    | Accounts Merge | Meta, Amazon | Email grouping |
    | Satisfiability | Google | Equality constraints |
  </Tab>
  <Tab title="Hard">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Swim in Rising Water | Google | Binary search + UF |
    | Largest Component | Meta | Size tracking |
    | Making A Large Island | Amazon | Virtual unions |
    | Bricks Falling | Google | Reverse time |
  </Tab>
</Tabs>

## Interview Tips

<AccordionGroup>
  <Accordion title="How to Explain Your Approach" icon="comments">
    **Script for interviews:**
    
    1. "I'll use Union Find for efficient connectivity queries."
    2. "I'll implement with path compression and union by rank."
    3. "Find operation compresses the path to root."
    4. "Union attaches smaller tree under larger."
    5. "Both operations are nearly O(1) amortized."
  </Accordion>
  
  <Accordion title="Union Find Template" icon="code">
    ```python
    class UnionFind:
        def __init__(self, n):
            self.parent = list(range(n))
            self.rank = [0] * n
            self.count = n
        
        def find(self, x):
            if self.parent[x] != x:
                self.parent[x] = self.find(self.parent[x])  # Path compression
            return self.parent[x]
        
        def union(self, x, y):
            px, py = self.find(x), self.find(y)
            if px == py:
                return False
            if self.rank[px] < self.rank[py]:
                px, py = py, px
            self.parent[py] = px
            if self.rank[px] == self.rank[py]:
                self.rank[px] += 1
            self.count -= 1
            return True
    ```
  </Accordion>
  
  <Accordion title="Common Variations" icon="gears">
    | Variation | Use Case |
    |-----------|----------|
    | Track component size | Largest component problems |
    | Weighted Union Find | Equations, ratios |
    | 2D to 1D mapping | Grid problems: i * cols + j |
    | Virtual nodes | Connect to boundary/source |
  </Accordion>
</AccordionGroup>

## Practice Problems

<CardGroup cols={2}>
  <Card title="Number of Provinces" icon="circle-nodes" href="https://leetcode.com/problems/number-of-provinces/">
    Connected components
  </Card>
  <Card title="Accounts Merge" icon="users" href="https://leetcode.com/problems/accounts-merge/">
    Email grouping
  </Card>
  <Card title="Redundant Connection" icon="link-slash" href="https://leetcode.com/problems/redundant-connection/">
    Cycle detection
  </Card>
  <Card title="Longest Consecutive" icon="arrow-right-long" href="https://leetcode.com/problems/longest-consecutive-sequence/">
    Value connectivity
  </Card>
</CardGroup>

## Practice Roadmap

<Steps>
  <Step title="Day 1: Basic Union Find">
    - Solve: Number of Provinces, Redundant Connection
    - Focus: Implement find with path compression, union by rank
  </Step>
  <Step title="Day 2: Grid Problems">
    - Solve: Number of Islands (UF approach), Surrounded Regions
    - Focus: 2D to 1D coordinate mapping
  </Step>
  <Step title="Day 3: Advanced Applications">
    - Solve: Accounts Merge, Satisfiability of Equations
    - Focus: Grouping with additional data
  </Step>
  <Step title="Day 4: Hard Problems">
    - Solve: Swim in Rising Water, Making A Large Island
    - Focus: Combining UF with other techniques
  </Step>
</Steps>

<Tip>
**Interview Tip**: When you see "connected components" or "group elements", think Union Find. It's especially powerful when components are built incrementally.
</Tip>
