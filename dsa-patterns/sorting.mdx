---
title: "Sorting Algorithms"
description: "Master essential sorting techniques and their applications"
icon: "arrow-down-a-z"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/20-sorting.svg"
  alt="Sorting Algorithms"
/>

## Overview

**Sorting** arranges elements in a specific order. Understanding various algorithms helps choose the right one for each situation.

## When to Choose Which

<CardGroup cols={2}>
  <Card title="Quick Sort" icon="bolt">
    General purpose, in-place, average O(n log n)
  </Card>
  <Card title="Merge Sort" icon="code-merge">
    Stable, guaranteed O(n log n), linked lists
  </Card>
  <Card title="Heap Sort" icon="mountain">
    In-place, O(n log n), no extra memory
  </Card>
  <Card title="Counting Sort" icon="calculator">
    Linear time for small range integers
  </Card>
</CardGroup>

## Algorithm Implementations

### 1. Quick Sort

<CodeGroup>
```python Python
def quick_sort(arr, low=0, high=None):
    """Average O(n log n), in-place, unstable"""
    if high is None:
        high = len(arr) - 1
    
    if low < high:
        pivot_idx = partition(arr, low, high)
        quick_sort(arr, low, pivot_idx - 1)
        quick_sort(arr, pivot_idx + 1, high)
    
    return arr

def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    
    for j in range(low, high):
        if arr[j] < pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1
```

```java Java
public class QuickSort {
    public void quickSort(int[] arr, int low, int high) {
        // Average O(n log n), in-place, unstable
        if (low < high) {
            int pivotIdx = partition(arr, low, high);
            quickSort(arr, low, pivotIdx - 1);
            quickSort(arr, pivotIdx + 1, high);
        }
    }
    
    private int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

```cpp C++
class QuickSort {
public:
    void quickSort(vector<int>& arr, int low, int high) {
        // Average O(n log n), in-place, unstable
        if (low < high) {
            int pivotIdx = partition(arr, low, high);
            quickSort(arr, low, pivotIdx - 1);
            quickSort(arr, pivotIdx + 1, high);
        }
    }
    
private:
    int partition(vector<int>& arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr[i], arr[j]);
            }
        }
        
        swap(arr[i + 1], arr[high]);
        return i + 1;
    }
};
```
</CodeGroup>

### 2. Merge Sort

<CodeGroup>
```python Python
def merge_sort(arr):
    """O(n log n), stable, O(n) space"""
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```

```java Java
public class MergeSort {
    public int[] mergeSort(int[] arr) {
        // O(n log n), stable, O(n) space
        if (arr.length <= 1) {
            return arr;
        }
        
        int mid = arr.length / 2;
        int[] left = mergeSort(Arrays.copyOfRange(arr, 0, mid));
        int[] right = mergeSort(Arrays.copyOfRange(arr, mid, arr.length));
        
        return merge(left, right);
    }
    
    private int[] merge(int[] left, int[] right) {
        int[] result = new int[left.length + right.length];
        int i = 0, j = 0, k = 0;
        
        while (i < left.length && j < right.length) {
            if (left[i] <= right[j]) {
                result[k++] = left[i++];
            } else {
                result[k++] = right[j++];
            }
        }
        
        while (i < left.length) result[k++] = left[i++];
        while (j < right.length) result[k++] = right[j++];
        
        return result;
    }
}
```

```cpp C++
class MergeSort {
public:
    vector<int> mergeSort(vector<int>& arr) {
        // O(n log n), stable, O(n) space
        if (arr.size() <= 1) {
            return arr;
        }
        
        int mid = arr.size() / 2;
        vector<int> left(arr.begin(), arr.begin() + mid);
        vector<int> right(arr.begin() + mid, arr.end());
        
        left = mergeSort(left);
        right = mergeSort(right);
        
        return merge(left, right);
    }
    
private:
    vector<int> merge(vector<int>& left, vector<int>& right) {
        vector<int> result;
        int i = 0, j = 0;
        
        while (i < left.size() && j < right.size()) {
            if (left[i] <= right[j]) {
                result.push_back(left[i++]);
            } else {
                result.push_back(right[j++]);
            }
        }
        
        while (i < left.size()) result.push_back(left[i++]);
        while (j < right.size()) result.push_back(right[j++]);
        
        return result;
    }
};
```
</CodeGroup>

### 3. Heap Sort

<CodeGroup>
```python Python
def heap_sort(arr):
    """O(n log n), in-place, unstable"""
    n = len(arr)
    
    # Build max heap
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # Extract elements
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
    
    return arr

def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and arr[left] > arr[largest]:
        largest = left
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
```

```java Java
public class HeapSort {
    public void heapSort(int[] arr) {
        // O(n log n), in-place, unstable
        int n = arr.length;
        
        // Build max heap
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        
        // Extract elements
        for (int i = n - 1; i > 0; i--) {
            swap(arr, 0, i);
            heapify(arr, i, 0);
        }
    }
    
    private void heapify(int[] arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        if (largest != i) {
            swap(arr, i, largest);
            heapify(arr, n, largest);
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

```cpp C++
class HeapSort {
public:
    void heapSort(vector<int>& arr) {
        // O(n log n), in-place, unstable
        int n = arr.size();
        
        // Build max heap
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        
        // Extract elements
        for (int i = n - 1; i > 0; i--) {
            swap(arr[0], arr[i]);
            heapify(arr, i, 0);
        }
    }
    
private:
    void heapify(vector<int>& arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        if (largest != i) {
            swap(arr[i], arr[largest]);
            heapify(arr, n, largest);
        }
    }
};
```
</CodeGroup>

### 4. Counting Sort

<CodeGroup>
```python Python
def counting_sort(arr):
    """O(n + k), stable, for small range integers"""
    if not arr:
        return arr
    
    min_val, max_val = min(arr), max(arr)
    range_size = max_val - min_val + 1
    
    count = [0] * range_size
    output = [0] * len(arr)
    
    # Count occurrences
    for num in arr:
        count[num - min_val] += 1
    
    # Cumulative count
    for i in range(1, range_size):
        count[i] += count[i - 1]
    
    # Build output (reverse for stability)
    for num in reversed(arr):
        output[count[num - min_val] - 1] = num
        count[num - min_val] -= 1
    
    return output
```

```java Java
public class CountingSort {
    public int[] countingSort(int[] arr) {
        // O(n + k), stable, for small range integers
        if (arr.length == 0) return arr;
        
        int minVal = Arrays.stream(arr).min().getAsInt();
        int maxVal = Arrays.stream(arr).max().getAsInt();
        int rangeSize = maxVal - minVal + 1;
        
        int[] count = new int[rangeSize];
        int[] output = new int[arr.length];
        
        // Count occurrences
        for (int num : arr) {
            count[num - minVal]++;
        }
        
        // Cumulative count
        for (int i = 1; i < rangeSize; i++) {
            count[i] += count[i - 1];
        }
        
        // Build output (reverse for stability)
        for (int i = arr.length - 1; i >= 0; i--) {
            output[count[arr[i] - minVal] - 1] = arr[i];
            count[arr[i] - minVal]--;
        }
        
        return output;
    }
}
```

```cpp C++
class CountingSort {
public:
    vector<int> countingSort(vector<int>& arr) {
        // O(n + k), stable, for small range integers
        if (arr.empty()) return arr;
        
        int minVal = *min_element(arr.begin(), arr.end());
        int maxVal = *max_element(arr.begin(), arr.end());
        int rangeSize = maxVal - minVal + 1;
        
        vector<int> count(rangeSize, 0);
        vector<int> output(arr.size());
        
        // Count occurrences
        for (int num : arr) {
            count[num - minVal]++;
        }
        
        // Cumulative count
        for (int i = 1; i < rangeSize; i++) {
            count[i] += count[i - 1];
        }
        
        // Build output (reverse for stability)
        for (int i = arr.size() - 1; i >= 0; i--) {
            output[count[arr[i] - minVal] - 1] = arr[i];
            count[arr[i] - minVal]--;
        }
        
        return output;
    }
};
```
</CodeGroup>

## Complexity Comparison

| Algorithm | Best | Average | Worst | Space | Stable |
|-----------|------|---------|-------|-------|--------|
| Quick Sort | O(n log n) | O(n log n) | O(n^2) | O(log n) | No |
| Merge Sort | O(n log n) | O(n log n) | O(n log n) | O(n) | Yes |
| Heap Sort | O(n log n) | O(n log n) | O(n log n) | O(1) | No |
| Counting Sort | O(n + k) | O(n + k) | O(n + k) | O(k) | Yes |

## Practice Problems

<CardGroup cols={2}>
  <Card title="Sort Colors" icon="palette" href="https://leetcode.com/problems/sort-colors/">
    Dutch National Flag algorithm
  </Card>
  <Card title="Kth Largest" icon="ranking-star" href="https://leetcode.com/problems/kth-largest-element-in-an-array/">
    Quick Select technique
  </Card>
  <Card title="Merge Intervals" icon="clock" href="https://leetcode.com/problems/merge-intervals/">
    Sort then merge
  </Card>
  <Card title="Sort List" icon="list-ol" href="https://leetcode.com/problems/sort-list/">
    Merge sort for linked list
  </Card>
</CardGroup>
