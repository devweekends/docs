---
title: "Breadth-First Search (BFS)"
description: "Master BFS for shortest paths and level-order exploration"
icon: "arrows-left-right"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/05-bfs.svg"
  alt="BFS Pattern"
/>

## What is BFS?

**Breadth-First Search** explores all neighbors at the current depth before moving to nodes at the next depth level. It uses a queue and guarantees the shortest path in unweighted graphs.

<Note>
**Quick Recognition**: Shortest path in unweighted graphs, level-order traversal, finding nearest target. Keywords: "minimum steps", "shortest path", "level by level".
</Note>

## Pattern Recognition Checklist

<CardGroup cols={2}>
  <Card title="Use BFS When" icon="check">
    - Finding shortest path (unweighted)
    - Level-order tree traversal
    - Finding nearest target
    - State space exploration (puzzles)
    - Multi-source shortest distances
  </Card>
  <Card title="Don't Use When" icon="xmark">
    - Weighted graph (use Dijkstra)
    - Need to explore deep paths first
    - Memory is very constrained
    - Preorder/inorder/postorder needed
  </Card>
</CardGroup>

## BFS vs DFS Quick Reference

| Aspect | BFS | DFS |
|--------|-----|-----|
| Data Structure | Queue (FIFO) | Stack/Recursion (LIFO) |
| Shortest Path | Yes (unweighted) | No |
| Space Complexity | O(width) | O(height) |
| Use Case | Nearest, level-order | Paths, cycles, connectivity |
| Traversal Order | Level by level | Deep first |

## When to Use

<CardGroup cols={2}>
  <Card title="Shortest Path" icon="route">
    Finding minimum steps in unweighted graphs
  </Card>
  <Card title="Level-Order Traversal" icon="layer-group">
    Processing tree/graph by levels
  </Card>
  <Card title="Nearest Neighbor" icon="location-dot">
    Finding closest target from source
  </Card>
  <Card title="State Space Search" icon="chess-board">
    Puzzle solving, game states
  </Card>
</CardGroup>

## Pattern Variations

### 1. Tree Level-Order Traversal

<CodeGroup>
```python Python
from collections import deque

def level_order(root):
    """Return nodes level by level"""
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)
        current_level = []
        
        for _ in range(level_size):
            node = queue.popleft()
            current_level.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(current_level)
    
    return result
```

```java Java
public List<List<Integer>> levelOrder(TreeNode root) {
    // Return nodes level by level
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        int levelSize = queue.size();
        List<Integer> currentLevel = new ArrayList<>();
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode node = queue.poll();
            currentLevel.add(node.val);
            
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
        
        result.add(currentLevel);
    }
    
    return result;
}
```

```cpp C++
vector<vector<int>> levelOrder(TreeNode* root) {
    // Return nodes level by level
    vector<vector<int>> result;
    if (root == nullptr) {
        return result;
    }
    
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        int levelSize = q.size();
        vector<int> currentLevel;
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            currentLevel.push_back(node->val);
            
            if (node->left) {
                q.push(node->left);
            }
            if (node->right) {
                q.push(node->right);
            }
        }
        
        result.push_back(currentLevel);
    }
    
    return result;
}
```
</CodeGroup>

### 2. Graph BFS (Shortest Path)

<CodeGroup>
```python Python
from collections import deque

def shortest_path(graph, start, end):
    """Find shortest path in unweighted graph"""
    if start == end:
        return 0
    
    queue = deque([(start, 0)])  # (node, distance)
    visited = {start}
    
    while queue:
        node, dist = queue.popleft()
        
        for neighbor in graph[node]:
            if neighbor == end:
                return dist + 1
            
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, dist + 1))
    
    return -1  # No path found
```

```java Java
public int shortestPath(Map<Integer, List<Integer>> graph, int start, int end) {
    // Find shortest path in unweighted graph
    if (start == end) {
        return 0;
    }
    
    Queue<int[]> queue = new LinkedList<>();
    queue.offer(new int[]{start, 0});  // {node, distance}
    Set<Integer> visited = new HashSet<>();
    visited.add(start);
    
    while (!queue.isEmpty()) {
        int[] curr = queue.poll();
        int node = curr[0], dist = curr[1];
        
        for (int neighbor : graph.getOrDefault(node, new ArrayList<>())) {
            if (neighbor == end) {
                return dist + 1;
            }
            
            if (!visited.contains(neighbor)) {
                visited.add(neighbor);
                queue.offer(new int[]{neighbor, dist + 1});
            }
        }
    }
    
    return -1;  // No path found
}
```

```cpp C++
int shortestPath(unordered_map<int, vector<int>>& graph, int start, int end) {
    // Find shortest path in unweighted graph
    if (start == end) {
        return 0;
    }
    
    queue<pair<int, int>> q;  // {node, distance}
    q.push({start, 0});
    unordered_set<int> visited;
    visited.insert(start);
    
    while (!q.empty()) {
        auto [node, dist] = q.front();
        q.pop();
        
        for (int neighbor : graph[node]) {
            if (neighbor == end) {
                return dist + 1;
            }
            
            if (!visited.count(neighbor)) {
                visited.insert(neighbor);
                q.push({neighbor, dist + 1});
            }
        }
    }
    
    return -1;  // No path found
}
```
</CodeGroup>

### 3. Grid BFS

<CodeGroup>
```python Python
from collections import deque

def shortest_path_grid(grid):
    """Find shortest path from top-left to bottom-right"""
    if not grid or grid[0][0] == 1:
        return -1
    
    rows, cols = len(grid), len(grid[0])
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    queue = deque([(0, 0, 1)])  # (row, col, distance)
    visited = {(0, 0)}
    
    while queue:
        r, c, dist = queue.popleft()
        
        if r == rows - 1 and c == cols - 1:
            return dist
        
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            
            if 0 <= nr < rows and 0 <= nc < cols:
                if grid[nr][nc] == 0 and (nr, nc) not in visited:
                    visited.add((nr, nc))
                    queue.append((nr, nc, dist + 1))
    
    return -1
```

```java Java
public int shortestPathGrid(int[][] grid) {
    // Find shortest path from top-left to bottom-right
    if (grid == null || grid.length == 0 || grid[0][0] == 1) {
        return -1;
    }
    
    int rows = grid.length, cols = grid[0].length;
    int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    
    Queue<int[]> queue = new LinkedList<>();
    queue.offer(new int[]{0, 0, 1});  // {row, col, distance}
    boolean[][] visited = new boolean[rows][cols];
    visited[0][0] = true;
    
    while (!queue.isEmpty()) {
        int[] curr = queue.poll();
        int r = curr[0], c = curr[1], dist = curr[2];
        
        if (r == rows - 1 && c == cols - 1) {
            return dist;
        }
        
        for (int[] dir : directions) {
            int nr = r + dir[0], nc = c + dir[1];
            
            if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                if (grid[nr][nc] == 0 && !visited[nr][nc]) {
                    visited[nr][nc] = true;
                    queue.offer(new int[]{nr, nc, dist + 1});
                }
            }
        }
    }
    
    return -1;
}
```

```cpp C++
int shortestPathGrid(vector<vector<int>>& grid) {
    // Find shortest path from top-left to bottom-right
    if (grid.empty() || grid[0][0] == 1) {
        return -1;
    }
    
    int rows = grid.size(), cols = grid[0].size();
    vector<pair<int, int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    
    queue<tuple<int, int, int>> q;  // {row, col, distance}
    q.push({0, 0, 1});
    vector<vector<bool>> visited(rows, vector<bool>(cols, false));
    visited[0][0] = true;
    
    while (!q.empty()) {
        auto [r, c, dist] = q.front();
        q.pop();
        
        if (r == rows - 1 && c == cols - 1) {
            return dist;
        }
        
        for (auto& [dr, dc] : directions) {
            int nr = r + dr, nc = c + dc;
            
            if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                if (grid[nr][nc] == 0 && !visited[nr][nc]) {
                    visited[nr][nc] = true;
                    q.push({nr, nc, dist + 1});
                }
            }
        }
    }
    
    return -1;
}
```
</CodeGroup>

### 4. Multi-Source BFS

<CodeGroup>
```python Python
from collections import deque

def walls_and_gates(rooms):
    """Fill each empty room with distance to nearest gate"""
    if not rooms:
        return
    
    INF = 2147483647
    GATE = 0
    rows, cols = len(rooms), len(rooms[0])
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    # Start BFS from all gates simultaneously
    queue = deque()
    for r in range(rows):
        for c in range(cols):
            if rooms[r][c] == GATE:
                queue.append((r, c))
    
    while queue:
        r, c = queue.popleft()
        
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            
            if 0 <= nr < rows and 0 <= nc < cols:
                if rooms[nr][nc] == INF:  # Empty room
                    rooms[nr][nc] = rooms[r][c] + 1
                    queue.append((nr, nc))
```

```java Java
public void wallsAndGates(int[][] rooms) {
    // Fill each empty room with distance to nearest gate
    if (rooms == null || rooms.length == 0) {
        return;
    }
    
    int INF = Integer.MAX_VALUE;
    int GATE = 0;
    int rows = rooms.length, cols = rooms[0].length;
    int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    
    // Start BFS from all gates simultaneously
    Queue<int[]> queue = new LinkedList<>();
    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols; c++) {
            if (rooms[r][c] == GATE) {
                queue.offer(new int[]{r, c});
            }
        }
    }
    
    while (!queue.isEmpty()) {
        int[] curr = queue.poll();
        int r = curr[0], c = curr[1];
        
        for (int[] dir : directions) {
            int nr = r + dir[0], nc = c + dir[1];
            
            if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                if (rooms[nr][nc] == INF) {  // Empty room
                    rooms[nr][nc] = rooms[r][c] + 1;
                    queue.offer(new int[]{nr, nc});
                }
            }
        }
    }
}
```

```cpp C++
void wallsAndGates(vector<vector<int>>& rooms) {
    // Fill each empty room with distance to nearest gate
    if (rooms.empty()) {
        return;
    }
    
    int INF = INT_MAX;
    int GATE = 0;
    int rows = rooms.size(), cols = rooms[0].size();
    vector<pair<int, int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    
    // Start BFS from all gates simultaneously
    queue<pair<int, int>> q;
    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols; c++) {
            if (rooms[r][c] == GATE) {
                q.push({r, c});
            }
        }
    }
    
    while (!q.empty()) {
        auto [r, c] = q.front();
        q.pop();
        
        for (auto& [dr, dc] : directions) {
            int nr = r + dr, nc = c + dc;
            
            if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                if (rooms[nr][nc] == INF) {  // Empty room
                    rooms[nr][nc] = rooms[r][c] + 1;
                    q.push({nr, nc});
                }
            }
        }
    }
}
```
</CodeGroup>

### 5. Word Ladder (State Space BFS)

<CodeGroup>
```python Python
from collections import deque

def word_ladder(begin_word, end_word, word_list):
    """Find shortest transformation sequence length"""
    word_set = set(word_list)
    if end_word not in word_set:
        return 0
    
    queue = deque([(begin_word, 1)])
    visited = {begin_word}
    
    while queue:
        word, length = queue.popleft()
        
        if word == end_word:
            return length
        
        # Try changing each character
        for i in range(len(word)):
            for c in 'abcdefghijklmnopqrstuvwxyz':
                new_word = word[:i] + c + word[i+1:]
                
                if new_word in word_set and new_word not in visited:
                    visited.add(new_word)
                    queue.append((new_word, length + 1))
    
    return 0
```

```java Java
public int wordLadder(String beginWord, String endWord, List<String> wordList) {
    // Find shortest transformation sequence length
    Set<String> wordSet = new HashSet<>(wordList);
    if (!wordSet.contains(endWord)) {
        return 0;
    }
    
    Queue<String> queue = new LinkedList<>();
    queue.offer(beginWord);
    Set<String> visited = new HashSet<>();
    visited.add(beginWord);
    int length = 1;
    
    while (!queue.isEmpty()) {
        int size = queue.size();
        
        for (int i = 0; i < size; i++) {
            String word = queue.poll();
            
            if (word.equals(endWord)) {
                return length;
            }
            
            char[] chars = word.toCharArray();
            for (int j = 0; j < chars.length; j++) {
                char original = chars[j];
                for (char c = 'a'; c <= 'z'; c++) {
                    chars[j] = c;
                    String newWord = new String(chars);
                    
                    if (wordSet.contains(newWord) && !visited.contains(newWord)) {
                        visited.add(newWord);
                        queue.offer(newWord);
                    }
                }
                chars[j] = original;
            }
        }
        length++;
    }
    
    return 0;
}
```

```cpp C++
int wordLadder(string beginWord, string endWord, vector<string>& wordList) {
    // Find shortest transformation sequence length
    unordered_set<string> wordSet(wordList.begin(), wordList.end());
    if (!wordSet.count(endWord)) {
        return 0;
    }
    
    queue<pair<string, int>> q;
    q.push({beginWord, 1});
    unordered_set<string> visited;
    visited.insert(beginWord);
    
    while (!q.empty()) {
        auto [word, length] = q.front();
        q.pop();
        
        if (word == endWord) {
            return length;
        }
        
        for (int i = 0; i < word.size(); i++) {
            string newWord = word;
            for (char c = 'a'; c <= 'z'; c++) {
                newWord[i] = c;
                
                if (wordSet.count(newWord) && !visited.count(newWord)) {
                    visited.insert(newWord);
                    q.push({newWord, length + 1});
                }
            }
        }
    }
    
    return 0;
}
```
</CodeGroup>

## Classic Problems

<AccordionGroup>
  <Accordion title="1. Binary Tree Level Order Traversal" icon="tree">
    **Pattern**: Process nodes level by level
    
    **Key**: Track level size before processing
  </Accordion>
  
  <Accordion title="2. Rotting Oranges" icon="lemon">
    **Pattern**: Multi-source BFS with time tracking
    
    **Key**: Start from all rotten oranges simultaneously
  </Accordion>
  
  <Accordion title="3. Word Ladder" icon="text">
    **Pattern**: State space BFS
    
    **Key**: Each word is a state, edges are single-char changes
  </Accordion>
  
  <Accordion title="4. 01 Matrix" icon="table-cells">
    **Pattern**: Multi-source BFS from target cells
    
    **Key**: Start from 0s to find distance to nearest 0
  </Accordion>
</AccordionGroup>

## Common Mistakes

<Warning>
**Avoid These Pitfalls:**
1. **Visiting before enqueueing**: Mark visited when adding to queue, not when processing
2. **Forgetting to track distance**: Include distance in queue tuple or use level-by-level
3. **Not handling disconnected components**: BFS from single source won't reach all nodes
4. **Wrong direction iteration**: Process all current level before incrementing distance
</Warning>

## Interview Problems by Company

<Tabs>
  <Tab title="Medium">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Level Order Traversal | All FAANG | Tree BFS |
    | Rotting Oranges | Amazon, Meta | Multi-source BFS |
    | Number of Islands | All FAANG | Grid BFS/DFS |
    | Open the Lock | Google | State space BFS |
    | Shortest Path in Matrix | Meta | Grid BFS |
  </Tab>
  <Tab title="Hard">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Word Ladder | Amazon, Google | State transformation |
    | Sliding Puzzle | Google | State space |
    | Cut Off Trees | Amazon | Multi-BFS |
    | Bus Routes | Google | Multi-source |
  </Tab>
</Tabs>

## Interview Tips

<AccordionGroup>
  <Accordion title="How to Explain Your Approach" icon="comments">
    **Script for interviews:**
    
    1. "I need shortest path in unweighted graph, so I'll use BFS."
    2. "I'll use a queue starting from the source."
    3. "For each level, I process all current nodes before moving deeper."
    4. "I mark nodes visited when enqueuing to avoid duplicates."
    5. "Time is O(V + E), space is O(V) for the queue."
  </Accordion>
  
  <Accordion title="BFS Template" icon="code">
    ```python
    from collections import deque
    
    def bfs(start, target, graph):
        queue = deque([(start, 0)])  # (node, distance)
        visited = {start}
        
        while queue:
            node, dist = queue.popleft()
            
            if node == target:
                return dist
            
            for neighbor in graph[node]:
                if neighbor not in visited:
                    visited.add(neighbor)  # Mark before enqueue!
                    queue.append((neighbor, dist + 1))
        
        return -1  # Not found
    ```
  </Accordion>
  
  <Accordion title="Multi-Source BFS" icon="sitemap">
    For problems like "Rotting Oranges" or "01 Matrix":
    
    1. Add ALL sources to initial queue
    2. Process level by level
    3. All sources expand simultaneously
    4. First to reach a cell = shortest distance
  </Accordion>
</AccordionGroup>

## Practice Problems

| Problem | Difficulty | Link |
|---------|------------|------|
| Binary Tree Level Order | Medium | [LeetCode 102](https://leetcode.com/problems/binary-tree-level-order-traversal/) |
| Rotting Oranges | Medium | [LeetCode 994](https://leetcode.com/problems/rotting-oranges/) |
| Word Ladder | Hard | [LeetCode 127](https://leetcode.com/problems/word-ladder/) |
| Shortest Path in Binary Matrix | Medium | [LeetCode 1091](https://leetcode.com/problems/shortest-path-in-binary-matrix/) |
| Open the Lock | Medium | [LeetCode 752](https://leetcode.com/problems/open-the-lock/) |

## Practice Roadmap

<Steps>
  <Step title="Day 1: Tree BFS">
    - Solve: Level Order Traversal, Right Side View
    - Focus: Level-by-level processing
  </Step>
  <Step title="Day 2: Grid BFS">
    - Solve: Number of Islands, Rotting Oranges
    - Focus: 4-directional movement, multi-source
  </Step>
  <Step title="Day 3: State Space BFS">
    - Solve: Open the Lock, Minimum Genetic Mutation
    - Focus: State as node, transformation as edge
  </Step>
  <Step title="Day 4: Advanced BFS">
    - Solve: Word Ladder, Sliding Puzzle
    - Focus: Complex state representations
  </Step>
</Steps>

<Tip>
**Interview Tip**: When you need shortest path in unweighted graph or level-by-level processing, BFS is the answer.
</Tip>
