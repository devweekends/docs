---
title: "Linked List Patterns"
description: "Master pointer manipulation for linked list problems"
icon: "link"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/14-linked-list.svg"
  alt="Linked List Pattern"
/>

## What is Linked List?

**Linked List** is a linear data structure where elements are connected via pointers. Unlike arrays, it allows O(1) insertions/deletions but O(n) access.

## When to Use

<CardGroup cols={2}>
  <Card title="Fast and Slow Pointers" icon="gauge-high">
    Cycle detection, finding middle
  </Card>
  <Card title="Reversal" icon="rotate-left">
    Reverse entire list or portions
  </Card>
  <Card title="Merging" icon="code-merge">
    Merge sorted lists, intersection
  </Card>
  <Card title="Dummy Node" icon="circle-dot">
    Simplify edge case handling
  </Card>
</CardGroup>

## Pattern Variations

### 1. Fast and Slow Pointers (Floyd's)

<CodeGroup>
```python Python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def has_cycle(head):
    """Detect cycle in linked list"""
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    
    return False

def find_middle(head):
    """Find middle node (second middle if even length)"""
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    return slow
```

```java Java
class ListNode {
    int val;
    ListNode next;
    ListNode(int val) { this.val = val; }
}

public class LinkedListPatterns {
    public boolean hasCycle(ListNode head) {
        // Detect cycle in linked list
        ListNode slow = head, fast = head;
        
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {
                return true;
            }
        }
        
        return false;
    }
    
    public ListNode findMiddle(ListNode head) {
        // Find middle node (second middle if even length)
        ListNode slow = head, fast = head;
        
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        
        return slow;
    }
}
```

```cpp C++
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

class LinkedListPatterns {
public:
    bool hasCycle(ListNode* head) {
        // Detect cycle in linked list
        ListNode* slow = head;
        ListNode* fast = head;
        
        while (fast != nullptr && fast->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast) {
                return true;
            }
        }
        
        return false;
    }
    
    ListNode* findMiddle(ListNode* head) {
        // Find middle node (second middle if even length)
        ListNode* slow = head;
        ListNode* fast = head;
        
        while (fast != nullptr && fast->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
        }
        
        return slow;
    }
};
```
</CodeGroup>

### 2. Reverse Linked List

<CodeGroup>
```python Python
def reverse_list(head):
    """Reverse entire linked list"""
    prev = None
    current = head
    
    while current:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node
    
    return prev

def reverse_between(head, left, right):
    """Reverse nodes from position left to right"""
    dummy = ListNode(0, head)
    prev = dummy
    
    # Move to node before left
    for _ in range(left - 1):
        prev = prev.next
    
    # Reverse from left to right
    current = prev.next
    for _ in range(right - left):
        next_node = current.next
        current.next = next_node.next
        next_node.next = prev.next
        prev.next = next_node
    
    return dummy.next
```

```java Java
public class ReverseLinkedList {
    public ListNode reverseList(ListNode head) {
        // Reverse entire linked list
        ListNode prev = null;
        ListNode current = head;
        
        while (current != null) {
            ListNode nextNode = current.next;
            current.next = prev;
            prev = current;
            current = nextNode;
        }
        
        return prev;
    }
    
    public ListNode reverseBetween(ListNode head, int left, int right) {
        // Reverse nodes from position left to right
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode prev = dummy;
        
        // Move to node before left
        for (int i = 0; i < left - 1; i++) {
            prev = prev.next;
        }
        
        // Reverse from left to right
        ListNode current = prev.next;
        for (int i = 0; i < right - left; i++) {
            ListNode nextNode = current.next;
            current.next = nextNode.next;
            nextNode.next = prev.next;
            prev.next = nextNode;
        }
        
        return dummy.next;
    }
}
```

```cpp C++
class ReverseLinkedList {
public:
    ListNode* reverseList(ListNode* head) {
        // Reverse entire linked list
        ListNode* prev = nullptr;
        ListNode* current = head;
        
        while (current != nullptr) {
            ListNode* nextNode = current->next;
            current->next = prev;
            prev = current;
            current = nextNode;
        }
        
        return prev;
    }
    
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        // Reverse nodes from position left to right
        ListNode* dummy = new ListNode(0);
        dummy->next = head;
        ListNode* prev = dummy;
        
        // Move to node before left
        for (int i = 0; i < left - 1; i++) {
            prev = prev->next;
        }
        
        // Reverse from left to right
        ListNode* current = prev->next;
        for (int i = 0; i < right - left; i++) {
            ListNode* nextNode = current->next;
            current->next = nextNode->next;
            nextNode->next = prev->next;
            prev->next = nextNode;
        }
        
        return dummy->next;
    }
};
```
</CodeGroup>

### 3. Merge Two Sorted Lists

<CodeGroup>
```python Python
def merge_two_lists(l1, l2):
    """Merge two sorted linked lists"""
    dummy = ListNode(0)
    current = dummy
    
    while l1 and l2:
        if l1.val <= l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    
    current.next = l1 or l2
    return dummy.next
```

```java Java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    // Merge two sorted linked lists
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    
    while (l1 != null && l2 != null) {
        if (l1.val <= l2.val) {
            current.next = l1;
            l1 = l1.next;
        } else {
            current.next = l2;
            l2 = l2.next;
        }
        current = current.next;
    }
    
    current.next = (l1 != null) ? l1 : l2;
    return dummy.next;
}
```

```cpp C++
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    // Merge two sorted linked lists
    ListNode* dummy = new ListNode(0);
    ListNode* current = dummy;
    
    while (l1 != nullptr && l2 != nullptr) {
        if (l1->val <= l2->val) {
            current->next = l1;
            l1 = l1->next;
        } else {
            current->next = l2;
            l2 = l2->next;
        }
        current = current->next;
    }
    
    current->next = (l1 != nullptr) ? l1 : l2;
    return dummy->next;
}
```
</CodeGroup>

### 4. Remove Nth Node From End

<CodeGroup>
```python Python
def remove_nth_from_end(head, n):
    """Remove nth node from end using two pointers"""
    dummy = ListNode(0, head)
    slow = fast = dummy
    
    # Move fast n+1 steps ahead
    for _ in range(n + 1):
        fast = fast.next
    
    # Move both until fast reaches end
    while fast:
        slow = slow.next
        fast = fast.next
    
    # Remove nth node
    slow.next = slow.next.next
    return dummy.next
```

```java Java
public ListNode removeNthFromEnd(ListNode head, int n) {
    // Remove nth node from end using two pointers
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode slow = dummy, fast = dummy;
    
    // Move fast n+1 steps ahead
    for (int i = 0; i <= n; i++) {
        fast = fast.next;
    }
    
    // Move both until fast reaches end
    while (fast != null) {
        slow = slow.next;
        fast = fast.next;
    }
    
    // Remove nth node
    slow.next = slow.next.next;
    return dummy.next;
}
```

```cpp C++
ListNode* removeNthFromEnd(ListNode* head, int n) {
    // Remove nth node from end using two pointers
    ListNode* dummy = new ListNode(0);
    dummy->next = head;
    ListNode* slow = dummy;
    ListNode* fast = dummy;
    
    // Move fast n+1 steps ahead
    for (int i = 0; i <= n; i++) {
        fast = fast->next;
    }
    
    // Move both until fast reaches end
    while (fast != nullptr) {
        slow = slow->next;
        fast = fast->next;
    }
    
    // Remove nth node
    slow->next = slow->next->next;
    return dummy->next;
}
```
</CodeGroup>

## Classic Problems

| Problem | Pattern | Key Insight |
|---------|---------|-------------|
| Cycle Detection | Fast/Slow | Floyd's algorithm |
| Middle of List | Fast/Slow | Fast moves 2x speed |
| Reverse List | Iterative | Track prev, curr, next |
| Merge K Lists | Divide/Heap | Merge pairs or use min-heap |
| Intersection | Length Diff | Align starts then traverse |
| Palindrome | Reverse Half | Reverse second half and compare |

## Practice Problems

<CardGroup cols={2}>
  <Card title="Reverse Linked List" icon="rotate-left" href="https://leetcode.com/problems/reverse-linked-list/">
    Basic reversal technique
  </Card>
  <Card title="Linked List Cycle II" icon="circle" href="https://leetcode.com/problems/linked-list-cycle-ii/">
    Find cycle start point
  </Card>
  <Card title="Merge K Sorted Lists" icon="layer-group" href="https://leetcode.com/problems/merge-k-sorted-lists/">
    Divide and conquer or heap
  </Card>
  <Card title="LRU Cache" icon="memory" href="https://leetcode.com/problems/lru-cache/">
    Doubly linked list + HashMap
  </Card>
</CardGroup>
