---
title: "Linked List Patterns"
description: "Master pointer manipulation for linked list problems"
icon: "link"
---

<img
  className="block rounded-lg"
  src="/images/dsa-techniques/14-linked-list.svg"
  alt="Linked List Pattern"
/>

## What is Linked List?

**Linked List** is a linear data structure where elements are connected via pointers. Unlike arrays, it allows O(1) insertions/deletions but O(n) access.

<Note>
**Quick Recognition**: Problems involving pointer manipulation, in-place modifications, or two-pointer techniques on sequences. Keywords: "reverse", "cycle", "merge lists", "middle node".
</Note>

## Pattern Recognition Checklist

<CardGroup cols={2}>
  <Card title="Use Linked List Patterns When" icon="check">
    - Detecting cycles (Floyd's algorithm)
    - Finding middle element
    - Reversing all or part of list
    - Merging sorted lists
    - Checking palindrome structure
    - Removing duplicates
  </Card>
  <Card title="Common Techniques" icon="lightbulb">
    - Dummy head for edge cases
    - Fast/slow pointers for cycle/middle
    - Prev/curr/next for reversal
    - Two-pointer for nth from end
    - In-place to save space
  </Card>
</CardGroup>

## When to Use

<CardGroup cols={2}>
  <Card title="Fast and Slow Pointers" icon="gauge-high">
    Cycle detection, finding middle
  </Card>
  <Card title="Reversal" icon="rotate-left">
    Reverse entire list or portions
  </Card>
  <Card title="Merging" icon="code-merge">
    Merge sorted lists, intersection
  </Card>
  <Card title="Dummy Node" icon="circle-dot">
    Simplify edge case handling
  </Card>
</CardGroup>

## Pattern Variations

### 1. Fast and Slow Pointers (Floyd's)

<CodeGroup>
```python Python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def has_cycle(head):
    """Detect cycle in linked list"""
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    
    return False

def find_middle(head):
    """Find middle node (second middle if even length)"""
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    return slow
```

```java Java
class ListNode {
    int val;
    ListNode next;
    ListNode(int val) { this.val = val; }
}

public class LinkedListPatterns {
    public boolean hasCycle(ListNode head) {
        // Detect cycle in linked list
        ListNode slow = head, fast = head;
        
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {
                return true;
            }
        }
        
        return false;
    }
    
    public ListNode findMiddle(ListNode head) {
        // Find middle node (second middle if even length)
        ListNode slow = head, fast = head;
        
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        
        return slow;
    }
}
```

```cpp C++
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

class LinkedListPatterns {
public:
    bool hasCycle(ListNode* head) {
        // Detect cycle in linked list
        ListNode* slow = head;
        ListNode* fast = head;
        
        while (fast != nullptr && fast->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast) {
                return true;
            }
        }
        
        return false;
    }
    
    ListNode* findMiddle(ListNode* head) {
        // Find middle node (second middle if even length)
        ListNode* slow = head;
        ListNode* fast = head;
        
        while (fast != nullptr && fast->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
        }
        
        return slow;
    }
};
```
</CodeGroup>

### 2. Reverse Linked List

<CodeGroup>
```python Python
def reverse_list(head):
    """Reverse entire linked list"""
    prev = None
    current = head
    
    while current:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node
    
    return prev

def reverse_between(head, left, right):
    """Reverse nodes from position left to right"""
    dummy = ListNode(0, head)
    prev = dummy
    
    # Move to node before left
    for _ in range(left - 1):
        prev = prev.next
    
    # Reverse from left to right
    current = prev.next
    for _ in range(right - left):
        next_node = current.next
        current.next = next_node.next
        next_node.next = prev.next
        prev.next = next_node
    
    return dummy.next
```

```java Java
public class ReverseLinkedList {
    public ListNode reverseList(ListNode head) {
        // Reverse entire linked list
        ListNode prev = null;
        ListNode current = head;
        
        while (current != null) {
            ListNode nextNode = current.next;
            current.next = prev;
            prev = current;
            current = nextNode;
        }
        
        return prev;
    }
    
    public ListNode reverseBetween(ListNode head, int left, int right) {
        // Reverse nodes from position left to right
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode prev = dummy;
        
        // Move to node before left
        for (int i = 0; i < left - 1; i++) {
            prev = prev.next;
        }
        
        // Reverse from left to right
        ListNode current = prev.next;
        for (int i = 0; i < right - left; i++) {
            ListNode nextNode = current.next;
            current.next = nextNode.next;
            nextNode.next = prev.next;
            prev.next = nextNode;
        }
        
        return dummy.next;
    }
}
```

```cpp C++
class ReverseLinkedList {
public:
    ListNode* reverseList(ListNode* head) {
        // Reverse entire linked list
        ListNode* prev = nullptr;
        ListNode* current = head;
        
        while (current != nullptr) {
            ListNode* nextNode = current->next;
            current->next = prev;
            prev = current;
            current = nextNode;
        }
        
        return prev;
    }
    
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        // Reverse nodes from position left to right
        ListNode* dummy = new ListNode(0);
        dummy->next = head;
        ListNode* prev = dummy;
        
        // Move to node before left
        for (int i = 0; i < left - 1; i++) {
            prev = prev->next;
        }
        
        // Reverse from left to right
        ListNode* current = prev->next;
        for (int i = 0; i < right - left; i++) {
            ListNode* nextNode = current->next;
            current->next = nextNode->next;
            nextNode->next = prev->next;
            prev->next = nextNode;
        }
        
        return dummy->next;
    }
};
```
</CodeGroup>

### 3. Merge Two Sorted Lists

<CodeGroup>
```python Python
def merge_two_lists(l1, l2):
    """Merge two sorted linked lists"""
    dummy = ListNode(0)
    current = dummy
    
    while l1 and l2:
        if l1.val <= l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    
    current.next = l1 or l2
    return dummy.next
```

```java Java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    // Merge two sorted linked lists
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    
    while (l1 != null && l2 != null) {
        if (l1.val <= l2.val) {
            current.next = l1;
            l1 = l1.next;
        } else {
            current.next = l2;
            l2 = l2.next;
        }
        current = current.next;
    }
    
    current.next = (l1 != null) ? l1 : l2;
    return dummy.next;
}
```

```cpp C++
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    // Merge two sorted linked lists
    ListNode* dummy = new ListNode(0);
    ListNode* current = dummy;
    
    while (l1 != nullptr && l2 != nullptr) {
        if (l1->val <= l2->val) {
            current->next = l1;
            l1 = l1->next;
        } else {
            current->next = l2;
            l2 = l2->next;
        }
        current = current->next;
    }
    
    current->next = (l1 != nullptr) ? l1 : l2;
    return dummy->next;
}
```
</CodeGroup>

### 4. Remove Nth Node From End

<CodeGroup>
```python Python
def remove_nth_from_end(head, n):
    """Remove nth node from end using two pointers"""
    dummy = ListNode(0, head)
    slow = fast = dummy
    
    # Move fast n+1 steps ahead
    for _ in range(n + 1):
        fast = fast.next
    
    # Move both until fast reaches end
    while fast:
        slow = slow.next
        fast = fast.next
    
    # Remove nth node
    slow.next = slow.next.next
    return dummy.next
```

```java Java
public ListNode removeNthFromEnd(ListNode head, int n) {
    // Remove nth node from end using two pointers
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode slow = dummy, fast = dummy;
    
    // Move fast n+1 steps ahead
    for (int i = 0; i <= n; i++) {
        fast = fast.next;
    }
    
    // Move both until fast reaches end
    while (fast != null) {
        slow = slow.next;
        fast = fast.next;
    }
    
    // Remove nth node
    slow.next = slow.next.next;
    return dummy.next;
}
```

```cpp C++
ListNode* removeNthFromEnd(ListNode* head, int n) {
    // Remove nth node from end using two pointers
    ListNode* dummy = new ListNode(0);
    dummy->next = head;
    ListNode* slow = dummy;
    ListNode* fast = dummy;
    
    // Move fast n+1 steps ahead
    for (int i = 0; i <= n; i++) {
        fast = fast->next;
    }
    
    // Move both until fast reaches end
    while (fast != nullptr) {
        slow = slow->next;
        fast = fast->next;
    }
    
    // Remove nth node
    slow->next = slow->next->next;
    return dummy->next;
}
```
</CodeGroup>

## Classic Problems

| Problem | Pattern | Key Insight |
|---------|---------|-------------|
| Cycle Detection | Fast/Slow | Floyd's algorithm |
| Middle of List | Fast/Slow | Fast moves 2x speed |
| Reverse List | Iterative | Track prev, curr, next |
| Merge K Lists | Divide/Heap | Merge pairs or use min-heap |
| Intersection | Length Diff | Align starts then traverse |
| Palindrome | Reverse Half | Reverse second half and compare |

## Interview Problems by Company

<Tabs>
  <Tab title="Easy">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Reverse List | All FAANG | Basic reversal |
    | Merge Two Lists | All FAANG | Two pointers |
    | Delete Node | Apple, Amazon | No prev access trick |
    | Middle of List | Amazon | Fast/slow |
  </Tab>
  <Tab title="Medium">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Add Two Numbers | All FAANG | Carry handling |
    | Remove Nth from End | Meta, Amazon | Gap technique |
    | Linked List Cycle II | Amazon | Floyd's + cycle start |
    | Copy with Random | All FAANG | Interleaving or HashMap |
    | Reorder List | Meta | Find middle + reverse + merge |
  </Tab>
  <Tab title="Hard">
    | Problem | Company | Key Concept |
    |---------|---------|-------------|
    | Merge K Lists | All FAANG | Heap or divide/conquer |
    | Reverse K Group | Meta, Google | K-reversal |
    | LRU Cache | All FAANG | Doubly linked + HashMap |
  </Tab>
</Tabs>

## Interview Tips

<AccordionGroup>
  <Accordion title="Always Use Dummy Node" icon="circle-dot">
    A dummy node simplifies edge cases when the head might change:
    
    ```python
    def solve(head):
        dummy = ListNode(0)
        dummy.next = head
        # ... operations ...
        return dummy.next  # New head
    ```
  </Accordion>
  
  <Accordion title="Reversal Template" icon="rotate-left">
    ```python
    def reverse(head):
        prev, curr = None, head
        while curr:
            next_node = curr.next
            curr.next = prev
            prev = curr
            curr = next_node
        return prev  # New head
    ```
  </Accordion>
  
  <Accordion title="Floyd's Cycle Detection" icon="circle">
    1. **Detect cycle**: Fast catches slow = cycle exists
    2. **Find start**: Reset one to head, move both at same speed
    
    ```python
    def find_cycle_start(head):
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:  # Cycle found
                slow = head
                while slow != fast:
                    slow = slow.next
                    fast = fast.next
                return slow  # Cycle start
        return None
    ```
  </Accordion>
</AccordionGroup>

## Practice Problems

<CardGroup cols={2}>
  <Card title="Reverse Linked List" icon="rotate-left" href="https://leetcode.com/problems/reverse-linked-list/">
    Basic reversal technique
  </Card>
  <Card title="Linked List Cycle II" icon="circle" href="https://leetcode.com/problems/linked-list-cycle-ii/">
    Find cycle start point
  </Card>
  <Card title="Merge K Sorted Lists" icon="layer-group" href="https://leetcode.com/problems/merge-k-sorted-lists/">
    Divide and conquer or heap
  </Card>
  <Card title="LRU Cache" icon="memory" href="https://leetcode.com/problems/lru-cache/">
    Doubly linked list + HashMap
  </Card>
</CardGroup>

## Practice Roadmap

<Steps>
  <Step title="Day 1: Basic Operations">
    - Solve: Reverse List, Merge Two Lists
    - Focus: Pointer manipulation
  </Step>
  <Step title="Day 2: Fast/Slow Pointers">
    - Solve: Middle of List, Cycle Detection, Cycle II
    - Focus: Floyd's algorithm
  </Step>
  <Step title="Day 3: In-Place Modifications">
    - Solve: Reorder List, Palindrome Linked List
    - Focus: Combining techniques
  </Step>
  <Step title="Day 4: Advanced">
    - Solve: LRU Cache, Merge K Lists, Reverse K Group
    - Focus: Design + complex operations
  </Step>
</Steps>

<Tip>
**Interview Tip**: Draw the linked list! Visualizing pointer changes helps avoid bugs. Always consider: What if head is null? What if only one node?
</Tip>
