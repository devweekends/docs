---
title: "API Design"
description: "REST, GraphQL, API versioning, rate limiting, and best practices"
icon: "plug"
---

## Why API Design Matters

APIs are contracts between services. Good API design leads to:

- **Developer Experience** - Easy to use and understand
- **Maintainability** - Evolve without breaking clients
- **Performance** - Efficient data transfer
- **Security** - Protected resources

## REST API Design

### Resource-Based URLs

```
┌─────────────────────────────────────────────────────────────────┐
│                    RESTful URL Design                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  [Good] (Resource-based):                                      │
│  ─────────────────────────                                      │
│  GET    /users              → List all users                   │
│  POST   /users              → Create a user                    │
│  GET    /users/123          → Get user 123                     │
│  PUT    /users/123          → Replace user 123                 │
│  PATCH  /users/123          → Update user 123                  │
│  DELETE /users/123          → Delete user 123                  │
│                                                                 │
│  GET    /users/123/orders   → Get orders for user 123          │
│  POST   /users/123/orders   → Create order for user 123        │
│                                                                 │
│  [Bad] (Action-based):                                         │
│  ─────────────────────────                                      │
│  GET    /getUsers                                               │
│  POST   /createUser                                             │
│  POST   /deleteUser/123                                         │
│  GET    /getUserOrders?userId=123                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Query Parameters

```
┌─────────────────────────────────────────────────────────────────┐
│                    Query Parameters                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Filtering:                                                     │
│  GET /products?category=electronics&price_min=100&in_stock=true │
│                                                                 │
│  Pagination:                                                    │
│  GET /users?page=2&per_page=20                                  │
│  GET /users?offset=40&limit=20                                  │
│  GET /users?cursor=eyJpZCI6MTIzfQ==                             │
│                                                                 │
│  Sorting:                                                       │
│  GET /products?sort=price          (ascending)                  │
│  GET /products?sort=-price         (descending)                 │
│  GET /products?sort=category,-price (multiple)                  │
│                                                                 │
│  Field Selection:                                               │
│  GET /users/123?fields=id,name,email                            │
│                                                                 │
│  Search:                                                        │
│  GET /products?q=laptop                                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Response Structure

```json
// Success Response
{
  "success": true,
  "data": {
    "id": 123,
    "name": "John Doe",
    "email": "john@example.com",
    "created_at": "2024-01-15T10:30:00Z"
  },
  "meta": {
    "request_id": "req_abc123"
  }
}

// List Response with Pagination
{
  "success": true,
  "data": [
    { "id": 1, "name": "User 1" },
    { "id": 2, "name": "User 2" }
  ],
  "pagination": {
    "page": 1,
    "per_page": 20,
    "total": 150,
    "total_pages": 8,
    "next_cursor": "eyJpZCI6MjB9"
  }
}

// Error Response
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid email format",
    "details": [
      {
        "field": "email",
        "message": "Must be a valid email address"
      }
    ]
  },
  "meta": {
    "request_id": "req_def456"
  }
}
```

### Pagination Strategies

```
┌─────────────────────────────────────────────────────────────────┐
│                    Pagination Comparison                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Offset Pagination                                           │
│     GET /users?offset=40&limit=20                               │
│     SQL: SELECT * FROM users LIMIT 20 OFFSET 40                │
│     + Simple, supports jumping to any page                     │
│     - Slow for large offsets (scans skipped rows)              │
│     - Inconsistent with concurrent writes                      │
│                                                                 │
│  2. Cursor Pagination                                           │
│     GET /users?cursor=eyJpZCI6MTIzfQ==&limit=20                 │
│     SQL: SELECT * FROM users WHERE id > 123 LIMIT 20           │
│     + Consistent, fast for any position                        │
│     + Handles concurrent writes well                           │
│     - Can't jump to arbitrary pages                            │
│     - Cursor can be complex for multi-column sorts             │
│                                                                 │
│  3. Keyset Pagination (cursor variant)                          │
│     GET /users?after_id=123&limit=20                            │
│     + Simple cursor format                                     │
│     + Works with indexes                                       │
│                                                                 │
│  Recommendation: Use cursor for large datasets                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## GraphQL

### GraphQL vs REST

```
REST                                GraphQL
───────────────────────            ───────────────────────

GET /users/123                     query {
→ All user fields                    user(id: 123) {
                                       id
GET /users/123/posts                   name
→ All posts                            posts {
                                         title
GET /users/123/followers               }
→ All followers                        followersCount
                                     }
3 requests                          }
Over-fetching data                  
                                    1 request
                                    Exact data needed
```

### GraphQL Schema Example

```graphql
type User {
  id: ID!
  name: String!
  email: String!
  posts: [Post!]!
  followers: [User!]!
  followersCount: Int!
  createdAt: DateTime!
}

type Post {
  id: ID!
  title: String!
  content: String!
  author: User!
  comments: [Comment!]!
  likes: Int!
}

type Query {
  user(id: ID!): User
  users(limit: Int, offset: Int): [User!]!
  post(id: ID!): Post
  feed(userId: ID!, limit: Int): [Post!]!
}

type Mutation {
  createUser(input: CreateUserInput!): User!
  updateUser(id: ID!, input: UpdateUserInput!): User!
  deleteUser(id: ID!): Boolean!
  createPost(input: CreatePostInput!): Post!
}

type Subscription {
  postCreated(userId: ID!): Post!
  commentAdded(postId: ID!): Comment!
}
```

### GraphQL Trade-offs

<CardGroup cols={2}>
  <Card title="GraphQL Pros" icon="check">
    - Fetch exactly what you need
    - Single endpoint
    - Strong typing
    - Self-documenting (introspection)
    - Great for complex, nested data
    - Reduces over/under-fetching
  </Card>
  <Card title="GraphQL Cons" icon="xmark">
    - Caching is harder (no HTTP cache)
    - N+1 query problem
    - Rate limiting complexity
    - File uploads are awkward
    - Learning curve
    - Performance monitoring harder
  </Card>
</CardGroup>

### N+1 Problem & DataLoader

```
┌─────────────────────────────────────────────────────────────────┐
│                    N+1 Problem in GraphQL                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Query:                                                         │
│  query {                                                        │
│    posts(limit: 10) {                                          │
│      title                                                      │
│      author { name }   ← Fetches author for EACH post          │
│    }                                                            │
│  }                                                              │
│                                                                 │
│  [Bad] Without DataLoader (11 queries):                            │
│  1. SELECT * FROM posts LIMIT 10                               │
│  2. SELECT * FROM users WHERE id = 1                           │
│  3. SELECT * FROM users WHERE id = 2                           │
│  ... (N more queries)                                          │
│                                                                 │
│  [Good] With DataLoader (2 queries):                                │
│  1. SELECT * FROM posts LIMIT 10                               │
│  2. SELECT * FROM users WHERE id IN (1, 2, 3, ...)            │
│                                                                 │
│  DataLoader batches requests within the same tick              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## API Versioning

### Versioning Strategies

```
┌─────────────────────────────────────────────────────────────────┐
│                    API Versioning Strategies                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. URL Path Versioning (Most Common)                           │
│     GET /v1/users/123                                           │
│     GET /v2/users/123                                           │
│     + Clear, easy to implement                                 │
│     - URL pollution, hard to deprecate                         │
│                                                                 │
│  2. Query Parameter                                             │
│     GET /users/123?version=2                                    │
│     + Optional, backwards compatible                           │
│     - Can be missed, caching issues                            │
│                                                                 │
│  3. Header Versioning                                           │
│     GET /users/123                                              │
│     Header: Accept: application/vnd.api+json;version=2         │
│     + Clean URLs, semantic                                     │
│     - Hidden, harder to test                                   │
│                                                                 │
│  4. Content Negotiation                                         │
│     Header: Accept: application/vnd.company.api.v2+json        │
│     + RESTful, flexible                                        │
│     - Complex, client overhead                                 │
│                                                                 │
│  Recommendation: URL path for public APIs, headers for internal│
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Version Migration Strategy

```
Timeline for API Version Deprecation
─────────────────────────────────────────────────────────

v1 Launch    v2 Launch    v1 Deprecated    v1 Sunset
    │            │              │              │
    │◄──────────►│◄────────────►│◄────────────►│
    │   Active   │   Migration  │   Warning    │
    │            │    Period    │   Period     │
    │            │   (6 months) │  (3 months)  │
    
Communication:
- Announce v2 with migration guide
- Add deprecation headers to v1
- Email users with timelines
- Provide breaking change logs
- Offer migration support
```

## Rate Limiting

### Common Algorithms

```
┌─────────────────────────────────────────────────────────────────┐
│                    Rate Limiting Algorithms                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Fixed Window                                                │
│     ┌─────────────────┬─────────────────┐                      │
│     │   Window 1      │   Window 2      │                      │
│     │   100 requests  │   100 requests  │                      │
│     │   00:00-01:00   │   01:00-02:00   │                      │
│     └─────────────────┴─────────────────┘                      │
│     ⚠️ Burst at window boundary (200 req in 2 seconds)         │
│                                                                 │
│  2. Sliding Window Log                                          │
│     Track timestamp of each request                             │
│     Count requests in last N seconds                            │
│     + Accurate, - Memory intensive                            │
│                                                                 │
│  3. Sliding Window Counter                                      │
│     Weighted average of current + previous window              │
│     + Memory efficient, + Smooth                              │
│                                                                 │
│  4. Token Bucket                                                │
│     ┌─────────────────────┐                                    │
│     │  Bucket (capacity)  │ ← Tokens added at fixed rate       │
│     │  ████████░░░░░░░░   │                                    │
│     │  (8/15 tokens)      │                                    │
│     └──────────┬──────────┘                                    │
│                │                                                │
│     Request takes 1 token                                      │
│     + Allows bursts up to capacity                            │
│                                                                 │
│  5. Leaky Bucket                                                │
│     Requests queue and process at fixed rate                   │
│     + Smooth output rate                                       │
│     - No burst handling                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Rate Limit Headers

```http
HTTP/1.1 200 OK
X-RateLimit-Limit: 1000
X-RateLimit-Remaining: 998
X-RateLimit-Reset: 1640000000
X-RateLimit-Reset-After: 3600

# When rate limited:
HTTP/1.1 429 Too Many Requests
Retry-After: 60
Content-Type: application/json

{
  "error": {
    "code": "RATE_LIMIT_EXCEEDED",
    "message": "Rate limit exceeded. Try again in 60 seconds.",
    "retry_after": 60
  }
}
```

### Distributed Rate Limiting

```
┌─────────────────────────────────────────────────────────────────┐
│               Distributed Rate Limiting with Redis              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                        ┌─────────┐                             │
│                        │  Redis  │  Central counter            │
│                        └────┬────┘                             │
│                             │                                   │
│         ┌───────────────────┼───────────────────┐              │
│         │                   │                   │               │
│    ┌────▼────┐         ┌────▼────┐         ┌────▼────┐        │
│    │ API 1   │         │ API 2   │         │ API 3   │        │
│    └─────────┘         └─────────┘         └─────────┘        │
│                                                                 │
│  Lua Script (atomic):                                          │
│  local current = redis.call('INCR', key)                       │
│  if current == 1 then                                          │
│      redis.call('EXPIRE', key, window_seconds)                 │
│  end                                                            │
│  return current <= limit                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## Authentication & Authorization

### Auth Patterns

```
┌─────────────────────────────────────────────────────────────────┐
│                    Authentication Methods                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. API Keys                                                    │
│     Header: X-API-Key: abc123                                   │
│     + Simple                                                   │
│     - Can't expire, no user context                            │
│     Use: Server-to-server, public APIs                         │
│                                                                 │
│  2. Bearer Tokens (JWT)                                         │
│     Header: Authorization: Bearer eyJhbGciOiJIUzI1...          │
│     + Stateless, contains claims                               │
│     - Can't revoke until expiry                                │
│     Use: User authentication                                    │
│                                                                 │
│  3. OAuth 2.0                                                   │
│     ┌────────┐    ┌────────┐    ┌────────┐                     │
│     │  User  │───►│  Auth  │───►│  App   │                     │
│     │        │◄───│ Server │◄───│        │                     │
│     └────────┘    └────────┘    └────────┘                     │
│     Use: Third-party access, SSO                               │
│                                                                 │
│  4. Session Cookies                                             │
│     Set-Cookie: session_id=abc123; HttpOnly; Secure            │
│     + Simple, can revoke server-side                          │
│     - CSRF vulnerability, not for APIs                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### JWT Structure

```
Header.Payload.Signature

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4iLCJpYXQiOjE1MTYyMzkwMjJ9.
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

┌─────────────────────────────────────────────────────────────────┐
│  Header (Base64)    │  Payload (Base64)   │  Signature         │
├─────────────────────┼─────────────────────┼─────────────────────┤
│  {                  │  {                  │  HMACSHA256(        │
│    "alg": "HS256",  │    "sub": "123",    │    base64(header) + │
│    "typ": "JWT"     │    "name": "John",  │    "." +            │
│  }                  │    "role": "admin", │    base64(payload), │
│                     │    "exp": 16500..., │    secret           │
│                     │    "iat": 16490...  │  )                  │
│                     │  }                  │                     │
└─────────────────────┴─────────────────────┴─────────────────────┘
```

## Idempotency

### Why Idempotency Matters

```
┌─────────────────────────────────────────────────────────────────┐
│                    The Problem                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Client                              Server                     │
│     │                                   │                       │
│     │──── POST /charge (card) ─────────►│                      │
│     │                                   │ Process payment       │
│     │         ❌ Network timeout ❌      │ $100 charged         │
│     │◄─── [Connection lost] ────────────│                      │
│     │                                   │                       │
│     │ "Did it work? Let me retry..."   │                       │
│     │                                   │                       │
│     │──── POST /charge (card) ─────────►│                      │
│     │                                   │ Process payment       │
│     │◄─── 200 OK ───────────────────────│ $100 charged AGAIN!  │
│                                                                 │
│  Customer charged $200 instead of $100!                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Idempotency Key Pattern

```
┌─────────────────────────────────────────────────────────────────┐
│                    Idempotency Key Solution                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Request:                                                       │
│  POST /v1/charges                                               │
│  Idempotency-Key: unique-request-id-123                         │
│  Content-Type: application/json                                 │
│                                                                 │
│  { "amount": 100, "currency": "USD", ... }                     │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   Server Logic                          │   │
│  │                                                         │   │
│  │  1. Check if idempotency_key exists in Redis/DB        │   │
│  │     → If exists: return cached response                │   │
│  │     → If not: continue                                  │   │
│  │                                                         │   │
│  │  2. Store idempotency_key with status "processing"     │   │
│  │                                                         │   │
│  │  3. Process the request                                 │   │
│  │                                                         │   │
│  │  4. Store response with idempotency_key               │   │
│  │     (TTL: 24 hours)                                    │   │
│  │                                                         │   │
│  │  5. Return response                                     │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## API Documentation

### OpenAPI/Swagger Example

```yaml
openapi: 3.0.0
info:
  title: User API
  version: 1.0.0
  description: API for managing users

servers:
  - url: https://api.example.com/v1

paths:
  /users:
    get:
      summary: List all users
      parameters:
        - name: page
          in: query
          schema:
            type: integer
            default: 1
        - name: limit
          in: query
          schema:
            type: integer
            default: 20
            maximum: 100
      responses:
        '200':
          description: Successful response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserList'
    post:
      summary: Create a user
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateUser'
      responses:
        '201':
          description: User created
        '400':
          description: Validation error

components:
  schemas:
    User:
      type: object
      properties:
        id:
          type: integer
        name:
          type: string
        email:
          type: string
          format: email
```

## Best Practices Summary

| Category | Best Practice |
|----------|---------------|
| **URLs** | Use nouns, plural resources, kebab-case |
| **Methods** | Use correct HTTP methods (GET=read, POST=create, etc.) |
| **Status Codes** | Return appropriate codes (201 for create, 204 for delete) |
| **Errors** | Consistent error format with codes and messages |
| **Versioning** | Plan for it from day 1, use URL path for public APIs |
| **Pagination** | Use cursor-based for large datasets |
| **Rate Limiting** | Implement early, return helpful headers |
| **Idempotency** | Require for all non-read operations |
| **Documentation** | Auto-generate from code when possible |

<Tip>
**Interview Tip**: When designing an API in an interview, start by identifying resources, define endpoints, discuss authentication, mention rate limiting, and talk about error handling. This shows comprehensive API design thinking.
</Tip>
