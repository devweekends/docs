---
title: "Interview Guide & Cheatsheet"
description: "Complete system design interview preparation guide with frameworks, templates, and tips"
icon: "clipboard-check"
---

<Frame>
  <img src="/images/system-design/interview-framework.svg" alt="System Design Interview Framework" />
</Frame>

## The System Design Interview

System design interviews test your ability to design large-scale distributed systems. Unlike coding interviews, there's no single "correct" answer—interviewers evaluate your **thought process, communication, and trade-off analysis**.

<Note>
**What interviewers are looking for:**
1. Can you drive the conversation and ask good questions?
2. Do you understand scalability and distributed systems?
3. Can you identify and solve bottlenecks?
4. Do you make reasonable trade-offs and justify them?
5. Can you communicate complex ideas clearly?
</Note>

## Interview Framework (45 minutes)

```
┌─────────────────────────────────────────────────────────────────┐
│              System Design Interview Timeline                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  0:00 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 0:45   │
│                                                                 │
│  ┌─────────┐ ┌─────────┐ ┌───────────────┐ ┌─────────────────┐ │
│  │ Require-│ │  Esti-  │ │  High-Level   │ │   Deep Dive +   │ │
│  │  ments  │ │ mation  │ │    Design     │ │   Bottlenecks   │ │
│  │  5 min  │ │  5 min  │ │    10 min     │ │     25 min      │ │
│  └─────────┘ └─────────┘ └───────────────┘ └─────────────────┘ │
│                                                                 │
│  Don't rush!  Show your   Draw as you     Focus on 2-3        │
│  Ask questions math!      explain         components deeply    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## Step 1: Requirements Clarification (5 min)

**Never skip this step!** Jumping to solutions is the #1 mistake candidates make.

### Questions to Ask

<Tabs>
  <Tab title="Functional">
    ```
    Core Features:
    □ "What are the most important features to focus on?"
    □ "Who are the users? What actions can they take?"
    □ "What does the user flow look like?"
    
    Scope:
    □ "Should we design the entire system or focus on X?"
    □ "Are there any features we should NOT include?"
    □ "Mobile app, web, or both?"
    
    Data:
    □ "What data do we need to store?"
    □ "What are the relationships between entities?"
    □ "Do we need to support search?"
    ```
  </Tab>
  <Tab title="Non-Functional">
    ```
    Scale:
    □ "How many users? DAU/MAU?"
    □ "How many requests per second?"
    □ "Read-heavy or write-heavy?"
    
    Performance:
    □ "What's the acceptable latency?"
    □ "What's the availability target? (99.9%?)"
    
    Consistency:
    □ "Is strong consistency required?"
    □ "Can we tolerate eventual consistency?"
    
    Other:
    □ "Any geographic distribution requirements?"
    □ "Any compliance/security requirements?"
    ```
  </Tab>
  <Tab title="Example Dialogue">
    ```
    Interviewer: "Design Twitter"
    
    You: "Before I start, I'd like to clarify a few things.
    
    For scope - should I focus on the core features like 
    posting tweets and the timeline, or also include 
    search, trending, and direct messages?
    
    For scale - are we designing for Twitter's actual 
    scale of ~500M users, or a smaller subset?
    
    For consistency - is it acceptable if a tweet takes 
    a few seconds to appear in all followers' timelines?
    
    ...Great, so I'll focus on posting and timeline for 
    500M users with eventual consistency. Let me start 
    with some capacity estimates..."
    ```
  </Tab>
</Tabs>

## Step 2: Capacity Estimation (5 min)

### Quick Formulas

```python
# Daily Active Users → QPS
QPS = DAU × actions_per_user / 86400
Peak_QPS = QPS × 3

# Example: 100M DAU, 10 actions/user
QPS = 100M × 10 / 100K = 10,000 QPS
Peak = 30,000 QPS

# Storage
Daily_Storage = DAU × actions × size_per_action
Yearly_Storage = Daily × 365

# Example: 100M users × 2 posts × 500 bytes
Daily = 100GB, Yearly = 36TB
```

### Numbers You Must Know

| Metric | Value | Rounded |
|--------|-------|---------|
| Seconds/day | 86,400 | ~100,000 |
| Seconds/month | 2.6M | ~2.5M |
| Seconds/year | 31.5M | ~30M |

| Latency | Time |
|---------|------|
| Memory access | 100 ns |
| SSD read | 100 μs |
| Network (same DC) | 0.5 ms |
| Network (cross-continent) | 150 ms |

| Capacity | Per Server |
|----------|------------|
| Concurrent connections | 10K-100K |
| Simple API QPS | 1K-10K |
| Complex API QPS | 100-500 |

<Tip>
**Say your assumptions out loud!** "I'll assume 86,400 is about 100,000 for easy math..." This shows you understand approximation and makes your calculations easy to follow.
</Tip>

## Step 3: High-Level Design (10 min)

### The Standard Architecture

Start with this template and modify based on requirements:

```
┌─────────────────────────────────────────────────────────────────┐
│                    Generic System Template                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                         ┌──────────┐                           │
│                         │ Clients  │                           │
│                         └────┬─────┘                           │
│                              │                                  │
│                         ┌────▼─────┐                           │
│                         │   CDN    │ (static assets, media)    │
│                         └────┬─────┘                           │
│                              │                                  │
│                         ┌────▼─────┐                           │
│                         │   LB     │ (load balancer)           │
│                         └────┬─────┘                           │
│                              │                                  │
│         ┌────────────────────┼────────────────────┐            │
│         │                    │                    │             │
│    ┌────▼────┐          ┌────▼────┐          ┌────▼────┐      │
│    │ Service │          │ Service │          │ Service │      │
│    │   A     │          │   B     │          │   C     │      │
│    └────┬────┘          └────┬────┘          └────┬────┘      │
│         │                    │                    │             │
│    ┌────▼────┐          ┌────▼────┐          ┌────▼────┐      │
│    │ Cache   │          │ Queue   │          │ Cache   │      │
│    │ (Redis) │          │ (Kafka) │          │ (Redis) │      │
│    └────┬────┘          └────┬────┘          └────┬────┘      │
│         │                    │                    │             │
│         └────────────────────┼────────────────────┘            │
│                              │                                  │
│                    ┌─────────▼─────────┐                       │
│                    │     Database      │                       │
│                    │  (Primary + Replicas)                     │
│                    └───────────────────┘                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### When to Add Components

| Component | Add When... |
|-----------|-------------|
| **CDN** | Serving static files, global users |
| **Load Balancer** | Multiple servers (always) |
| **Cache (Redis)** | Read-heavy, repeated queries |
| **Message Queue** | Async processing, decoupling |
| **Search (Elasticsearch)** | Full-text search needed |
| **Blob Storage (S3)** | Images, videos, files |
| **Rate Limiter** | Public API, preventing abuse |

### API Design Template

```
Always define 2-3 core APIs:

POST /api/v1/tweets
─────────────────────────────────────────────
Request:
{
  "content": "Hello world",
  "media_ids": ["abc123"]
}

Response:
{
  "tweet_id": "123456",
  "created_at": "2024-01-15T10:30:00Z"
}

─────────────────────────────────────────────

GET /api/v1/feed?user_id=123&cursor=xxx&limit=20
─────────────────────────────────────────────
Response:
{
  "tweets": [...],
  "next_cursor": "yyy"
}
```

## Step 4: Deep Dive (20 min)

### What to Deep Dive On

The interviewer will guide you, but be prepared to discuss:

<CardGroup cols={2}>
  <Card title="Data Model" icon="database">
    - Table schemas
    - Relationships
    - Indexing strategy
    - Sharding key selection
  </Card>
  <Card title="Scaling" icon="chart-line">
    - Horizontal vs vertical
    - Caching strategy
    - Database partitioning
    - Read replicas
  </Card>
  <Card title="Core Algorithm" icon="code">
    - News feed generation
    - Matching algorithm
    - Ranking/scoring
    - Rate limiting
  </Card>
  <Card title="Reliability" icon="shield">
    - Failure handling
    - Data replication
    - Consistency guarantees
    - Monitoring/alerting
  </Card>
</CardGroup>

### Database Schema Template

```sql
-- Always include:
-- 1. Primary key (usually BIGINT or UUID)
-- 2. Created/updated timestamps
-- 3. Indexes for common queries

CREATE TABLE users (
    id              BIGINT PRIMARY KEY,
    username        VARCHAR(50) UNIQUE NOT NULL,
    email           VARCHAR(255) UNIQUE NOT NULL,
    password_hash   VARCHAR(255) NOT NULL,
    created_at      TIMESTAMP DEFAULT NOW(),
    updated_at      TIMESTAMP DEFAULT NOW()
);

-- Index for login
CREATE INDEX idx_users_email ON users(email);

-- Think about:
-- □ What queries will we run?
-- □ Which columns need indexes?
-- □ How will we shard if needed?
-- □ What's the partition key?
```

## Step 5: Bottlenecks & Trade-offs (5 min)

### Common Bottlenecks

```
┌─────────────────────────────────────────────────────────────────┐
│                    Bottleneck Checklist                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  □ Single Points of Failure                                    │
│    → Add redundancy (multiple servers, replicas)               │
│                                                                 │
│  □ Database Bottleneck                                          │
│    → Read replicas, caching, sharding                          │
│                                                                 │
│  □ Hot Partitions                                               │
│    → Better shard key, consistent hashing                      │
│                                                                 │
│  □ Cascading Failures                                           │
│    → Circuit breakers, bulkheads, timeouts                     │
│                                                                 │
│  □ Network Latency                                              │
│    → CDN, edge caching, geographic distribution                │
│                                                                 │
│  □ Write Amplification                                          │
│    → Async writes, batching, fan-out optimization              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Trade-off Discussions

Always mention trade-offs. This shows senior thinking:

| Decision | Trade-off |
|----------|-----------|
| **SQL vs NoSQL** | Consistency vs Scale |
| **Sync vs Async** | Latency vs Reliability |
| **Cache** | Speed vs Staleness |
| **Denormalization** | Read speed vs Write complexity |
| **Microservices** | Flexibility vs Complexity |
| **Strong consistency** | Correctness vs Availability |

```
Good answer pattern:

"I chose X over Y because [requirement]. 
The trade-off is [downside], but we can 
mitigate this by [solution]."

Example:

"I chose eventual consistency for the timeline 
because low latency is more important than seeing 
tweets immediately. The trade-off is users might 
not see a tweet for a few seconds, but this is 
acceptable for a social feed."
```

## Quick Reference: Component Cheatsheet

### Databases

| Type | Examples | Use When |
|------|----------|----------|
| **SQL** | PostgreSQL, MySQL | ACID, complex queries, joins |
| **Key-Value** | Redis, DynamoDB | Simple lookups, caching, sessions |
| **Document** | MongoDB | Flexible schema, hierarchical data |
| **Wide-Column** | Cassandra, HBase | High write throughput, time-series |
| **Graph** | Neo4j | Relationships, recommendations |
| **Search** | Elasticsearch | Full-text search, logs |

### Caching Patterns

| Pattern | How It Works | Use When |
|---------|--------------|----------|
| **Cache-Aside** | App checks cache, then DB | Read-heavy, cache misses OK |
| **Write-Through** | Write to cache + DB together | Need consistency |
| **Write-Behind** | Write to cache, async to DB | High write throughput |
| **Read-Through** | Cache loads from DB on miss | Simplify app logic |

### Message Queue Patterns

| Pattern | Use Case |
|---------|----------|
| **Point-to-Point** | Task distribution, job queues |
| **Pub/Sub** | Event broadcasting, notifications |
| **Event Sourcing** | Audit log, state reconstruction |
| **CQRS** | Separate read/write models |

## Red Flags to Avoid

<Warning>
**Things that will hurt your interview:**

- **Jumping to solution** without asking questions

- **Silent thinking** for too long (think out loud!)

- **No numbers** - always do capacity estimation

- **Over-engineering** - start simple, add complexity

- **Ignoring trade-offs** - everything has a cost

- **Not drawing** - use diagrams to communicate

- **Single solution** - discuss alternatives

- **Forgetting failures** - systems fail, plan for it
</Warning>

## Green Flags That Impress

<Tip>
**Things that will help your interview:**

+ **Ask clarifying questions** before designing

+ **Think out loud** - share your reasoning

+ **Use real numbers** - show you understand scale

+ **Draw as you explain** - visual communication

+ **Discuss trade-offs** - show senior thinking

+ **Consider failures** - what happens when X fails?

+ **Be structured** - follow the framework

+ **Know when to stop** - don't over-design
</Tip>

## Practice Problems by Level

### Entry Level (30 min)
1. URL Shortener
2. Paste bin
3. Rate Limiter
4. Key-Value Store

### Mid Level (45 min)
5. Twitter Timeline
6. Instagram
7. WhatsApp
8. Notification System
9. Web Crawler

### Senior Level (60 min)
10. YouTube
11. Google Search
12. Uber/Lyft
13. Distributed Cache
14. Payment System
15. Ticket Booking (BookMyShow)

---

## Final Checklist Before Interview

```
□ Review the framework (5-5-10-20-5 minutes)
□ Memorize key numbers (QPS, latency, storage)
□ Practice 3-5 problems end-to-end
□ Have a drawing tool ready (Excalidraw, paper)
□ Prepare questions to ask
□ Review common trade-offs
□ Get good sleep!
```
