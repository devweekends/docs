---
title: "System Design Building Blocks"
description: "Essential components for designing scalable systems"
icon: "cubes"
---

## Overview

Every large-scale system is built from common building blocks. Understanding these components and when to use them is essential for system design.

## Load Balancers

Distribute traffic across multiple servers for scalability and reliability.

```
                         ┌──────────────┐
                         │    Client    │
                         └──────┬───────┘
                                │
                         ┌──────▼───────┐
                         │    Load      │
                         │   Balancer   │
                         └──────┬───────┘
                                │
          ┌─────────────────────┼─────────────────────┐
          │                     │                     │
   ┌──────▼──────┐       ┌──────▼──────┐       ┌──────▼──────┐
   │   Server 1  │       │   Server 2  │       │   Server 3  │
   └─────────────┘       └─────────────┘       └─────────────┘
```

### Load Balancing Algorithms

| Algorithm | Description | Use Case |
|-----------|-------------|----------|
| **Round Robin** | Rotate through servers | Equal server capacity |
| **Weighted Round Robin** | Based on server capacity | Different server specs |
| **Least Connections** | Send to least busy | Variable request duration |
| **IP Hash** | Same client → same server | Session affinity |
| **Least Response Time** | Fastest server | Performance-critical |

### Layer 4 vs Layer 7

```
Layer 7 (Application)              Layer 4 (Transport)
┌─────────────────────┐           ┌─────────────────────┐
│ HTTP/HTTPS aware    │           │ TCP/UDP only        │
│ URL-based routing   │           │ IP + Port routing   │
│ SSL termination     │           │ Faster (less work)  │
│ Content switching   │           │ No content awareness│
│ Request modification│           │ Simple forwarding   │
└─────────────────────┘           └─────────────────────┘
```

## Caching

Store frequently accessed data in fast storage to reduce latency and database load.

### Cache Layers

```
┌─────────────────────────────────────────────────────────────┐
│                      Application                            │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────▼─────────────────────────────┐
│                    L1: In-Memory Cache                     │
│                    (Application RAM)                       │
│                    Latency: ~1ms                          │
└─────────────────────────────┬─────────────────────────────┘
                              │ Miss
┌─────────────────────────────▼─────────────────────────────┐
│                   L2: Distributed Cache                    │
│                   (Redis/Memcached)                        │
│                   Latency: ~5ms                           │
└─────────────────────────────┬─────────────────────────────┘
                              │ Miss
┌─────────────────────────────▼─────────────────────────────┐
│                      L3: Database                          │
│                   Latency: ~50-100ms                       │
└─────────────────────────────────────────────────────────────┘
```

### Caching Strategies

#### Cache-Aside (Lazy Loading)

```python
def get_user(user_id):
    # 1. Check cache
    user = cache.get(f"user:{user_id}")
    if user:
        return user  # Cache hit
    
    # 2. Cache miss - query database
    user = db.query("SELECT * FROM users WHERE id = ?", user_id)
    
    # 3. Store in cache
    cache.set(f"user:{user_id}", user, ttl=3600)
    
    return user
```

#### Write-Through

```python
def update_user(user_id, data):
    # 1. Update database
    db.update("UPDATE users SET ... WHERE id = ?", data, user_id)
    
    # 2. Update cache immediately
    cache.set(f"user:{user_id}", data, ttl=3600)
```

#### Write-Behind (Write-Back)

```python
def update_user(user_id, data):
    # 1. Update cache immediately
    cache.set(f"user:{user_id}", data)
    
    # 2. Queue database write (async)
    write_queue.push({"user_id": user_id, "data": data})
    
# Background worker
def process_writes():
    while True:
        item = write_queue.pop()
        db.update("UPDATE users SET ...", item["data"], item["user_id"])
```

### Cache Invalidation

| Strategy | Description | Trade-off |
|----------|-------------|-----------|
| **TTL** | Expire after time | Simple but may serve stale |
| **Event-based** | Invalidate on write | Complex but consistent |
| **Version tags** | Change key on update | Wastes memory |

## Message Queues

Enable asynchronous communication and decouple components.

```
Producer ──► Queue ──► Consumer

┌──────────┐     ┌─────────────────┐     ┌──────────┐
│ Service  │────►│   Message       │────►│  Worker  │
│    A     │     │   Queue         │     │    1     │
└──────────┘     │                 │     └──────────┘
                 │  ┌───┬───┬───┐  │     ┌──────────┐
                 │  │msg│msg│msg│  │────►│  Worker  │
                 │  └───┴───┴───┘  │     │    2     │
                 └─────────────────┘     └──────────┘
```

### When to Use

<CardGroup cols={2}>
  <Card title="Async Processing" icon="clock">
    Email sending, image processing, report generation
  </Card>
  <Card title="Load Leveling" icon="chart-line">
    Handle traffic spikes by queuing requests
  </Card>
  <Card title="Decoupling" icon="unlink">
    Services don't need to know about each other
  </Card>
  <Card title="Reliability" icon="shield">
    Messages persist if consumer is down
  </Card>
</CardGroup>

### Queue Types

| Type | Description | Use Case |
|------|-------------|----------|
| **Point-to-Point** | One consumer per message | Task queues |
| **Pub/Sub** | Multiple consumers | Event broadcasting |
| **Priority Queue** | Process by priority | Critical tasks first |
| **Dead Letter Queue** | Failed messages | Error handling |

## Content Delivery Network (CDN)

Distribute content globally for faster access.

```
                          ┌─────────────┐
                          │   Origin    │
                          │   Server    │
                          └──────┬──────┘
                                 │
     ┌───────────────────────────┼───────────────────────────┐
     │                           │                           │
┌────▼────┐                ┌─────▼─────┐               ┌─────▼─────┐
│  Edge   │                │   Edge    │               │   Edge    │
│  (USA)  │                │  (Europe) │               │  (Asia)   │
└────┬────┘                └─────┬─────┘               └─────┬─────┘
     │                           │                           │
     │                           │                           │
┌────▼────┐                ┌─────▼─────┐               ┌─────▼─────┐
│US Users │                │ EU Users  │               │Asia Users │
│ ~20ms   │                │  ~20ms    │               │  ~20ms    │
└─────────┘                └───────────┘               └───────────┘

Without CDN: All users → Origin (100-300ms for distant users)
```

### CDN Strategies

| Strategy | Description | Best For |
|----------|-------------|----------|
| **Push** | Upload to CDN proactively | Static content, known files |
| **Pull** | CDN fetches on first request | Dynamic content, large catalogs |

## API Gateway

Single entry point for all client requests.

```
┌──────────────────────────────────────────────────────────────┐
│                       API Gateway                            │
├──────────────────────────────────────────────────────────────┤
│  • Authentication         • Rate Limiting                    │
│  • SSL Termination        • Request Routing                  │
│  • Load Balancing         • Response Caching                 │
│  • API Versioning         • Request/Response Transform       │
│  • Analytics & Logging    • Circuit Breaking                 │
└──────────────────────────────────────────────────────────────┘
           │              │              │              │
    ┌──────▼──────┐ ┌─────▼─────┐ ┌─────▼─────┐ ┌─────▼─────┐
    │   Users     │ │  Orders   │ │  Products │ │  Payments │
    │   Service   │ │  Service  │ │  Service  │ │  Service  │
    └─────────────┘ └───────────┘ └───────────┘ └───────────┘
```

## Database Replication

Copy data across multiple servers for availability and read scaling.

### Master-Slave Replication

```
     Writes                           Reads
        │                               │
        ▼                               ▼
   ┌─────────┐                   ┌───────────┐
   │ Master  │                   │  Slave 1  │
   │  (RW)   │──── Replication ──│   (RO)    │
   └─────────┘         │         └───────────┘
                       │
                       │         ┌───────────┐
                       └─────────│  Slave 2  │
                                 │   (RO)    │
                                 └───────────┘
```

### Multi-Master Replication

```
   ┌─────────┐            ┌─────────┐
   │ Master  │◄──────────►│ Master  │
   │   1     │  Sync      │   2     │
   │  (RW)   │            │  (RW)   │
   └─────────┘            └─────────┘
       │                       │
       ▼                       ▼
   ┌─────────┐            ┌─────────┐
   │ Slave 1 │            │ Slave 2 │
   └─────────┘            └─────────┘
```

## Comparison Summary

| Component | Purpose | When to Use |
|-----------|---------|-------------|
| **Load Balancer** | Distribute traffic | Multiple servers |
| **Cache** | Speed up reads | Hot data, expensive queries |
| **Message Queue** | Async processing | Decoupling, spike handling |
| **CDN** | Global content delivery | Static assets, global users |
| **API Gateway** | Single entry point | Microservices, security |
| **DB Replication** | Availability & reads | High availability, read-heavy |

<Tip>
**Design Tip**: Don't add components just because they're common. Each adds complexity. Start simple and add components as specific problems arise.
</Tip>
