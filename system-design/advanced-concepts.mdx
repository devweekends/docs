---
title: "Advanced Concepts"
description: "Senior-level system design concepts for Staff+ interviews"
icon: "brain"
---

<Warning>
**Senior/Staff Level Content**: This section covers advanced topics that differentiate senior engineers from mid-level. Master these for L5+ (Senior) and Staff interviews at FAANG.
</Warning>

## Consistency Deep Dive

### Linearizability vs Serializability

Most candidates confuse these. Know the difference!

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Linearizability vs Serializability                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  LINEARIZABILITY (Single-object, real-time)                    â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                      â”‚
â”‚  â€¢ Operations appear to happen atomically at some point         â”‚
â”‚  â€¢ Real-time ordering: if op A completes before op B starts,   â”‚
â”‚    then A is ordered before B                                   â”‚
â”‚  â€¢ Think: "single copy of data that everyone sees"             â”‚
â”‚                                                                 â”‚
â”‚  Time â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º            â”‚
â”‚                                                                 â”‚
â”‚  Client A:  â”€â”€[write x=1]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                          â”‚
â”‚  Client B:        â”€â”€â”€â”€â”€â”€[read x]â”€â”€â”€                            â”‚
â”‚                          â”‚                                      â”‚
â”‚                          â””â”€â–º Must return 1 (write completed)   â”‚
â”‚                                                                 â”‚
â”‚  SERIALIZABILITY (Multi-object, transactions)                  â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                    â”‚
â”‚  â€¢ Transactions appear to execute in SOME serial order          â”‚
â”‚  â€¢ Doesn't guarantee real-time ordering                         â”‚
â”‚  â€¢ Think: "transactions don't see partial state"               â”‚
â”‚                                                                 â”‚
â”‚  T1: read(A), write(B)                                         â”‚
â”‚  T2: read(B), write(A)                                         â”‚
â”‚  Serial order: T1â†’T2 or T2â†’T1, but not interleaved            â”‚
â”‚                                                                 â”‚
â”‚  STRICT SERIALIZABILITY                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                        â”‚
â”‚  â€¢ Both! Serial order + real-time ordering                      â”‚
â”‚  â€¢ Most expensive, what Spanner provides                        â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Isolation Levels (Know All Four!)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Isolation Levels                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  READ UNCOMMITTED (Weakest)                                     â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                      â”‚
â”‚  â€¢ Can see uncommitted changes (dirty reads)                   â”‚
â”‚  â€¢ Almost never used                                            â”‚
â”‚                                                                 â”‚
â”‚  T1: write(x=1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ rollback                          â”‚
â”‚  T2:     read(x) â”€â–º 1 (dirty read!)                            â”‚
â”‚                                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                 â”‚
â”‚  READ COMMITTED (Default in PostgreSQL)                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                          â”‚
â”‚  â€¢ Only see committed data                                     â”‚
â”‚  â€¢ Allows non-repeatable reads                                  â”‚
â”‚                                                                 â”‚
â”‚  T1: read(x) â”€â–º 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ read(x) â”€â–º 2 (changed!)         â”‚
â”‚  T2:      write(x=2), commit                                   â”‚
â”‚                                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                 â”‚
â”‚  REPEATABLE READ (Default in MySQL InnoDB)                      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                      â”‚
â”‚  â€¢ Same query returns same results in a transaction             â”‚
â”‚  â€¢ Allows phantom reads (new rows appear)                       â”‚
â”‚                                                                 â”‚
â”‚  T1: SELECT COUNT(*) WHERE age > 30 â”€â–º 5                       â”‚
â”‚  T2:      INSERT INTO users (age=35), commit                   â”‚
â”‚  T1: SELECT COUNT(*) WHERE age > 30 â”€â–º 6 (phantom!)            â”‚
â”‚                                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                 â”‚
â”‚  SERIALIZABLE (Strongest)                                       â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                       â”‚
â”‚  â€¢ Full isolation, as if transactions ran serially              â”‚
â”‚  â€¢ Highest safety, lowest performance                           â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

| Level | Dirty Read | Non-Repeatable Read | Phantom Read |
|-------|------------|---------------------|--------------|
| Read Uncommitted | âœ“ | âœ“ | âœ“ |
| Read Committed | âœ— | âœ“ | âœ“ |
| Repeatable Read | âœ— | âœ— | âœ“ |
| Serializable | âœ— | âœ— | âœ— |

<Tip>
**Interview Answer**: "I'd use Read Committed for most cases. Serializable only for critical financial transactions where consistency matters more than throughput."
</Tip>

## Distributed Consensus Deep Dive

### Leader Election: Why It's Hard

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Split Brain Problem                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Initial State: Node A is leader                               â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚ Node A â”‚â”€â”€â”€â”€â”€â”€â”‚ Node B â”‚â”€â”€â”€â”€â”€â”€â”‚ Node C â”‚                   â”‚
â”‚  â”‚ LEADER â”‚      â”‚FOLLOWERâ”‚      â”‚FOLLOWERâ”‚                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                                                                 â”‚
â”‚  Network partition occurs:                                     â”‚
â”‚                                                                 â”‚
â”‚  Partition 1         â•‘         Partition 2                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”          â•‘          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ Node A â”‚          â•‘          â”‚ Node B â”‚â”€â”‚ Node C â”‚         â”‚
â”‚  â”‚ LEADER â”‚          â•‘          â”‚FOLLOWERâ”‚ â”‚FOLLOWERâ”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â•‘          â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                      â•‘               â”‚                         â”‚
â”‚  A thinks it's       â•‘          B or C becomes leader!        â”‚
â”‚  still leader!       â•‘          (timeout, no heartbeat)        â”‚
â”‚                      â•‘                                         â”‚
â”‚  DANGER: Two leaders! (Split brain)                            â”‚
â”‚                                                                 â”‚
â”‚  Solution: Quorum-based voting                                 â”‚
â”‚  â€¢ Need majority (N/2 + 1) to elect leader                     â”‚
â”‚  â€¢ Partition 1 has 1/3 (minority) â†’ can't write               â”‚
â”‚  â€¢ Partition 2 has 2/3 (majority) â†’ can elect, can write      â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Raft: The Algorithm You Should Know

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Raft Consensus                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  KEY CONCEPTS:                                                  â”‚
â”‚                                                                 â”‚
â”‚  1. TERMS (Logical Clock)                                       â”‚
â”‚     â€¢ Time divided into terms                                   â”‚
â”‚     â€¢ Each term has at most one leader                         â”‚
â”‚     â€¢ Term number monotonically increases                       â”‚
â”‚                                                                 â”‚
â”‚     Term 1       Term 2       Term 3                           â”‚
â”‚     â”œâ”€â”€Leader Aâ”€â”€â”¼â”€â”€Electionâ”€â”€â”¼â”€â”€Leader Bâ”€â”€â”€â”€â”€â”€â–º               â”‚
â”‚                  â”‚  (failed)  â”‚                                 â”‚
â”‚                                                                 â”‚
â”‚  2. LOG REPLICATION                                             â”‚
â”‚                                                                 â”‚
â”‚     Leader Log:  [1:x=1] [1:y=2] [2:x=3] [2:z=4]               â”‚
â”‚                    â†“       â†“       â†“       â†“                   â”‚
â”‚     Follower 1:  [1:x=1] [1:y=2] [2:x=3] [2:z=4] âœ“             â”‚
â”‚     Follower 2:  [1:x=1] [1:y=2] [2:x=3]         (catching up) â”‚
â”‚                                                                 â”‚
â”‚     Entry committed when replicated to majority                 â”‚
â”‚                                                                 â”‚
â”‚  3. LEADER ELECTION                                             â”‚
â”‚                                                                 â”‚
â”‚     Follower timeout â†’ Candidate â†’ RequestVote RPC             â”‚
â”‚     â€¢ Vote granted if:                                         â”‚
â”‚       - Candidate's term >= voter's term                       â”‚
â”‚       - Candidate's log is at least as up-to-date              â”‚
â”‚       - Voter hasn't voted for someone else this term          â”‚
â”‚     â€¢ Majority votes â†’ become Leader                           â”‚
â”‚                                                                 â”‚
â”‚  4. SAFETY GUARANTEE                                            â”‚
â”‚     â€¢ Elected leader has all committed entries                  â”‚
â”‚     â€¢ Leaders never overwrite their log                         â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Clock Synchronization

### Why Wall Clocks Fail

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Clock Synchronization Problems                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Physical clocks drift (100 ms/day typical)                    â”‚
â”‚  NTP sync has error bounds (1-10ms typically)                  â”‚
â”‚                                                                 â”‚
â”‚  Problem scenario:                                              â”‚
â”‚                                                                 â”‚
â”‚  Machine A (clock: 10:00:00.000):  write(x=1) @ 10:00:00.000  â”‚
â”‚  Machine B (clock: 10:00:00.050):  write(x=2) @ 10:00:00.050  â”‚
â”‚                                                                 â”‚
â”‚  But B's clock is 100ms ahead! Real order:                     â”‚
â”‚  â€¢ B actually wrote at real time 09:59:59.950                  â”‚
â”‚  â€¢ A wrote at real time 10:00:00.000                           â”‚
â”‚  â€¢ A happened AFTER B, but timestamps say B is newer!          â”‚
â”‚                                                                 â”‚
â”‚  Solution 1: Logical clocks (Lamport)                          â”‚
â”‚  Solution 2: Vector clocks                                      â”‚
â”‚  Solution 3: Hybrid clocks (HLC)                               â”‚
â”‚  Solution 4: GPS/atomic clocks (Spanner's TrueTime)            â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Vector Clocks (Conflict Detection)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Vector Clocks                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Each node maintains vector: {A: count, B: count, C: count}    â”‚
â”‚                                                                 â”‚
â”‚  Node A         Node B         Node C                          â”‚
â”‚  {A:0,B:0,C:0}  {A:0,B:0,C:0}  {A:0,B:0,C:0}                   â”‚
â”‚      â”‚              â”‚              â”‚                            â”‚
â”‚  write(x=1)         â”‚              â”‚                            â”‚
â”‚  {A:1,B:0,C:0}      â”‚              â”‚                            â”‚
â”‚      â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚              â”‚                            â”‚
â”‚      â”‚         {A:1,B:0,C:0}       â”‚                            â”‚
â”‚      â”‚              â”‚              â”‚                            â”‚
â”‚      â”‚         write(y=2)          â”‚                            â”‚
â”‚      â”‚         {A:1,B:1,C:0}       â”‚                            â”‚
â”‚      â”‚              â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚                            â”‚
â”‚      â”‚              â”‚         {A:1,B:1,C:0}                     â”‚
â”‚      â”‚              â”‚              â”‚                            â”‚
â”‚                                                                 â”‚
â”‚  Comparison:                                                    â”‚
â”‚  {A:1,B:2,C:0} vs {A:2,B:1,C:0}                                â”‚
â”‚  Neither dominates â†’ CONFLICT! Must resolve                    â”‚
â”‚                                                                 â”‚
â”‚  {A:1,B:2,C:0} vs {A:1,B:3,C:0}                                â”‚
â”‚  Second dominates â†’ Second is newer, no conflict               â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Data Partitioning Strategies

### Partition Key Selection

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Choosing Partition Keys                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  GOOD Partition Key Properties:                                 â”‚
â”‚  âœ“ High cardinality (many unique values)                       â”‚
â”‚  âœ“ Evenly distributed access                                   â”‚
â”‚  âœ“ Matches query patterns                                      â”‚
â”‚                                                                 â”‚
â”‚  Example: E-commerce Orders                                     â”‚
â”‚                                                                 â”‚
â”‚  âŒ BAD: partition by date                                      â”‚
â”‚     â€¢ Today's partition gets all traffic (hot partition)       â”‚
â”‚     â€¢ Old partitions sit idle                                  â”‚
â”‚                                                                 â”‚
â”‚  âŒ BAD: partition by country                                   â”‚
â”‚     â€¢ US partition has 60% of traffic                          â”‚
â”‚     â€¢ Small countries underutilized                            â”‚
â”‚                                                                 â”‚
â”‚  âœ… GOOD: partition by order_id                                â”‚
â”‚     â€¢ Random distribution                                       â”‚
â”‚     â€¢ But: can't query "all orders for user X" easily          â”‚
â”‚                                                                 â”‚
â”‚  âœ… BETTER: partition by user_id                                â”‚
â”‚     â€¢ User's orders on same partition (locality)               â”‚
â”‚     â€¢ Query patterns match                                     â”‚
â”‚     â€¢ Watch for celebrity users (hot partition)                â”‚
â”‚                                                                 â”‚
â”‚  âœ… BEST: compound key (user_id, order_date)                   â”‚
â”‚     â€¢ Partition by user_id                                     â”‚
â”‚     â€¢ Sort by order_date within partition                      â”‚
â”‚     â€¢ Efficient for "user X's orders in last month"           â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Handling Hot Partitions

```python
# Strategy 1: Add random suffix
def get_partition_key(celebrity_id):
    if is_celebrity(celebrity_id):
        # Split celebrity across 10 partitions
        suffix = random.randint(0, 9)
        return f"{celebrity_id}_{suffix}"
    return celebrity_id

# Reading requires scatter-gather
def get_celebrity_data(celebrity_id):
    results = []
    for suffix in range(10):
        key = f"{celebrity_id}_{suffix}"
        results.extend(query_partition(key))
    return results

# Strategy 2: Time-based suffix
def get_partition_key_time(user_id):
    # Different partition each hour
    hour = datetime.now().hour
    return f"{user_id}_{hour % 4}"
```

## Exactly-Once Semantics

### The Three Delivery Guarantees

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Message Delivery Guarantees                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  AT-MOST-ONCE                                                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                  â”‚
â”‚  Send and forget. May lose messages.                           â”‚
â”‚  Use case: Metrics, logs (some loss OK)                        â”‚
â”‚                                                                 â”‚
â”‚  Producer â”€â”€[msg]â”€â”€â–º Broker    (might fail silently)           â”‚
â”‚                                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                 â”‚
â”‚  AT-LEAST-ONCE                                                  â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                  â”‚
â”‚  Retry until ACK. May duplicate messages.                      â”‚
â”‚  Use case: Most applications (with idempotent consumers)       â”‚
â”‚                                                                 â”‚
â”‚  Producer â”€â”€[msg]â”€â”€â–º Broker â”€â”€[ACK]â”€â”€â–º Producer                â”‚
â”‚      â”‚                  â”‚                                       â”‚
â”‚      â””â”€â”€[retry]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ (if no ACK, retry â†’ duplicate)       â”‚
â”‚                                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                 â”‚
â”‚  EXACTLY-ONCE                                                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                   â”‚
â”‚  Each message processed exactly once. Hard to achieve!         â”‚
â”‚  Use case: Financial transactions, critical data               â”‚
â”‚                                                                 â”‚
â”‚  Achieved via: Idempotency + Deduplication + Transactions      â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Implementing Exactly-Once

```python
class ExactlyOnceProcessor:
    """
    Exactly-once processing with idempotency keys
    """
    
    def process_message(self, message):
        idempotency_key = message.id
        
        # Step 1: Check if already processed
        if self.is_processed(idempotency_key):
            return self.get_cached_result(idempotency_key)
        
        # Step 2: Process with transaction
        with self.db.transaction():
            # Do the work
            result = self.do_business_logic(message)
            
            # Record as processed (same transaction!)
            self.mark_processed(idempotency_key, result)
            
            # Commit message offset (Kafka-style)
            self.commit_offset(message.offset)
        
        return result
    
    def is_processed(self, key):
        return self.db.exists(f"processed:{key}")
    
    def mark_processed(self, key, result):
        self.db.set(f"processed:{key}", result, ttl=86400)
```

## Distributed Caching Patterns

### Cache Stampede Prevention

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Cache Stampede Problem                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Popular key expires â†’ 1000 servers hit DB simultaneously      â”‚
â”‚                                                                 â”‚
â”‚  Server 1 â”€â”                                                    â”‚
â”‚  Server 2 â”€â”¤                                                    â”‚
â”‚  Server 3 â”€â”¼â”€â”€â”€â–º Cache MISS â”€â”€â”€â–º Database â† ðŸ’¥ OVERWHELMED     â”‚
â”‚  ...       â”‚                                                    â”‚
â”‚  Server N â”€â”˜                                                    â”‚
â”‚                                                                 â”‚
â”‚  SOLUTIONS:                                                     â”‚
â”‚                                                                 â”‚
â”‚  1. LOCKING (Mutex)                                             â”‚
â”‚     First request acquires lock, others wait or get stale      â”‚
â”‚                                                                 â”‚
â”‚  2. PROBABILISTIC EARLY EXPIRATION                              â”‚
â”‚     Refresh before expiry with some probability                â”‚
â”‚                                                                 â”‚
â”‚  3. BACKGROUND REFRESH                                          â”‚
â”‚     Never expire, refresh asynchronously                       â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```python
import random
import time

class StampedePreventingCache:
    def get(self, key, fetch_func, ttl=3600, beta=1.0):
        cached = self.cache.get(key)
        
        if cached:
            value, expiry, delta = cached
            now = time.time()
            
            # Probabilistic early refresh
            # As we approach expiry, probability increases
            gap = expiry - now
            if gap > 0:
                # XFetch algorithm
                random_early = delta * beta * math.log(random.random())
                if gap + random_early > 0:
                    return value  # Use cached value
        
        # Cache miss or early refresh triggered
        # Use distributed lock to prevent stampede
        lock_key = f"lock:{key}"
        if self.acquire_lock(lock_key, timeout=5):
            try:
                start = time.time()
                value = fetch_func()
                delta = time.time() - start
                
                self.cache.set(key, (value, time.time() + ttl, delta))
                return value
            finally:
                self.release_lock(lock_key)
        else:
            # Someone else is refreshing, return stale or wait
            if cached:
                return cached[0]  # Return stale
            time.sleep(0.1)
            return self.get(key, fetch_func, ttl, beta)  # Retry
```

## Rate Limiting at Scale

### Distributed Rate Limiting

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Distributed Rate Limiting Strategies                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  STRATEGY 1: Centralized (Redis)                               â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                              â”‚
â”‚  All servers check same Redis                                  â”‚
â”‚  âœ“ Accurate   âœ— Single point of failure                       â”‚
â”‚                                                                 â”‚
â”‚  Server 1 â”€â”                                                    â”‚
â”‚  Server 2 â”€â”¼â”€â”€â”€â–º Redis â”€â”€â”€â–º Accurate count                     â”‚
â”‚  Server 3 â”€â”˜                                                    â”‚
â”‚                                                                 â”‚
â”‚  STRATEGY 2: Local + Sync                                       â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                        â”‚
â”‚  Local counters, periodically sync                             â”‚
â”‚  âœ“ Fast   âœ— Approximate                                        â”‚
â”‚                                                                 â”‚
â”‚  Server 1: local_count=50 â”€â”€â”                                  â”‚
â”‚  Server 2: local_count=40 â”€â”€â”¼â”€â”€â–º Sync every 1s                 â”‚
â”‚  Server 3: local_count=30 â”€â”€â”˜                                  â”‚
â”‚                                                                 â”‚
â”‚  STRATEGY 3: Token Bucket with Redis                           â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                              â”‚
â”‚  Each request: DECR if tokens > 0                              â”‚
â”‚  Background: Refill tokens at fixed rate                       â”‚
â”‚                                                                 â”‚
â”‚  Lua script for atomic check-and-decrement:                    â”‚
â”‚  local tokens = redis.call('GET', key)                         â”‚
â”‚  if tokens > 0 then                                            â”‚
â”‚      redis.call('DECR', key)                                   â”‚
â”‚      return 1  -- allowed                                      â”‚
â”‚  end                                                           â”‚
â”‚  return 0  -- rejected                                         â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## CQRS (Command Query Responsibility Segregation)

CQRS separates read and write operations into different models, optimizing each for its specific use case.

![CQRS Pattern](/images/system-design/cqrs.svg)

<Tabs>
  <Tab title="Python">
```python
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any
from datetime import datetime
from abc import ABC, abstractmethod
import asyncio
from enum import Enum

# ============== Commands (Write Side) ==============
class CommandType(Enum):
    CREATE_ORDER = "create_order"
    UPDATE_ORDER = "update_order"
    CANCEL_ORDER = "cancel_order"

@dataclass
class Command:
    command_type: CommandType
    aggregate_id: str
    payload: Dict[str, Any]
    timestamp: datetime = field(default_factory=datetime.utcnow)
    correlation_id: str = field(default_factory=lambda: str(uuid.uuid4()))

class CommandHandler(ABC):
    @abstractmethod
    async def handle(self, command: Command) -> None:
        pass

class OrderCommandHandler(CommandHandler):
    def __init__(self, event_store: 'EventStore', event_bus: 'EventBus'):
        self.event_store = event_store
        self.event_bus = event_bus
    
    async def handle(self, command: Command) -> str:
        if command.command_type == CommandType.CREATE_ORDER:
            return await self._handle_create_order(command)
        elif command.command_type == CommandType.CANCEL_ORDER:
            return await self._handle_cancel_order(command)
        raise ValueError(f"Unknown command type: {command.command_type}")
    
    async def _handle_create_order(self, command: Command) -> str:
        # Business validation
        order_id = str(uuid.uuid4())
        
        # Create event
        event = Event(
            event_type=EventType.ORDER_CREATED,
            aggregate_id=order_id,
            payload={
                "user_id": command.payload["user_id"],
                "items": command.payload["items"],
                "total": command.payload["total"],
            },
            version=1
        )
        
        # Persist event
        await self.event_store.append(event)
        
        # Publish for read model updates
        await self.event_bus.publish(event)
        
        return order_id
    
    async def _handle_cancel_order(self, command: Command) -> None:
        # Load current state from events
        events = await self.event_store.get_events(command.aggregate_id)
        order = OrderAggregate.from_events(events)
        
        # Business validation
        if order.status == OrderStatus.CANCELLED:
            raise ValueError("Order already cancelled")
        if order.status == OrderStatus.SHIPPED:
            raise ValueError("Cannot cancel shipped order")
        
        # Create cancellation event
        event = Event(
            event_type=EventType.ORDER_CANCELLED,
            aggregate_id=command.aggregate_id,
            payload={"reason": command.payload.get("reason", "User requested")},
            version=order.version + 1
        )
        
        await self.event_store.append(event)
        await self.event_bus.publish(event)

# ============== Queries (Read Side) ==============
@dataclass
class OrderReadModel:
    """Denormalized read model optimized for queries"""
    id: str
    user_id: str
    status: str
    items: List[Dict]
    total: float
    created_at: datetime
    updated_at: datetime

class OrderQueryService:
    def __init__(self, read_db: 'ReadDatabase'):
        self.read_db = read_db
    
    async def get_order(self, order_id: str) -> Optional[OrderReadModel]:
        """Fast read from denormalized model"""
        return await self.read_db.find_one("orders", {"id": order_id})
    
    async def get_user_orders(
        self, 
        user_id: str, 
        status: Optional[str] = None,
        limit: int = 10,
        offset: int = 0
    ) -> List[OrderReadModel]:
        """Query with filters - optimized for read patterns"""
        query = {"user_id": user_id}
        if status:
            query["status"] = status
        
        return await self.read_db.find(
            "orders",
            query,
            sort=[("created_at", -1)],
            limit=limit,
            skip=offset
        )
    
    async def get_orders_by_status(self, status: str) -> List[OrderReadModel]:
        """Admin query - different index"""
        return await self.read_db.find(
            "orders",
            {"status": status},
            sort=[("updated_at", -1)]
        )

# ============== Read Model Projector ==============
class OrderProjector:
    """Updates read model based on events"""
    
    def __init__(self, read_db: 'ReadDatabase'):
        self.read_db = read_db
    
    async def project(self, event: 'Event') -> None:
        handler = getattr(self, f"_handle_{event.event_type.value}", None)
        if handler:
            await handler(event)
    
    async def _handle_order_created(self, event: 'Event') -> None:
        order = OrderReadModel(
            id=event.aggregate_id,
            user_id=event.payload["user_id"],
            status="pending",
            items=event.payload["items"],
            total=event.payload["total"],
            created_at=event.timestamp,
            updated_at=event.timestamp
        )
        await self.read_db.insert("orders", order.__dict__)
    
    async def _handle_order_cancelled(self, event: 'Event') -> None:
        await self.read_db.update(
            "orders",
            {"id": event.aggregate_id},
            {
                "status": "cancelled",
                "cancellation_reason": event.payload["reason"],
                "updated_at": event.timestamp
            }
        )
```
  </Tab>
  <Tab title="JavaScript">
```javascript
// ============== Commands (Write Side) ==============
const CommandType = {
  CREATE_ORDER: 'create_order',
  UPDATE_ORDER: 'update_order',
  CANCEL_ORDER: 'cancel_order'
};

class Command {
  constructor(commandType, aggregateId, payload) {
    this.commandType = commandType;
    this.aggregateId = aggregateId;
    this.payload = payload;
    this.timestamp = new Date();
    this.correlationId = crypto.randomUUID();
  }
}

class OrderCommandHandler {
  constructor(eventStore, eventBus) {
    this.eventStore = eventStore;
    this.eventBus = eventBus;
  }

  async handle(command) {
    switch (command.commandType) {
      case CommandType.CREATE_ORDER:
        return this.handleCreateOrder(command);
      case CommandType.CANCEL_ORDER:
        return this.handleCancelOrder(command);
      default:
        throw new Error(`Unknown command type: ${command.commandType}`);
    }
  }

  async handleCreateOrder(command) {
    const orderId = crypto.randomUUID();
    
    const event = new Event(
      EventType.ORDER_CREATED,
      orderId,
      {
        userId: command.payload.userId,
        items: command.payload.items,
        total: command.payload.total
      },
      1
    );

    await this.eventStore.append(event);
    await this.eventBus.publish(event);
    
    return orderId;
  }

  async handleCancelOrder(command) {
    // Load current state from events
    const events = await this.eventStore.getEvents(command.aggregateId);
    const order = OrderAggregate.fromEvents(events);

    // Business validation
    if (order.status === 'cancelled') {
      throw new Error('Order already cancelled');
    }
    if (order.status === 'shipped') {
      throw new Error('Cannot cancel shipped order');
    }

    const event = new Event(
      EventType.ORDER_CANCELLED,
      command.aggregateId,
      { reason: command.payload.reason || 'User requested' },
      order.version + 1
    );

    await this.eventStore.append(event);
    await this.eventBus.publish(event);
  }
}

// ============== Queries (Read Side) ==============
class OrderQueryService {
  constructor(readDb) {
    this.readDb = readDb;
  }

  async getOrder(orderId) {
    return this.readDb.findOne('orders', { id: orderId });
  }

  async getUserOrders(userId, { status, limit = 10, offset = 0 } = {}) {
    const query = { userId };
    if (status) query.status = status;

    return this.readDb.find('orders', query, {
      sort: { createdAt: -1 },
      limit,
      skip: offset
    });
  }

  async getOrdersByStatus(status) {
    return this.readDb.find('orders', { status }, {
      sort: { updatedAt: -1 }
    });
  }
}

// ============== Read Model Projector ==============
class OrderProjector {
  constructor(readDb) {
    this.readDb = readDb;
  }

  async project(event) {
    const handlerName = `handle${this.toPascalCase(event.eventType)}`;
    if (this[handlerName]) {
      await this[handlerName](event);
    }
  }

  async handleOrderCreated(event) {
    const order = {
      id: event.aggregateId,
      userId: event.payload.userId,
      status: 'pending',
      items: event.payload.items,
      total: event.payload.total,
      createdAt: event.timestamp,
      updatedAt: event.timestamp
    };
    await this.readDb.insert('orders', order);
  }

  async handleOrderCancelled(event) {
    await this.readDb.update(
      'orders',
      { id: event.aggregateId },
      {
        status: 'cancelled',
        cancellationReason: event.payload.reason,
        updatedAt: event.timestamp
      }
    );
  }

  toPascalCase(str) {
    return str.replace(/_([a-z])/g, (g) => g[1].toUpperCase())
              .replace(/^[a-z]/, (c) => c.toUpperCase());
  }
}

// ============== Usage Example ==============
const app = express();

// Command endpoint (write)
app.post('/orders', async (req, res) => {
  const command = new Command(
    CommandType.CREATE_ORDER,
    null,
    req.body
  );
  
  const orderId = await commandHandler.handle(command);
  res.status(201).json({ orderId });
});

// Query endpoint (read)
app.get('/orders/:id', async (req, res) => {
  const order = await queryService.getOrder(req.params.id);
  if (!order) return res.status(404).json({ error: 'Not found' });
  res.json(order);
});
```
  </Tab>
</Tabs>

## Event Sourcing

Event sourcing stores all changes as a sequence of events, providing a complete audit trail and enabling time-travel debugging.

![Event Sourcing](/images/system-design/event-sourcing.svg)

<Tabs>
  <Tab title="Python">
```python
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
from datetime import datetime
from enum import Enum
from abc import ABC, abstractmethod
import json
import uuid

class EventType(Enum):
    ORDER_CREATED = "order_created"
    ORDER_ITEM_ADDED = "order_item_added"
    ORDER_ITEM_REMOVED = "order_item_removed"
    ORDER_SUBMITTED = "order_submitted"
    ORDER_PAID = "order_paid"
    ORDER_SHIPPED = "order_shipped"
    ORDER_DELIVERED = "order_delivered"
    ORDER_CANCELLED = "order_cancelled"

@dataclass
class Event:
    event_type: EventType
    aggregate_id: str
    payload: Dict[str, Any]
    version: int
    timestamp: datetime = field(default_factory=datetime.utcnow)
    event_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    metadata: Dict[str, Any] = field(default_factory=dict)

class EventStore:
    """Append-only event store with PostgreSQL"""
    
    def __init__(self, db_pool):
        self.db_pool = db_pool
    
    async def append(self, event: Event) -> None:
        """Append event with optimistic concurrency control"""
        async with self.db_pool.acquire() as conn:
            try:
                await conn.execute("""
                    INSERT INTO events (
                        event_id, aggregate_id, event_type, 
                        payload, version, timestamp, metadata
                    )
                    VALUES ($1, $2, $3, $4, $5, $6, $7)
                """,
                    event.event_id,
                    event.aggregate_id,
                    event.event_type.value,
                    json.dumps(event.payload),
                    event.version,
                    event.timestamp,
                    json.dumps(event.metadata)
                )
            except UniqueViolationError:
                raise ConcurrencyError(
                    f"Version {event.version} already exists for {event.aggregate_id}"
                )
    
    async def get_events(
        self, 
        aggregate_id: str, 
        from_version: int = 0
    ) -> List[Event]:
        """Load all events for an aggregate"""
        async with self.db_pool.acquire() as conn:
            rows = await conn.fetch("""
                SELECT event_id, aggregate_id, event_type, 
                       payload, version, timestamp, metadata
                FROM events
                WHERE aggregate_id = $1 AND version > $2
                ORDER BY version ASC
            """, aggregate_id, from_version)
            
            return [
                Event(
                    event_id=row['event_id'],
                    aggregate_id=row['aggregate_id'],
                    event_type=EventType(row['event_type']),
                    payload=json.loads(row['payload']),
                    version=row['version'],
                    timestamp=row['timestamp'],
                    metadata=json.loads(row['metadata'])
                )
                for row in rows
            ]
    
    async def get_all_events(
        self, 
        from_position: int = 0,
        batch_size: int = 1000
    ) -> List[Event]:
        """Stream all events for projections"""
        async with self.db_pool.acquire() as conn:
            rows = await conn.fetch("""
                SELECT * FROM events
                WHERE global_position > $1
                ORDER BY global_position ASC
                LIMIT $2
            """, from_position, batch_size)
            
            return [self._row_to_event(row) for row in rows]

# ============== Aggregate with Event Sourcing ==============
class OrderStatus(Enum):
    DRAFT = "draft"
    PENDING = "pending"
    PAID = "paid"
    SHIPPED = "shipped"
    DELIVERED = "delivered"
    CANCELLED = "cancelled"

@dataclass
class OrderAggregate:
    """Order aggregate rebuilt from events"""
    id: str
    user_id: Optional[str] = None
    status: OrderStatus = OrderStatus.DRAFT
    items: List[Dict] = field(default_factory=list)
    total: float = 0.0
    version: int = 0
    created_at: Optional[datetime] = None
    
    @classmethod
    def from_events(cls, events: List[Event]) -> 'OrderAggregate':
        """Reconstruct aggregate from event history"""
        aggregate = cls(id=events[0].aggregate_id if events else None)
        
        for event in events:
            aggregate._apply(event)
        
        return aggregate
    
    def _apply(self, event: Event) -> None:
        """Apply event to update state"""
        handler = getattr(self, f"_apply_{event.event_type.value}", None)
        if handler:
            handler(event)
        self.version = event.version
    
    def _apply_order_created(self, event: Event) -> None:
        self.user_id = event.payload["user_id"]
        self.status = OrderStatus.DRAFT
        self.created_at = event.timestamp
    
    def _apply_order_item_added(self, event: Event) -> None:
        self.items.append(event.payload["item"])
        self._recalculate_total()
    
    def _apply_order_item_removed(self, event: Event) -> None:
        item_id = event.payload["item_id"]
        self.items = [i for i in self.items if i["id"] != item_id]
        self._recalculate_total()
    
    def _apply_order_submitted(self, event: Event) -> None:
        self.status = OrderStatus.PENDING
    
    def _apply_order_paid(self, event: Event) -> None:
        self.status = OrderStatus.PAID
    
    def _apply_order_shipped(self, event: Event) -> None:
        self.status = OrderStatus.SHIPPED
    
    def _apply_order_cancelled(self, event: Event) -> None:
        self.status = OrderStatus.CANCELLED
    
    def _recalculate_total(self) -> None:
        self.total = sum(
            item["price"] * item["quantity"] 
            for item in self.items
        )

# ============== Snapshots for Performance ==============
class SnapshotStore:
    """Store periodic snapshots to speed up replay"""
    
    def __init__(self, db_pool, snapshot_interval: int = 100):
        self.db_pool = db_pool
        self.snapshot_interval = snapshot_interval
    
    async def save_snapshot(
        self, 
        aggregate_id: str, 
        aggregate: OrderAggregate
    ) -> None:
        """Save aggregate snapshot"""
        async with self.db_pool.acquire() as conn:
            await conn.execute("""
                INSERT INTO snapshots (aggregate_id, version, state, created_at)
                VALUES ($1, $2, $3, $4)
                ON CONFLICT (aggregate_id) 
                DO UPDATE SET version = $2, state = $3, created_at = $4
            """,
                aggregate_id,
                aggregate.version,
                json.dumps(aggregate.__dict__, default=str),
                datetime.utcnow()
            )
    
    async def get_snapshot(
        self, 
        aggregate_id: str
    ) -> Optional[OrderAggregate]:
        """Load latest snapshot"""
        async with self.db_pool.acquire() as conn:
            row = await conn.fetchrow("""
                SELECT state, version FROM snapshots
                WHERE aggregate_id = $1
            """, aggregate_id)
            
            if row:
                state = json.loads(row['state'])
                return OrderAggregate(**state)
            return None

class OrderRepository:
    """Repository using snapshots + events"""
    
    def __init__(
        self, 
        event_store: EventStore, 
        snapshot_store: SnapshotStore
    ):
        self.event_store = event_store
        self.snapshot_store = snapshot_store
    
    async def get(self, order_id: str) -> Optional[OrderAggregate]:
        # Try to load from snapshot first
        aggregate = await self.snapshot_store.get_snapshot(order_id)
        
        if aggregate:
            # Only replay events after snapshot
            events = await self.event_store.get_events(
                order_id, 
                from_version=aggregate.version
            )
        else:
            # Replay all events
            events = await self.event_store.get_events(order_id)
            if not events:
                return None
            aggregate = OrderAggregate(id=order_id)
        
        # Apply remaining events
        for event in events:
            aggregate._apply(event)
        
        # Create snapshot if needed
        if aggregate.version % self.snapshot_store.snapshot_interval == 0:
            await self.snapshot_store.save_snapshot(order_id, aggregate)
        
        return aggregate
```
  </Tab>
  <Tab title="JavaScript">
```javascript
const { v4: uuidv4 } = require('uuid');

// ============== Event Types ==============
const EventType = {
  ORDER_CREATED: 'order_created',
  ORDER_ITEM_ADDED: 'order_item_added',
  ORDER_ITEM_REMOVED: 'order_item_removed',
  ORDER_SUBMITTED: 'order_submitted',
  ORDER_PAID: 'order_paid',
  ORDER_SHIPPED: 'order_shipped',
  ORDER_CANCELLED: 'order_cancelled'
};

class Event {
  constructor(eventType, aggregateId, payload, version) {
    this.eventId = uuidv4();
    this.eventType = eventType;
    this.aggregateId = aggregateId;
    this.payload = payload;
    this.version = version;
    this.timestamp = new Date();
    this.metadata = {};
  }
}

// ============== Event Store ==============
class EventStore {
  constructor(pool) {
    this.pool = pool;
  }

  async append(event) {
    const client = await this.pool.connect();
    try {
      await client.query(`
        INSERT INTO events (
          event_id, aggregate_id, event_type, 
          payload, version, timestamp, metadata
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7)
      `, [
        event.eventId,
        event.aggregateId,
        event.eventType,
        JSON.stringify(event.payload),
        event.version,
        event.timestamp,
        JSON.stringify(event.metadata)
      ]);
    } catch (error) {
      if (error.code === '23505') { // Unique violation
        throw new ConcurrencyError(
          `Version ${event.version} already exists for ${event.aggregateId}`
        );
      }
      throw error;
    } finally {
      client.release();
    }
  }

  async getEvents(aggregateId, fromVersion = 0) {
    const client = await this.pool.connect();
    try {
      const result = await client.query(`
        SELECT * FROM events
        WHERE aggregate_id = $1 AND version > $2
        ORDER BY version ASC
      `, [aggregateId, fromVersion]);

      return result.rows.map(row => ({
        eventId: row.event_id,
        eventType: row.event_type,
        aggregateId: row.aggregate_id,
        payload: row.payload,
        version: row.version,
        timestamp: row.timestamp,
        metadata: row.metadata
      }));
    } finally {
      client.release();
    }
  }

  async getAllEvents(fromPosition = 0, batchSize = 1000) {
    const client = await this.pool.connect();
    try {
      const result = await client.query(`
        SELECT * FROM events
        WHERE global_position > $1
        ORDER BY global_position ASC
        LIMIT $2
      `, [fromPosition, batchSize]);

      return result.rows;
    } finally {
      client.release();
    }
  }
}

// ============== Order Aggregate ==============
const OrderStatus = {
  DRAFT: 'draft',
  PENDING: 'pending',
  PAID: 'paid',
  SHIPPED: 'shipped',
  DELIVERED: 'delivered',
  CANCELLED: 'cancelled'
};

class OrderAggregate {
  constructor(id) {
    this.id = id;
    this.userId = null;
    this.status = OrderStatus.DRAFT;
    this.items = [];
    this.total = 0;
    this.version = 0;
    this.createdAt = null;
  }

  static fromEvents(events) {
    if (!events.length) return null;
    
    const aggregate = new OrderAggregate(events[0].aggregateId);
    
    for (const event of events) {
      aggregate.apply(event);
    }
    
    return aggregate;
  }

  apply(event) {
    const handler = this[`apply${this.toPascalCase(event.eventType)}`];
    if (handler) {
      handler.call(this, event);
    }
    this.version = event.version;
  }

  applyOrderCreated(event) {
    this.userId = event.payload.userId;
    this.status = OrderStatus.DRAFT;
    this.createdAt = event.timestamp;
  }

  applyOrderItemAdded(event) {
    this.items.push(event.payload.item);
    this.recalculateTotal();
  }

  applyOrderItemRemoved(event) {
    const itemId = event.payload.itemId;
    this.items = this.items.filter(i => i.id !== itemId);
    this.recalculateTotal();
  }

  applyOrderSubmitted(event) {
    this.status = OrderStatus.PENDING;
  }

  applyOrderPaid(event) {
    this.status = OrderStatus.PAID;
  }

  applyOrderShipped(event) {
    this.status = OrderStatus.SHIPPED;
  }

  applyOrderCancelled(event) {
    this.status = OrderStatus.CANCELLED;
  }

  recalculateTotal() {
    this.total = this.items.reduce(
      (sum, item) => sum + (item.price * item.quantity),
      0
    );
  }

  toPascalCase(str) {
    return str.replace(/_([a-z])/g, (g) => g[1].toUpperCase())
              .replace(/^[a-z]/, (c) => c.toUpperCase());
  }
}

// ============== Snapshot Store ==============
class SnapshotStore {
  constructor(pool, snapshotInterval = 100) {
    this.pool = pool;
    this.snapshotInterval = snapshotInterval;
  }

  async saveSnapshot(aggregateId, aggregate) {
    const client = await this.pool.connect();
    try {
      await client.query(`
        INSERT INTO snapshots (aggregate_id, version, state, created_at)
        VALUES ($1, $2, $3, $4)
        ON CONFLICT (aggregate_id) 
        DO UPDATE SET version = $2, state = $3, created_at = $4
      `, [
        aggregateId,
        aggregate.version,
        JSON.stringify(aggregate),
        new Date()
      ]);
    } finally {
      client.release();
    }
  }

  async getSnapshot(aggregateId) {
    const client = await this.pool.connect();
    try {
      const result = await client.query(`
        SELECT state, version FROM snapshots
        WHERE aggregate_id = $1
      `, [aggregateId]);

      if (result.rows.length > 0) {
        const state = result.rows[0].state;
        const aggregate = new OrderAggregate(aggregateId);
        Object.assign(aggregate, state);
        return aggregate;
      }
      return null;
    } finally {
      client.release();
    }
  }
}

// ============== Order Repository ==============
class OrderRepository {
  constructor(eventStore, snapshotStore) {
    this.eventStore = eventStore;
    this.snapshotStore = snapshotStore;
  }

  async get(orderId) {
    // Try to load from snapshot first
    let aggregate = await this.snapshotStore.getSnapshot(orderId);
    let events;

    if (aggregate) {
      // Only replay events after snapshot
      events = await this.eventStore.getEvents(orderId, aggregate.version);
    } else {
      // Replay all events
      events = await this.eventStore.getEvents(orderId);
      if (!events.length) return null;
      aggregate = new OrderAggregate(orderId);
    }

    // Apply remaining events
    for (const event of events) {
      aggregate.apply(event);
    }

    // Create snapshot if needed
    if (aggregate.version % this.snapshotStore.snapshotInterval === 0) {
      await this.snapshotStore.saveSnapshot(orderId, aggregate);
    }

    return aggregate;
  }
}

// ============== Time Travel / Replay ==============
class EventReplayer {
  constructor(eventStore) {
    this.eventStore = eventStore;
  }

  async getStateAtTime(aggregateId, targetTime) {
    const events = await this.eventStore.getEvents(aggregateId);
    const filteredEvents = events.filter(e => 
      new Date(e.timestamp) <= targetTime
    );
    return OrderAggregate.fromEvents(filteredEvents);
  }

  async replayAllEvents(projector, fromPosition = 0) {
    let position = fromPosition;
    const batchSize = 1000;

    while (true) {
      const events = await this.eventStore.getAllEvents(position, batchSize);
      
      if (events.length === 0) break;

      for (const event of events) {
        await projector.project(event);
        position = event.global_position;
      }

      console.log(`Replayed up to position ${position}`);
    }

    return position;
  }
}

module.exports = {
  Event,
  EventType,
  EventStore,
  OrderAggregate,
  SnapshotStore,
  OrderRepository,
  EventReplayer
};
```
  </Tab>
</Tabs>

<Tip>
**When to use Event Sourcing:**
- Audit requirements (financial systems, healthcare)
- Need to replay/debug past states
- Complex business logic with temporal queries
- Event-driven microservices architecture
</Tip>

## Interview Questions: Senior Level

<Accordion title="How would you design for multi-region active-active?">
**Key Points**:
1. **Data replication**: Async replication between regions (eventual consistency)
2. **Conflict resolution**: Last-write-wins (with vector clocks) or custom merge
3. **Routing**: GeoDNS to route users to nearest region
4. **Failover**: Health checks + automatic DNS failover
5. **Consistency**: Accept that cross-region writes may conflict

**Trade-offs to mention**:
- Latency vs consistency
- Cost of running in multiple regions
- Complexity of conflict resolution
</Accordion>

<Accordion title="How do you handle a database that can't keep up with writes?">
**Solutions in order of complexity**:
1. **Batch writes**: Accumulate and write in batches
2. **Write-behind cache**: Write to Redis, async persist to DB
3. **Message queue**: Queue writes, process at sustainable rate
4. **Sharding**: Distribute writes across multiple DB nodes
5. **Different DB**: Switch to write-optimized DB (Cassandra, ScyllaDB)

**Always ask**: "What's the consistency requirement? Can we lose some writes?"
</Accordion>

<Accordion title="Explain how you'd implement distributed transactions">
**Answer structure**:
1. **First ask**: "Do we really need distributed transactions?" Often can redesign.
2. **2PC**: Strong consistency, but blocking and slow
3. **Saga**: Eventual consistency, compensating transactions
4. **Outbox pattern**: Reliable event publishing with local transaction

**Code example for Saga**:
```python
async def create_order_saga(order):
    try:
        order_id = await order_service.create(order)
        await inventory_service.reserve(order.items)
        await payment_service.charge(order.payment)
        await order_service.confirm(order_id)
    except PaymentFailed:
        await inventory_service.release(order.items)
        await order_service.cancel(order_id)
```
</Accordion>

<Accordion title="How do you debug a latency spike in a distributed system?">
**Systematic approach**:
1. **Observe**: Check metrics dashboards (p99 latency by service)
2. **Trace**: Use distributed tracing (Jaeger/Zipkin) to find slow span
3. **Correlate**: Check if spike correlates with deployments, traffic, or GC
4. **Drill down**: Once you find the service, check:
   - CPU/memory usage
   - DB query times (slow query log)
   - Network latency between services
   - Thread pool saturation
   - Lock contention

**Common causes**: DB slow queries, GC pauses, connection pool exhaustion, lock contention, network issues
</Accordion>

<Accordion title="How would you design a system that handles 1M requests per second?">
**Approach**:
1. **Back of envelope**: 1M RPS = ~60K servers at 16 RPS each (conservative)
2. **Stateless compute**: Horizontal scaling with load balancer
3. **Caching**: Cache everything possible (aim for 99%+ cache hit)
4. **CDN**: Serve static content from edge
5. **Database**: Shard aggressively, read replicas
6. **Async**: Queue non-critical work

**Bottleneck analysis**:
- Network: 1M Ã— 10KB = 10GB/s = 80Gbps (need multiple LBs)
- Compute: 1M / 10K (RPS per server) = 100 servers minimum
- Database: Can't hit DB for every request, need 99%+ cache hit
</Accordion>
