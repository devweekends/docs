---
title: "Database Design"
description: "SQL vs NoSQL, Sharding, Replication, and Indexing strategies"
icon: "database"
---

## SQL vs NoSQL

### When to Use SQL (Relational)

<CardGroup cols={2}>
  <Card title="ACID Required" icon="shield">
    Financial transactions, inventory management
  </Card>
  <Card title="Complex Queries" icon="magnifying-glass">
    Reporting, analytics with JOINs
  </Card>
  <Card title="Structured Data" icon="table">
    Fixed schema, clear relationships
  </Card>
  <Card title="Data Integrity" icon="lock">
    Foreign keys, constraints matter
  </Card>
</CardGroup>

### When to Use NoSQL

<CardGroup cols={2}>
  <Card title="Flexible Schema" icon="shapes">
    Evolving data models, semi-structured data
  </Card>
  <Card title="High Scale" icon="chart-line">
    Horizontal scaling, massive data volume
  </Card>
  <Card title="Low Latency" icon="bolt">
    Key-value lookups, caching layer
  </Card>
  <Card title="High Write Volume" icon="pen">
    Time series, event logging
  </Card>
</CardGroup>

### NoSQL Types

```
┌─────────────────────────────────────────────────────────────────┐
│                          NoSQL Types                            │
├─────────────────┬─────────────────┬─────────────────┬───────────┤
│   Key-Value     │    Document     │   Column-Family │   Graph   │
├─────────────────┼─────────────────┼─────────────────┼───────────┤
│ Redis           │ MongoDB         │ Cassandra       │ Neo4j     │
│ Memcached       │ CouchDB         │ HBase           │ Amazon    │
│ DynamoDB        │ DynamoDB        │ BigTable        │ Neptune   │
├─────────────────┼─────────────────┼─────────────────┼───────────┤
│ Simple lookups  │ Flexible docs   │ Wide columns    │ Relations │
│ Caching         │ Content mgmt    │ Time series     │ Social    │
│ Session store   │ User profiles   │ Analytics       │ Recommend │
└─────────────────┴─────────────────┴─────────────────┴───────────┘
```

## Database Sharding

Distribute data across multiple databases for horizontal scaling.

### Sharding Strategies

#### 1. Range-Based Sharding

```
┌─────────────────────────────────────────────────────────────┐
│                    User ID Range Sharding                   │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  User IDs 1-1M      User IDs 1M-2M     User IDs 2M-3M      │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐     │
│  │   Shard 1   │    │   Shard 2   │    │   Shard 3   │     │
│  └─────────────┘    └─────────────┘    └─────────────┘     │
│                                                             │
└─────────────────────────────────────────────────────────────┘

Pros: Simple, range queries work
Cons: Hotspots (new users all hit last shard)
```

#### 2. Hash-Based Sharding

```python
def get_shard(user_id, num_shards):
    return hash(user_id) % num_shards

# User 12345 → Shard (12345 % 4) = Shard 1
# User 67890 → Shard (67890 % 4) = Shard 2
```

```
┌─────────────────────────────────────────────────────────────┐
│                    Hash-Based Sharding                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│     hash(id) % 4                                           │
│     ┌────────────────────────────────────────┐             │
│     │              Shard Key                  │             │
│     └────────────────────────────────────────┘             │
│          │         │         │         │                   │
│          ▼         ▼         ▼         ▼                   │
│     ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐           │
│     │Shard 0 │ │Shard 1 │ │Shard 2 │ │Shard 3 │           │
│     └────────┘ └────────┘ └────────┘ └────────┘           │
│                                                             │
└─────────────────────────────────────────────────────────────┘

Pros: Even distribution
Cons: Range queries need all shards, resharding is hard
```

#### 3. Consistent Hashing

```
                    ┌───────────────────┐
                   ╱                     ╲
                  │                       │
             Node A    ●───────────●    Node B
                 ●                  ●
                │                    │
               │      Hash Ring       │
               │                      │
                ●                    ●
             Node D    ●───────────●    Node C
                  │                       │
                   ╲                     ╱
                    └───────────────────┘

• Keys hash to positions on ring
• Assigned to next node clockwise
• Adding/removing nodes only affects neighbors
```

### Sharding Challenges

| Challenge | Solution |
|-----------|----------|
| **Cross-shard queries** | Application-level joins, denormalization |
| **Transactions** | 2PC, Saga pattern, design to avoid |
| **Resharding** | Consistent hashing, virtual shards |
| **Hotspots** | Better shard key, splitting hot shards |

## Database Replication

### Synchronous vs Asynchronous

```
Synchronous Replication           Asynchronous Replication
                                  
Client ──► Master ──► Replica     Client ──► Master ─ ─► Replica
              │                                │
              ▼                                ▼
         Wait for ACK                   Return immediately
              │                                │
              ▼                                ▼
         Return to client             Replica catches up later
         
Pros: Strong consistency            Pros: Lower latency
Cons: Higher latency               Cons: Possible data loss
```

### Replication Topologies

```
Single Leader                    Multi-Leader
                                 
   ┌────────┐                   ┌────────┐   ┌────────┐
   │ Leader │                   │Leader A│◄─►│Leader B│
   └────┬───┘                   └────┬───┘   └────┬───┘
        │                            │            │
   ┌────┴────┐                  ┌────┴───┐  ┌────┴───┐
   │         │                  │Follower│  │Follower│
┌──┴──┐   ┌──┴──┐              └────────┘  └────────┘
│Foll1│   │Foll2│              
└─────┘   └─────┘              Use: Multi-datacenter
                               Challenge: Conflict resolution


Leaderless (Dynamo-style)
                                 
   ┌──────┐   ┌──────┐   ┌──────┐
   │Node A│◄─►│Node B│◄─►│Node C│
   └──────┘   └──────┘   └──────┘
       ▲                     ▲
       └─────────────────────┘
       
Write to W nodes, Read from R nodes
W + R > N ensures consistency
```

## Indexing

### B-Tree Index (Default)

```
                    ┌───────────────────┐
                    │    Root Node      │
                    │  [10, 20, 30]     │
                    └─────────┬─────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
┌───────▼───────┐   ┌─────────▼─────────┐   ┌───────▼───────┐
│   [5, 8, 9]   │   │  [12, 15, 18]     │   │ [25, 28, 35]  │
└───────┬───────┘   └─────────┬─────────┘   └───────┬───────┘
        │                     │                     │
        ▼                     ▼                     ▼
    [Leaf nodes with actual row pointers]
    
• Balanced tree structure
• O(log n) lookups
• Good for range queries
• Default for most databases
```

### Index Types

```sql
-- Single Column Index
CREATE INDEX idx_email ON users(email);

-- Composite Index (order matters!)
CREATE INDEX idx_name ON users(last_name, first_name);
-- Helps: WHERE last_name = 'Smith'
-- Helps: WHERE last_name = 'Smith' AND first_name = 'John'
-- Does NOT help: WHERE first_name = 'John'

-- Covering Index (includes columns)
CREATE INDEX idx_covering ON users(email) INCLUDE (name, status);
-- Query reads only from index, no table lookup

-- Partial Index
CREATE INDEX idx_active ON users(email) WHERE status = 'active';
-- Smaller index, only for specific queries

-- Full-Text Index
CREATE INDEX idx_content ON articles USING GIN(to_tsvector('english', content));
-- For text search
```

### Index Trade-offs

| Benefit | Cost |
|---------|------|
| Faster reads | Slower writes |
| Faster sorting | Storage space |
| Faster joins | Memory usage |
| — | Index maintenance |

## Query Optimization

### EXPLAIN ANALYZE

```sql
EXPLAIN ANALYZE
SELECT * FROM orders 
WHERE user_id = 123 
AND created_at > '2024-01-01';

-- Output:
-- Index Scan using idx_orders_user_date on orders
--   Index Cond: ((user_id = 123) AND (created_at > '2024-01-01'))
--   Rows Returned: 45
--   Actual Time: 0.023..0.089 ms
```

### Common Optimizations

```sql
-- ❌ Bad: Function on column prevents index use
SELECT * FROM users WHERE YEAR(created_at) = 2024;

-- ✅ Good: Range query uses index
SELECT * FROM users 
WHERE created_at >= '2024-01-01' AND created_at < '2025-01-01';

-- ❌ Bad: SELECT * fetches unnecessary data
SELECT * FROM users WHERE id = 123;

-- ✅ Good: Select only needed columns
SELECT id, name, email FROM users WHERE id = 123;

-- ❌ Bad: N+1 queries
for user in users:
    orders = query("SELECT * FROM orders WHERE user_id = ?", user.id)

-- ✅ Good: Single query with JOIN
SELECT u.*, o.* FROM users u 
LEFT JOIN orders o ON u.id = o.user_id 
WHERE u.status = 'active';
```

## Database Selection Guide

| Requirement | Recommended |
|-------------|-------------|
| Complex transactions | PostgreSQL, MySQL |
| Simple key-value | Redis, DynamoDB |
| Document storage | MongoDB |
| Time series | InfluxDB, TimescaleDB |
| Full-text search | Elasticsearch |
| Graph relations | Neo4j |
| Analytics | ClickHouse, BigQuery |
| Global scale | CockroachDB, Spanner |

<Tip>
**Design Tip**: Start with PostgreSQL for most applications. It handles JSON, full-text search, and scales well. Add specialized databases only when needed.
</Tip>
