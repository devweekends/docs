---
title: "OS Architecture & Fundamentals"
sidebarTitle: "Architecture & Fundamentals"
description: "Core concepts, layered architecture, and kernel subsystems"
icon: "layer-group"
---

# Operating System Architecture & Fundamentals

Before diving into code and implementation details, it's crucial to understand the high-level architecture of an operating system and the fundamental problems it solves.

## Operating System Architecture

Modern operating systems are typically organized in a **layered architecture**. This design separates user applications from the underlying hardware, ensuring security, stability, and ease of development.

![Operating System Organization and Architecture](/images/os-architecture.svg)

### Layer 1: User Space (The Top Layer)

This is where your applications live. Whether it's a text editor (VI), a compiler (CC), a shell (SH), or a web browser, they all run in **User Space**.

*   **Restricted Privileges**: Programs here run in "user mode" on the CPU. They cannot execute privileged instructions or access hardware directly.
*   **Isolation**: If a user program crashes, it doesn't bring down the whole system.
*   **Dependency**: To do anything useful (read a file, send a packet, draw to the screen), user programs must ask the kernel for help.

### Layer 2: Kernel Space (The Core)

The **Kernel** is the trusted core of the operating system. It runs in "kernel mode" (or supervisor mode) with full access to all hardware resources.

*   **The Gatekeeper**: It mediates all interactions between user applications and hardware.
*   **Resource Manager**: It decides who gets CPU time (scheduling), who gets memory, and how devices are accessed.
*   **Subsystems**: It contains critical components like the File System, Process Management, Memory Management, and the Network Stack.

### Layer 3: Hardware Layer (The Foundation)

At the bottom lies the physical hardware: the CPU, RAM, Disk, and Network Interface Cards (NICs). The OS abstracts this hardware so applications don't need to know the specific details of the machine they are running on.

### Interface Boundaries

*   **System Call Interface**: The boundary between User Space and Kernel Space. This is the only legal way for applications to cross into kernel mode.
*   **Hardware Abstraction Layer (HAL)**: The boundary between the Kernel and Hardware. Drivers and the HAL hide the complexity of specific hardware devices.

---

## Linux vs The Kernel: Understanding the Distinction

When people say "Linux," they often mean different things. It's important to understand the distinction between the **Linux kernel** and a **Linux operating system** (or Linux distribution).

### What is the Linux Kernel?

The **Linux kernel** is just the core component — the kernel itself. It was created by Linus Torvalds in 1991 and is the heart of the operating system.

**The kernel is responsible for:**
- Managing hardware resources (CPU, memory, devices)
- Process scheduling and management
- Memory management and virtual memory
- Device drivers
- File system support
- Network stack implementation
- System call interface

**What the kernel is NOT:**
- It's not a complete operating system
- It doesn't include user applications (shell, text editors, compilers)
- It doesn't include system utilities (ls, cp, grep)
- It doesn't include graphical interfaces
- It doesn't include package managers or init systems

### What is a Linux Operating System?

A **Linux operating system** (or Linux distribution) is a complete, usable system built around the Linux kernel. It includes:

1. **The Linux Kernel** - The core
2. **GNU Utilities** - Command-line tools (bash, coreutils, grep, sed, awk)
3. **System Libraries** - glibc (C library), other shared libraries
4. **Init System** - systemd, SysVinit, or OpenRC
5. **Package Manager** - apt, yum, pacman, etc.
6. **User Applications** - Text editors, web browsers, development tools
7. **Desktop Environment** (optional) - GNOME, KDE, XFCE
8. **Configuration Tools** - System administration utilities

### The GNU/Linux Debate

Technically, most "Linux" systems should be called **GNU/Linux** because:
- The kernel is Linux
- Most of the user-space tools come from the GNU Project (started by Richard Stallman in 1983)

```
┌─────────────────────────────────────────────────────────┐
│              COMPLETE LINUX SYSTEM                       │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  User Applications                                       │
│  ┌────────────────────────────────────────────────────┐ │
│  │  Firefox, LibreOffice, VS Code, etc.               │ │
│  └────────────────────────────────────────────────────┘ │
│                                                          │
│  Desktop Environment (Optional)                          │
│  ┌────────────────────────────────────────────────────┐ │
│  │  GNOME, KDE, XFCE                                  │ │
│  └────────────────────────────────────────────────────┘ │
│                                                          │
│  System Utilities & Tools                                │
│  ┌────────────────────────────────────────────────────┐ │
│  │  GNU Coreutils (ls, cp, mv, grep, sed)             │ │
│  │  Shells (bash, zsh)                                │ │
│  │  Package Managers (apt, yum)                       │ │
│  └────────────────────────────────────────────────────┘ │
│                                                          │
│  System Libraries                                        │
│  ┌────────────────────────────────────────────────────┐ │
│  │  glibc, libssl, libpthread                         │ │
│  └────────────────────────────────────────────────────┘ │
│                                                          │
│  Init System                                             │
│  ┌────────────────────────────────────────────────────┐ │
│  │  systemd / SysVinit / OpenRC                       │ │
│  └────────────────────────────────────────────────────┘ │
│                                                          │
│  ═══════════════════════════════════════════════════    │
│                                                          │
│  THE LINUX KERNEL                                        │
│  ┌────────────────────────────────────────────────────┐ │
│  │  Process Management, Memory Management             │ │
│  │  File Systems, Device Drivers, Network Stack       │ │
│  └────────────────────────────────────────────────────┘ │
│                                                          │
│  ═══════════════════════════════════════════════════    │
│                                                          │
│  Hardware (CPU, RAM, Disk, Network)                      │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

### Popular Linux Distributions

Different organizations package the Linux kernel with different sets of tools and configurations:

| Distribution | Target Audience | Package Manager | Init System |
|--------------|----------------|-----------------|-------------|
| **Ubuntu** | Desktop users, beginners | apt | systemd |
| **Debian** | Stability-focused users | apt | systemd |
| **Fedora** | Developers, cutting-edge | dnf | systemd |
| **Red Hat Enterprise Linux (RHEL)** | Enterprise servers | yum/dnf | systemd |
| **Arch Linux** | Advanced users | pacman | systemd |
| **Alpine Linux** | Containers, minimal systems | apk | OpenRC |
| **CentOS / Rocky Linux** | RHEL-compatible servers | yum/dnf | systemd |

### Key Takeaways

<Note>
**When someone says "Linux," context matters:**
- **"I'm running Linux"** → They mean a Linux distribution (Ubuntu, Fedora, etc.)
- **"The Linux kernel version is 6.5"** → They're talking about the kernel specifically
- **"Linux kernel development"** → Working on the core kernel code
- **"Linux system administration"** → Managing a complete Linux OS
</Note>

**For this course:**
- When we discuss **kernel internals**, we're talking about the Linux kernel itself
- When we discuss **system administration** or **user space**, we're talking about the complete Linux operating system
- Understanding this distinction is crucial for technical interviews and system design discussions

---

## Fundamental Purposes of an Operating System

Why do we even need an operating system? Why can't applications just talk to hardware directly? An OS solves several critical problems:

### 1. Hardware Abstraction
*   **Problem**: Hardware is complex and diverse. A hard drive from Vendor A works differently than one from Vendor B.
*   **OS Solution**: The OS provides uniform, simplified interfaces. You write to a "file", and the OS handles whether that file is on an SSD, HDD, or a network share.
*   **Benefit**: Portability. Programmers write code once, and it runs on any hardware supported by the OS.

### 2. Multiplexing (Resource Sharing)
*   **Problem**: You have one CPU and limited RAM, but you want to run 50 programs at once.
*   **OS Solution**: The OS "time-shares" the CPU (switching between processes milliseconds at a time) and "space-shares" memory.
*   **Benefit**: Efficiency. Expensive hardware resources are utilized fully, and users perceive that programs are running simultaneously.

### 3. Isolation (Protection)
*   **Problem**: A buggy program could overwrite another program's memory or crash the system. Malicious code could steal data.
*   **OS Solution**: The OS enforces strict boundaries. Process A cannot touch Process B's memory. User programs cannot execute dangerous CPU instructions.
*   **Benefit**: Stability and Security. One crash doesn't kill the system.

### 4. Controlled Sharing
*   **Problem**: Total isolation is too restrictive. Sometimes processes *need* to talk to each other (e.g., a web server talking to a database).
*   **OS Solution**: The OS provides safe mechanisms for Inter-Process Communication (IPC) like pipes, shared memory, and sockets.
*   **Benefit**: Cooperation. Programs can work together safely.

### 5. Security and Access Control
*   **Problem**: In a multi-user system, users shouldn't be able to read each other's private files.
*   **OS Solution**: Authentication (login) and Authorization (file permissions, ACLs).
*   **Benefit**: Privacy. Data is protected in shared environments.

### 6. Performance Optimization
*   **Problem**: Naive access to resources is slow.
*   **OS Solution**: The OS uses smart algorithms: caching frequently used disk blocks in RAM, scheduling processes to minimize latency, and using DMA (Direct Memory Access) to offload the CPU.
*   **Benefit**: Speed. The system feels responsive and handles high throughput.

---

## Inside the Kernel: Major Subsystems

The kernel is a complex beast, often containing millions of lines of code. It is divided into logical subsystems, each with a specific responsibility.

### 1. File System Layer
*   **Content Management**: Tracks where data lives on the disk (blocks, sectors).
*   **Namespace Management**: Organizes files into a hierarchy (directories, filenames).
*   **Abstraction**: Allows different file systems (ext4, NTFS, FAT32) to look the same to applications.

### 2. Process Management
*   **Lifecycle**: Creates, manages, and destroys processes.
*   **Scheduling**: Decides which process runs on which CPU core and for how long.
*   **Context Switching**: Saves the state of a running process and restores another.

### 3. Memory Management
*   **Virtual Memory**: Gives each process the illusion of having its own large, private memory.
*   **Translation**: Maps virtual addresses to physical RAM using Page Tables.
*   **Paging/Swapping**: Moves data between RAM and disk when memory is full.

### 4. Access Control System
*   **Authentication**: Verifies user identity.
*   **Authorization**: Checks permissions (e.g., "Does User A have read access to `/home/userB/private.txt`?").

### 5. Device Drivers
*   **The Translators**: Small programs that know how to speak to specific hardware (graphics cards, USB controllers) and translate OS requests into hardware commands.

### 6. Network Stack
*   **Communication**: Implements protocols like TCP/IP to allow the computer to talk to the world.
*   **Routing**: Decides where to send data packets.

---

## The Application-Kernel Interface (System Calls)

The **System Call** is the primary mechanism for applications to interact with the OS. It is a programmatic request for a service.

### How System Calls Work

1.  **Request**: Application calls a library function (e.g., `open()`).
2.  **Trap**: The library executes a special CPU instruction (trap/syscall) that switches the CPU from User Mode to Kernel Mode.
3.  **Handle**: The Kernel's system call handler runs. It verifies the arguments (security check) and performs the operation.
4.  **Return**: The Kernel switches back to User Mode and returns the result to the application.

### Examples

*   **Process Control**: `fork()` (create process), `exec()` (run program), `exit()` (terminate).
*   **File Operations**: `open()`, `read()`, `write()`, `close()`.
*   **Communication**: `socket()`, `connect()`, `send()`, `recv()`.
*   **Memory**: `mmap()` (map memory), `brk()` (change heap size).

> **Note**: System calls are expensive because of the "mode switch" overhead. High-performance applications often try to minimize the number of system calls they make (e.g., by buffering data).
