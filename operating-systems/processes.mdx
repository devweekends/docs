---
title: "Process Management"
sidebarTitle: "Processes"
description: "Deep dive into process lifecycle, PCB, fork/exec, and context switching"
icon: "microchip"
---

# Process Management

A **process** is a program in execution — the fundamental unit of work in an operating system. Understanding process management is essential for senior engineering interviews, as it underlies everything from application behavior to container orchestration.

<Info>
**Interview Frequency**: Very High (asked in 80%+ of OS interviews)  
**Key Topics**: Process states, fork/exec, context switching, PCB  
**Time to Master**: 8-10 hours
</Info>

---

## Process vs Program

<CardGroup cols={2}>
  <Card title="Program" icon="file-code">
    - Static entity stored on disk
    - Contains code and static data
    - Passive — does nothing by itself
    - Example: `/usr/bin/python3`
  </Card>
  <Card title="Process" icon="play">
    - Dynamic instance in execution
    - Has runtime state (registers, heap, stack)
    - Active — consumes CPU, memory, I/O
    - Example: Running Python interpreter with PID 1234
  </Card>
</CardGroup>

<Note>
**Interview Insight**: "A program becomes a process when loaded into memory and given system resources. Multiple processes can run the same program simultaneously."
</Note>

---

## Process Memory Layout

Every process has a well-defined memory layout:

```
┌─────────────────────────────────────────────────────────────────┐
│                        HIGH ADDRESSES                            │
├─────────────────────────────────────────────────────────────────┤
│                         KERNEL SPACE                             │
│          (not accessible from user mode)                         │
├─────────────────────────────────────────────────────────────────┤
│                            STACK                                 │
│    ↓ grows downward                                              │
│    - Local variables                                             │
│    - Function call frames                                        │
│    - Return addresses                                            │
├─────────────────────────────────────────────────────────────────┤
│                              ↕                                   │
│                     (unmapped region)                            │
├─────────────────────────────────────────────────────────────────┤
│                            HEAP                                  │
│    ↑ grows upward                                                │
│    - Dynamic memory (malloc/new)                                 │
│    - Managed by memory allocator                                 │
├─────────────────────────────────────────────────────────────────┤
│                     BSS (Uninitialized Data)                     │
│    - Global/static variables initialized to 0                    │
├─────────────────────────────────────────────────────────────────┤
│                     DATA (Initialized Data)                      │
│    - Global/static variables with initial values                 │
├─────────────────────────────────────────────────────────────────┤
│                         TEXT (Code)                              │
│    - Executable instructions                                     │
│    - Read-only (usually)                                         │
├─────────────────────────────────────────────────────────────────┤
│                        LOW ADDRESSES                             │
└─────────────────────────────────────────────────────────────────┘
```

### Memory Segment Details

| Segment | Contents | Characteristics |
|---------|----------|-----------------|
| **Text** | Machine code | Read-only, sharable between processes |
| **Data** | Initialized globals | `int x = 10;` lives here |
| **BSS** | Uninitialized globals | `int y;` — initialized to 0 by OS |
| **Heap** | Dynamic allocation | `malloc()`, `new` — programmer managed |
| **Stack** | Function calls | Automatic allocation/deallocation |

<Warning>
**Common Bug**: Stack overflow occurs when stack grows into heap or exceeds its limit. Heap fragmentation occurs when many small allocations leave unusable gaps.
</Warning>

---

## Process Control Block (PCB)

The **PCB** (or **task_struct** in Linux) is the kernel's data structure representing a process:

```c
// Simplified view of Linux task_struct
struct task_struct {
    // Process Identification
    pid_t pid;                    // Process ID
    pid_t tgid;                   // Thread Group ID
    
    // Process State
    volatile long state;          // RUNNING, SLEEPING, etc.
    
    // Scheduling Information
    int prio, static_prio;        // Priority values
    struct sched_entity se;       // Scheduler entity
    
    // Memory Management
    struct mm_struct *mm;         // Memory descriptor
    
    // File System
    struct files_struct *files;   // Open file table
    struct fs_struct *fs;         // Filesystem info
    
    // Credentials
    const struct cred *cred;      // Security credentials
    
    // Parent/Child Relationships
    struct task_struct *parent;   // Parent process
    struct list_head children;    // Child processes
    
    // CPU Context (saved on context switch)
    struct thread_struct thread;  // CPU-specific state
    
    // Signals
    struct signal_struct *signal; // Signal handlers
};
```

### PCB Information Categories

<Tabs>
  <Tab title="Identification">
    - **PID**: Unique process identifier
    - **PPID**: Parent process ID
    - **UID/GID**: User and group ownership
    - **Session ID**: For terminal sessions
  </Tab>
  <Tab title="CPU State">
    - **Program Counter**: Next instruction address
    - **Registers**: General purpose, stack pointer
    - **CPU scheduling state**: Priority, time slice
    - **Flags**: Condition codes
  </Tab>
  <Tab title="Memory">
    - **Page table pointer**: Virtual→Physical mapping
    - **Memory limits**: Stack/heap boundaries
    - **Memory usage stats**: RSS, virtual size
  </Tab>
  <Tab title="I/O & Files">
    - **Open file table**: File descriptors
    - **Current directory**: Working directory
    - **Root directory**: For chroot
  </Tab>
</Tabs>

---

## Process States

A process transitions through various states during its lifetime:

```
                          ┌─────────────────────────────────────┐
                          │           State Diagram              │
                          └─────────────────────────────────────┘

    ┌──────────┐   fork()    ┌──────────┐
    │  Parent  │────────────→│   NEW    │
    └──────────┘             └────┬─────┘
                                  │ admitted
                                  ↓
    ┌────────────────────────────────────────────────────────────┐
    │                        READY QUEUE                          │
    │   ┌──────────┐  ┌──────────┐  ┌──────────┐                 │
    │   │  READY   │  │  READY   │  │  READY   │  ...            │
    │   └────┬─────┘  └──────────┘  └──────────┘                 │
    └────────│───────────────────────────────────────────────────┘
             │ scheduler dispatch
             ↓
      ┌──────────┐                          ┌──────────┐
      │ RUNNING  │─── I/O or event wait ───→│ BLOCKED  │
      └────┬─────┘                          └────┬─────┘
           │                                     │ I/O complete
           │ preempt/yield                       │
           │←────────────────────────────────────┘
           │
           ↓ exit()
      ┌──────────┐          wait()           ┌──────────┐
      │  ZOMBIE  │←──────────────────────────│  PARENT  │
      └────┬─────┘                           └──────────┘
           │ reaped
           ↓
      ┌──────────┐
      │TERMINATED│
      └──────────┘
```

### State Definitions

| State | Description | Linux Representation |
|-------|-------------|---------------------|
| **New** | Process being created | N/A (transient) |
| **Ready** | Waiting for CPU | TASK_RUNNING (in run queue) |
| **Running** | Executing on CPU | TASK_RUNNING (current) |
| **Blocked/Waiting** | Waiting for I/O or event | TASK_INTERRUPTIBLE / TASK_UNINTERRUPTIBLE |
| **Zombie** | Terminated, waiting for parent | TASK_ZOMBIE |
| **Terminated** | Fully cleaned up | N/A (removed) |

<Note>
**TASK_INTERRUPTIBLE vs TASK_UNINTERRUPTIBLE**: 
- Interruptible: Process can be woken by signals (common case)
- Uninterruptible: Must complete I/O first (shows as 'D' in `ps` — often disk I/O)
</Note>

---

## Process Creation: fork() and exec()

The Unix process model is elegant: **fork()** creates a copy, **exec()** transforms it.

### fork() — Creating a Child Process

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    int x = 100;
    
    pid_t pid = fork();  // Create child process
    
    if (pid < 0) {
        // Error occurred
        perror("fork failed");
        return 1;
    } 
    else if (pid == 0) {
        // Child process
        x += 50;
        printf("Child: x = %d, PID = %d, Parent PID = %d\n", 
               x, getpid(), getppid());
    } 
    else {
        // Parent process
        x -= 50;
        printf("Parent: x = %d, PID = %d, Child PID = %d\n", 
               x, getpid(), pid);
        wait(NULL);  // Wait for child to terminate
    }
    
    return 0;
}
```

**Output:**
```
Parent: x = 50, PID = 1000, Child PID = 1001
Child: x = 150, PID = 1001, Parent PID = 1000
```

### What fork() Actually Does

```
Before fork():                After fork():
┌─────────────────┐          ┌─────────────────┐  ┌─────────────────┐
│     Process     │          │     Parent      │  │      Child      │
│    PID: 1000    │   ───►   │    PID: 1000    │  │    PID: 1001    │
│                 │          │                 │  │                 │
│  Code Segment   │          │  Code Segment   │  │  Code Segment   │
│  Data: x = 100  │          │  Data: x = 100  │  │  Data: x = 100  │
│  Stack          │          │  Stack          │  │  Stack          │
│  Heap           │          │  Heap           │  │  Heap           │
│  Files: 0,1,2   │          │  Files: 0,1,2   │  │  Files: 0,1,2   │
└─────────────────┘          └─────────────────┘  └─────────────────┘
                                    │                    │
                                    └─ fork() returns ─→ returns 0
                                       child PID (1001)
```

### Copy-on-Write (COW)

Modern systems don't actually copy all memory immediately:

<Steps>
  <Step title="Initial State">
    After fork(), parent and child share the same physical pages marked read-only
  </Step>
  <Step title="Write Attempt">
    When either process tries to write, a page fault occurs
  </Step>
  <Step title="Copy Made">
    Kernel copies only that specific page for the writer
  </Step>
  <Step title="Continue">
    Process continues with its own private copy of that page
  </Step>
</Steps>

<Tip>
**Why COW?** Many processes fork() then immediately exec(), so copying all memory would be wasted work. COW makes fork() nearly O(1) in practice.
</Tip>

### exec() Family — Replacing Process Image

```c
#include <unistd.h>

int main() {
    pid_t pid = fork();
    
    if (pid == 0) {
        // Child: replace with ls command
        char *args[] = {"ls", "-la", "/home", NULL};
        execvp("ls", args);
        
        // Only reached if exec fails
        perror("execvp failed");
        return 1;
    }
    
    wait(NULL);
    return 0;
}
```

### exec() Variants

| Function | Path Search | Arguments | Environment |
|----------|-------------|-----------|-------------|
| `execl` | No | List | Inherited |
| `execlp` | Yes ($PATH) | List | Inherited |
| `execle` | No | List | Explicit |
| `execv` | No | Array | Inherited |
| `execvp` | Yes ($PATH) | Array | Inherited |
| `execve` | No | Array | Explicit |

**Mnemonic**: 
- `l` = list, `v` = vector (array)
- `p` = path search
- `e` = environment

---

## Context Switching

A **context switch** is the process of saving one process's state and restoring another's.

### What Gets Saved/Restored

```
┌─────────────────────────────────────────────────────────────────┐
│                    CONTEXT SWITCH SEQUENCE                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Process A (Running)          →→→→→→          Process B (Ready)  │
│                                                                  │
│  1. Interrupt/Syscall triggers switch                           │
│                                                                  │
│  2. Save Process A's context:                                   │
│     ├─ Program Counter                                          │
│     ├─ Stack Pointer                                            │
│     ├─ General Registers                                        │
│     ├─ Floating Point Registers                                 │
│     ├─ Condition Codes/Flags                                    │
│     └─ Memory Management (page table base)                      │
│                                                                  │
│  3. Update Process A's PCB                                      │
│     └─ State: RUNNING → READY/BLOCKED                           │
│                                                                  │
│  4. Select Process B (scheduler decision)                       │
│                                                                  │
│  5. Load Process B's context:                                   │
│     ├─ Restore all registers from PCB                           │
│     ├─ Set page table base register                             │
│     └─ Flush TLB (or use ASID to avoid)                         │
│                                                                  │
│  6. Update Process B's PCB                                      │
│     └─ State: READY → RUNNING                                   │
│                                                                  │
│  7. Jump to Process B's saved PC                                │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Context Switch Overhead

<Warning>
Context switches are **expensive**! They typically cost 1-10 microseconds directly, but indirect costs (cache pollution, TLB flush) can be much higher.
</Warning>

| Cost Component | Typical Time | Description |
|----------------|--------------|-------------|
| Register Save/Restore | 0.1-0.5 μs | Dozens of registers |
| TLB Flush | 0.5-2 μs | Invalidate virtual→physical mappings |
| Cache Effects | 10-100+ μs | Cold cache causes many misses |
| Scheduler Decision | 0.1-1 μs | Selecting next process |

### Reducing Context Switch Overhead

1. **ASID (Address Space Identifiers)**: Avoid full TLB flush
2. **Larger time slices**: Fewer switches (but higher latency)
3. **CPU pinning**: Keep process on same CPU for cache warmth
4. **User-space threading**: Avoid kernel involvement for green threads

---

## Zombie and Orphan Processes

### Zombie Process

A **zombie** is a terminated process whose parent hasn't yet called `wait()`:

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();
    
    if (pid == 0) {
        // Child exits immediately
        printf("Child exiting\n");
        return 0;
    }
    
    // Parent doesn't call wait() - child becomes zombie
    printf("Parent sleeping... child is now a zombie\n");
    sleep(60);  // During this time, child is zombie
    
    return 0;
}
```

**Check with `ps`:**
```bash
$ ps aux | grep Z
user  1001  0.0  0.0  0  0  ?  Z  12:00  0:00 [a.out] <defunct>
```

<Warning>
**Problem**: Zombies consume PID entries. A system can run out of PIDs if too many zombies accumulate.

**Solution**: Parent must call `wait()` or `waitpid()`, or use `SIGCHLD` handler.
</Warning>

### Orphan Process

An **orphan** is a child whose parent terminated first:

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();
    
    if (pid > 0) {
        // Parent exits immediately
        printf("Parent exiting, child will be orphaned\n");
        return 0;
    }
    
    // Child continues running
    sleep(5);
    printf("Orphan child: my new parent is %d\n", getppid());
    
    return 0;
}
```

**Output:**
```
Parent exiting, child will be orphaned
Orphan child: my new parent is 1
```

<Note>
Orphans are "adopted" by init (PID 1) or a subreaper process, which will properly reap them when they terminate.
</Note>

---

## Fork Variants

### vfork()

A **vfork()** is optimized for the fork-then-exec pattern:

```c
pid_t pid = vfork();

if (pid == 0) {
    // Child: MUST call exec() or _exit() immediately
    // Parent is SUSPENDED until child does so
    execl("/bin/ls", "ls", NULL);
    _exit(1);  // Not exit() — avoid flushing parent's buffers
}
```

| Aspect | fork() | vfork() |
|--------|--------|---------|
| Address space | Copied (COW) | Shared with parent |
| Parent execution | Continues | Suspended until exec/_exit |
| Safety | Safe for any use | Dangerous — child can corrupt parent |
| Use case | General | fork + immediate exec |

### clone() — Linux's Swiss Army Knife

The `clone()` system call provides fine-grained control over resource sharing:

```c
#include <sched.h>

// Create new thread (shares everything)
clone(fn, stack, CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, arg);

// Create new process (like fork)
clone(fn, stack, SIGCHLD, arg);

// Create process with new namespace (containers)
clone(fn, stack, CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET, arg);
```

**Common Clone Flags:**

| Flag | Effect |
|------|--------|
| `CLONE_VM` | Share virtual memory |
| `CLONE_FS` | Share filesystem info (cwd, root) |
| `CLONE_FILES` | Share file descriptor table |
| `CLONE_SIGHAND` | Share signal handlers |
| `CLONE_THREAD` | Same thread group (for pthreads) |
| `CLONE_NEWPID` | New PID namespace (containers) |
| `CLONE_NEWNS` | New mount namespace |

---

## Interview Deep Dive Questions

<AccordionGroup>
  <Accordion title="Q1: Explain what happens when you type 'ls' in a shell">
    **Complete Answer:**
    
    1. Shell (bash) reads input "ls" from stdin
    2. Shell parses the command and arguments
    3. Shell calls `fork()` to create child process
       - COW creates lightweight copy
    4. Child process calls `execvp("ls", args)`
       - Kernel loads `/bin/ls` executable
       - New code, data, heap, stack are set up
       - File descriptors 0,1,2 remain (inherited)
    5. Parent shell calls `waitpid()` and blocks
    6. ls process runs, writes to stdout (fd 1)
    7. ls calls `exit(0)`, becomes zombie
    8. Parent's `waitpid()` returns, zombie is reaped
    9. Shell displays next prompt
  </Accordion>
  
  <Accordion title="Q2: Why is fork() before exec() expensive?">
    **Answer:**
    
    Even with COW, fork() still must:
    - Allocate new PID and PCB
    - Copy page table entries (not data, but metadata)
    - Copy file descriptor table
    - Copy signal handlers and other process state
    - Set up memory mappings
    
    For a process with 10GB virtual memory, copying page table entries alone can be significant.
    
    **Alternatives:**
    - `vfork()`: Suspends parent, shares address space
    - `posix_spawn()`: Single call that does fork+exec atomically
    - Clone with minimal sharing for containers
  </Accordion>
  
  <Accordion title="Q3: Can a zombie process be killed with kill -9?">
    **Answer:**
    
    **No.** A zombie is already dead — it's not running any code. `kill` sends signals to running processes.
    
    A zombie exists only because:
    - Its exit status hasn't been collected by parent
    - Its PCB entry and PID are retained for this purpose
    
    **To eliminate zombies:**
    - Parent calls `wait()`/`waitpid()`
    - Kill the parent — orphaned zombies are adopted by init and reaped
    - Use `SIGCHLD` handler to auto-reap
    
    ```c
    // Auto-reap children
    signal(SIGCHLD, SIG_IGN);
    ```
  </Accordion>
  
  <Accordion title="Q4: What's the difference between process and thread context switch?">
    **Answer:**
    
    | Aspect | Process Switch | Thread Switch |
    |--------|----------------|---------------|
    | Address space | Changes | Same |
    | Page table | Switched (TLB flush) | Not changed |
    | CPU registers | Saved/restored | Saved/restored |
    | Kernel overhead | Higher | Lower |
    | Cache effects | Worse (different memory) | Better (shared data) |
    | Typical cost | 1-10 μs + cache misses | 0.1-1 μs |
    
    Thread switches within the same process are much cheaper because:
    - No page table switch needed
    - Shared memory means cached data stays valid
    - Only thread-local state needs saving
  </Accordion>
  
  <Accordion title="Q5: Design a system to handle 10,000 concurrent connections">
    **Answer:**
    
    **Process-per-connection (not recommended):**
    - 10,000 processes = massive memory overhead
    - Context switch overhead kills performance
    
    **Thread-per-connection:**
    - Better but still problematic at 10K
    - Stack memory: 10K × 8MB = 80GB virtual memory
    - Thread switching overhead
    
    **Event-driven (epoll/io_uring):**
    - Single thread handles many connections
    - Use `epoll_wait()` to multiplex I/O
    - Non-blocking I/O for all sockets
    
    **Hybrid:**
    - Multiple worker processes (CPU count)
    - Each uses event loop for many connections
    - Examples: Nginx, Node.js cluster
    
    ```c
    // epoll example
    int epfd = epoll_create1(0);
    while (1) {
        int n = epoll_wait(epfd, events, MAX_EVENTS, -1);
        for (int i = 0; i < n; i++) {
            handle_event(events[i]);  // Non-blocking
        }
    }
    ```
  </Accordion>
</AccordionGroup>

---

## Practice Exercises

<Steps>
  <Step title="Fork Chain">
    Write a program that creates a chain of N processes (each child creates one grandchild). Print the process tree.
  </Step>
  <Step title="Zombie Factory">
    Create a program that generates zombies, then use `ps` to observe them. Implement proper cleanup.
  </Step>
  <Step title="Measure Context Switch">
    Use pipes between two processes to measure context switch time by rapidly passing a token back and forth.
  </Step>
  <Step title="Custom Shell">
    Implement a simple shell that can run commands, handle pipes, and manage background processes.
  </Step>
</Steps>

---

## Key Takeaways

<CardGroup cols={2}>
  <Card title="Process = Execution Context" icon="microchip">
    PCB contains everything kernel needs: state, memory, files, credentials
  </Card>
  <Card title="Fork + Exec" icon="code-branch">
    Unix model: copy then transform. COW makes fork cheap.
  </Card>
  <Card title="Context Switch Cost" icon="clock">
    Direct cost + cache/TLB effects. Minimize switches for performance.
  </Card>
  <Card title="Zombie/Orphan Handling" icon="ghost">
    Always reap children. Orphans adopted by init.
  </Card>
</CardGroup>

---

Next: [Threads & Concurrency](/operating-systems/threads) →
