---
title: "xv6: A Teaching Operating System"
sidebarTitle: "xv6 OS"
description: "Learn OS internals through xv6, a simple Unix-like teaching operating system"
icon: "book-open-reader"
---

# xv6 - The Teaching Operating System

xv6 is a **simple, Unix-like operating system** designed specifically for teaching. It's become the gold standard for OS courses worldwide.

---

## What is xv6?

**Origin Story:**
- Created at MIT for their 6.828 Operating System Engineering course
- Reimplementation of **Unix V6** (from 1975) in modern C
- Originally for x86, now mainly **xv6-riscv** for RISC-V

**Philosophy:**
- Small enough to understand completely (~9,000 lines of code)
- Real enough to be useful (actual working OS)
- Simple enough to teach (no unnecessary complexity)
- Complete enough to demonstrate key OS concepts

---

## Why xv6 is Perfect for Learning

**1. It's Actually Small**
```
Linux kernel:    20+ million lines
Windows NT:      50+ million lines  
xv6:             ~9,000 lines       ← You can read ALL of it!
```

**2. It's Real**
- Not a toy - actually boots and runs
- Real processes, real file system, real scheduler
- Has a shell, can run programs
- Demonstrates actual OS implementation

**3. It's Well-Documented**
- Comes with a detailed book explaining every line
- Clean, readable code
- Extensive comments
- "xv6: a simple, Unix-like teaching operating system" (free PDF)

---

## What xv6 Includes

xv6 implements core Unix concepts:

**Process Management:**
- `fork()` - create processes
- `exec()` - run programs
- `wait()` - wait for children
- `exit()` - terminate
- Context switching
- Simple round-robin scheduler

**File System:**
- Unix-like hierarchical file system
- inodes, directories, paths
- File descriptors
- `open()`, `read()`, `write()`, `close()`

**System Calls:**
About 21 system calls total:
```c
fork(), exit(), wait(), exec()
open(), write(), read(), close()
mkdir(), chdir(), dup(), pipe()
kill(), sleep(), uptime()
```

**Memory Management:**
- Virtual memory with page tables
- User/kernel address spaces
- Simple memory allocator

**Devices:**
- Console (keyboard/screen)
- Disk driver
- UART (serial port)

**User Programs:**
- Shell (sh)
- Basic utilities: ls, cat, grep, rm, mkdir, echo, etc.

---

## xv6 File Structure

```
xv6-riscv/
├── kernel/           # Kernel code
│   ├── main.c       # Boot and initialization
│   ├── proc.c       # Process management
│   ├── vm.c         # Virtual memory
│   ├── fs.c         # File system
│   ├── bio.c        # Buffer cache
│   ├── trap.c       # Interrupt/exception handling
│   ├── syscall.c    # System call dispatcher
│   └── ...
├── user/            # User-space programs
│   ├── sh.c         # Shell
│   ├── ls.c         # List files
│   ├── cat.c        # Print file
│   ├── grep.c       # Search
│   └── ...
├── mkfs/            # File system creation tool
└── Makefile         # Build system
```

---

## Getting Started with xv6

**Installation (Ubuntu/Debian):**
```bash
# Install dependencies
sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu 

# Clone xv6
git clone git://github.com/mit-pdos/xv6-riscv.git
cd xv6-riscv

# Build and run
make qemu

# You'll see xv6 boot and get a shell prompt:
$ 
```

**First Commands to Try:**
```bash
$ ls              # List files
$ cat README      # Show file contents  
$ echo hello xv6  # Print text
$ grep the README # Search in file
$ wc README       # Word count
$ mkdir test      # Create directory
$ sh              # Start new shell
```

---

## The Complete Boot Sequence

### Step 1: QEMU Starts
```
1. QEMU creates virtual RISC-V machine
2. Loads kernel/kernel at RAM address 0x80000000
3. Sets PC (program counter) to 0x80000000
4. Starts executing
```

### Step 2: Entry Point (`kernel/entry.S`)
```assembly
# This is the first code that runs!
# We're in Machine mode (highest privilege)

_entry:
    # Setup stack for each CPU
    la sp, stack0           # Load stack address
    li a0, 1024*4           # Stack size
    csrr a1, mhartid        # Get CPU ID
    addi a1, a1, 1
    mul a0, a0, a1
    add sp, sp, a0          # sp = stack0 + (cpu_id + 1) * 4096
    
    # Jump to start() in C
    call start
```

### Step 3: Machine Mode Setup (`kernel/start.c`)
```c
void start()
{
  // Set M Previous Privilege mode to Supervisor (S-mode)
  unsigned long x = r_mstatus();
  x &= ~MSTATUS_MPP_MASK;
  x |= MSTATUS_MPP_S;
  w_mstatus(x);

  // Set return address to main()
  w_mepc((uint64)main);
  
  // Delegate interrupts and exceptions to S-mode
  w_medeleg(0xffff);
  w_mideleg(0xffff);
  
  // Enable timer interrupts in S-mode
  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);

  // Set supervisor trap vector
  w_stvec((uint64)kernelvec);

  // Configure Physical Memory Protection
  w_pmpaddr0(0x3fffffffffffffull);
  w_pmpcfg0(0xf);

  // Timer interrupt initialization
  timerinit();

  // Return to S-mode and jump to main()
  asm volatile("mret");
}
```

### Step 4: Kernel Main (`kernel/main.c`)
```c
void main()
{
  if(cpuid() == 0){
    consoleinit();     // Initialize UART for console I/O
    printfinit();      // Initialize printf
    printf("\n");
    printf("xv6 kernel is booting\n");
    printf("\n");
    kinit();           // Physical memory allocator
    kvminit();         // Create kernel page table
    kvminithart();     // Turn on paging
    procinit();        // Process table
    trapinit();        // Trap vectors
    trapinithart();    // Install kernel trap vector
    plicinit();        // Interrupt controller
    plicinithart();    // Ask PLIC for device interrupts
    binit();           // Buffer cache
    iinit();           // Inode table
    fileinit();        // File table
    virtio_disk_init();// Disk driver
    userinit();        // First user process
    __sync_synchronize();
    started = 1;
  } else {
    while(started == 0)
      ;
    __sync_synchronize();
    printf("hart %d starting\n", cpuid());
    kvminithart();
    trapinithart();
    plicinithart();
  }

  scheduler();         // Start scheduling processes
}
```

---

## How System Calls Work

Let's trace `fork()` from user space to kernel and back:

### User Program Calls fork()
```c
// user/sh.c
int pid = fork();
```

### Step 1: User Library Wrapper (`user/usys.S`)
```assembly
.global fork
fork:
    li a7, SYS_fork    # a7 = system call number (1)
    ecall              # Trap into kernel!
    ret                # Return with result in a0
```

### Step 2: Trap Entry (`kernel/trampoline.S`)
```assembly
uservec:
    # Save user registers
    csrw sscratch, a0
    sd ra, 40(a0)
    sd sp, 48(a0)
    # ... save all 32 registers ...
    
    # Load kernel page table
    ld t1, 0(a0)
    csrw satp, t1
    sfence.vma zero, zero
    
    # Jump to usertrap() in C
    jr t0
```

### Step 3: Trap Handler (`kernel/trap.c`)
```c
void usertrap(void)
{
  struct proc *p = myproc();
  p->trapframe->epc = r_sepc();

  if(r_scause() == 8){
    // System call
    p->trapframe->epc += 4;   // Advance PC past ecall
    intr_on();
    syscall();                 // Handle the system call!
  }

  usertrapret();
}
```

### Step 4: System Call Dispatcher (`kernel/syscall.c`)
```c
void syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7;      // Get syscall number
  
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    p->trapframe->a0 = syscalls[num]();  // Call handler
  } else {
    printf("%d %s: unknown sys call %d\n", p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
```

### Step 5: Fork Implementation (`kernel/proc.c`)
```c
int fork(void)
{
  struct proc *np;
  struct proc *p = myproc();

  // Allocate process
  if((np = allocproc()) == 0)
    return -1;

  // Copy user memory from parent to child
  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
    freeproc(np);
    return -1;
  }
  np->sz = p->sz;

  // Copy saved user registers
  *(np->trapframe) = *(p->trapframe);
  np->trapframe->a0 = 0;  // Child returns 0

  // Copy open file descriptors
  for(int i = 0; i < NOFILE; i++)
    if(p->ofile[i])
      np->ofile[i] = filedup(p->ofile[i]);

  np->state = RUNNABLE;
  return np->pid;  // Parent returns child's PID
}
```

---

## The Copy Program - Understanding I/O and System Calls

Let's examine a simple but instructive program that demonstrates how user programs interact with the kernel through system calls.

### What the Copy Program Does

The `copy` program is a minimal example that:
1. **Reads** input from stdin (your keyboard)
2. **Writes** it back to stdout (your terminal)
3. **Repeats** until end-of-file (Ctrl-D)

### The Code

```c
// user/copy.c
#include "kernel/types.h"
#include "user/user.h"

int main()
{
  char buf[64];  // Buffer to hold input (max 64 bytes)
  int n;

  while(1){
    n = read(0, buf, sizeof(buf));  // Read from stdin (fd 0)
    
    if(n <= 0)     // End of file or error
      break;
    
    write(1, buf, n);  // Write to stdout (fd 1)
  }
  
  exit(0);  // Exit system call
}
```

### Running It

```bash
$ copy
xyz↵              # You type this
xyz               # Program echoes it back
hello↵            # You type this
hello             # Program echoes it back
^D                # Press Ctrl-D to send EOF
$                 # Program exits, back to shell
```

---

## Understanding File Descriptors

### What is a File Descriptor?

A **file descriptor (fd)** is an integer that represents an open file or I/O stream. Think of it as a ticket number or reference ID for an open file.

### Standard File Descriptors

Every program starts with three pre-opened file descriptors:

```c
0 = stdin  (standard input)   - keyboard by default
1 = stdout (standard output)  - terminal screen by default  
2 = stderr (standard error)   - terminal screen (for errors)
```

**The shell sets these up before running your program!**

### File Descriptor Table

Each process has a file descriptor table:

```
Process's file descriptor table:
┌────┬─────────────────────┐
│ FD │  Points to          │
├────┼─────────────────────┤
│ 0  │ → Console (stdin)   │
│ 1  │ → Console (stdout)  │
│ 2  │ → Console (stderr)  │
│ 3  │ (unused)            │
│ 4  │ (unused)            │
│... │ ...                 │
│ 15 │ (unused)            │
└────┴─────────────────────┘
```

If the program opens a file:
```c
int fd = open("file.txt", O_RDONLY);  // Returns 3 (first available)
```

---

## System Call Details

### 1. read() System Call

**Function signature:**
```c
int read(int fd, void *buf, int n)
```

**Parameters:**
- `fd` - file descriptor to read from
- `buf` - buffer to store data
- `n` - maximum bytes to read

**Return value:**
- **Positive number** = bytes actually read
- **0** = end of file (EOF)
- **-1** = error occurred

**Example:**
```c
n = read(0, buf, 64);  // Read up to 64 bytes from stdin
if(n < 0){
  fprintf(2, "read error\n");  // Write to stderr
  exit(1);
}
if(n == 0){
  break;  // EOF - normal termination
}
```

### 2. write() System Call

**Function signature:**
```c
int write(int fd, void *buf, int n)
```

**Parameters:**
- `fd` - file descriptor to write to
- `buf` - data to write
- `n` - number of bytes to write

**Return value:**
- **Positive number** = bytes actually written
- **-1** = error occurred

**Example:**
```c
int written = write(1, buf, n);  // Write n bytes to stdout
if(written < 0){
  fprintf(2, "write error\n");
  exit(1);
}
```

### 3. exit() System Call

**Function signature:**
```c
void exit(int status)
```

**What it does:**
- Terminates the current process
- Returns control to parent (usually shell)
- Cleans up resources (closes files, frees memory)

```c
exit(0);  // Normal successful termination
exit(1);  // Error termination
```

---

## Complete Execution Flow

### Step-by-Step: What Happens When You Run Copy

```
1. Shell starts copy program
   - fork() creates new process
   - exec("copy") replaces process with copy program
   - File descriptors 0, 1, 2 inherited from shell

2. copy program starts
   - Enters while loop
   - Calls read(0, buf, 64)

3. read() system call
   User space:
   - ecall instruction traps to kernel
   
   Kernel space:
   - usertrap() catches the trap
   - syscall() dispatches to sys_read()
   - sys_read() calls fileread()
   - fileread() reads from UART (console driver)
   - UART waits for keyboard input
   
   (You type "xyz\n")
   
   - UART receives 4 bytes
   - Kernel copies to user buffer
   - Returns 4 to user space

4. Back in user space
   - n = 4
   - Program calls write(1, buf, 4)

5. write() system call
   - ecall traps to kernel
   - Kernel dispatches to sys_write()
   - Writes to UART
   - UART displays "xyz\n" on screen
   - Returns 4 to user space

6. Loop continues
   - Back to read(), waiting for more input

7. (You press Ctrl-D)
   - read() returns 0 (EOF)
   - Loop exits
   - Calls exit(0)

8. exit() system call
   - Kernel cleans up process
   - Returns to shell
```

---

## Error Handling Best Practices

<Warning>
**Important**: Tutorial code often skips error checking for clarity, but production code must check every system call!
</Warning>

### Bad Example (No Error Checking)
```c
// Don't do this in real code!
n = read(0, buf, sizeof(buf));
write(1, buf, n);  // What if read failed?
```

### Good Example (Proper Error Checking)
```c
n = read(0, buf, sizeof(buf));
if(n < 0){
  fprintf(2, "read error\n");
  exit(1);
}
if(n == 0){
  break;  // EOF - normal
}

int written = write(1, buf, n);
if(written < 0){
  fprintf(2, "write error\n");
  exit(1);
}
if(written != n){
  fprintf(2, "partial write\n");
  exit(1);
}
```

### Why System Calls Can Fail

- File descriptor doesn't exist
- No permission to read/write
- Disk full (for write)
- Interrupted by signal
- Hardware failure

---

## Practical Exercise: Enhanced Copy

### Add Line Numbers

```c
#include "kernel/types.h"
#include "user/user.h"

int main()
{
  char buf[64];
  int n, linenum = 1;
  int i;

  while(1){
    // Print line number
    printf("%d: ", linenum);
    
    n = read(0, buf, sizeof(buf));
    if(n <= 0)
      break;
    
    write(1, buf, n);
    
    // Count newlines
    for(i = 0; i < n; i++){
      if(buf[i] == '\n')
        linenum++;
    }
  }
  
  exit(0);
}
```

**Output:**
```bash
$ copy2
1: hello
hello
2: world
world
3: ^D
$
```

---

## Common Labs/Assignments

<AccordionGroup>
  <Accordion title="Lab 1: Add a System Call">
    **Goal:** Add `getppid()` system call to get parent process ID
    
    **Steps:**
    1. Add syscall number to `kernel/syscall.h`
    2. Add user-space stub to `user/usys.pl`
    3. Add prototype to `user/user.h`
    4. Implement `sys_getppid()` in `kernel/sysproc.c`
    5. Add to syscall table in `kernel/syscall.c`
    
    **Implementation:**
    ```c
    // kernel/sysproc.c
    uint64 sys_getppid(void)
    {
      return myproc()->parent->pid;
    }
    ```
  </Accordion>
  
  <Accordion title="Lab 2: Priority Scheduler">
    **Goal:** Replace round-robin with priority-based scheduling
    
    **Modifications:**
    1. Add `priority` field to `struct proc`
    2. Modify scheduler to pick highest priority runnable process
    3. Add system call to set process priority
    4. Test with CPU-bound and I/O-bound processes
  </Accordion>
  
  <Accordion title="Lab 3: Copy-on-Write Fork">
    **Goal:** Implement lazy copying for `fork()`
    
    **Concepts:**
    - Mark pages as read-only in both parent and child
    - Handle page faults when either tries to write
    - Allocate new page and copy on write
    - Reference counting for shared pages
  </Accordion>
  
  <Accordion title="Lab 4: Lazy Allocation">
    **Goal:** Allocate memory only when actually used
    
    **Implementation:**
    - `sbrk()` increases size but doesn't allocate pages
    - Page fault handler allocates pages on first access
    - Reduces memory waste for sparse allocations
  </Accordion>
</AccordionGroup>

---

## Debugging with GDB

### Setup
```bash
# Terminal 1: Start xv6 with debugging
make qemu-gdb

# Terminal 2: Start GDB
gdb-multiarch kernel/kernel
(gdb) target remote localhost:26000
```

### Useful Commands
```gdb
# Set breakpoints
(gdb) break main
(gdb) break syscall
(gdb) break sys_fork

# Run
(gdb) continue

# Inspect
(gdb) backtrace
(gdb) info registers
(gdb) print myproc()->pid
(gdb) x/10x $sp

# Step through
(gdb) step
(gdb) next
(gdb) finish
```

---

## xv6 vs Real Operating Systems

| Feature | xv6 | Linux | Windows |
|---------|-----|-------|---------|
| **Lines of Code** | ~9,000 | 20M+ | 50M+ |
| **System Calls** | 21 | 300+ | 2000+ |
| **Scheduler** | Simple RR | CFS | NT Scheduler |
| **File Systems** | One simple FS | ext4, btrfs, etc. | NTFS |
| **Security** | Minimal | SELinux, etc. | ACLs, etc. |
| **Networking** | None | Full TCP/IP | Full stack |
| **Purpose** | Teaching | Production | Production |
| **Understand It All?** | ✅ Yes! | ❌ No way | ❌ Impossible |

---

## Resources

### Official Materials
- [xv6 Book](https://pdos.csail.mit.edu/6.828/2023/xv6/book-riscv-rev3.pdf) - Complete guide
- [xv6 Source Code](https://github.com/mit-pdos/xv6-riscv) - GitHub repository
- [MIT 6.S081](https://pdos.csail.mit.edu/6.828/2023/) - OS Engineering course

### Community Resources
- [xv6 Chinese Book](https://github.com/FrankZn/xv6-riscv-book-Chinese)
- [xv6 Labs](https://pdos.csail.mit.edu/6.828/2023/labs/) - Hands-on exercises

---

## Interview Relevance

<Note>
**Why xv6 matters for interviews:**
- Demonstrates deep OS understanding beyond theory
- Shows you've written kernel code
- Provides concrete examples for abstract concepts
- Common in systems engineering interviews at top companies
</Note>

**Sample Interview Questions:**
1. "Walk me through what happens when you call `fork()` in xv6"
2. "How does xv6 implement virtual memory?"
3. "Explain the xv6 file system structure"
4. "How would you add networking to xv6?"
5. "What are the limitations of xv6's scheduler?"

---

## Bottom Line

xv6 is the **perfect OS for learning** because:

✅ You can actually read and understand the entire system  
✅ It's real - runs on actual (virtualized) hardware  
✅ Demonstrates all core OS concepts  
✅ Well-documented with a great textbook  
✅ Used by top universities worldwide  
✅ Clean, modern C code  
✅ Runs in QEMU (no special hardware needed)

<Tip>
**Getting Started:** Clone xv6-riscv, read the first 3 chapters of the xv6 book, and try running it in QEMU. Then pick one of the lab exercises and start hacking!
</Tip>
