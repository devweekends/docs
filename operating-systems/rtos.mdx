---
title: "Real-Time Operating Systems"
sidebarTitle: "RTOS"
description: "Hard vs Soft RTOS, scheduling algorithms (RMS, EDF), and priority inversion"
icon: "stopwatch"
---

# Real-Time Operating Systems (RTOS)

A **Real-Time Operating System (RTOS)** is designed to serve real-time applications that process data as it comes in, typically without buffer delays. In an RTOS, **correctness** depends not only on the logical result but also on the **time** at which it is delivered.

<Info>
**Interview Frequency**: Medium (High for embedded/robotics roles)
**Key Topics**: Hard vs Soft RTOS, Rate Monotonic Scheduling, Priority Inversion
**Time to Master**: 6-8 hours
</Info>

---

## RTOS vs GPOS

General Purpose Operating Systems (GPOS) like Linux or Windows prioritize **throughput** and **fairness**. RTOS prioritizes **determinism** and **latency**.

| Feature | GPOS (Linux/Windows) | RTOS (FreeRTOS/VxWorks) |
|---------|----------------------|-------------------------|
| **Goal** | Maximize throughput, user convenience | Deterministic response time |
| **Scheduling** | Fairness-based (CFS) | Priority-based preemptive |
| **Latency** | Unpredictable (ms to sec) | Bounded (microseconds) |
| **Interrupts** | Can be deferred | Immediate handling |
| **Memory** | Virtual memory, paging | often Flat memory, no paging (for speed) |

---

## Types of Real-Time Systems

### Hard Real-Time
Missing a deadline is a **system failure** (catastrophic).
- **Examples**: Airbag deployment, pacemaker, flight control system.
- **Requirement**: Deterministic guarantee (100% success).

### Soft Real-Time
Missing a deadline degrades **quality of service** but is not catastrophic.
- **Examples**: Video streaming (dropped frames), online gaming.
- **Requirement**: Statistical guarantee (99% success).

### Firm Real-Time
Infrequent deadline misses are tolerable, but the result is useless after the deadline.
- **Examples**: Automated manufacturing quality check.

---

## Real-Time Scheduling Algorithms

Scheduling is the heart of an RTOS. The goal is to ensure all tasks meet their deadlines.

### Task Model
- **Period (T)**: Time between task activations.
- **Execution Time (C)**: Time to complete the task.
- **Deadline (D)**: Time by which task must finish (usually D = T).
- **Utilization (U)**: $U = C/T$. Total $U = \sum (C_i / T_i)$.

### 1. Rate Monotonic Scheduling (RMS)
A **static priority** algorithm.
- **Rule**: Shorter period = Higher priority.
- **Preemptive**: Yes.
- **Optimality**: Optimal among static priority algorithms.
- **Schedulability Test**: $\sum U_i \le n(2^{1/n} - 1)$. For large $n$, limit is ~69%.

![Rate Monotonic Scheduling](/images/courses/rtos-rms.svg)

### 2. Earliest Deadline First (EDF)
A **dynamic priority** algorithm.
- **Rule**: Closer deadline = Higher priority.
- **Preemptive**: Yes.
- **Optimality**: Optimal among dynamic algorithms.
- **Schedulability Test**: $\sum U_i \le 1$ (100% utilization possible!).

![Earliest Deadline First](/images/courses/rtos-edf.svg)

---

## Priority Inversion

A classic RTOS problem where a high-priority task is blocked by a low-priority task, effectively inverting their priorities.

### The Scenario
1. **Task L** (Low priority) acquires a lock (mutex).
2. **Task H** (High priority) preempts L and tries to acquire the lock -> **Blocks**.
3. **Task M** (Medium priority) preempts L (since M > L).
4. **Result**: Task H is waiting for L, but L cannot run because M is running. H is effectively blocked by M!

![Priority Inversion](/images/courses/rtos-priority-inversion.svg)

### The Solution: Priority Inheritance
When Task H blocks on a lock held by Task L, **Task L temporarily inherits Task H's priority**.
- This prevents Task M from preempting Task L.
- Once Task L releases the lock, it reverts to its original priority.

---

## RTOS Architecture

RTOS kernels are typically **microkernels** to minimize footprint and latency.

### Key Components
1. **Scheduler**: Preemptive, priority-based.
2. **Interrupt Handling**: Nested interrupts, deferred processing (Bottom Halves).
3. **Inter-Process Communication (IPC)**: Queues, Semaphores, Mutexes (lightweight).
4. **Memory Management**: Static allocation or fixed-size blocks (pools) to avoid fragmentation.

---

## Interview Deep Dive Questions

<AccordionGroup>
  <Accordion title="Q1: Why is Virtual Memory (Paging) often avoided in Hard RTOS?">
    **Answer:**
    Paging introduces **unpredictable latency**.
    - If a page fault occurs, the CPU must fetch data from disk.
    - Disk I/O time is non-deterministic (milliseconds).
    - This can cause a hard real-time task (requiring microsecond response) to miss its deadline.
    - RTOS often uses **physical addressing** or **locked pages** to guarantee memory access times.
  </Accordion>

  <Accordion title="Q2: Explain the Mars Pathfinder Priority Inversion bug.">
    **Answer:**
    In 1997, the Mars Pathfinder spacecraft began resetting itself.
    - **Cause**: Priority Inversion.
    - A low-priority meteorological task held a mutex.
    - A high-priority bus management task waited for the mutex.
    - A medium-priority communications task preempted the meteorological task.
    - The high-priority task waited too long, triggering a watchdog timer reset.
    - **Fix**: Enabled **Priority Inheritance** via a patch sent from Earth.
  </Accordion>

  <Accordion title="Q3: Compare RMS and EDF. Which one would you choose?">
    **Answer:**
    | Feature | RMS | EDF |
    |---------|-----|-----|
    | **Priority** | Static (Fixed) | Dynamic (Changes) |
    | **Complexity** | Low (Simple implementation) | High (Update priorities constantly) |
    | **Utilization** | Lower (~69%) | Higher (100%) |
    | **Overhead** | Low | Higher |

    **Choice**:
    - Use **RMS** for simple, safety-critical systems where simplicity and predictability are paramount (avionics).
    - Use **EDF** for multimedia or systems needing high resource efficiency where 100% CPU usage is desired.
  </Accordion>
</AccordionGroup>
