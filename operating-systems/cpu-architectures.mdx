---
title: "CPU Architectures & ISAs"
sidebarTitle: "CPU Architectures"
description: "Understanding x86, ARM, and RISC-V instruction set architectures"
icon: "microchip"
---

# CPU Architectures & Instruction Set Architectures

Operating systems must interact closely with the underlying CPU architecture. Understanding different instruction set architectures (ISAs) is crucial for systems programming, kernel development, and performance optimization.

## What is an Instruction Set Architecture (ISA)?

An **ISA** defines the interface between software and hardware. It specifies:
- **Instructions**: What operations the CPU can perform (add, load, store, jump)
- **Registers**: Fast storage locations inside the CPU
- **Memory Model**: How the CPU accesses RAM
- **Addressing Modes**: How instructions specify operands
- **Data Types**: Supported sizes (byte, word, doubleword)

<Note>
The ISA is the "contract" between hardware and software. Compilers generate machine code for a specific ISA, and the OS kernel must use ISA-specific instructions for privileged operations.
</Note>

---

## Major CPU Architectures

### x86-64 (AMD64, Intel 64)

**History**: Evolved from Intel's 8086 (1978) → 80386 (32-bit) → x86-64 (64-bit, 2003)

**Characteristics**:
- **CISC** (Complex Instruction Set Computer)
- Variable-length instructions (1-15 bytes)
- Rich instruction set with complex addressing modes
- Backward compatible with 32-bit and 16-bit code
- Dominant in desktops, laptops, and servers

**Registers** (64-bit mode):
- **General Purpose**: RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP, R8-R15 (16 registers)
- **Instruction Pointer**: RIP
- **Flags**: RFLAGS (status and control)
- **Segment**: CS, DS, SS, ES, FS, GS

**Privilege Levels**:
- Ring 0 (Kernel mode) - Full access
- Ring 1, 2 (rarely used)
- Ring 3 (User mode) - Restricted

**System Call Mechanism**:
```asm
; Modern x86-64 system call
mov rax, 1          ; syscall number (write)
mov rdi, 1          ; fd (stdout)
mov rsi, msg        ; buffer
mov rdx, len        ; count
syscall             ; invoke kernel
```

**Strengths**:
- Mature ecosystem, extensive tooling
- High single-thread performance
- Strong backward compatibility

**Weaknesses**:
- Complex, power-hungry
- Large die size
- Proprietary (Intel, AMD)

---

### ARM (Advanced RISC Machine)

**History**: Developed by ARM Holdings (1985), now Arm Ltd.

**Characteristics**:
- **RISC** (Reduced Instruction Set Computer)
- Fixed-length instructions (32-bit in ARMv7, variable in ARMv8 with Thumb)
- Load/Store architecture (only load/store access memory)
- Dominant in mobile, embedded, and increasingly in servers (AWS Graviton, Apple M-series)

**Versions**:
- **ARMv7** (32-bit): Cortex-A series, used in older smartphones
- **ARMv8** (64-bit): AArch64, used in modern phones, Apple Silicon, AWS Graviton
- **ARMv9**: Latest, with enhanced security (CCA) and AI features

**Registers** (AArch64):
- **General Purpose**: X0-X30 (31 registers, 64-bit)
- **Stack Pointer**: SP
- **Program Counter**: PC
- **Zero Register**: XZR (always reads as zero)

**Privilege Levels** (Exception Levels):
- EL0 (User mode)
- EL1 (Kernel mode)
- EL2 (Hypervisor)
- EL3 (Secure Monitor)

**System Call Mechanism**:
```asm
; ARM64 system call
mov x8, #64         ; syscall number (write)
mov x0, #1          ; fd
ldr x1, =msg        ; buffer
mov x2, #len        ; count
svc #0              ; supervisor call
```

**Strengths**:
- Power efficient (critical for mobile)
- Scalable (from microcontrollers to supercomputers)
- Large ecosystem, many vendors

**Weaknesses**:
- Fragmentation (many vendors, custom extensions)
- Licensing model (not open)

---

### RISC-V

**History**: Developed at UC Berkeley (2010), now managed by RISC-V International

**Characteristics**:
- **Open-source ISA** - Free to use, no licensing fees
- **Modular design** - Base ISA + optional extensions
- **Clean slate** - No legacy baggage, designed for modern needs
- Fixed-length 32-bit instructions (with optional compressed 16-bit extension)

**Philosophy**:
> "RISC-V is not a CPU, it's a specification. Anyone can design a RISC-V processor."

**Base ISAs**:
- **RV32I**: 32-bit integer base
- **RV64I**: 64-bit integer base
- **RV128I**: 128-bit (future-proofing)

**Standard Extensions**:
- **M**: Integer multiplication and division
- **A**: Atomic instructions (for synchronization)
- **F**: Single-precision floating-point
- **D**: Double-precision floating-point
- **C**: Compressed instructions (16-bit)
- **G**: General-purpose (IMAFD combined)

**Registers** (RV64):
- **General Purpose**: x0-x31 (32 registers)
  - x0 is hardwired to zero
  - x1 (ra): return address
  - x2 (sp): stack pointer
  - x8 (s0/fp): frame pointer
- **Program Counter**: PC
- **Floating Point**: f0-f31 (if F/D extension)

**Privilege Levels**:
- **M-mode** (Machine): Highest privilege, firmware
- **S-mode** (Supervisor): OS kernel
- **U-mode** (User): Applications

**System Call Mechanism**:
```asm
# RISC-V system call
li a7, 64           # syscall number (write)
li a0, 1            # fd
la a1, msg          # buffer
li a2, len          # count
ecall               # environment call
```

**Strengths**:
- **Open and free**: No licensing costs, no vendor lock-in
- **Simplicity**: Clean, orthogonal design
- **Extensibility**: Easy to add custom instructions
- **Growing ecosystem**: Supported by major companies (Google, NVIDIA, Western Digital)

**Weaknesses**:
- **Immature ecosystem**: Fewer tools, libraries compared to x86/ARM
- **Limited hardware availability**: Mostly embedded/experimental (as of 2024)
- **Software compatibility**: Existing x86/ARM binaries don't run

---

## RISC-V in Operating Systems

### Linux on RISC-V

Linux has official RISC-V support since kernel 4.15 (2018).

**Key features**:
- Full SMP (Symmetric Multi-Processing) support
- Virtual memory with Sv39/Sv48 page tables
- Device tree support
- KVM hypervisor support

**Distributions**:
- Debian, Fedora, Ubuntu, Arch Linux all have RISC-V ports
- Embedded: Yocto, Buildroot

### Why RISC-V Matters for OS Development

1. **Educational**: Clean ISA makes it easier to learn OS internals
2. **Customization**: Add domain-specific instructions (crypto, AI)
3. **Sovereignty**: Countries/companies can design their own CPUs
4. **Innovation**: Lower barrier to entry for new CPU designs

### RISC-V vs x86 vs ARM: OS Perspective

| Feature | x86-64 | ARM (AArch64) | RISC-V |
|---------|--------|---------------|--------|
| **ISA Type** | CISC | RISC | RISC |
| **Openness** | Proprietary | Proprietary | Open-source |
| **Registers** | 16 GP | 31 GP | 32 GP |
| **Instruction Length** | Variable (1-15 bytes) | Fixed (32-bit) | Fixed (32-bit, 16-bit with C) |
| **Privilege Levels** | 4 rings | 4 ELs | 3 modes (M/S/U) |
| **System Call** | `syscall` | `svc` | `ecall` |
| **Ecosystem Maturity** | Very High | High | Growing |
| **Power Efficiency** | Low | High | High (design-dependent) |
| **Use Cases** | Servers, Desktops | Mobile, Embedded, Servers | Embedded, Research, Future servers |

---

## Practical Implications for OS Developers

### 1. Context Switching
Different architectures have different register sets to save/restore:
- x86-64: ~20 registers + FPU state
- ARM: 31 GP registers + NEON/SVE state
- RISC-V: 32 GP registers + FP state (if present)

### 2. System Calls
Each architecture has its own calling convention:
- **x86-64**: Arguments in rdi, rsi, rdx, rcx, r8, r9
- **ARM**: Arguments in x0-x7
- **RISC-V**: Arguments in a0-a7

### 3. Memory Ordering
- **x86**: Strong memory model (TSO - Total Store Order)
- **ARM**: Weak memory model (requires explicit barriers)
- **RISC-V**: Weak memory model (RVWMO - RISC-V Weak Memory Ordering)

### 4. Atomic Operations
All three support atomic compare-and-swap, but with different instructions:
- **x86**: `lock cmpxchg`
- **ARM**: `ldxr`/`stxr` (load-exclusive/store-exclusive)
- **RISC-V**: `lr.w`/`sc.w` (load-reserved/store-conditional)

---

## The Future: RISC-V Adoption

**Current State (2024)**:
- **Embedded**: SiFive, Espressif (ESP32-C3), Bouffalo Lab
- **HPC**: European Processor Initiative (EPI)
- **AI/ML**: Custom accelerators with RISC-V control cores
- **Automotive**: Potential for safety-critical systems

**Challenges**:
- Software ecosystem needs to mature
- Need more high-performance implementations
- Toolchain and debugging support improving but not yet at x86/ARM level

**Opportunities**:
- China's push for technological independence
- IoT and edge computing (billions of devices)
- Academic research and education

---

## Interview Focus

<AccordionGroup>
  <Accordion title="Why does the OS need to know about the CPU architecture?">
    The OS kernel contains architecture-specific code for:
    - **Context switching**: Saving/restoring CPU registers
    - **System calls**: Entering kernel mode (syscall/svc/ecall)
    - **Memory management**: Page table formats differ
    - **Interrupt handling**: Architecture-specific interrupt controllers
    - **Atomic operations**: Implementing locks and synchronization
  </Accordion>
  
  <Accordion title="What are the trade-offs between CISC (x86) and RISC (ARM, RISC-V)?">
    **CISC (x86)**:
    - Pro: Fewer instructions for same task, better code density
    - Pro: Mature ecosystem, extensive optimizations
    - Con: Complex to decode, power-hungry, large die size
    
    **RISC (ARM, RISC-V)**:
    - Pro: Simpler hardware, easier to pipeline, power-efficient
    - Pro: More registers, cleaner design
    - Con: More instructions for same task (but modern compilers mitigate this)
  </Accordion>
  
  <Accordion title="Why is RISC-V important?">
    1. **Open-source**: No licensing fees, no vendor lock-in
    2. **Customization**: Add domain-specific instructions
    3. **Education**: Clean ISA for learning
    4. **Geopolitics**: Technological sovereignty
    5. **Innovation**: Lowers barrier for new CPU designs
  </Accordion>
</AccordionGroup>

---

## Resources

- [RISC-V Specification](https://riscv.org/technical/specifications/)
- [x86-64 ABI](https://gitlab.com/x86-psABIs/x86-64-ABI)
- [ARM Architecture Reference Manual](https://developer.arm.com/documentation/)
- [Linux RISC-V Port](https://www.kernel.org/doc/html/latest/riscv/index.html)

<Note>
**For this course**: When we discuss kernel internals, we'll primarily use x86-64 examples (most common), but the concepts apply to all architectures. Understanding these differences is crucial for cross-platform OS development.
</Note>
