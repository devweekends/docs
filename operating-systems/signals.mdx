---
title: "Signal Architecture"
sidebarTitle: "Signals"
description: "The internal mechanics of Signal delivery, Signal Frames, and Async-Signal Safety"
icon: "bolt"
---

# Signal Architecture

Signals are the Unix equivalent of hardware interrupts for user-space processes. While they seem simple (send a signal, catch it in a handler), their internal implementation is a masterpiece of kernel-to-user-space context switching.

---

## 1. How Signals Are Delivered
When a process receives a signal (e.g., `SIGSEGV` or `SIGINT`), the kernel doesn't just call a function. It must force the user process to execute a handler at an **arbitrary point in its execution**.

### The Delivery Flow
1.  **Generation**: A process calls `kill()` or the hardware triggers an exception.
2.  **Pending State**: The kernel marks the signal as "pending" in the process's `task_struct`.
3.  **Check on Return**: The kernel checks for pending signals every time it's about to return to user-space (e.g., after a syscall or an interrupt).
4.  **Signal Delivery**: If a signal is pending and not masked, the kernel initiates the delivery.

---

## 2. Signal Frames & The User Stack
The most complex part of signal delivery is managing the user stack. The kernel cannot execute the signal handler in kernel mode; it must do it in user mode.

### Setting up the Frame
1.  **Save User Context**: The kernel saves the current user registers (RIP, RSP, RFLAGS, etc.) onto the **User Stack**. This data is called a **Signal Frame**.
2.  **Modify RIP**: The kernel changes the saved Instruction Pointer (RIP) in the kernel-trap frame to point to the start of the user's signal handler.
3.  **Return to User**: The kernel performs a "return from interrupt" (e.g., `sysret` or `iret`). The CPU resumes execution at the signal handler.

### The Return: `rt_sigreturn`
When the signal handler finishes, how does the process go back to what it was doing?
-   The kernel places a small piece of code (the **Restorer**) on the stack or in a fixed location.
-   The signal handler "returns" to this restorer.
-   The restorer calls the `rt_sigreturn` system call.
-   The kernel sees the `rt_sigreturn`, reads the saved context from the signal frame on the user stack, restores the registers, and resumes the original program.

---

## 3. Async-Signal Safety
Signals are **asynchronous**. They can arrive while your program is in the middle of a `malloc()` or a `printf()`.

### The Problem
If your program is inside `malloc()` (which holds a global lock) and a signal arrives whose handler also calls `malloc()`, you will **deadlock** with yourself.

### The Rules
-   Only call **Async-Signal Safe** functions in a signal handler (e.g., `write`, `read`, `_exit`).
-   Never use standard I/O (`printf`, `fopen`) or memory allocation (`malloc`, `free`).
-   Common practice: Set a global `volatile sig_atomic_t` flag and handle the logic in your main loop.

---

## 4. Signal Stacks: `sigaltstack`
If a process suffers a **Stack Overflow**, it receives a `SIGSEGV`. However, to handle that signal, the kernel needs to push a signal frame onto the stack. If the stack is full, the kernel can't push the frame, and the process is killed instantly.
-   *Solution*: `sigaltstack()`. This allows a process to define a separate, dedicated stack for signal handlers.

---

## 5. Signals vs. Threads
In a multi-threaded process:
-   **Direct Signals**: Generated by a specific thread (e.g., `SIGSEGV`, `SIGFPE`, `SIGILL`) are delivered only to that thread.
-   **Process-wide Signals**: (e.g., `SIGINT`, `SIGTERM`) are delivered to **one arbitrary thread** that doesn't have the signal masked.

---

## 6. Modern Alternative: `signalfd`
Handling signals is painful due to async-safety issues. Linux provides `signalfd`, which allows you to receive signals as data from a file descriptor.
-   You mask the signals normally.
-   You `read()` from the signalfd.
-   This converts the asynchronous signal into a **synchronous event**, making it safe to use with `epoll` and standard libraries.

---

## Summary for Senior Engineers
-   **Signal handlers are not normal functions**: They run on a modified stack with a kernel-injected return path.
-   **The `rt_sigreturn` syscall** is the only way to safely exit a signal handler and restore the machine state.
-   **Async-safety** is non-negotiable. If you ignore it, your program will flake out under load.
-   **Use `signalfd`** in modern applications to avoid the complexities of asynchronous handlers.

Next: [Debugging & Performance Observability](/operating-systems/debugging-performance) â†’
