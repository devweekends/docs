---
title: "OS Security"
sidebarTitle: "Security"
description: "Access control, capabilities, sandboxing, and system hardening"
icon: "shield-halved"
---

# Operating System Security

**OS security** protects system resources from unauthorized access and malicious attacks. Understanding security principles is essential for building robust systems.

<Info>
**Interview Frequency**: Medium-High  
**Key Topics**: Access control, capabilities, sandboxing, containers  
**Time to Master**: 12-15 hours
</Info>

---

## Security Principles

```
┌─────────────────────────────────────────────────────────────────┐
│                    SECURITY FUNDAMENTALS                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   CIA Triad                                                      │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                 Confidentiality                         │   │
│   │                      ▲                                   │   │
│   │                     / \                                  │   │
│   │                    /   \                                 │   │
│   │                   /     \                                │   │
│   │        Integrity ◄───────► Availability                 │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│   Key Principles:                                                │
│   • Least Privilege: Minimum necessary access                   │
│   • Defense in Depth: Multiple security layers                  │
│   • Fail Secure: Default to secure state on failure             │
│   • Complete Mediation: Check every access                      │
│   • Separation of Privilege: Multiple conditions for access     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Privilege Rings

```
┌─────────────────────────────────────────────────────────────────┐
│                    x86 PRIVILEGE RINGS                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│                    ┌─────────────────────┐                       │
│                    │      Ring 0         │                       │
│                    │    Kernel Mode      │                       │
│                    │  (Most privileged)  │                       │
│              ┌─────┴─────────────────────┴─────┐                 │
│              │          Ring 1 & 2             │                 │
│              │      (Rarely used today)        │                 │
│        ┌─────┴─────────────────────────────────┴─────┐           │
│        │                  Ring 3                     │           │
│        │               User Mode                     │           │
│        │          (Least privileged)                 │           │
│        └─────────────────────────────────────────────┘           │
│                                                                  │
│   Modern usage (simplified to 2 levels):                        │
│   • Ring 0: Kernel (full hardware access)                       │
│   • Ring 3: User applications (restricted)                      │
│                                                                  │
│   Hypervisors add:                                               │
│   • Ring -1: VMM/Hypervisor (more privileged than kernel)       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Mode Transitions

```c
// User to Kernel transition triggers:
// 1. System call (intentional)
int result = syscall(SYS_read, fd, buffer, size);

// 2. Exception (page fault, divide by zero)
int crash = 1 / 0;

// 3. Hardware interrupt (timer, I/O)
// Handled automatically by hardware

// Kernel to User transition:
// - Return from system call/interrupt
// - sigreturn
```

---

## Access Control

### Discretionary Access Control (DAC)

Owner decides who can access:

```bash
# Traditional Unix permissions
$ ls -l myfile
-rwxr-x--- 1 alice devs 4096 Jan 1 10:00 myfile
│││ │││ │││
│││ │││ └─── Others: no access
│││ └─────── Group (devs): read, execute
└─────────── Owner (alice): read, write, execute

# Numeric representation
chmod 750 myfile  # rwxr-x---

# Change owner
chown alice:devs myfile
```

### Access Control Matrix

```
┌─────────────────────────────────────────────────────────────────┐
│                    ACCESS CONTROL MATRIX                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│              │  /etc/passwd  │  /home/alice  │  /tmp/data  │     │
│   ───────────┼───────────────┼───────────────┼─────────────┤     │
│   root       │    rw-        │     rwx       │     rwx     │     │
│   alice      │    r--        │     rwx       │     rw-     │     │
│   bob        │    r--        │     ---       │     r--     │     │
│   www-data   │    r--        │     ---       │     ---     │     │
│                                                                  │
│   Stored as:                                                     │
│   • ACL (Access Control List): Per-object                       │
│   • Capability List: Per-subject                                │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### POSIX ACLs

Extended access control:

```bash
# View ACL
$ getfacl myfile
# file: myfile
# owner: alice
# group: devs
user::rwx
user:bob:r-x       # Specific user permission
group::r-x
group:admins:rwx   # Specific group permission
mask::rwx
other::---

# Set ACL
$ setfacl -m u:bob:rx myfile    # Add user permission
$ setfacl -m g:admins:rwx myfile  # Add group permission
$ setfacl -x u:bob myfile       # Remove user permission
$ setfacl -b myfile             # Remove all ACLs
```

---

## Mandatory Access Control (MAC)

System enforces policy, owner cannot override:

### SELinux

```bash
# SELinux context format: user:role:type:level
$ ls -Z /var/www/html/index.html
-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 index.html

# httpd (Apache) can only access files with httpd_sys_content_t type
# Even if file permissions allow, SELinux blocks

# Check current mode
$ getenforce
Enforcing

# Temporarily disable (bad practice)
$ setenforce 0  # Permissive (logs only)

# Change file context
$ chcon -t httpd_sys_content_t /var/www/html/newfile

# Restore default context
$ restorecon -Rv /var/www/html/
```

### AppArmor

```bash
# Profile example: /etc/apparmor.d/usr.sbin.nginx
#include <tunables/global>

/usr/sbin/nginx {
  #include <abstractions/base>
  
  # Network access
  network inet stream,
  network inet6 stream,
  
  # File access
  /var/www/** r,
  /var/log/nginx/** rw,
  /run/nginx.pid rw,
  
  # Config files
  /etc/nginx/** r,
  
  # Deny everything else by default
}
```

### MAC vs DAC Comparison

| Aspect | DAC | MAC |
|--------|-----|-----|
| Control | Owner decides | System policy |
| Override | Owner can grant | Cannot bypass |
| Complexity | Simple | Complex |
| Example | chmod | SELinux |
| Use case | General files | High security |

---

## Linux Capabilities

Split root privileges into smaller units:

```bash
# Traditional: root or nothing
# Capabilities: Fine-grained privileges

# View process capabilities
$ getpcaps $$
1234: = cap_chown,cap_dac_override+ep

# Key capabilities
CAP_CHOWN           # Change file ownership
CAP_DAC_OVERRIDE    # Bypass file permissions
CAP_NET_ADMIN       # Network configuration
CAP_NET_BIND_SERVICE # Bind to ports < 1024
CAP_NET_RAW         # Raw sockets
CAP_SYS_ADMIN       # Many admin operations
CAP_SYS_PTRACE      # Debug other processes

# Set file capability
$ setcap 'cap_net_bind_service=+ep' /usr/bin/myserver
# Now myserver can bind port 80 without running as root

# Remove capabilities
$ setcap -r /usr/bin/myserver
```

### Capability Sets

```c
// Each process has three capability sets:
// Permitted (P): Maximum capabilities process can use
// Effective (E): Currently active capabilities
// Inheritable (I): Passed to child processes

// Drop capabilities after setup
#include <sys/capability.h>

void drop_caps() {
    cap_t caps = cap_get_proc();
    
    // Keep only what we need
    cap_value_t keep[] = {CAP_NET_BIND_SERVICE};
    
    cap_clear(caps);
    cap_set_flag(caps, CAP_PERMITTED, 1, keep, CAP_SET);
    cap_set_flag(caps, CAP_EFFECTIVE, 1, keep, CAP_SET);
    
    cap_set_proc(caps);
    cap_free(caps);
}
```

---

## Sandboxing

### Seccomp (Secure Computing Mode)

Filter system calls:

```c
#include <seccomp.h>

void sandbox_process() {
    scmp_filter_ctx ctx;
    
    // Default: kill process on violation
    ctx = seccomp_init(SCMP_ACT_KILL);
    
    // Allow specific syscalls
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0);
    
    // Allow read only from specific fd
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 1,
                     SCMP_A0(SCMP_CMP_EQ, STDIN_FILENO));
    
    // Apply filter
    seccomp_load(ctx);
    
    // Now: any other syscall kills the process!
    // open("/etc/passwd", O_RDONLY);  // SIGKILL!
}
```

### Namespaces

Isolate system resources:

```c
#include <sched.h>

// Create new namespace
int clone_flags = CLONE_NEWPID |  // New PID namespace
                  CLONE_NEWNET |  // New network namespace
                  CLONE_NEWNS  |  // New mount namespace
                  CLONE_NEWUTS |  // New hostname
                  CLONE_NEWIPC |  // New IPC namespace
                  CLONE_NEWUSER;  // New user namespace

int pid = clone(child_func, stack_top, clone_flags, NULL);

// Or using unshare:
unshare(CLONE_NEWNS);  // New mount namespace
```

### Control Groups (cgroups)

Limit resource usage:

```bash
# Create a cgroup
mkdir /sys/fs/cgroup/memory/myapp
mkdir /sys/fs/cgroup/cpu/myapp

# Set limits
echo 100000000 > /sys/fs/cgroup/memory/myapp/memory.limit_in_bytes  # 100MB
echo 50000 > /sys/fs/cgroup/cpu/myapp/cpu.cfs_quota_us              # 50% CPU

# Add process to cgroup
echo $$ > /sys/fs/cgroup/memory/myapp/cgroup.procs
echo $$ > /sys/fs/cgroup/cpu/myapp/cgroup.procs

# Using cgroupv2 (unified):
echo "+memory +cpu" > /sys/fs/cgroup/myapp/cgroup.subtree_control
echo "100M" > /sys/fs/cgroup/myapp/memory.max
echo "50000 100000" > /sys/fs/cgroup/myapp/cpu.max
```

### Container Security Stack

```
┌─────────────────────────────────────────────────────────────────┐
│                    CONTAINER ISOLATION                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                    Application                          │   │
│   └─────────────────────────────────────────────────────────┘   │
│                             │                                    │
│   ┌─────────────────────────┼───────────────────────────────┐   │
│   │              Seccomp (syscall filter)                   │   │
│   │              "Only these syscalls allowed"               │   │
│   └─────────────────────────┼───────────────────────────────┘   │
│                             │                                    │
│   ┌─────────────────────────┼───────────────────────────────┐   │
│   │              Capabilities (privilege filter)            │   │
│   │              "Only these capabilities allowed"           │   │
│   └─────────────────────────┼───────────────────────────────┘   │
│                             │                                    │
│   ┌─────────────────────────┼───────────────────────────────┐   │
│   │              Namespaces (resource isolation)            │   │
│   │              PID, NET, MNT, USER, UTS, IPC               │   │
│   └─────────────────────────┼───────────────────────────────┘   │
│                             │                                    │
│   ┌─────────────────────────┼───────────────────────────────┐   │
│   │              Cgroups (resource limits)                  │   │
│   │              CPU, Memory, I/O, PIDs                      │   │
│   └─────────────────────────┼───────────────────────────────┘   │
│                             │                                    │
│   ┌─────────────────────────┼───────────────────────────────┐   │
│   │              SELinux/AppArmor (MAC)                     │   │
│   │              "Container type can only access X"          │   │
│   └─────────────────────────┼───────────────────────────────┘   │
│                             ▼                                    │
│                    Linux Kernel                                  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Memory Protection

### Address Space Layout Randomization (ASLR)

ASLR is a critical security technique that randomizes memory addresses to make exploit development extremely difficult.

```
┌──────────────────────────────────────────────────────────────────┐
│                HOW ASLR WORKS                                    │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Without ASLR (predictable):                                    │
│  ┌──────────────────────────────────────────────┐               │
│  │ Stack:          0x7fffffffffff                │               │
│  │ Heap:           0x555555554000                │               │
│  │ libc.so:        0x7ffff7a00000                │               │
│  │ Program text:   0x400000                      │               │
│  └──────────────────────────────────────────────┘               │
│                                                                  │
│  Attacker knows exact addresses! Can craft exploits easily.     │
│                                                                  │
│  ═══════════════════════════════════════════════════════════════ │
│                                                                  │
│  With ASLR (randomized each run):                               │
│  ┌──────────────────────────────────────────────┐               │
│  │ Run 1:                                       │               │
│  │ Stack:          0x7ffc8a123000                │               │
│  │ Heap:           0x5564b2a01000                │               │
│  │ libc.so:        0x7f42c8e00000                │               │
│  │ Program text:   0x55d8f3200000  (PIE)        │               │
│  │                                              │               │
│  │ Run 2:                                       │               │
│  │ Stack:          0x7ffd9c456000  ◄── Different│               │
│  │ Heap:           0x557a21b03000  ◄── Different│               │
│  │ libc.so:        0x7f9ab1200000  ◄── Different│               │
│  │ Program text:   0x56a4c8100000  ◄── Different│               │
│  └──────────────────────────────────────────────┘               │
│                                                                  │
│  Attacker can't predict! Must leak addresses first.             │
│                                                                  │
│  ═══════════════════════════════════════════════════════════════ │
│                                                                  │
│  What Gets Randomized:                                          │
│  ────────────────────                                          │
│                                                                  │
│  Level 0 (disabled):                                            │
│  • Nothing randomized                                           │
│  • Only for debugging!                                          │
│                                                                  │
│  Level 1 (conservative):                                        │
│  • Stack randomized                                             │
│  • Shared libraries (mmap)                                      │
│  • vDSO (virtual dynamic shared object)                         │
│  • But NOT heap (brk)                                           │
│                                                                  │
│  Level 2 (full - default):                                      │
│  • Everything from level 1                                      │
│  • PLUS heap (brk-based allocations)                            │
│  • PLUS PIE executable text (if compiled with -fPIE)            │
│                                                                  │
│  ═══════════════════════════════════════════════════════════════ │
│                                                                  │
│  Entropy (randomness bits):                                     │
│  ─────────────────────────────                                      │
│                                                                  │
│  x86-64 (64-bit):                                               │
│  • Stack:       ~24 bits (16 million possibilities)             │
│  • mmap:        ~28 bits (268 million)                          │
│  • PIE:         ~28 bits (268 million)                          │
│  • Heap:        ~13 bits (8192 possibilities - WEAK!)           │
│                                                                  │
│  ARM64:                                                         │
│  • Higher entropy: ~33 bits for stack/mmap                      │
│  • ~4 billion possibilities!                                    │
│                                                                  │
│  Why not more entropy?                                          │
│  • Address space limitations                                    │
│  • Cache alignment requirements                                 │
│  • Performance (more entropy = more cache misses)               │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

#### ASLR Configuration and Usage

```bash
# Check ASLR status
$ cat /proc/sys/kernel/randomize_va_space
2  # Full randomization

# 0: Disabled (NEVER use in production!)
# 1: Conservative (stack, mmap, vDSO)
# 2: Full (+ brk/heap) - RECOMMENDED

# View randomized addresses (note: changes each run)
$ cat /proc/self/maps
5648a0200000-5648a0201000 r--p /usr/bin/cat  # PIE executable
7f3e4c200000-7f3e4c3a0000 r--p /usr/lib/libc.so.6  # Library
7ffd9a100000-7ffd9a121000 rw-p [stack]  # Stack

# Compare two runs - addresses differ:
$ for i in {1..3}; do cat /proc/self/maps | grep stack; done
7ffd9a100000-7ffd9a121000 rw-p [stack]
7ffe3b200000-7ffe3b221000 rw-p [stack]  ◄── Different!
7ffc2c300000-7ffc2c321000 rw-p [stack]  ◄── Different!

# Disable ASLR for debugging (temporary)
$ setarch $(uname -m) -R ./myprogram

# Or per-process
$ echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
$ ./myprogram
$ echo 2 | sudo tee /proc/sys/kernel/randomize_va_space  # Re-enable!

# Check if binary is position-independent (PIE)
$ readelf -h /bin/cat | grep Type
  Type:                              DYN (Position-Independent Executable file)

# Compile with PIE (modern default)
$ gcc -fPIE -pie program.c -o program

# Without PIE (fixed address, defeats some ASLR)
$ gcc -no-pie program.c -o program
```

#### ASLR Limitations and Bypass Techniques

```
┌──────────────────────────────────────────────────────────────────┐
│                ASLR BYPASSES                                     │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. Information Leaks                                           │
│  ═══════════════════                                            │
│                                                                  │
│  If attacker can read memory, they can leak addresses:          │
│                                                                  │
│  Example vulnerability:                                         │
│  ┌────────────────────────────────────┐                         │
│  │ void leak() {                      │                         │
│  │   char *ptr = malloc(100);         │                         │
│  │   printf("%p\n", ptr);  // LEAK!   │                         │
│  │   // Attacker now knows heap base │                         │
│  │ }                                  │                         │
│  └────────────────────────────────────┘                         │
│                                                                  │
│  Common leak vectors:                                           │
│  • Format string bugs: printf(user_input)                       │
│  • Stack frame leaks: uninitialized variables                   │
│  • Pointer disclosure in error messages                         │
│  • Memory corruption reading past buffer                        │
│                                                                  │
│  ───────────────────────────────────────────────────────────── │
│                                                                  │
│  2. Brute Force (for 32-bit systems)                            │
│  ═══════════════════════════════════                            │
│                                                                  │
│  32-bit ASLR has limited entropy:                               │
│  • Stack: ~16 bits = 65,536 possibilities                       │
│  • Can try all in minutes with remote service                   │
│  • 64-bit: 24+ bits = millions/billions (infeasible)            │
│                                                                  │
│  Attack:                                                        │
│  for i in $(seq 1 100000); do                                   │
│    ./exploit 0x7f800000  # Try this stack address               │
│    ./exploit 0x7f810000  # Try next                             │
│    ...  # Eventually hit correct address                        │
│  done                                                           │
│                                                                  │
│  Defense: Use 64-bit systems!                                   │
│                                                                  │
│  ───────────────────────────────────────────────────────────── │
│                                                                  │
│  3. Partial Overwrites                                          │
│  ═══════════════════════                                        │
│                                                                  │
│  ASLR randomizes high bytes, but low bytes often predictable:   │
│                                                                  │
│  Library address: 0x7f42c8e00000                                │
│                   ^^^^^^^^ ◄── Randomized                       │
│                         ^^^^^^ ◄── Fixed (page aligned)         │
│                                                                  │
│  Partial overwrite attack:                                      │
│  • Overflow only 2-3 bytes                                      │
│  • Keep randomized high bytes intact                            │
│  • Only need to guess low bytes (less entropy)                  │
│                                                                  │
│  ───────────────────────────────────────────────────────────── │
│                                                                  │
│  4. Heap Feng Shui                                              │
│  ══════════════════                                             │
│                                                                  │
│  Heap ASLR has lower entropy (~13 bits on x86-64)               │
│  Attackers manipulate heap layout to create predictable state:  │
│                                                                  │
│  1. Allocate many objects (spray)                               │
│  2. Free specific ones to create holes                          │
│  3. Allocate attacker-controlled data                           │
│  4. Now heap layout is somewhat predictable!                    │
│                                                                  │
│  ───────────────────────────────────────────────────────────── │
│                                                                  │
│  5. Side Channels                                               │
│  ═════════════                                                │
│                                                                  │
│  Timing attacks can leak address bits:                          │
│  • Cache timing differences                                     │
│  • Page fault timing                                            │
│  • Spectre/Meltdown variants                                    │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

#### ASLR Best Practices

```
┌──────────────────────────────────────────────────────────────────┐
│                ASLR STRENGTHENING                                │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. Always compile with PIE (Position Independent Executable)   │
│     gcc -fPIE -pie program.c                                    │
│                                                                  │
│  2. Use full ASLR (level 2)                                     │
│     echo 2 > /proc/sys/kernel/randomize_va_space               │
│                                                                  │
│  3. Avoid information leaks                                     │
│     • Never print pointers                                      │
│     • Don't disclose addresses in errors                        │
│     • Initialize all variables                                  │
│                                                                  │
│  4. Combine with other defenses                                 │
│     • Stack canaries (detect overflow)                          │
│     • NX bit (prevent code execution)                           │
│     • RELRO (protect GOT/PLT)                                   │
│     • Seccomp (restrict syscalls)                               │
│                                                                  │
│  5. Limit address space information                             │
│     • kptr_restrict=2 (hide kernel pointers)                    │
│     • dmesg_restrict=1 (limit dmesg access)                     │
│                                                                  │
│  Remember: ASLR is not a silver bullet!                         │
│  It makes exploits harder, not impossible.                      │
│  Defense in depth is essential.                                 │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

### Stack Canaries

Stack canaries are "canary values" placed on the stack between local variables and control data to detect buffer overflows.

```
┌──────────────────────────────────────────────────────────────────┐
│                STACK CANARY MECHANISM                            │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Stack Layout (without canary):                                 │
│  ┌──────────────────────────────────────┐                       │
│  │ Local variables (buffer)             │  Low addresses        │
│  ├──────────────────────────────────────┤                       │
│  │ Saved frame pointer (RBP)            │                       │
│  ├──────────────────────────────────────┤                       │
│  │ Return address                       │  ◄── Attack target!   │
│  └──────────────────────────────────────┘  High addresses       │
│                                                                  │
│  Stack Layout (with canary):                                    │
│  ┌──────────────────────────────────────┐                       │
│  │ Local variables (buffer)             │  Low addresses        │
│  ├──────────────────────────────────────┤                       │
│  │ CANARY VALUE (random)                │  ◄── Detector!        │
│  ├──────────────────────────────────────┤                       │
│  │ Saved frame pointer (RBP)            │                       │
│  ├──────────────────────────────────────┤                       │
│  │ Return address                       │                       │
│  └──────────────────────────────────────┘  High addresses       │
│                                                                  │
│  How It Works:                                                  │
│  ─────────────                                                  │
│                                                                  │
│  Function prologue (entry):                                     │
│  1. Generate random canary value (once per process)             │
│  2. Store in TLS (Thread Local Storage)                         │
│  3. Push canary onto stack                                      │
│  4. Continue with function                                      │
│                                                                  │
│  Function epilogue (exit):                                      │
│  1. Read canary from stack                                      │
│  2. Compare with original in TLS                                │
│  3. If mismatch → call __stack_chk_fail()                       │
│  4. If match → normal return                                    │
│                                                                  │
│  Why It Detects Overflows:                                      │
│  • Buffer overflow overwrites SEQUENTIALLY                      │
│  • Must overwrite canary to reach return address               │
│  • Attacker doesn't know random canary value                    │
│  • Overwriting with wrong value triggers detection              │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

#### Stack Canary Implementation

```c
// Example function with canary protection
void vulnerable() {
    char buffer[16];
    // Compiler-generated stack layout:
    // [buffer] [canary] [saved_rbp] [return_addr]
    
    gets(buffer);  // Overflow!
    // If buffer overflow overwrites canary:
    //   __stack_chk_fail() called → process terminates
}

// What the compiler generates (simplified):
void vulnerable_protected() {
    // PROLOGUE
    unsigned long canary;
    canary = __stack_chk_guard;  // Load from TLS/global
    
    char buffer[16];
    // ... function body ...
    gets(buffer);
    
    // EPILOGUE
    if (canary != __stack_chk_guard) {
        __stack_chk_fail();  // ABORT! Stack smashed!
    }
    return;
}

// Canary is typically stored in:
// x86-64: fs:0x28 (Thread Local Storage segment)
// ARM64: x18 register or TLS

// View canary in GDB:
// (gdb) x/gx $fs_base+0x28
// 0x7ffff7fb3028: 0x1234567890abcdef  ◄── Random canary

// Compile options:
// -fstack-protector         Protect functions with buffers > 8 bytes
// -fstack-protector-strong  Protect more functions (arrays, address taken)
// -fstack-protector-all     Protect ALL functions (performance cost!)
// -fno-stack-protector      Disable (only for debugging!)

// Check if binary has stack protector:
$ readelf -s /bin/cat | grep stack_chk
    42: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail
// Presence of __stack_chk_fail means canaries enabled
```

#### Bypassing Stack Canaries

```
┌──────────────────────────────────────────────────────────────────┐
│                CANARY BYPASS TECHNIQUES                          │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. Information Leak                                            │
│  ═══════════════════                                            │
│                                                                  │
│  If attacker can read canary, they can include it in overflow:  │
│                                                                  │
│  void leak_and_exploit() {                                      │
│    char buffer[16];                                             │
│    unsigned long *canary_ptr = (unsigned long*)&buffer[16];     │
│    unsigned long canary = *canary_ptr;  // Read canary          │
│                                                                  │
│    // Now overflow with correct canary:                         │
│    char payload[100];                                           │
│    memcpy(payload, "AAAA...", 16);     // Fill buffer          │
│    memcpy(payload+16, &canary, 8);      // Preserve canary!     │
│    memcpy(payload+24, &malicious_addr, 8);  // Overwrite RET   │
│    memcpy(buffer, payload, 100);  // Overflow!                  │
│  }                                                               │
│                                                                  │
│  ───────────────────────────────────────────────────────────── │
│                                                                  │
│  2. Byte-by-Byte Brute Force                                    │
│  ═══════════════════════════                                │
│                                                                  │
│  For programs that fork():                                      │
│  • Canary same across forks (process copy)                      │
│  • Try each byte 0x00-0xFF (256 attempts)                       │
│  • If no crash → correct byte!                                  │
│  • Repeat for all 8 bytes                                       │
│  • Total: 256 × 8 = 2048 attempts                               │
│                                                                  │
│  Example (32-bit canary, 4 bytes):                              │
│  for byte0 in 0..255:                                           │
│    if try_overflow(byte0, ?, ?, ?) doesn't crash:               │
│      canary[0] = byte0  # Found first byte!                     │
│      break                                                      │
│                                                                  │
│  Defense: Use exec() instead of fork(), or refresh canary       │
│                                                                  │
│  ───────────────────────────────────────────────────────────── │
│                                                                  │
│  3. Overwrite Other Data                                        │
│  ═══════════════════════                                        │
│                                                                  │
│  Canary only protects return address on stack.                  │
│  But other targets exist:                                       │
│                                                                  │
│  • Function pointers in local variables                         │
│  • Global variables (no canary protection!)                     │
│  • Heap metadata (use-after-free, etc.)                         │
│  • GOT/PLT entries (if no RELRO)                                │
│                                                                  │
│  Example:                                                       │
│  void vuln() {                                                  │
│    void (*fptr)() = &safe_function;                             │
│    char buffer[16];                                             │
│    gets(buffer);  // Overflow fptr, NOT return address!         │
│    fptr();  // Call attacker-controlled function                │
│  }                                                               │
│                                                                  │
│  ───────────────────────────────────────────────────────────── │
│                                                                  │
│  4. Canary Null Byte                                            │
│  ═══════════════════                                            │
│                                                                  │
│  On some systems, canary starts with 0x00 (null byte):          │
│  Canary: 0x0012345678abcdef                                     │
│           ^^                                                    │
│  Why? Prevents string-based overflows (strcpy stops at null)    │
│                                                                  │
│  But if overflow uses memcpy (doesn't stop at null):            │
│  • Attacker can include 0x00 in payload                         │
│  • Slightly easier to guess                                     │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

#### Defense In Depth

```
Stack canaries are ONE layer. Always combine:

✓ Stack canaries      → Detect buffer overflow
✓ ASLR               → Randomize addresses  
✓ NX/DEP             → Prevent code execution
✓ RELRO              → Protect GOT/PLT
✓ PIE                → Position independent executable
✓ Seccomp            → Limit syscalls
✓ Safe coding        → No gets(), strcpy(), sprintf()

Modern systems use ALL of these together!
```

### Non-Executable Memory (NX/DEP)

```c
// Mark memory regions as non-executable
// Prevents code injection attacks

#include <sys/mman.h>

// Allocate executable memory (rare, dangerous)
void *mem = mmap(NULL, size,
                 PROT_READ | PROT_WRITE | PROT_EXEC,
                 MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

// Later, make it non-writable (W^X)
mprotect(mem, size, PROT_READ | PROT_EXEC);

// Stack and heap are typically:
// PROT_READ | PROT_WRITE (no PROT_EXEC)
```

---

## Kernel Security

### KASLR (Kernel ASLR)

```bash
# Check if KASLR is enabled
$ cat /proc/cmdline | grep -o nokaslr
# Empty = enabled

# Kernel symbols randomized each boot
$ cat /proc/kallsyms
ffffffffc0123456 t some_kernel_function
# Address different next boot
```

### Kernel Hardening

```bash
# Restrict dmesg access
$ sysctl kernel.dmesg_restrict=1

# Restrict kernel pointer leaks
$ sysctl kernel.kptr_restrict=2

# Disable kernel module loading
$ sysctl kernel.modules_disabled=1

# Enable strict memory protection
$ sysctl vm.mmap_min_addr=65536

# Restrict ptrace
$ sysctl kernel.yama.ptrace_scope=2
# 0: Classic (any process)
# 1: Restricted (parent only)
# 2: Admin only
# 3: Disabled completely
```

---

## Authentication & Authorization

### PAM (Pluggable Authentication Modules)

```bash
# /etc/pam.d/sshd
auth       required     pam_unix.so        # Password check
auth       required     pam_faillock.so    # Lock after failures
auth       optional     pam_gnome_keyring.so

account    required     pam_unix.so
account    required     pam_nologin.so     # Check /etc/nologin

password   required     pam_pwquality.so   # Password quality
password   required     pam_unix.so sha512

session    required     pam_limits.so      # Resource limits
session    required     pam_unix.so
```

### sudo Configuration

```bash
# /etc/sudoers (use visudo to edit!)

# User alice can run any command as root
alice ALL=(ALL) ALL

# User bob can only restart nginx
bob ALL=(root) /usr/bin/systemctl restart nginx

# Group wheel can sudo without password (dangerous!)
%wheel ALL=(ALL) NOPASSWD: ALL

# Logging
Defaults    logfile=/var/log/sudo.log
Defaults    log_input, log_output
```

---

## Cryptographic Security

### Disk Encryption (LUKS)

```bash
# Setup encrypted partition
$ cryptsetup luksFormat /dev/sda2
$ cryptsetup luksOpen /dev/sda2 encrypted_data
$ mkfs.ext4 /dev/mapper/encrypted_data
$ mount /dev/mapper/encrypted_data /mnt/secure

# Close when done
$ umount /mnt/secure
$ cryptsetup luksClose encrypted_data
```

### Secure Boot Chain

```
┌─────────────────────────────────────────────────────────────────┐
│                    SECURE BOOT CHAIN                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌───────────────────────────────────────────────────────────┐ │
│   │  Hardware: CPU initializes, loads firmware                │ │
│   └─────────────────────────┬─────────────────────────────────┘ │
│                             ▼ Verify signature                   │
│   ┌───────────────────────────────────────────────────────────┐ │
│   │  UEFI Firmware: Contains Microsoft/vendor keys           │ │
│   └─────────────────────────┬─────────────────────────────────┘ │
│                             ▼ Verify signature                   │
│   ┌───────────────────────────────────────────────────────────┐ │
│   │  Shim: Signed by Microsoft, loads GRUB                   │ │
│   └─────────────────────────┬─────────────────────────────────┘ │
│                             ▼ Verify signature                   │
│   ┌───────────────────────────────────────────────────────────┐ │
│   │  GRUB: Signed by distro, loads kernel                    │ │
│   └─────────────────────────┬─────────────────────────────────┘ │
│                             ▼ Verify signature                   │
│   ┌───────────────────────────────────────────────────────────┐ │
│   │  Kernel: Signed, verifies modules                         │ │
│   └─────────────────────────┬─────────────────────────────────┘ │
│                             ▼                                    │
│   ┌───────────────────────────────────────────────────────────┐ │
│   │  User Space: Protected by kernel security                 │ │
│   └───────────────────────────────────────────────────────────┘ │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Interview Deep Dive Questions

<AccordionGroup>
  <Accordion title="Q1: Explain the principle of least privilege with examples">
    **Answer:**
    
    **Principle**: Grant minimum access needed to perform a function.
    
    **Examples**:
    
    1. **File Permissions**:
       ```bash
       # Bad: World-readable config with passwords
       -rw-r--r-- config.ini
       
       # Good: Only owner can read
       -rw------- config.ini
       ```
    
    2. **Service Accounts**:
       ```bash
       # Bad: Web server runs as root
       User root
       
       # Good: Dedicated unprivileged user
       User www-data
       ```
    
    3. **Capabilities**:
       ```bash
       # Bad: Run as root to bind port 80
       sudo ./webserver
       
       # Good: Grant only needed capability
       setcap 'cap_net_bind_service=+ep' ./webserver
       ./webserver
       ```
    
    4. **Containers**:
       ```yaml
       # Kubernetes: Drop all capabilities, add only needed
       securityContext:
         capabilities:
           drop: ["ALL"]
           add: ["NET_BIND_SERVICE"]
         runAsNonRoot: true
         readOnlyRootFilesystem: true
       ```
    
    5. **Database Access**:
       ```sql
       -- Bad: App connects as admin
       GRANT ALL ON *.* TO 'app'@'%';
       
       -- Good: Only needed permissions
       GRANT SELECT, INSERT, UPDATE ON shop.* TO 'app'@'%';
       ```
    
    **Benefits**:
    - Limits blast radius of compromise
    - Reduces attack surface
    - Easier auditing
    - Defense in depth
  </Accordion>
  
  <Accordion title="Q2: How do containers provide isolation?">
    **Answer:**
    
    **Layered Isolation**:
    
    ```
    Container Runtime (Docker/containerd)
         │
         ├── Namespaces (Isolation)
         │   ├── PID: Own process tree
         │   ├── NET: Own network stack
         │   ├── MNT: Own filesystem view
         │   ├── UTS: Own hostname
         │   ├── IPC: Own shared memory
         │   └── USER: UID/GID mapping
         │
         ├── Cgroups (Limits)
         │   ├── Memory: Limit RAM usage
         │   ├── CPU: Limit CPU time
         │   ├── I/O: Limit disk bandwidth
         │   └── PIDs: Limit process count
         │
         ├── Seccomp (Syscall filter)
         │   └── Block dangerous syscalls
         │
         ├── Capabilities (Privilege filter)
         │   └── Drop unneeded privileges
         │
         └── LSM (SELinux/AppArmor)
             └── Mandatory access control
    ```
    
    **What containers DON'T isolate**:
    - Kernel (shared with host)
    - Time (system clock)
    - Kernel keyring
    - Some /proc, /sys entries
    
    **Container vs VM**:
    
    | Aspect | Container | VM |
    |--------|-----------|-----|
    | Kernel | Shared | Separate |
    | Overhead | Low | High |
    | Startup | Milliseconds | Seconds |
    | Isolation | Process-level | Hardware-level |
    | Attack surface | Larger | Smaller |
    
    **Best practices**:
    ```bash
    # Run as non-root
    docker run --user 1000:1000 myapp
    
    # Read-only filesystem
    docker run --read-only myapp
    
    # Drop capabilities
    docker run --cap-drop ALL --cap-add NET_BIND_SERVICE myapp
    
    # Use seccomp profile
    docker run --security-opt seccomp=profile.json myapp
    ```
  </Accordion>
  
  <Accordion title="Q3: Explain a buffer overflow attack and protections">
    **Answer:**
    
    **Attack**:
    ```c
    void vulnerable() {
        char buffer[64];
        gets(buffer);  // No bounds checking!
        // Attacker sends 100 bytes, overwrites return address
    }
    
    // Stack before overflow:
    [buffer (64 bytes)] [saved_rbp] [return_addr]
    
    // After overflow:
    [shellcode..............................] [jmp_to_buf]
                                               ↑
                                        Now points to shellcode
    ```
    
    **Protections**:
    
    1. **Stack Canaries**:
       ```
       [buffer] [CANARY] [saved_rbp] [return_addr]
       
       Before return: check if canary changed
       If changed: __stack_chk_fail() → abort
       ```
    
    2. **ASLR**:
       ```
       Addresses randomized each run
       Attacker can't know where to jump
       ```
    
    3. **NX/DEP**:
       ```
       Stack marked non-executable
       Shellcode can't run even if injected
       ```
    
    4. **RELRO (Relocation Read-Only)**:
       ```
       GOT made read-only after startup
       Prevents GOT overwrite attacks
       ```
    
    5. **PIE (Position Independent Executable)**:
       ```
       Code segment also randomized
       No fixed addresses to target
       ```
    
    **Checking protections**:
    ```bash
    $ checksec --file=/usr/bin/nginx
    RELRO         STACK CANARY    NX      PIE
    Full RELRO    Canary found    NX on   PIE enabled
    ```
    
    **Modern attacks bypass with**:
    - ROP (Return-Oriented Programming)
    - Information leaks to defeat ASLR
    - Heap exploitation
  </Accordion>
  
  <Accordion title="Q4: How does SELinux work?">
    **Answer:**
    
    **Core Concept**: Every process and file has a security context
    
    ```
    Format: user:role:type:level
    Example: system_u:system_r:httpd_t:s0
    ```
    
    **Type Enforcement**:
    ```
    httpd_t (Apache process type)
       │
       ├── CAN access httpd_sys_content_t (web files)
       ├── CAN access httpd_log_t (logs)
       ├── CANNOT access user_home_t (home directories)
       └── CANNOT access etc_t (system config)
    ```
    
    **Policy Rules**:
    ```
    # Allow httpd to read content
    allow httpd_t httpd_sys_content_t:file { read getattr };
    
    # Allow httpd to write logs
    allow httpd_t httpd_log_t:file { write append };
    
    # Deny by default - anything not allowed is blocked
    ```
    
    **Workflow when Apache accesses a file**:
    ```
    1. Apache (httpd_t) tries to read /var/www/index.html
    2. File has context httpd_sys_content_t
    3. SELinux checks policy: httpd_t → httpd_sys_content_t:file:read
    4. Policy allows → access granted
    
    If Apache tries to read /etc/shadow:
    1. File has context shadow_t
    2. SELinux checks: httpd_t → shadow_t:file:read
    3. No policy allows this → DENIED
    4. Even if DAC allows (unlikely), SELinux blocks
    ```
    
    **Troubleshooting**:
    ```bash
    # Check for denials
    $ ausearch -m AVC -ts recent
    
    # Generate policy module for denial
    $ audit2allow -a -M mymodule
    $ semodule -i mymodule.pp
    
    # Temporarily set permissive (logs only)
    $ setenforce 0
    ```
  </Accordion>
  
  <Accordion title="Q5: Design a secure multi-tenant system">
    **Answer:**
    
    **Requirements**:
    - Multiple customers share infrastructure
    - Complete isolation between tenants
    - Resource limits per tenant
    - Audit logging
    
    **Architecture**:
    
    ```
    ┌─────────────────────────────────────────────────────────────┐
    │                    Load Balancer                             │
    │              (TLS termination, WAF)                         │
    └───────────────────────┬─────────────────────────────────────┘
                            │
    ┌───────────────────────┼─────────────────────────────────────┐
    │                 API Gateway                                  │
    │  • Authentication (JWT validation)                          │
    │  • Tenant identification                                    │
    │  • Rate limiting per tenant                                 │
    └───────────────────────┬─────────────────────────────────────┘
                            │
         ┌──────────────────┼──────────────────┐
         │                  │                  │
         ▼                  ▼                  ▼
    ┌─────────┐       ┌─────────┐       ┌─────────┐
    │ Tenant A│       │ Tenant B│       │ Tenant C│
    │Container│       │Container│       │Container│
    │         │       │         │       │         │
    │ Limits: │       │ Limits: │       │ Limits: │
    │ CPU: 2  │       │ CPU: 4  │       │ CPU: 1  │
    │ Mem: 4G │       │ Mem: 8G │       │ Mem: 2G │
    └────┬────┘       └────┬────┘       └────┬────┘
         │                 │                 │
    ┌────▼────┐       ┌────▼────┐       ┌────▼────┐
    │ DB: A   │       │ DB: B   │       │ DB: C   │
    │(isolated)│      │(isolated)│      │(isolated)│
    └─────────┘       └─────────┘       └─────────┘
    ```
    
    **Isolation Mechanisms**:
    
    1. **Network Level**:
       ```yaml
       # Kubernetes NetworkPolicy
       apiVersion: networking.k8s.io/v1
       kind: NetworkPolicy
       spec:
         podSelector:
           matchLabels:
             tenant: A
         ingress:
           - from:
             - podSelector:
                 matchLabels:
                   tenant: A
         # Tenant A pods can only talk to Tenant A pods
       ```
    
    2. **Data Level**:
       ```sql
       -- Row-level security
       CREATE POLICY tenant_isolation ON data
       USING (tenant_id = current_setting('app.tenant_id'));
       ```
    
    3. **Compute Level**:
       ```yaml
       # Resource quotas
       resources:
         limits:
           cpu: "2"
           memory: "4Gi"
         requests:
           cpu: "500m"
           memory: "1Gi"
       ```
    
    4. **Audit**:
       ```bash
       # All API calls logged with tenant context
       # Immutable audit trail
       # Anomaly detection
       ```
    
    **Defense in Depth**:
    - Every layer assumes others might fail
    - Multiple redundant security controls
    - Zero trust between components
  </Accordion>
</AccordionGroup>

---

## Security Checklist

<Steps>
  <Step title="Principle of Least Privilege">
    Run services with minimum required permissions. Use capabilities instead of root.
  </Step>
  <Step title="Enable Security Features">
    ASLR, stack canaries, NX bit, RELRO, PIE, SELinux/AppArmor.
  </Step>
  <Step title="Limit Attack Surface">
    Remove unused software, close unused ports, disable unnecessary services.
  </Step>
  <Step title="Implement Defense in Depth">
    Multiple security layers. Don't rely on single control.
  </Step>
  <Step title="Audit and Monitor">
    Log security events, monitor for anomalies, regular vulnerability scanning.
  </Step>
</Steps>

---

## Key Takeaways

<CardGroup cols={2}>
  <Card title="Least Privilege" icon="minimize">
    Always grant minimum necessary access. Drop capabilities immediately.
  </Card>
  <Card title="Defense in Depth" icon="layer-group">
    Multiple security layers. Seccomp + capabilities + namespaces + MAC.
  </Card>
  <Card title="Container Security" icon="box">
    Containers share kernel. Use all isolation mechanisms together.
  </Card>
  <Card title="Memory Protection" icon="shield">
    ASLR, canaries, NX work together. Modern attacks bypass with ROP.
  </Card>
</CardGroup>

---

Next: [Linux Internals](/operating-systems/linux-internals) →
