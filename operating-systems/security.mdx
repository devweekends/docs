---
title: "OS Security"
sidebarTitle: "Security"
description: "Access control, capabilities, sandboxing, and system hardening"
icon: "shield-halved"
---

# Operating System Security

**OS security** protects system resources from unauthorized access and malicious attacks. Understanding security principles is essential for building robust systems.

<Info>
**Interview Frequency**: Medium-High  
**Key Topics**: Access control, capabilities, sandboxing, containers  
**Time to Master**: 12-15 hours
</Info>

---

## Security Principles

![Security Fundamentals](/images/courses/security-fundamentals.svg)

---

## Privilege Rings

![Privilege Rings](/images/courses/privilege-rings.svg)

### Mode Transitions

```c
// User to Kernel transition triggers:
// 1. System call (intentional)
int result = syscall(SYS_read, fd, buffer, size);

// 2. Exception (page fault, divide by zero)
int crash = 1 / 0;

// 3. Hardware interrupt (timer, I/O)
// Handled automatically by hardware

// Kernel to User transition:
// - Return from system call/interrupt
// - sigreturn
```

---

## Access Control

### Discretionary Access Control (DAC)

Owner decides who can access:

```bash
# Traditional Unix permissions
$ ls -l myfile
-rwxr-x--- 1 alice devs 4096 Jan 1 10:00 myfile
│││ │││ │││
│││ │││ └─── Others: no access
│││ └─────── Group (devs): read, execute
└─────────── Owner (alice): read, write, execute

# Numeric representation
chmod 750 myfile  # rwxr-x---

# Change owner
chown alice:devs myfile
```

### Access Control Matrix

![Access Control Matrix](/images/courses/access-control-matrix.svg)

### POSIX ACLs

Extended access control:

```bash
# View ACL
$ getfacl myfile
# file: myfile
# owner: alice
# group: devs
user::rwx
user:bob:r-x       # Specific user permission
group::r-x
group:admins:rwx   # Specific group permission
mask::rwx
other::---

# Set ACL
$ setfacl -m u:bob:rx myfile    # Add user permission
$ setfacl -m g:admins:rwx myfile  # Add group permission
$ setfacl -x u:bob myfile       # Remove user permission
$ setfacl -b myfile             # Remove all ACLs
```

---

## Mandatory Access Control (MAC)

System enforces policy, owner cannot override:

### SELinux

```bash
# SELinux context format: user:role:type:level
$ ls -Z /var/www/html/index.html
-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 index.html

# httpd (Apache) can only access files with httpd_sys_content_t type
# Even if file permissions allow, SELinux blocks

# Check current mode
$ getenforce
Enforcing

# Temporarily disable (bad practice)
$ setenforce 0  # Permissive (logs only)

# Change file context
$ chcon -t httpd_sys_content_t /var/www/html/newfile

# Restore default context
$ restorecon -Rv /var/www/html/
```

### AppArmor

```bash
# Profile example: /etc/apparmor.d/usr.sbin.nginx
#include <tunables/global>

/usr/sbin/nginx {
  #include <abstractions/base>
  
  # Network access
  network inet stream,
  network inet6 stream,
  
  # File access
  /var/www/** r,
  /var/log/nginx/** rw,
  /run/nginx.pid rw,
  
  # Config files
  /etc/nginx/** r,
  
  # Deny everything else by default
}
```

### MAC vs DAC Comparison

| Aspect | DAC | MAC |
|--------|-----|-----|
| Control | Owner decides | System policy |
| Override | Owner can grant | Cannot bypass |
| Complexity | Simple | Complex |
| Example | chmod | SELinux |
| Use case | General files | High security |

---

## Linux Capabilities

Split root privileges into smaller units:

```bash
# Traditional: root or nothing
# Capabilities: Fine-grained privileges

# View process capabilities
$ getpcaps $$
1234: = cap_chown,cap_dac_override+ep

# Key capabilities
CAP_CHOWN           # Change file ownership
CAP_DAC_OVERRIDE    # Bypass file permissions
CAP_NET_ADMIN       # Network configuration
CAP_NET_BIND_SERVICE # Bind to ports < 1024
CAP_NET_RAW         # Raw sockets
CAP_SYS_ADMIN       # Many admin operations
CAP_SYS_PTRACE      # Debug other processes

# Set file capability
$ setcap 'cap_net_bind_service=+ep' /usr/bin/myserver
# Now myserver can bind port 80 without running as root

# Remove capabilities
$ setcap -r /usr/bin/myserver
```

### Capability Sets

```c
// Each process has three capability sets:
// Permitted (P): Maximum capabilities process can use
// Effective (E): Currently active capabilities
// Inheritable (I): Passed to child processes

// Drop capabilities after setup
#include <sys/capability.h>

void drop_caps() {
    cap_t caps = cap_get_proc();
    
    // Keep only what we need
    cap_value_t keep[] = {CAP_NET_BIND_SERVICE};
    
    cap_clear(caps);
    cap_set_flag(caps, CAP_PERMITTED, 1, keep, CAP_SET);
    cap_set_flag(caps, CAP_EFFECTIVE, 1, keep, CAP_SET);
    
    cap_set_proc(caps);
    cap_free(caps);
}
```

---

## Sandboxing

### Seccomp (Secure Computing Mode)

Filter system calls:

```c
#include <seccomp.h>

void sandbox_process() {
    scmp_filter_ctx ctx;
    
    // Default: kill process on violation
    ctx = seccomp_init(SCMP_ACT_KILL);
    
    // Allow specific syscalls
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0);
    
    // Allow read only from specific fd
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 1,
                     SCMP_A0(SCMP_CMP_EQ, STDIN_FILENO));
    
    // Apply filter
    seccomp_load(ctx);
    
    // Now: any other syscall kills the process!
    // open("/etc/passwd", O_RDONLY);  // SIGKILL!
}
```

### Namespaces

Isolate system resources:

```c
#include <sched.h>

// Create new namespace
int clone_flags = CLONE_NEWPID |  // New PID namespace
                  CLONE_NEWNET |  // New network namespace
                  CLONE_NEWNS  |  // New mount namespace
                  CLONE_NEWUTS |  // New hostname
                  CLONE_NEWIPC |  // New IPC namespace
                  CLONE_NEWUSER;  // New user namespace

int pid = clone(child_func, stack_top, clone_flags, NULL);

// Or using unshare:
unshare(CLONE_NEWNS);  // New mount namespace
```

### Control Groups (cgroups)

Limit resource usage:

```bash
# Create a cgroup
mkdir /sys/fs/cgroup/memory/myapp
mkdir /sys/fs/cgroup/cpu/myapp

# Set limits
echo 100000000 > /sys/fs/cgroup/memory/myapp/memory.limit_in_bytes  # 100MB
echo 50000 > /sys/fs/cgroup/cpu/myapp/cpu.cfs_quota_us              # 50% CPU

# Add process to cgroup
echo $$ > /sys/fs/cgroup/memory/myapp/cgroup.procs
echo $$ > /sys/fs/cgroup/cpu/myapp/cgroup.procs

# Using cgroupv2 (unified):
echo "+memory +cpu" > /sys/fs/cgroup/myapp/cgroup.subtree_control
echo "100M" > /sys/fs/cgroup/myapp/memory.max
echo "50000 100000" > /sys/fs/cgroup/myapp/cpu.max
```

### Container Security Stack

![Container Isolation](/images/courses/container-isolation.svg)

---

## Memory Protection

### Address Space Layout Randomization (ASLR)

ASLR is a critical security technique that randomizes memory addresses to make exploit development extremely difficult.

![ASLR Visualized](/images/courses/aslr-visualized.svg)

#### ASLR Configuration and Usage

```bash
# Check ASLR status
$ cat /proc/sys/kernel/randomize_va_space
2  # Full randomization

# 0: Disabled (NEVER use in production!)
# 1: Conservative (stack, mmap, vDSO)
# 2: Full (+ brk/heap) - RECOMMENDED

# View randomized addresses (note: changes each run)
$ cat /proc/self/maps
5648a0200000-5648a0201000 r--p /usr/bin/cat  # PIE executable
7f3e4c200000-7f3e4c3a0000 r--p /usr/lib/libc.so.6  # Library
7ffd9a100000-7ffd9a121000 rw-p [stack]  # Stack

# Compare two runs - addresses differ:
$ for i in {1..3}; do cat /proc/self/maps | grep stack; done
7ffd9a100000-7ffd9a121000 rw-p [stack]
7ffe3b200000-7ffe3b221000 rw-p [stack]  ◄── Different!
7ffc2c300000-7ffc2c321000 rw-p [stack]  ◄── Different!

# Disable ASLR for debugging (temporary)
$ setarch $(uname -m) -R ./myprogram

# Or per-process
$ echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
$ ./myprogram
$ echo 2 | sudo tee /proc/sys/kernel/randomize_va_space  # Re-enable!

# Check if binary is position-independent (PIE)
$ readelf -h /bin/cat | grep Type
  Type:                              DYN (Position-Independent Executable file)

# Compile with PIE (modern default)
$ gcc -fPIE -pie program.c -o program

# Without PIE (fixed address, defeats some ASLR)
       kind: NetworkPolicy
       spec:
         podSelector:
           matchLabels:
             tenant: A
         ingress:
           - from:
             - podSelector:
                 matchLabels:
                   tenant: A
         # Tenant A pods can only talk to Tenant A pods
       ```
    
    2. **Data Level**:
       ```sql
       -- Row-level security
       CREATE POLICY tenant_isolation ON data
       USING (tenant_id = current_setting('app.tenant_id'));
       ```
    
    3. **Compute Level**:
       ```yaml
       # Resource quotas
       resources:
         limits:
           cpu: "2"
           memory: "4Gi"
         requests:
           cpu: "500m"
           memory: "1Gi"
       ```
    
    4. **Audit**:
       ```bash
       # All API calls logged with tenant context
       # Immutable audit trail
       # Anomaly detection
       ```
    
    **Defense in Depth**:
    - Every layer assumes others might fail
    - Multiple redundant security controls
    - Zero trust between components
  </Accordion>
</AccordionGroup>

---

## Security Checklist

<Steps>
  <Step title="Principle of Least Privilege">
    Run services with minimum required permissions. Use capabilities instead of root.
  </Step>
  <Step title="Enable Security Features">
    ASLR, stack canaries, NX bit, RELRO, PIE, SELinux/AppArmor.
  </Step>
  <Step title="Limit Attack Surface">
    Remove unused software, close unused ports, disable unnecessary services.
  </Step>
  <Step title="Implement Defense in Depth">
    Multiple security layers. Don't rely on single control.
  </Step>
  <Step title="Audit and Monitor">
    Log security events, monitor for anomalies, regular vulnerability scanning.
  </Step>
</Steps>

---

## Key Takeaways

<CardGroup cols={2}>
  <Card title="Least Privilege" icon="minimize">
    Always grant minimum necessary access. Drop capabilities immediately.
  </Card>
  <Card title="Defense in Depth" icon="layer-group">
    Multiple security layers. Seccomp + capabilities + namespaces + MAC.
  </Card>
  <Card title="Container Security" icon="box">
    Containers share kernel. Use all isolation mechanisms together.
  </Card>
  <Card title="Memory Protection" icon="shield">
    ASLR, canaries, NX work together. Modern attacks bypass with ROP.
  </Card>
</CardGroup>

---

Next: [Linux Internals](/operating-systems/linux-internals) →
