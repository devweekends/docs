---
title: "Power & Thermal Management"
sidebarTitle: "Power Management"
description: "C-states, P-states, DVFS, and the OS Idle Loop"
icon: "battery-bolt"
---

# Power & Thermal Management

In modern computing, performance is limited by heat, not by circuits. A senior engineer must understand how the OS manages the CPU's power consumption to balance battery life, performance, and thermal limits. This comprehensive guide covers everything from ACPI fundamentals to advanced power management in data centers.

<Info>
**Mastery Level**: Senior Systems Engineer
**Key Concepts**: C-states, P-states, DVFS, cpufreq governors, Runtime PM, ACPI
**Prerequisites**: [CPU Scheduling](/operating-systems/scheduling), [Kernel Internals](/operating-systems/linux-internals)
**Duration**: 8-10 hours for complete mastery
</Info>

---

## Course Overview

```
┌──────────────────────────────────────────────────────────────┐
│                  POWER MANAGEMENT MASTERY                     │
│                  ════════════════════════                     │
├──────────────────────────────────────────────────────────────┤
│                                                               │
│  LAYER 1: Hardware Power States                              │
│  ───────────────────────────────                             │
│  ■ ACPI Standards and Specifications                         │
│  ■ CPU C-states (Idle Power)                                 │
│  ■ CPU P-states (Performance vs Power)                       │
│  ■ System Sleep States (S-states)                            │
│                                                               │
│  LAYER 2: OS Power Management                                │
│  ─────────────────────────────                               │
│  ■ Idle Loop and Governor Selection                          │
│  ■ cpufreq Framework and Governors                           │
│  ■ Dynamic Voltage and Frequency Scaling                     │
│  ■ Tickless Kernel (NO_HZ)                                   │
│                                                               │
│  LAYER 3: Device Power Management                            │
│  ─────────────────────────────────                           │
│  ■ Runtime PM Framework                                      │
│  ■ System Suspend/Resume                                     │
│  ■ Wake Events and Wake Locks                                │
│  ■ Device-specific Power States                              │
│                                                               │
│  LAYER 4: Thermal Management                                 │
│  ────────────────────────                                    │
│  ■ Thermal Zones and Trip Points                             │
│  ■ Cooling Devices and Policies                              │
│  ■ Thermal Throttling Strategies                             │
│  ■ Temperature Monitoring                                    │
│                                                               │
│  LAYER 5: Advanced Topics                                    │
│  ──────────────────────                                      │
│  ■ Embedded Systems Power Management                         │
│  ■ Data Center Power Efficiency                              │
│  ■ Battery Management                                        │
│  ■ Power Capping and Budgeting                               │
│                                                               │
└──────────────────────────────────────────────────────────────┘
```

---

## 1. ACPI (Advanced Configuration and Power Interface)

ACPI is the industry-standard specification that allows the OS to discover and control hardware power states.

### 1.1 ACPI Overview

```
ACPI Architecture:
══════════════════

┌─────────────────────────────────────────────────────────┐
│                    Operating System                      │
│  ┌──────────────────────────────────────────────────┐  │
│  │         ACPI Core (OS Power Manager)             │  │
│  │  • Power state transitions                       │  │
│  │  • Thermal management                            │  │
│  │  • Device configuration                          │  │
│  └───────────────────┬──────────────────────────────┘  │
│                      │ ACPI Interface                   │
└──────────────────────┼──────────────────────────────────┘
                       │
┌──────────────────────┼──────────────────────────────────┐
│                      │ BIOS/UEFI Firmware               │
│  ┌───────────────────▼──────────────────────────────┐  │
│  │            ACPI Tables (AML/ASL)                 │  │
│  │  • DSDT: Differentiated System Description Table│  │
│  │  • SSDT: Secondary System Description Tables    │  │
│  │  • FADT: Fixed ACPI Description Table           │  │
│  │  • MADT: Multiple APIC Description Table        │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────┐
│                   Hardware Platform                      │
│  • CPU, chipset, devices                                │
│  • Power management logic                               │
│  • Thermal sensors                                      │
└─────────────────────────────────────────────────────────┘

Key Components:
───────────────
1. ACPI Tables: Describe hardware capabilities
2. AML (ACPI Machine Language): Interpreted by OS
3. ACPI Drivers: OS-specific implementations
4. GPE (General Purpose Events): Hardware event signaling
```

### 1.2 ACPI Global States (G-states)

```
Global System States:
═══════════════════════

G0 (S0) - Working
    └─> System is fully operational
        • CPU can be in C0 (active) or C1-Cn (idle)
        • Devices can be in D0 (active) or D1-D3 (power saving)

G1 - Sleeping (Multiple S-states)
    ├─> S1 (Standby): CPU stopped, RAM powered, quick wake
    ├─> S2 (Suspend to RAM, deprecated): Like S1 but CPU powered off
    ├─> S3 (Suspend to RAM): RAM retained, everything else off
    │   • "Sleep mode" on laptops
    │   • Wake time: 1-5 seconds
    │   • Power: <5W typical
    └─> S4 (Hibernate): Save RAM to disk, power off everything
        • "Hibernation"
        • Wake time: 30-60 seconds (full boot)
        • Power: 0W

G2 (S5) - Soft Off
    └─> Mechanical off, but power supply still connected
        • Can wake via WoL (Wake-on-LAN), power button
        • Power: <1W

G3 - Mechanical Off
    └─> Complete power disconnection
        • No power consumption
        • Requires physical power-on

Power Consumption Timeline:
───────────────────────────
G0/S0:     50-150W (Desktop), 5-15W (Laptop active)
G1/S1:     10-20W
G1/S3:     1-5W
G1/S4:     0-1W
G2/S5:     0-1W
G3:        0W
```

---

## 2. CPU Power States (C-states)

C-states describe how "deeply" a CPU core is sleeping when idle.

### 2.1 C-state Hierarchy

```
CPU C-states (Deeper = More Power Saved, Longer Wake Latency):
═══════════════════════════════════════════════════════════════

C0 - Operating State
    └─> CPU executing instructions
        • Full power
        • No latency
        • P-states control frequency/voltage

C1 - Halt
    └─> CPU executes HLT instruction
        • Clock stopped, but CPU powered
        • Wake latency: <1 μs
        • Power saved: ~10-20%
        • Implementation: x86 HLT instruction

C1E - Enhanced Halt
    └─> C1 + reduced voltage
        • Wake latency: ~10 μs
        • Power saved: ~30-40%

C2 - Stop Grant
    └─> CPU clock stopped, caches flushed (but retained)
        • Wake latency: ~50-100 μs
        • Power saved: ~40-60%
        • (Legacy, rarely used on modern CPUs)

C3 - Deep Sleep
    └─> L1/L2 caches flushed, CPU clock stopped
        • Cache coherency maintained by hardware
        • Wake latency: ~100-200 μs
        • Power saved: ~60-80%

C6 - Deep Power Down
    └─> Core voltage dropped to near zero
        • L1/L2 caches powered off (contents lost)
        • L3 cache may be retained or flushed
        • Wake latency: ~200-500 μs
        • Power saved: ~80-90%
        • Requires re-initialization on wake

C7 - Package Deep Sleep
    └─> Entire CPU package (all cores) in deep sleep
        • All caches flushed
        • Voltage dropped to minimum
        • Wake latency: ~500-1000 μs
        • Power saved: ~90-95%

C8/C9/C10 - (Intel Specific)
    └─> Progressively deeper package states
        • Additional voltage reduction
        • Wake latency: ~1-5 ms
        • Power saved: ~95-99%

Trade-off Visualization:
────────────────────────
Power Saved:  ████████████████████████████████████████ (C10)
              ███████████████████████████████ (C6)
              ███████████████████ (C3)
              ██████████ (C1E)
              ████ (C1)
              (C0)

Wake Latency: █ (C0)
              ██ (C1)
              ████ (C1E)
              ███████████ (C3)
              ██████████████████ (C6)
              ████████████████████████████ (C10)
```

### 2.2 C-state Selection Algorithm

```c
// Simplified idle loop with C-state selection
void cpu_idle_loop(void) {
    while (1) {
        // Check if there's work to do
        if (need_resched()) {
            schedule();
            continue;
        }

        // No work: enter idle state
        struct cpuidle_device *dev = get_cpu_device();
        struct cpuidle_driver *drv = get_cpu_driver();

        // Predict idle duration
        unsigned int next_event = tick_nohz_get_sleep_length();

        // Select deepest C-state that fits idle duration
        int state = cpuidle_select(drv, dev, next_event);

        // Enter C-state
        cpuidle_enter(drv, dev, state);

        // CPU wakes up here due to interrupt
    }
}

// C-state selection logic (menu governor)
int cpuidle_select(struct cpuidle_driver *drv,
                   struct cpuidle_device *dev,
                   unsigned int predicted_idle) {
    int best_state = 0;

    for (int i = 0; i < drv->state_count; i++) {
        struct cpuidle_state *s = &drv->states[i];

        // Skip if exit latency exceeds idle duration
        if (s->exit_latency > predicted_idle)
            break;

        // Consider energy efficiency
        // (deeper states save more power but cost more to enter/exit)
        if (predicted_idle > s->target_residency) {
            best_state = i;
        }
    }

    return best_state;
}
```

### 2.3 Viewing and Controlling C-states

```bash
# View available C-states
$ cpupower idle-info

CPUidle driver: intel_idle
CPUidle governor: menu

Available idle states: C1 C1E C3 C6 C7s C8 C9 C10
C1:           Latency: 2     Residency: 2     Usage: 123456789
C1E:          Latency: 10    Residency: 20    Usage: 98765432
C3:           Latency: 80    Residency: 100   Usage: 45678901
C6:           Latency: 200   Residency: 300   Usage: 23456789
C7s:          Latency: 500   Residency: 800   Usage: 12345678
C8:           Latency: 800   Residency: 1000  Usage: 6789012
C9:           Latency: 1200  Residency: 2000  Usage: 3456789
C10:          Latency: 2000  Residency: 5000  Usage: 1234567

# Disable deep C-states (reduce latency, increase power)
$ cpupower idle-set -d 3   # Disable C-states >= C3

# Disable specific C-state
$ echo 1 > /sys/devices/system/cpu/cpu0/cpuidle/state3/disable

# View C-state statistics
$ cat /sys/devices/system/cpu/cpu0/cpuidle/state*/time
245678901234   # C1 time (μs)
189012345678   # C1E time (μs)
98765432109    # C3 time (μs)
...

# View real-time C-state residency
$ turbostat --quiet --show Core,CPU,C1%,C3%,C6%,C7%
Core CPU  C1%   C3%   C6%   C7%
-    -    2.3   5.6   12.4  78.9
0    0    1.2   4.5   11.2  82.3
0    1    3.4   6.7   13.6  75.5
```

---

## 3. CPU Performance States (P-states)

P-states describe the frequency and voltage of the CPU while it is **active** (in C0).

### 3.1 P-state Hierarchy

```
CPU P-states (Active Power Management):
════════════════════════════════════════

P0 - Maximum Performance
    └─> Highest frequency and voltage
        • Turbo Boost may exceed base frequency
        • Example: 4.5 GHz @ 1.35V
        • Power: 125W TDP

P1 - Base Frequency
    └─> Advertised base frequency
        • Example: 3.6 GHz @ 1.20V
        • Power: 95W TDP

P2-Pn - Reduced Performance States
    └─> Progressively lower frequency/voltage
        • Example: 2.4 GHz @ 0.95V (P2)
        • Example: 1.6 GHz @ 0.80V (P3)
        • Example: 800 MHz @ 0.70V (Pn)
        • Power scales roughly with V² × f

Voltage-Frequency Relationship:
────────────────────────────────
Power ∝ V² × f

Example:
P0: 4.0 GHz @ 1.3V → P = 1.3² × 4.0 = 6.76 (relative)
P1: 3.0 GHz @ 1.1V → P = 1.1² × 3.0 = 3.63 (relative)
P2: 2.0 GHz @ 0.9V → P = 0.9² × 2.0 = 1.62 (relative)

Reducing frequency from 4.0 to 2.0 GHz (50%)
AND voltage from 1.3 to 0.9V (30%)
Results in 76% power reduction!
```

### 3.2 DVFS (Dynamic Voltage and Frequency Scaling)

```
DVFS Control Loop:
══════════════════

┌─────────────────────────────────────────────────────┐
│                 cpufreq Framework                    │
│                                                      │
│  ┌────────────────────────────────────────────┐    │
│  │            Governor (Policy)               │    │
│  │  • performance: Always P0                  │    │
│  │  • powersave: Always Pn (lowest)           │    │
│  │  • ondemand: Dynamic based on load         │    │
│  │  • conservative: Gradual frequency changes │    │
│  │  • schedutil: Integrated with scheduler    │    │
│  └─────────────────┬──────────────────────────┘    │
│                    │ Frequency request              │
│  ┌─────────────────▼──────────────────────────┐    │
│  │            cpufreq Driver                  │    │
│  │  • acpi-cpufreq: ACPI-based (legacy)      │    │
│  │  • intel_pstate: Intel hardware control   │    │
│  │  • amd-pstate: AMD hardware control       │    │
│  └─────────────────┬──────────────────────────┘    │
└────────────────────┼───────────────────────────────┘
                     │
┌────────────────────▼───────────────────────────────┐
│                  Hardware                          │
│  • Voltage regulator                               │
│  • PLL (Phase-Locked Loop) for frequency          │
│  • Performance counters                            │
└────────────────────────────────────────────────────┘

Load Monitoring:
────────────────
1. Sample CPU usage every N milliseconds (e.g., 10ms)
2. Calculate utilization: busy_time / (busy_time + idle_time)
3. If util > 80%: Request higher P-state
4. If util < 20%: Request lower P-state
5. Apply hysteresis to avoid thrashing
```

### 3.3 cpufreq Governors in Detail

```c
// ondemand Governor (classic, load-based)
struct od_policy_dbs_info {
    unsigned int sampling_rate;      // How often to check (default: 10ms)
    unsigned int up_threshold;       // Load % to go to max freq (default: 80)
    unsigned int down_threshold;     // Load % to reduce freq (default: 20)
    unsigned int io_is_busy;         // Count iowait as busy
};

// Algorithm:
void ondemand_update(struct cpufreq_policy *policy) {
    unsigned int load = get_cpu_load(policy->cpu);

    if (load > policy->up_threshold) {
        // High load: jump to maximum frequency immediately
        cpufreq_driver_target(policy, policy->max);
    } else if (load < policy->down_threshold) {
        // Low load: gradually reduce frequency
        unsigned int freq = policy->cur * load / 100;
        cpufreq_driver_target(policy, freq);
    }
}

// conservative Governor (gentler frequency changes)
struct cs_policy_dbs_info {
    unsigned int sampling_rate;
    unsigned int up_threshold;         // default: 80
    unsigned int down_threshold;       // default: 20
    unsigned int freq_step;            // % to change per step (default: 5)
};

// Algorithm: Change frequency gradually
void conservative_update(struct cpufreq_policy *policy) {
    unsigned int load = get_cpu_load(policy->cpu);

    if (load > policy->up_threshold) {
        // Increase by one step (e.g., 5% of max freq)
        unsigned int freq = policy->cur + (policy->max * freq_step / 100);
        cpufreq_driver_target(policy, freq);
    } else if (load < policy->down_threshold) {
        // Decrease by one step
        unsigned int freq = policy->cur - (policy->max * freq_step / 100);
        cpufreq_driver_target(policy, freq);
    }
}

// schedutil Governor (modern, scheduler-integrated)
void schedutil_update(struct cpufreq_policy *policy) {
    // Use scheduler's knowledge of CPU utilization
    unsigned long util = cpu_util(policy->cpu);
    unsigned long max = arch_scale_cpu_capacity(policy->cpu);

    // Direct utilization → frequency mapping
    unsigned int freq = map_util_freq(util, max, policy->cpuinfo.max_freq);

    // Apply frequency
    cpufreq_driver_target(policy, freq);
}

// intel_pstate (hardware-managed P-states)
struct intel_pstate_policy {
    unsigned int min_perf_pct;   // Minimum performance %
    unsigned int max_perf_pct;   // Maximum performance %
    unsigned int epp;            // Energy Performance Preference
                                 // 0 = performance, 255 = power save
};

// Hardware manages frequency automatically within bounds!
// OS just sets policy parameters
```

### 3.4 Configuring cpufreq

```bash
# View current governor and frequencies
$ cpupower frequency-info

analyzing CPU 0:
  driver: intel_pstate
  CPUs which run at the same hardware frequency: 0
  CPUs which need to have their frequency coordinated by software: 0
  maximum transition latency: 20.0 us
  hardware limits: 800 MHz - 4.50 GHz
  available cpufreq governors: performance powersave
  current policy: frequency should be within 800 MHz and 4.50 GHz.
                  The governor "powersave" may decide which speed to use
                  within this range.
  current CPU frequency: 2.30 GHz (asserted by call to hardware)
  boost state support:
    Supported: yes
    Active: yes

# Set governor (all CPUs)
$ cpupower frequency-set -g performance   # Maximum performance
$ cpupower frequency-set -g powersave     # Power saving
$ cpupower frequency-set -g ondemand      # Dynamic (if available)
$ cpupower frequency-set -g schedutil     # Scheduler-integrated

# Set frequency range
$ cpupower frequency-set -d 1.5GHz -u 3.5GHz

# Set specific frequency (performance governor)
$ cpupower frequency-set -f 3.0GHz

# Intel pstate: Set Energy Performance Preference
$ echo 0 > /sys/devices/system/cpu/cpu*/cpufreq/energy_performance_preference
# 0 = performance, 128 = balanced, 255 = power

# Disable turbo boost
$ echo 1 > /sys/devices/system/cpu/intel_pstate/no_turbo

# Per-CPU configuration
$ echo performance > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
$ echo 3000000 > /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq

# Monitor frequency in real-time
$ watch -n 1 "grep MHz /proc/cpuinfo"

# Detailed frequency stats
$ turbostat --quiet --interval 1
```

---

## 4. The OS Idle Loop

When the scheduler has no more tasks to run, it executes the **Idle Task**.

### 4.1 Idle Loop Architecture

```c
// Simplified Linux idle loop
void cpu_idle_loop(void) {
    // Called by each CPU when it has nothing to do

    while (1) {
        // 1. Check for pending work
        while (!need_resched()) {
            // RCU idle mode (no RCU read-side critical sections)
            rcu_idle_enter();

            // Tickless mode: stop scheduler tick if possible
            tick_nohz_idle_enter();

            // 2. Select appropriate idle state (C-state)
            if (cpu_idle_force_poll) {
                // Polling mode (for ultra-low latency)
                cpu_relax();
            } else {
                // Call cpuidle framework to select best C-state
                cpuidle_idle_call();
            }

            // 3. Exit idle
            tick_nohz_idle_exit();
            rcu_idle_exit();
        }

        // 4. Work arrived: schedule it
        schedule_preempt_disabled();
    }
}

// cpuidle framework
void cpuidle_idle_call(void) {
    struct cpuidle_device *dev = this_cpu_ptr(&cpuidle_devices);
    struct cpuidle_driver *drv = cpuidle_get_cpu_driver(dev);

    // Predict how long CPU will be idle
    unsigned int next_event = tick_nohz_get_sleep_length();

    // Select best C-state
    int idx = cpuidle_select(drv, dev, next_event);

    // Enter C-state (CPU sleeps here)
    cpuidle_enter_state(dev, drv, idx);

    // CPU wakes up due to interrupt
}
```

### 4.2 Menu Governor (C-state Selection)

```c
// Menu governor: Predict idle duration, select deepest safe C-state
struct menu_device {
    unsigned int last_state_idx;
    unsigned int predicted_us;     // Predicted idle time
    unsigned int measured_us;      // Actual idle time
    unsigned int correction_factor;// Tune predictions over time
};

int menu_select(struct cpuidle_driver *drv,
                struct cpuidle_device *dev,
                bool *stop_tick) {
    struct menu_device *data = this_cpu_ptr(&menu_devices);

    // 1. Get time until next timer
    unsigned int next_timer_us = tick_nohz_get_sleep_length();

    // 2. Apply correction factor (learn from past predictions)
    unsigned int predicted_us = next_timer_us;
    if (data->correction_factor < 100) {
        predicted_us *= data->correction_factor;
        predicted_us /= 100;
    }

    // 3. Find deepest C-state that fits
    int best_idx = 0;
    for (int i = drv->state_count - 1; i >= 0; i--) {
        struct cpuidle_state *s = &drv->states[i];

        // Skip disabled states
        if (s->disabled || dev->states_usage[i].disable)
            continue;

        // Skip if exit latency too high
        if (s->exit_latency > predicted_us)
            continue;

        // Check if worth entering (target residency)
        // (time in state must exceed cost of entering/exiting)
        if (predicted_us < s->target_residency)
            continue;

        // This is the deepest suitable state
        best_idx = i;
        break;
    }

    data->predicted_us = predicted_us;
    data->last_state_idx = best_idx;

    // Should we stop the tick?
    *stop_tick = (best_idx > 0);

    return best_idx;
}

// After waking from idle, adjust predictions
void menu_update(struct cpuidle_driver *drv, struct cpuidle_device *dev) {
    struct menu_device *data = this_cpu_ptr(&menu_devices);

    // Measure how long we actually slept
    unsigned int measured_us = dev->last_residency;

    // Update correction factor
    if (measured_us < data->predicted_us) {
        // Woke up earlier than expected: reduce future predictions
        data->correction_factor -= 1;
    } else if (measured_us > data->predicted_us * 1.5) {
        // Slept much longer: increase future predictions
        data->correction_factor += 1;
    }

    // Clamp correction factor
    if (data->correction_factor < 50)
        data->correction_factor = 50;
    if (data->correction_factor > 200)
        data->correction_factor = 200;
}
```

---

## 5. Tickless Kernels (NO_HZ)

In older kernels, the CPU woke up every 1ms (the "Timer Tick") just to check if anything needed doing. This prevented deep C-states.

### 5.1 NO_HZ Modes

```
Traditional Kernel (HZ=1000):
═════════════════════════════

Time:   0ms    1ms    2ms    3ms    4ms    5ms    ...
        |      |      |      |      |      |
CPU:   [Work] [Idle] [Idle] [Idle] [Idle] [Idle]
Tick:   ↑      ↑      ↑      ↑      ↑      ↑
                      unnecessary wakeups!

Even when idle, CPU wakes every 1ms to handle timer tick
→ Cannot enter deep C-states (C6+)
→ Wastes power

NO_HZ_IDLE (Tickless Idle):
════════════════════════════

Time:   0ms    1ms    2ms    3ms    4ms    5ms    ...
        |                          |
CPU:   [Work]  [Deep C-state (C6)] [Timer]
Tick:   ↑                          ↑

Timer tick stopped during idle
→ CPU can stay in C6 for extended periods
→ Significant power savings

NO_HZ_FULL (Full Tickless):
════════════════════════════

Time:   0ms    1ms    2ms    3ms    4ms    5ms    ...
        |                                        |
CPU:   [Single Task Running.....................] [Tick]

Timer tick stopped even when running a single task
→ Zero jitter for real-time applications
→ Used for: HPC, low-latency trading, RT control systems
```

### 5.2 Configuring NO_HZ

```bash
# Check current NO_HZ configuration
$ cat /boot/config-$(uname -r) | grep NO_HZ

CONFIG_NO_HZ_IDLE=y          # Tickless idle
CONFIG_NO_HZ_FULL=y          # Full tickless
CONFIG_NO_HZ=y

# View tick statistics
$ cat /proc/timer_list | grep -A 5 "cpu: 0"

# Enable NO_HZ_FULL for specific CPUs (boot parameter)
# /etc/default/grub:
GRUB_CMDLINE_LINUX="nohz_full=1-7 isolcpus=1-7"
# Disables tick on CPUs 1-7 when running single task

# Update grub
$ sudo update-grub
$ sudo reboot

# Verify NO_HZ_FULL is active
$ cat /sys/devices/system/cpu/nohz_full
1-7

# Monitor tick activity
$ perf stat -e timer:hrtimer_expire_entry -a sleep 10
# Fewer events = better tickless behavior
```

---

## 6. Thermal Management

### 6.1 Thermal Architecture

```
Thermal Management Stack:
═════════════════════════

┌─────────────────────────────────────────────────────┐
│                   User Space                         │
│  • thermald (Intel)                                 │
│  • system76-power                                   │
│  • Custom monitoring tools                          │
└─────────────────────┬───────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────┐
│              Thermal Framework (Kernel)              │
│                                                      │
│  ┌────────────────────────────────────────────┐    │
│  │           Thermal Zones                    │    │
│  │  • CPU package (coretemp)                  │    │
│  │  • Individual cores                        │    │
│  │  • GPU                                     │    │
│  │  • Battery, charger                        │    │
│  │  • Ambient sensors                         │    │
│  └─────────────────┬──────────────────────────┘    │
│                    │                                │
│  ┌─────────────────▼──────────────────────────┐    │
│  │         Trip Points (Thresholds)           │    │
│  │  • Active: Start fan (50°C)                │    │
│  │  • Passive: Throttle CPU (75°C)            │    │
│  │  • Hot: Aggressive throttle (90°C)         │    │
│  │  • Critical: Emergency shutdown (105°C)    │    │
│  └─────────────────┬──────────────────────────┘    │
│                    │                                │
│  ┌─────────────────▼──────────────────────────┐    │
│  │          Cooling Devices                   │    │
│  │  • CPU frequency scaling (P-states)        │    │
│  │  • Fan speed control                       │    │
│  │  • GPU throttling                          │    │
│  └────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────┐
│                   Hardware                           │
│  • Temperature sensors (DTS)                        │
│  • Fan controllers (PWM)                            │
│  • CPU/GPU power control                            │
└─────────────────────────────────────────────────────┘
```

### 6.2 Thermal Policies

```c
// Thermal zone structure
struct thermal_zone_device {
    char type[THERMAL_NAME_LENGTH];  // "acpitz", "coretemp", etc.
    struct thermal_trip *trips;      // Array of trip points
    int num_trips;

    int temperature;                 // Current temp (millidegrees C)
    int last_temperature;
    int polling_delay;               // Polling interval (ms)

    struct thermal_cooling_device *cooling_devices[];
};

// Trip point structure
struct thermal_trip {
    int temperature;                 // Threshold (millidegrees C)
    enum thermal_trip_type type;     // ACTIVE, PASSIVE, HOT, CRITICAL
    unsigned long upper;             // Max cooling state
    unsigned long lower;             // Min cooling state
};

// Thermal governor policies
enum thermal_governor_type {
    THERMAL_GOV_STEP_WISE,          // Gradual throttling
    THERMAL_GOV_FAIR_SHARE,         // Distribute throttling fairly
    THERMAL_GOV_USER_SPACE,         // User-space daemon controls
    THERMAL_GOV_POWER_ALLOCATOR,    // Power budget based
};

// Step-wise governor (most common)
void step_wise_throttle(struct thermal_zone_device *tz) {
    int temp = tz->temperature;

    for (int i = 0; i < tz->num_trips; i++) {
        struct thermal_trip *trip = &tz->trips[i];

        if (temp < trip->temperature)
            continue;  // Below trip point

        // Temperature exceeded: increase cooling
        for (each cooling_device) {
            unsigned long cur_state = get_cooling_state(dev);

            if (cur_state < trip->upper) {
                // Increase cooling (reduce freq, increase fan)
                set_cooling_state(dev, cur_state + 1);
            }
        }
    }

    // If temperature dropped, reduce cooling
    if (temp < tz->last_temperature - hysteresis) {
        for (each cooling_device) {
            unsigned long cur_state = get_cooling_state(dev);

            if (cur_state > 0) {
                set_cooling_state(dev, cur_state - 1);
            }
        }
    }

    tz->last_temperature = temp;
}
```

### 6.3 Monitoring Thermal Status

```bash
# View all thermal zones
$ ls /sys/class/thermal/
cooling_device0  thermal_zone0  thermal_zone2  thermal_zone4
cooling_device1  thermal_zone1  thermal_zone3  thermal_zone5

# Read temperature (millidegrees Celsius)
$ cat /sys/class/thermal/thermal_zone0/temp
48000  # 48.0°C

# View thermal zone type
$ cat /sys/class/thermal/thermal_zone0/type
acpitz

# View trip points
$ cat /sys/class/thermal/thermal_zone0/trip_point_*_type
active
passive
critical

$ cat /sys/class/thermal/thermal_zone0/trip_point_*_temp
50000   # Active: 50°C
75000   # Passive: 75°C
105000  # Critical: 105°C

# View cooling devices
$ cat /sys/class/thermal/cooling_device*/type
Processor  # CPU frequency scaling
Fan        # System fan

# View current cooling state
$ cat /sys/class/thermal/cooling_device0/cur_state
0  # 0 = no throttling

$ cat /sys/class/thermal/cooling_device0/max_state
10  # 10 levels of throttling

# Real-time temperature monitoring
$ watch -n 1 "sensors"

# Or use lm-sensors
$ sensors
coretemp-isa-0000
Adapter: ISA adapter
Package id 0:  +52.0°C  (high = +80.0°C, crit = +100.0°C)
Core 0:        +48.0°C  (high = +80.0°C, crit = +100.0°C)
Core 1:        +49.0°C  (high = +80.0°C, crit = +100.0°C)
Core 2:        +51.0°C  (high = +80.0°C, crit = +100.0°C)
Core 3:        +52.0°C  (high = +80.0°C, crit = +100.0°C)

# Advanced monitoring with turbostat
$ turbostat --quiet --interval 1 --show Core,CPU,CoreTmp,PkgTmp,PkgWatt
Core CPU CoreTmp PkgTmp  PkgWatt
-    -   48      52      25.3
0    0   47      52      25.3
0    1   48      52      25.3
1    2   49      52      25.3
1    3   52      52      25.3
```

---

## 7. Runtime Power Management

Runtime PM allows devices to enter low-power states when idle, independently of system sleep.

### 7.1 Runtime PM Framework

```c
// Device runtime PM states
enum rpm_status {
    RPM_ACTIVE = 0,      // Device is active
    RPM_RESUMING,        // Device is resuming
    RPM_SUSPENDED,       // Device is suspended
    RPM_SUSPENDING,      // Device is suspending
};

// Device PM operations
struct dev_pm_ops {
    int (*runtime_suspend)(struct device *dev);
    int (*runtime_resume)(struct device *dev);
    int (*runtime_idle)(struct device *dev);
};

// Example: Network device runtime PM
static int netdev_runtime_suspend(struct device *dev) {
    struct net_device *netdev = to_net_device(dev);

    // Stop device operations
    netdev_stop_hw(netdev);

    // Disable device clocks
    clk_disable(netdev->clk);

    // Reduce device voltage (if possible)
    regulator_set_voltage(netdev->regulator, LOW_VOLTAGE);

    return 0;
}

static int netdev_runtime_resume(struct device *dev) {
    struct net_device *netdev = to_net_device(dev);

    // Restore voltage
    regulator_set_voltage(netdev->regulator, NORMAL_VOLTAGE);

    // Enable clocks
    clk_enable(netdev->clk);

    // Restart device
    netdev_start_hw(netdev);

    return 0;
}

// Runtime PM API usage
void driver_use_device(struct device *dev) {
    // Inform runtime PM we're using the device
    pm_runtime_get_sync(dev);  // May resume if suspended

    // Use device...
    do_device_operation(dev);

    // Done with device
    pm_runtime_put(dev);  // May suspend if idle
}

// Autosuspend (delay before suspending)
void driver_configure_autosuspend(struct device *dev) {
    pm_runtime_set_autosuspend_delay(dev, 2000);  // 2 seconds
    pm_runtime_use_autosuspend(dev);
    pm_runtime_enable(dev);
}
```

### 7.2 Viewing Runtime PM Status

```bash
# View runtime PM status for all devices
$ cat /sys/devices/*/power/runtime_status
active
suspended
suspended
active
...

# View specific device
$ cat /sys/bus/pci/devices/0000:00:1f.3/power/runtime_status
suspended

$ cat /sys/bus/pci/devices/0000:00:1f.3/power/runtime_usage
0

$ cat /sys/bus/pci/devices/0000:00:1f.3/power/runtime_active_time
123456789  # microseconds

$ cat /sys/bus/pci/devices/0000:00:1f.3/power/runtime_suspended_time
987654321  # microseconds

# Enable/disable autosuspend for device
$ echo 2000 > /sys/bus/pci/devices/0000:00:1f.3/power/autosuspend_delay_ms
$ echo auto > /sys/bus/pci/devices/0000:00:1f.3/power/control  # Enable autosuspend
$ echo on > /sys/bus/pci/devices/0000:00:1f.3/power/control    # Disable autosuspend

# View all devices with runtime PM enabled
$ find /sys -name runtime_status -exec grep -l active {} \; | \
  sed 's|/power/runtime_status||' | \
  xargs -I {} basename {}
```

---

## 8. System Suspend and Resume

### 8.1 Suspend Process

```
System Suspend (S3 - Suspend to RAM):
══════════════════════════════════════

User initiates suspend (systemctl suspend, power button, lid close)
    │
    ▼
1. User-space freeze
   • Stop user processes
   • Sync filesystems
       │
       ▼
2. Device suspend (PM callbacks)
   • Call runtime_suspend() for each device
   • Devices powered down in order:
     - Leaf devices first (USB, network, etc.)
     - Bus controllers
     - Core devices (CPU, memory controller)
       │
       ▼
3. Disable non-boot CPUs
   • Migrate processes to CPU 0
   • Power down CPUs 1-N
       │
       ▼
4. Platform suspend
   • Save CPU context (registers, MMU state)
   • Save ACPI state
   • Disable interrupts (except wake sources)
       │
       ▼
5. Enter S3 state
   • Cut power to most devices
   • RAM remains powered (self-refresh mode)
   • Wake sources remain enabled (keyboard, lid, RTC)
       │
       ▼
   [System is suspended, ~1-5W power]
       │
   [Wake event occurs]
       │
       ▼
6. Platform resume
   • Restore ACPI state
   • Restore CPU context
   • Enable interrupts
       │
       ▼
7. Enable non-boot CPUs
   • Power up CPUs 1-N
       │
       ▼
8. Device resume
   • Call runtime_resume() for each device
   • Devices powered up in reverse order:
     - Core devices first
     - Bus controllers
     - Leaf devices
       │
       ▼
9. Thaw user-space
   • Resume processes
   • Restore network connections
       │
       ▼
System operational

Total suspend time: ~1-2 seconds
Total resume time:  ~2-5 seconds
```

### 8.2 Wake Sources

```bash
# View enabled wake sources
$ cat /proc/acpi/wakeup
Device  S-state  Status   Sysfs node
LID     S3       *enabled   platform:PNP0C0D:00
SLPB    S3       *enabled   platform:PNP0C0E:00
GLAN    S4       *disabled  pci:0000:00:1f.6
XHC     S3       *enabled   pci:0000:00:14.0

# Disable wake from device
$ echo XHC > /proc/acpi/wakeup  # Toggle

# View wakeup count (to detect spurious wakeups)
$ cat /sys/power/wakeup_count
42

# Initiate suspend with wakeup protection
$ count=$(cat /sys/power/wakeup_count) && \
  echo $count > /sys/power/wakeup_count && \
  echo mem > /sys/power/state

# View last wake source
$ dmesg | grep -i "wake"
[12345.678] PM: Wakeup from IRQ 9 (ACPI SCI)
```

---

## 9. Wake Locks (Android Power Management)

### 9.1 Wakelock Concept

```
Android Wakelock System:
════════════════════════

┌──────────────────────────────────────────────────┐
│                 Applications                      │
│  ┌────────────────────────────────────────┐     │
│  │  PARTIAL_WAKE_LOCK:                    │     │
│  │  • CPU stays on                        │     │
│  │  • Screen can turn off                 │     │
│  │  • Used for: background music, sync    │     │
│  │                                         │     │
│  │  SCREEN_DIM_WAKE_LOCK:                 │     │
│  │  • Screen stays dimmed                 │     │
│  │                                         │     │
│  │  SCREEN_BRIGHT_WAKE_LOCK:              │     │
│  │  • Screen stays at full brightness     │     │
│  │  • Used for: video playback            │     │
│  │                                         │     │
│  │  FULL_WAKE_LOCK:                       │     │
│  │  • Screen + CPU stay on                │     │
│  │  • Deprecated (use FLAG_KEEP_SCREEN_ON)│     │
│  └────────────────────────────────────────┘     │
└────────────────────┬─────────────────────────────┘
                     │
┌────────────────────▼─────────────────────────────┐
│            Power Manager Service                 │
│  • Tracks all active wakelocks                   │
│  • Decides when system can suspend               │
│  • Manages suspend blockers                      │
└────────────────────┬─────────────────────────────┘
                     │
┌────────────────────▼─────────────────────────────┐
│                  Kernel                          │
│  /sys/power/wake_lock   (acquire)                │
│  /sys/power/wake_unlock (release)                │
└──────────────────────────────────────────────────┘

Rule: System can suspend ONLY when no wakelocks are held
```

### 9.2 Wakelock Debugging

```bash
# View active wakelocks (Android/Linux)
$ cat /sys/kernel/debug/wakeup_sources
name            active_count    event_count     wakeup_count    ...
PowerManagerService.Display  1234        2345            1234
PowerManagerService.WakeLocks 456         567             456
alarm           12345       23456           12345

# View detailed wakelock stats
$ dumpsys power  # Android

# Find app holding wakelock
$ dumpsys batterystats | grep -A 10 "Wake lock"

# Release all wakelocks (debugging)
$ echo 1 > /sys/power/pm_test  # Test mode
$ echo mem > /sys/power/state   # Try suspend
```

---

## 10. Embedded Systems Power Management

### 10.1 Embedded-Specific Considerations

```
Embedded Power Management Techniques:
═══════════════════════════════════════

1. Clock Gating
   • Disable clocks to unused peripherals
   • Example: Turn off SPI clock when not in use
   • Power saved: 10-50 mW per peripheral

2. Power Gating
   • Completely power off unused domains
   • Example: Power down USB subsystem if no devices
   • Power saved: 50-500 mW per domain

3. Voltage Scaling
   • Reduce voltage for low-performance scenarios
   • Example: Drop from 1.2V to 0.9V for idle
   • Power saved: ~50% (power ∝ V²)

4. Sleep Modes
   • MCU-specific deep sleep states
   • Example (ARM Cortex-M):
     - Sleep: CPU clock stopped
     - Deep Sleep: Most clocks stopped
     - Standby: Only RTC and backup RAM powered
   • Wake latency: 10μs - 10ms

5. DMA for Zero-Copy
   • Use DMA to transfer data without CPU
   • CPU can sleep during transfer
   • Power saved: 50-100 mW

6. Interrupt-Driven Design
   • CPU sleeps, wakes only on interrupts
   • Avoid polling loops
   • Power saved: 100-500 mW

Example Power Budget (IoT Device):
───────────────────────────────────
Active mode (WiFi on):      500 mW
Active mode (WiFi off):     100 mW
Light sleep (RAM on):        10 mW
Deep sleep (RTC only):        1 mW
Hibernation (external wake): 0.1 mW

Battery life (3000 mAh at 3.7V):
• Always active: ~22 hours
• 90% sleep, 10% active: ~200 hours (8 days)
• 99% deep sleep: ~10000 hours (13 months)
```

---

## 11. Interview Questions

<AccordionGroup>
  <Accordion title="Q1: Explain the difference between C-states and P-states.">
    **Answer**:

    **C-states (Idle Power States)**:
    - Control power consumption when CPU is **idle** (not executing instructions)
    - Deeper C-states save more power but have higher wake latency
    - Examples: C0 (active), C1 (halt), C3 (deep sleep), C6 (power down)
    - Selected by cpuidle governor based on predicted idle duration
    - Trade-off: Power savings vs wake latency

    **P-states (Performance States)**:
    - Control power consumption when CPU is **active** (executing instructions)
    - Lower P-states mean lower frequency and voltage → less power, less performance
    - Examples: P0 (max freq), P1 (base), Pn (minimum)
    - Selected by cpufreq governor based on workload demand
    - Trade-off: Performance vs power consumption

    **Key Distinction**:
    - C-states: Idle (CPU doing nothing)
    - P-states: Active (CPU doing work, but at what speed?)

    **Example**:
    ```
    Scenario 1: CPU running video encoding
    - C-state: C0 (active, not idle)
    - P-state: P0 (maximum performance needed)

    Scenario 2: CPU between tasks
    - C-state: C6 (deep power down, long idle predicted)
    - P-state: N/A (not active)

    Scenario 3: CPU doing background compilation
    - C-state: C0 (active)
    - P-state: P2 (medium frequency is sufficient)
    ```
  </Accordion>

  <Accordion title="Q2: What is the 'race to sleep' strategy in power management?">
    **Answer**:

    **Race to Sleep**: Complete work as fast as possible (high P-state) and return to deep sleep (high C-state) rather than running slowly for longer.

    **Mathematics**:
    ```
    Scenario A: Slow and steady
    - Frequency: 1.0 GHz
    - Voltage: 0.8V
    - Time: 100ms
    - Power: 0.8² × 1.0 = 0.64 (relative)
    - Energy: 0.64 × 100ms = 64 units

    Scenario B: Race to sleep
    - Frequency: 2.0 GHz
    - Voltage: 1.2V
    - Time: 50ms (2x faster)
    - Power: 1.2² × 2.0 = 2.88 (relative)
    - Energy (active): 2.88 × 50ms = 144 units
    - Energy (sleep): 0.1 × 50ms = 5 units
    - Total: 149 units

    Wait, B uses more energy?!
    ```

    **The Trick**: Static power consumption!

    Modern CPUs have two power components:
    - **Dynamic power**: Varies with frequency/voltage (scales as V² × f)
    - **Static power**: Leakage current (constant when powered, zero when off)

    ```
    Real calculation (with static power):

    Scenario A: (static=0.5, dynamic=0.64)
    - Total: (0.5 + 0.64) × 100ms = 114 units

    Scenario B: (static=0.5 active, 0.01 sleep; dynamic=2.88 active, 0 sleep)
    - Active: (0.5 + 2.88) × 50ms = 169 units
    - Sleep: 0.01 × 50ms = 0.5 units
    - Total: 169.5 units

    Hmm, still worse...
    ```

    **When Race to Sleep Wins**:
    1. **Work arrives intermittently**: More time in deep C-states
    2. **Static power dominates**: Modern process nodes (7nm, 5nm) have high leakage
    3. **Memory-bound workloads**: CPU waiting for memory anyway

    **Real Example**:
    ```
    Web server handling requests:
    - Request arrives → Race to P0 (max freq)
    - Process in 10ms
    - Return to C6 (deep sleep) for 990ms
    - Average power: Much lower than staying at medium frequency
    ```

    **When to Avoid**:
    - Continuous compute workloads (video encoding)
    - When thermals are constrained
    - When frequency scaling overhead is high
  </Accordion>

  <Accordion title="Q3: Explain NO_HZ_FULL and why it's important for low-latency applications.">
    **Answer**:

    **NO_HZ_FULL (Full Tickless Kernel)**:

    **Problem with Traditional Kernels**:
    ```
    Every 1ms (HZ=1000), timer interrupt fires:
    ────────────────────────────────────────────
    [App running]
        ↓ (1ms later)
    [INTERRUPT!] → Scheduler runs → [Resume app]
                   (50-100μs latency spike)

    For low-latency apps (trading, audio, control systems):
    - 50μs jitter every 1ms is unacceptable
    - Breaks real-time guarantees
    ```

    **NO_HZ_FULL Solution**:
    ```
    Kernel stops timer tick on CPUs running single task:
    ────────────────────────────────────────────────────
    [App running continuously, no interrupts]
    └─> Zero scheduling overhead
    └─> Deterministic latency
    ```

    **Configuration**:
    ```bash
    # Boot parameters
    nohz_full=1-7        # Make CPUs 1-7 tickless
    isolcpus=1-7         # Isolate CPUs from scheduler
    rcu_nocbs=1-7        # Move RCU callbacks off these CPUs

    # In application
    # 1. Pin thread to isolated CPU
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(1, &cpuset);
    pthread_setaffinity_np(pthread_self(), sizeof(cpuset), &cpuset);

    # 2. Set RT priority
    struct sched_param param = {.sched_priority = 99};
    pthread_setschedparam(pthread_self(), SCHED_FIFO, &param);

    # 3. Now thread runs with zero jitter
    while (1) {
        process_with_deterministic_latency();
    }
    ```

    **Benefits**:
    - Latency: ~1μs (from ~50μs)
    - Jitter: less than 1μs (from ±50μs)
    - Suitable for: Trading, audio processing, industrial control

    **Trade-offs**:
    - Kernel overhead moved to CPU 0
    - Complexity in CPU isolation
    - Not suitable for general-purpose workloads
  </Accordion>

  <Accordion title="Q4: How would you diagnose a laptop with poor battery life?">
    **Answer**:

    **Systematic Diagnosis**:

    **1. Baseline Power Consumption**:
    ```bash
    # Check current power draw
    $ cat /sys/class/power_supply/BAT0/power_now
    15000000  # 15W (too high for idle!)

    # Expected idle: 3-5W (laptop), 0.5-2W (ultrabook)
    ```

    **2. Check C-state Residency**:
    ```bash
    $ turbostat --quiet --show CPU,C1%,C3%,C6%,C7%
    CPU  C1%   C3%   C6%   C7%
    0    15.2  8.3   5.1   0.0  # BAD: Not entering C7!
    1    12.8  9.1   4.7   0.0
    2    18.3  7.9   6.2   0.0
    3    14.1  8.5   5.4   0.0

    # Healthy idle should show >90% in deep C-states
    ```

    **3. Find Wake Sources**:
    ```bash
    $ cat /sys/kernel/debug/wakeup_sources
    name            active_count    ...
    PNP0C0D:00      1234            # Lid switch (normal)
    alarmtimer      12345           # High! Find culprit
    uhci_hcd        56789           # USB waking CPU

    # Identify processes causing wakeups
    $ powertop
    # Shows:
    # - Top power consumers
    # - Devices preventing deep sleep
    # - Tunable parameters
    ```

    **4. Check for Busy Devices**:
    ```bash
    # Find devices not in runtime PM
    $ for dev in /sys/bus/*/devices/*/power/runtime_status; do
        if grep -q active $dev; then
            echo $(dirname $dev)
        fi
    done

    # Common culprits:
    # - USB devices without autosuspend
    # - Network card in active polling
    # - Bluetooth always on
    ```

    **5. Check CPU Frequency**:
    ```bash
    $ watch -n 1 "grep MHz /proc/cpuinfo"
    # If stuck at high frequency → check governor

    $ cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor
    performance  # BAD for battery!

    # Fix:
    $ cpupower frequency-set -g powersave
    ```

    **6. Check for Rogue Processes**:
    ```bash
    $ top -b -n 1 | head -20
    # Look for processes consuming >1% CPU at idle

    $ perf top -U  # User-space CPU consumers
    ```

    **7. Common Fixes**:
    ```bash
    # Enable laptop mode
    $ echo 5 > /proc/sys/vm/laptop_mode

    # Enable USB autosuspend
    $ for dev in /sys/bus/usb/devices/*/power/control; do
        echo auto > $dev
    done

    # Enable SATA link power management
    $ echo med_power_with_dipm > /sys/class/scsi_host/host*/link_power_management_policy

    # Enable audio codec power saving
    $ echo 1 > /sys/module/snd_hda_intel/parameters/power_save

    # Enable PCIe ASPM
    $ echo powersave > /sys/module/pcie_aspm/parameters/policy
    ```

    **8. Verify Improvements**:
    ```bash
    $ cat /sys/class/power_supply/BAT0/power_now
    4500000  # 4.5W - much better!

    $ turbostat --quiet --show CPU,C1%,C6%,C7%
    CPU  C1%   C6%   C7%
    0    1.2   3.4   94.8  # Excellent!
    ```
  </Accordion>

  <Accordion title="Q5: Explain thermal throttling and how to monitor it.">
    **Answer**:

    **Thermal Throttling**: Reducing CPU frequency/voltage to lower heat generation when temperature exceeds safe thresholds.

    **Thermal Throttling Process**:
    ```
    Normal Operation:
    ─────────────────
    Temperature: 50°C
    Frequency: 3.5 GHz (P0)
    Voltage: 1.2V
    Power: 45W

    Under Load:
    ───────────
    Temperature rises: 50°C → 60°C → 70°C → 80°C

    At 75°C (Passive Trip Point):
    ──────────────────────────────
    Thermal zone triggers passive cooling
    → Reduce P-state: 3.5 GHz → 3.0 GHz
    → Reduce voltage: 1.2V → 1.05V
    → Power drops: 45W → 32W
    → Temperature stabilizes at 72°C

    If Still Rising (85°C - Hot Trip Point):
    ─────────────────────────────────────────
    Aggressive throttling
    → Drop to minimum P-state: 800 MHz
    → Maximum fan speed
    → Power: 15W
    → Temperature drops to 60°C

    Critical (100°C - Critical Trip Point):
    ────────────────────────────────────────
    Emergency shutdown to prevent damage
    ```

    **Monitoring Thermal Throttling**:

    1. **Real-Time Temperature**:
    ```bash
    $ watch -n 1 "sensors | grep -A 10 coretemp"
    coretemp-isa-0000
    Package id 0:  +78.0°C  (high = +80.0°C, crit = +100.0°C)
    Core 0:        +75.0°C  (high = +80.0°C, crit = +100.0°C)
    Core 1:        +78.0°C  (high = +80.0°C, crit = +100.0°C)  # Hot!
    Core 2:        +76.0°C  (high = +80.0°C, crit = +100.0°C)
    Core 3:        +77.0°C  (high = +80.0°C, crit = +100.0°C)
    ```

    2. **Detect Throttling Events**:
    ```bash
    # Check for throttling in dmesg
    $ dmesg | grep -i throttl
    [12345.678] CPU0: Package temperature above threshold
    [12345.789] CPU0: Core temperature above threshold

    # Check thermal events
    $ journalctl -k | grep thermal
    ```

    3. **Monitor Frequency During Throttling**:
    ```bash
    $ turbostat --quiet --interval 1 --show Core,CPU,Avg_MHz,Busy%,CoreTmp,PkgWatt
    Core CPU Avg_MHz Busy%  CoreTmp PkgWatt
    -    -   1200    35.2   78      32.5   # Throttled to 1.2 GHz!
    0    0   1150    34.8   78      32.5
    0    1   1180    35.1   78      32.5
    1    2   1220    35.5   77      32.5
    1    3   1250    35.8   76      32.5

    # Normal would be 3.5 GHz at this load level
    ```

    4. **Check Cooling Device States**:
    ```bash
    $ cat /sys/class/thermal/cooling_device*/cur_state
    0  # No throttling
    8  # Significant throttling (out of max_state=10)
    ```

    5. **Programmatic Detection**:
    ```c
    // Read thermal throttling status (MSR)
    #include <linux/msr.h>

    uint64_t msr;
    rdmsrl(MSR_IA32_THERM_STATUS, msr);

    if (msr & (1 << 0)) {
        printf("Thermal throttling active!\n");
    }

    if (msr & (1 << 1)) {
        printf("Thermal throttling log!\n");
    }
    ```

    **Preventing Thermal Issues**:
    ```bash
    # 1. Improve cooling
    # - Clean dust from fans/heatsink
    # - Replace thermal paste
    # - Ensure adequate airflow

    # 2. Lower base frequency
    $ echo 3000000 > /sys/devices/system/cpu/cpu*/cpufreq/scaling_max_freq

    # 3. Disable turbo boost
    $ echo 1 > /sys/devices/system/cpu/intel_pstate/no_turbo

    # 4. Limit power consumption
    $ echo 35000000 > /sys/class/powercap/intel-rapl/intel-rapl:0/constraint_0_power_limit_uw
    # Limit to 35W

    # 5. Use laptop mode (more aggressive power management)
    $ tlp start  # TLP: Advanced power management tool
    ```
  </Accordion>
</AccordionGroup>

---

## 12. Advanced Practice

<CardGroup cols={2}>
  <Card title="Practice 1: C-state Analysis" icon="moon">
    Monitor C-state residency:
    - Use `turbostat` to track C-states
    - Find processes preventing deep sleep
    - Calculate power savings from C-states
    - Tune for maximum battery life
  </Card>

  <Card title="Practice 2: cpufreq Tuning" icon="gauge">
    Experiment with governors:
    - Benchmark each governor
    - Measure power vs performance
    - Create custom governor parameters
    - Optimize for your workload
  </Card>

  <Card title="Practice 3: Thermal Stress Testing" icon="temperature-high">
    Stress test thermal management:
    - Run CPU stress test
    - Monitor temperature and throttling
    - Adjust trip points
    - Measure thermal response time
  </Card>

  <Card title="Practice 4: Battery Life Optimization" icon="battery-full">
    Maximize laptop battery life:
    - Use `powertop` to find issues
    - Enable all power-saving features
    - Measure before/after battery life
    - Create power profile scripts
  </Card>
</CardGroup>

```bash
# Comprehensive power analysis script
#!/bin/bash

echo "=== Power Management Analysis ==="
echo

echo "1. Current Power Consumption:"
if [ -f /sys/class/power_supply/BAT0/power_now ]; then
    power_uw=$(cat /sys/class/power_supply/BAT0/power_now)
    power_w=$(echo "scale=2; $power_uw / 1000000" | bc)
    echo "   Battery draw: ${power_w}W"
else
    echo "   (Battery information not available)"
fi

echo
echo "2. CPU Frequency and Governor:"
for cpu in /sys/devices/system/cpu/cpu[0-9]*; do
    if [ -f $cpu/cpufreq/scaling_cur_freq ]; then
        freq=$(cat $cpu/cpufreq/scaling_cur_freq)
        gov=$(cat $cpu/cpufreq/scaling_governor)
        echo "   $(basename $cpu): ${freq} kHz, governor: $gov"
    fi
done

echo
echo "3. C-state Residency:"
turbostat --quiet --show CPU,C1%,C3%,C6%,C7% sleep 1 2>/dev/null || \
    echo "   (turbostat not available)"

echo
echo "4. Active Wake Sources:"
if [ -f /sys/kernel/debug/wakeup_sources ]; then
    awk 'NR>1 && $2>0 {print "   " $1 ": " $2 " events"}' \
        /sys/kernel/debug/wakeup_sources | head -5
fi

echo
echo "5. Thermal Status:"
if command -v sensors &> /dev/null; then
    sensors | grep -E "Package|Core" | head -5
else
    echo "   (lm-sensors not installed)"
fi

echo
echo "6. Runtime PM Status (sample):"
for dev in /sys/devices/pci0000:00/*/power/runtime_status; do
    if [ -f "$dev" ]; then
        status=$(cat "$dev")
        dev_name=$(basename $(dirname $(dirname "$dev")))
        echo "   $dev_name: $status"
    fi
done | head -5

echo
echo "7. Power Saving Recommendations:"
echo "   Run: sudo powertop --auto-tune"
echo "   Run: sudo tlp start"
```

---

## 13. Key Takeaways

<CardGroup cols={2}>
  <Card title="Power vs Performance" icon="balance-scale">
    Always a trade-off:
    - Deep C-states save power but add latency
    - High P-states provide performance but consume more
    - Choose based on workload requirements
  </Card>

  <Card title="Modern Hardware Helps" icon="microchip">
    Hardware power management has improved:
    - Intel/AMD hardware-managed P-states
    - Per-core power gating
    - Advanced idle states
    - OS provides policy, hardware executes
  </Card>

  <Card title="Monitoring is Essential" icon="chart-line">
    Can't optimize what you don't measure:
    - Use turbostat for CPU states
    - Use powertop for system-wide analysis
    - Monitor temperature continuously
    - Profile before and after changes
  </Card>

  <Card title="No One-Size-Fits-All" icon="wrench">
    Different workloads need different strategies:
    - Servers: Maximum performance
    - Laptops: Balance performance and battery
    - Embedded: Aggressive power saving
    - Real-time: Disable deep C-states for latency
  </Card>
</CardGroup>

---

## Resources for Further Study

<AccordionGroup>
  <Accordion title="Essential Reading" icon="book">
    - **Intel Software Developer Manual**: Volume 3, Chapter 14 (Power and Thermal Management)
    - **ACPI Specification**: Version 6.5 (acpi.org)
    - **Linux Power Management Documentation**: `Documentation/power/` in kernel source
    - **"Modern Processor Design"** by Shen & Lipasti: Chapter on power management
  </Accordion>

  <Accordion title="Tools and Utilities" icon="wrench">
    - **turbostat**: Real-time CPU state monitoring
    - **powertop**: System-wide power analysis
    - **cpupower**: CPU frequency control
    - **tlp**: Laptop power management
    - **thermald**: Intel thermal daemon
  </Accordion>

  <Accordion title="Hands-On Labs" icon="flask">
    - Implement a simple cpuidle governor
    - Write a thermal monitoring daemon
    - Create power profiles for different scenarios
    - Measure battery life improvements
    - Debug power regressions
  </Accordion>

  <Accordion title="Advanced Topics" icon="rocket">
    - Intel Speed Shift (HWP) internals
    - AMD SenseMI technology
    - ARM big.LITTLE and DynamIQ
    - GPU power management
    - SoC-level power management
    - Data center power capping
  </Accordion>
</AccordionGroup>

---

Next: [Operating Systems Summary & Interview Prep](/operating-systems/interview-prep) →
