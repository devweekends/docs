---
title: "Device Drivers: Hardware Abstraction & Interrupts"
sidebarTitle: "Device Drivers"
description: "A deep dive into Char/Block drivers, MMIO, DMA descriptor rings, and Bottom Half architecture"
icon: "plug"
---

# Device Drivers & Hardware I/O

A device driver is a specialized kernel module that acts as a translator between the operating system's generic I/O requests and the hardware's specific register-level interface. For a systems engineer, the driver layer is where software meets the raw physics of the machine.

<Info>
**Mastery Level**: Senior Systems Engineer  
**Key Internals**: MMIO, DMA Descriptor Rings, Tasklets vs. Workqueues, Major/Minor Numbers  
**Prerequisites**: [I/O Systems](/operating-systems/io-systems), [Kernel Memory](/operating-systems/kernel-memory)
</Info>

---

## 1. Talking to Hardware: Ports and MMIO

The CPU has two primary ways to communicate with a hardware device's registers.

### 1.1 Port-Mapped I/O (PMIO)
- **Mechanism**: Uses a separate address space and specialized instructions (`in`, `out` on x86).
- **Scope**: Limited (usually 64KB on x86). Primarily used for legacy devices like the keyboard controller or serial ports.

### 1.2 Memory-Mapped I/O (MMIO)
- **Mechanism**: The hardware registers are mapped directly into the CPU's **Physical Address Space**.
- **Usage**: To the CPU, reading a status register is just a `MOV` instruction from a specific address.
- **Barriers**: Because the compiler or CPU might reorder memory accesses, drivers must use **Memory Barriers** (`wmb()`, `rmb()`) to ensure the hardware receives commands in the correct order.

---

## 2. Character vs. Block Devices

Linux classifies most hardware into three categories: Character, Block, and Network.

| Feature | Character Devices | Block Devices |
|---------|-------------------|---------------|
| **Access** | Sequential (Stream of bytes) | Random (Addressable blocks) |
| **Buffering** | None (Direct) | Heavy (Page Cache) |
| **Example** | Serial ports, Mice, Keyboards | Hard drives, SSDs, SD cards |
| **Interface** | `open`, `read`, `write` | Block Layer / Request Queues |

### The Major and Minor Numbers
- **Major Number**: Identifies the **Driver** (e.g., all SATA disks use the same major number).
- **Minor Number**: Identifies the **Device Instance** (e.g., `sda` vs `sdb`).

---

## 3. Interrupt Handling: The Split-Half Model

Hardware is slow; the CPU is fast. To avoid wasting CPU cycles "polling" for data, devices use **Interrupts**.

### 3.1 The Top Half (Interrupt Service Routine)
When an interrupt occurs, the kernel stops everything and runs the **Top Half**.
- **Constraint**: Must be extremely fast. 
- **Rule**: **CANNOT SLEEP**. You cannot call `malloc` or wait on a mutex in the top half because it runs in "Interrupt Context," not a process context.

### 3.2 The Bottom Half (Deferred Work)
The top half does the bare minimum (e.g., acknowledged the hardware) and schedules a **Bottom Half** to do the heavy lifting (e.g., parsing a network packet).

| Mechanism | Context | Characteristics |
|-----------|---------|-----------------|
| **Softirqs** | Interrupt | High priority, statically defined (e.g., Networking/Timer). |
| **Tasklets** | Interrupt | Built on Softirqs. Easier to use but only run on one CPU at a time. |
| **Workqueues** | **Process** | Runs in a kernel thread. **CAN SLEEP**. Best for long-running tasks like disk I/O. |

---

## 4. DMA: Zero-Copy Hardware Transfers

**Direct Memory Access (DMA)** allows hardware to read/write directly to System RAM without involving the CPU.

### 4.1 Descriptor Rings
Modern high-performance devices (like NVMe or 100G NICs) use **Descriptor Rings**.
1. The Driver puts a "Descriptor" (a command + a pointer to a buffer) into a ring buffer in RAM.
2. The Driver writes to an MMIO register ("Doorbell") to tell the device.
3. The Device reads the ring, performs the DMA, and writes a "Completion" back to a second ring.

### 4.2 Scatter-Gather I/O
If a data buffer is scattered across non-contiguous physical pages, the driver provides a **Scatterlist**. The DMA controller can then "gather" these pieces into a single transfer, avoiding expensive memory copies.

---

## 5. The Linux Driver Model

The kernel uses a unified model to track hardware.
- **`struct bus_type`**: Represents the transport (PCI, USB, I2C).
- **`struct device`**: Represents a physical piece of hardware.
- **`struct device_driver`**: Represents the code that can manage a device.

**The Matchmaking**: When a new device is plugged into the PCI bus, the PCI bus core iterates through all registered `device_driver` objects. If a driver's "Vendor ID" and "Device ID" match the hardware, the kernel calls the driver's `probe()` function.

---

## 6. Driver Development Lifecycle

Understanding drivers in the abstract is useful, but real systems follow a concrete lifecycle from **prototype** to **production**.

### 6.1 Out-of-Tree vs In-Tree Drivers

- **Out-of-tree (external)**:
  - Built as separate modules against the kernel headers.
  - Often shipped by hardware vendors; updated independently from the main kernel.
  - Managed via tools like **DKMS** so they rebuild automatically on kernel upgrades.
- **In-tree (mainline)**:
  - Maintained directly in the kernel source tree.
  - Benefit from continuous testing, refactoring, and API stability guarantees.
  - Preferred for long-term maintenance and security.

### 6.2 Typical Development Flow

1. **Prototype**:
   - Start with a minimal `probe`/`remove` driver that can identify the device and print logs.
   - Use `dmesg`, `lspci`, and `/sys/bus/*` to introspect resources.
2. **Basic I/O and interrupts**:
   - Map MMIO regions, configure basic registers.
   - Wire up interrupt handlers and verify they fire correctly.
3. **DMA and performance**:
   - Implement descriptor rings and DMA paths.
   - Use `perf`, `/proc/interrupts`, and custom tracing to validate throughput and latency.
4. **Error handling and recovery**:
   - Handle hotplug, reset, timeouts, and error paths robustly.
   - Ensure resources are released correctly on failure and module unload.
5. **Upstreaming and maintenance**:
   - Conform to subsystem style (netdev, block, DRM, etc.).
   - Add documentation and selftests where possible.

### 6.3 Common Pitfalls

- Forgetting to handle **suspend/resume** paths, leading to devices that break after sleep.
- Using blocking operations or sleeping in **interrupt context** instead of deferring to workqueues.
- Leaking DMA mappings or neglecting IOMMU interactions, causing subtle memory corruption.

Keep this lifecycle in mind when reading or writing real drivers; the concepts in this chapter map directly onto these stages.

---

## 7. Interview Deep Dive: Senior Level

<AccordionGroup>
  <Accordion title="Why must the Top Half of an interrupt handler be non-blocking?">
    The Top Half runs in "Interrupt Context." In this state, there is no associated process (no `task_struct`). If the handler were to sleep (e.g., waiting for a mutex), the scheduler would try to switch to another process, but it wouldn't know how to "return" to the interrupt handler later because it has no stack or state in the scheduler's run-queue. This would lead to an immediate system hang or panic.
  </Accordion>

  <Accordion title="Explain 'Interrupt Storm' and how NAPI mitigates it.">
    An interrupt storm occurs when a device (like a 10Gbps NIC) generates interrupts faster than the CPU can handle them, causing the CPU to spend 100% of its time in the Top Half. **NAPI (New API)** mitigates this by switching from Interrupts to **Polling** under high load. After the first interrupt, the driver disables interrupts and tells the kernel to "poll" the device in a bottom-half until the data buffer is empty.
  </Accordion>

  <Accordion title="What is 'IOMMU' and why is it used?">
    An IOMMU (Input-Output Memory Management Unit) is to a device what an MMU is to a process. it translates **Device Virtual Addresses** to **Host Physical Addresses**. It is used for:
    1. **Security**: Preventing a malicious device from DMA-ing into kernel memory.
    2. **Virtualization**: Allowing a Guest VM to have direct access to a physical PCI device (PCI Passthrough).
  </Accordion>
</AccordionGroup>

---

## 7. Advanced Practice

1. **Interrupt Statistics**: Run `watch -n1 cat /proc/interrupts` and identify which CPU is handling the most network or disk interrupts.
2. **Module Programming**: Write a minimal "Hello World" Linux Kernel Module (LKM) and load it using `insmod`.
3. **PCI Exploration**: Use `lspci -vvv` to find the MMIO address range and IRQ number of your network card.

---
Next: [The Advanced Storage Stack](/operating-systems/storage-stack) â†’
