---
title: "SOLID Principles in Practice"
description: "Applying SOLID principles to real-world LLD scenarios"
icon: "compass-drafting"
---

<Frame>
  <img src="/images/LLD/solid-principles.svg" alt="SOLID Principles" />
</Frame>

## What is SOLID?

SOLID is an acronym for five design principles that help you write maintainable, flexible, and testable code:

| Letter | Principle | One-Liner |
|--------|-----------|-----------|
| **S** | Single Responsibility | One class, one reason to change |
| **O** | Open/Closed | Open for extension, closed for modification |
| **L** | Liskov Substitution | Subtypes must be substitutable for base types |
| **I** | Interface Segregation | Many specific interfaces > one general interface |
| **D** | Dependency Inversion | Depend on abstractions, not concretions |

---

## üö® Code Smell Recognition

Before diving into principles, learn to recognize when code violates SOLID:

<Tabs>
  <Tab title="S Violations">
```python
# üö® GOD CLASS - does everything
class UserManager:
    def create_user(self): pass
    def authenticate(self): pass
    def send_email(self): pass      # ‚ùå Email is not user management
    def generate_report(self): pass  # ‚ùå Reporting is separate concern
    def backup_data(self): pass      # ‚ùå Backup is infrastructure

# Signs of SRP violation:
# - Class has many unrelated methods
# - Class name includes "Manager", "Handler", "Processor", "Utils"
# - You need to change the class for different reasons
```
  </Tab>
  <Tab title="O Violations">
```python
# üö® MODIFICATION REQUIRED for new types
class DiscountCalculator:
    def calculate(self, customer_type: str, amount: float):
        if customer_type == "regular":
            return amount * 0.95
        elif customer_type == "premium":
            return amount * 0.90
        elif customer_type == "vip":      # ‚ùå Had to modify existing code
            return amount * 0.80
        # Adding new type = modifying this class

# Signs of OCP violation:
# - Adding new type requires modifying existing code
# - Long if-elif chains based on type
# - switch/case statements that grow over time
```
  </Tab>
  <Tab title="L Violations">
```python
# üö® SUBTYPE breaks parent contract
class Bird:
    def fly(self):
        return "Flying"

class Penguin(Bird):
    def fly(self):
        raise Exception("Can't fly!")  # ‚ùå Violates LSP

# Using Bird anywhere would break with Penguin:
def make_bird_fly(bird: Bird):
    return bird.fly()  # üí• Crashes for Penguin!

# Signs of LSP violation:
# - Subclass throws "not implemented" exceptions
# - Subclass has empty/no-op override methods
# - Type checking required before calling methods
```
  </Tab>
  <Tab title="I Violations">
```python
# üö® FAT INTERFACE forces unused methods
class IWorker(ABC):
    @abstractmethod
    def work(self): pass
    
    @abstractmethod
    def eat(self): pass
    
    @abstractmethod
    def sleep(self): pass

class Robot(IWorker):
    def work(self): 
        print("Working")
    
    def eat(self):
        pass  # ‚ùå Robot doesn't eat - forced to implement
    
    def sleep(self):
        pass  # ‚ùå Robot doesn't sleep - forced to implement

# Signs of ISP violation:
# - Classes implement methods they don't use
# - Empty/stub method implementations
# - Changes to interface affect unrelated clients
```
  </Tab>
  <Tab title="D Violations">
```python
# üö® TIGHT COUPLING to concrete classes
class OrderService:
    def __init__(self):
        self.db = MySQLDatabase()       # ‚ùå Concrete dependency
        self.email = SMTPEmailSender()  # ‚ùå Hard to test
        self.payment = StripePayment()  # ‚ùå Hard to swap
    
    def place_order(self, order):
        self.db.save(order)
        self.email.send(order.customer_email)
        self.payment.charge(order.total)

# Signs of DIP violation:
# - Class creates its own dependencies with `new`/direct instantiation
# - Hard to unit test (no way to inject mocks)
# - Changing implementation requires modifying clients
```
  </Tab>
</Tabs>

---

## Case Study: E-commerce Order System

We'll refactor a poorly designed order system step by step.

### ‚ùå Initial Bad Design (Violates ALL SOLID Principles)

```python
class Order:
    def __init__(self, items, customer_email):
        self.items = items
        self.customer_email = customer_email
        self.status = "pending"
    
    def calculate_total(self):
        total = sum(item.price * item.quantity for item in self.items)
        # Apply discount based on items
        if total > 100:
            total *= 0.9
        return total
    
    def process_payment(self, card_number, cvv):
        # Direct payment processing
        print(f"Processing payment of ${self.calculate_total()}")
        # Credit card API call here
        return True
    
    def update_inventory(self):
        for item in self.items:
            # Direct database call
            print(f"Reducing stock for {item.name}")
    
    def send_confirmation_email(self):
        # Direct email sending
        print(f"Sending email to {self.customer_email}")
    
    def generate_invoice_pdf(self):
        # PDF generation logic
        print("Generating PDF invoice")
    
    def save_to_database(self):
        # Database save logic
        print("Saving order to database")
```

**Problems**:
- One class does everything (violates SRP)
- Hard to test (depends on external services)
- Can't change payment/email without modifying Order
- Tightly coupled to implementations

---

## S - Single Responsibility Principle

> Each class should have only one reason to change.

### ‚úÖ Refactored: Separate Responsibilities

```python
# Order only handles order data
class Order:
    def __init__(self, items: List[OrderItem], customer: Customer):
        self.id = uuid.uuid4()
        self.items = items
        self.customer = customer
        self.status = OrderStatus.PENDING
        self.created_at = datetime.now()
    
    def calculate_total(self) -> Decimal:
        return sum(item.subtotal for item in self.items)

# Separate class for pricing/discounts
class PricingService:
    def __init__(self, discount_rules: List[DiscountRule]):
        self.discount_rules = discount_rules
    
    def calculate_final_price(self, order: Order) -> Decimal:
        total = order.calculate_total()
        for rule in self.discount_rules:
            total = rule.apply(total, order)
        return total

# Separate class for payment
class PaymentProcessor:
    def process(self, order: Order, payment_method: PaymentMethod) -> PaymentResult:
        pass

# Separate class for notifications
class NotificationService:
    def send_order_confirmation(self, order: Order) -> None:
        pass

# Separate class for inventory
class InventoryService:
    def reserve_items(self, items: List[OrderItem]) -> bool:
        pass
    
    def release_items(self, items: List[OrderItem]) -> None:
        pass

# Separate class for persistence
class OrderRepository:
    def save(self, order: Order) -> None:
        pass
    
    def find_by_id(self, order_id: UUID) -> Optional[Order]:
        pass
```

---

## O - Open/Closed Principle

> Open for extension, closed for modification.

### ‚úÖ Extensible Discount System

```python
from abc import ABC, abstractmethod

class DiscountRule(ABC):
    @abstractmethod
    def apply(self, total: Decimal, order: Order) -> Decimal:
        pass
    
    @abstractmethod
    def is_applicable(self, order: Order) -> bool:
        pass

class BulkDiscountRule(DiscountRule):
    """10% off for orders over $100"""
    def is_applicable(self, order: Order) -> bool:
        return order.calculate_total() > 100
    
    def apply(self, total: Decimal, order: Order) -> Decimal:
        if self.is_applicable(order):
            return total * Decimal("0.9")
        return total

class FirstOrderDiscountRule(DiscountRule):
    """15% off for first-time customers"""
    def __init__(self, order_repository: OrderRepository):
        self.order_repository = order_repository
    
    def is_applicable(self, order: Order) -> bool:
        past_orders = self.order_repository.find_by_customer(order.customer.id)
        return len(past_orders) == 0
    
    def apply(self, total: Decimal, order: Order) -> Decimal:
        if self.is_applicable(order):
            return total * Decimal("0.85")
        return total

class HolidayDiscountRule(DiscountRule):
    """20% off during holidays"""
    def __init__(self, holiday_calendar: HolidayCalendar):
        self.holiday_calendar = holiday_calendar
    
    def is_applicable(self, order: Order) -> bool:
        return self.holiday_calendar.is_holiday(order.created_at)
    
    def apply(self, total: Decimal, order: Order) -> Decimal:
        if self.is_applicable(order):
            return total * Decimal("0.8")
        return total

# Adding new discount = new class, no modification to existing code!
class LoyaltyDiscountRule(DiscountRule):
    """5% off for loyalty members"""
    def is_applicable(self, order: Order) -> bool:
        return order.customer.is_loyalty_member
    
    def apply(self, total: Decimal, order: Order) -> Decimal:
        if self.is_applicable(order):
            return total * Decimal("0.95")
        return total
```

---

## L - Liskov Substitution Principle

> Subtypes must be substitutable for their base types.

### ‚ùå Violation Example

```python
class Bird:
    def fly(self):
        return "Flying"

class Penguin(Bird):
    def fly(self):
        raise Exception("Penguins can't fly!")  # Violates LSP!
```

### ‚úÖ Correct Hierarchy

```python
class Bird(ABC):
    @abstractmethod
    def move(self):
        pass

class FlyingBird(Bird):
    def move(self):
        return self.fly()
    
    def fly(self):
        return "Flying through the air"

class SwimmingBird(Bird):
    def move(self):
        return self.swim()
    
    def swim(self):
        return "Swimming in water"

class Sparrow(FlyingBird):
    pass

class Penguin(SwimmingBird):
    pass

# Now any Bird can be used interchangeably
def make_bird_move(bird: Bird):
    print(bird.move())  # Works for all birds!
```

### ‚úÖ Payment Example

```python
class PaymentMethod(ABC):
    @abstractmethod
    def pay(self, amount: Decimal) -> PaymentResult:
        pass
    
    @abstractmethod
    def supports_refund(self) -> bool:
        pass

class CreditCardPayment(PaymentMethod):
    def pay(self, amount: Decimal) -> PaymentResult:
        # Process credit card
        return PaymentResult(success=True)
    
    def supports_refund(self) -> bool:
        return True
    
    def refund(self, amount: Decimal) -> RefundResult:
        return RefundResult(success=True)

class CashOnDelivery(PaymentMethod):
    def pay(self, amount: Decimal) -> PaymentResult:
        # Mark as COD
        return PaymentResult(success=True, is_cod=True)
    
    def supports_refund(self) -> bool:
        return False  # No refund for COD until delivered

# Client code works with any PaymentMethod
def process_order(order: Order, payment: PaymentMethod):
    result = payment.pay(order.total)
    if result.success:
        order.mark_as_paid()
```

---

## I - Interface Segregation Principle

> Clients should not depend on interfaces they don't use.

### ‚ùå Fat Interface

```python
class Worker(ABC):
    @abstractmethod
    def work(self):
        pass
    
    @abstractmethod
    def eat(self):
        pass
    
    @abstractmethod
    def sleep(self):
        pass
    
    @abstractmethod
    def attend_meeting(self):
        pass
    
    @abstractmethod
    def write_report(self):
        pass
```

### ‚úÖ Segregated Interfaces

```python
class Workable(ABC):
    @abstractmethod
    def work(self):
        pass

class Feedable(ABC):
    @abstractmethod
    def eat(self):
        pass

class Sleepable(ABC):
    @abstractmethod
    def sleep(self):
        pass

class Manageable(ABC):
    @abstractmethod
    def attend_meeting(self):
        pass
    
    @abstractmethod
    def write_report(self):
        pass

# Human employee implements all
class Employee(Workable, Feedable, Sleepable, Manageable):
    def work(self):
        print("Working on tasks")
    
    def eat(self):
        print("Having lunch")
    
    def sleep(self):
        print("Sleeping at night")
    
    def attend_meeting(self):
        print("In meeting")
    
    def write_report(self):
        print("Writing report")

# Robot only implements what it can do
class Robot(Workable):
    def work(self):
        print("Processing tasks 24/7")
```

### ‚úÖ E-commerce Example

```python
# Instead of one huge OrderService interface
class OrderReader(ABC):
    @abstractmethod
    def find_by_id(self, order_id: UUID) -> Order:
        pass
    
    @abstractmethod
    def find_by_customer(self, customer_id: UUID) -> List[Order]:
        pass

class OrderWriter(ABC):
    @abstractmethod
    def save(self, order: Order) -> None:
        pass
    
    @abstractmethod
    def update(self, order: Order) -> None:
        pass

class OrderCanceller(ABC):
    @abstractmethod
    def cancel(self, order_id: UUID, reason: str) -> None:
        pass

# Services can depend on only what they need
class OrderDisplayService:
    def __init__(self, reader: OrderReader):  # Only needs read
        self.reader = reader

class CheckoutService:
    def __init__(self, writer: OrderWriter):  # Only needs write
        self.writer = writer
```

---

## D - Dependency Inversion Principle

> Depend on abstractions, not concretions.

### ‚ùå Tight Coupling

```python
class OrderService:
    def __init__(self):
        self.db = PostgreSQLDatabase()  # Directly depends on implementation
        self.payment = StripePayment()
        self.email = SendGridEmail()
```

### ‚úÖ Dependency Injection

```python
# Abstractions
class Database(ABC):
    @abstractmethod
    def save(self, entity: Any) -> None:
        pass

class PaymentGateway(ABC):
    @abstractmethod
    def charge(self, amount: Decimal) -> PaymentResult:
        pass

class EmailService(ABC):
    @abstractmethod
    def send(self, to: str, subject: str, body: str) -> None:
        pass

# Implementations
class PostgreSQLDatabase(Database):
    def save(self, entity: Any) -> None:
        print("Saving to PostgreSQL")

class StripePaymentGateway(PaymentGateway):
    def charge(self, amount: Decimal) -> PaymentResult:
        print("Charging via Stripe")
        return PaymentResult(success=True)

# Service depends on abstractions
class OrderService:
    def __init__(
        self,
        database: Database,
        payment: PaymentGateway,
        email: EmailService
    ):
        self.database = database
        self.payment = payment
        self.email = email
    
    def place_order(self, order: Order) -> None:
        self.payment.charge(order.total)
        self.database.save(order)
        self.email.send(
            order.customer.email,
            "Order Confirmed",
            f"Your order {order.id} is confirmed"
        )

# Easy to swap implementations
service = OrderService(
    database=PostgreSQLDatabase(),
    payment=StripePaymentGateway(),
    email=SendGridEmailService()
)

# Easy to test with mocks
test_service = OrderService(
    database=MockDatabase(),
    payment=MockPayment(),
    email=MockEmail()
)
```

## SOLID Summary

| Principle | One-liner | Benefit |
|-----------|-----------|---------|
| **S**ingle Responsibility | One reason to change | Easier maintenance |
| **O**pen/Closed | Extend without modifying | Safer changes |
| **L**iskov Substitution | Subtypes are interchangeable | Reliable polymorphism |
| **I**nterface Segregation | Small, focused interfaces | Less coupling |
| **D**ependency Inversion | Depend on abstractions | Flexible, testable |

---

## üéØ Quick Decision Guide

When designing classes, ask yourself:

<Steps>
  <Step title="Single Responsibility Check">
    **Question**: Does this class have only one reason to change?
    
    **Red Flag**: Class name contains "Manager", "Handler", "Utils", "Helper"
    
    **Fix**: Extract each responsibility into its own class
  </Step>
  <Step title="Open/Closed Check">
    **Question**: Can I add new behavior without modifying existing code?
    
    **Red Flag**: Long if-elif chains based on type
    
    **Fix**: Use polymorphism, Strategy pattern, or plugin architecture
  </Step>
  <Step title="Liskov Substitution Check">
    **Question**: Can I use any subtype wherever the parent is expected?
    
    **Red Flag**: Type checking before method calls, "not implemented" exceptions
    
    **Fix**: Redesign hierarchy or use composition instead
  </Step>
  <Step title="Interface Segregation Check">
    **Question**: Does every implementer need ALL methods in the interface?
    
    **Red Flag**: Empty stub implementations, methods throwing "not supported"
    
    **Fix**: Split into smaller, focused interfaces
  </Step>
  <Step title="Dependency Inversion Check">
    **Question**: Does this class depend on abstractions, not concretions?
    
    **Red Flag**: Using `new` or direct instantiation of dependencies
    
    **Fix**: Inject dependencies through constructor/parameters
  </Step>
</Steps>

---

## üí° Interview Tips

<AccordionGroup>
  <Accordion title="How to Demonstrate SOLID" icon="star">
    During LLD interviews, explicitly mention when you're applying SOLID:
    
    - *"I'm separating payment processing into its own class for Single Responsibility"*
    - *"Using an interface here so we can add new payment methods without modifying existing code - that's Open/Closed"*
    - *"I'll inject the database as a dependency so it's easy to test"*
  </Accordion>
  
  <Accordion title="When SOLID is Overkill" icon="triangle-exclamation">
    SOLID adds complexity. Don't apply it to:
    - Simple scripts or one-off utilities
    - Classes with only 1-2 methods
    - Early prototypes (refactor later)
    
    Apply SOLID when you expect:
    - Multiple developers
    - Long-term maintenance
    - Frequent changes/extensions
  </Accordion>
  
  <Accordion title="Testing Benefits" icon="flask">
    SOLID code is easy to test:
    
    ```python
    # With DIP, testing is trivial:
    def test_order_service():
        mock_db = MockDatabase()
        mock_email = MockEmailService()
        service = OrderService(mock_db, mock_email)
        
        service.place_order(test_order)
        
        assert mock_db.save_called
        assert mock_email.send_called
    ```
  </Accordion>
</AccordionGroup>

<Tip>
**Remember**: SOLID principles are guidelines, not rules. Apply them where they add value. Over-engineering is also a problem! The goal is clean, maintainable code - not perfect adherence to principles.
</Tip>
