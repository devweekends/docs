---
title: "Case Study: Parking Lot System"
description: "Complete low-level design for a multi-level parking lot system"
icon: "square-parking"
---

## Problem Statement

Design a parking lot system that can:
- Handle multiple floors and different vehicle types
- Track available and occupied spots
- Calculate parking fees based on duration
- Support multiple entry/exit points

## Step 1: Clarify Requirements

### Functional Requirements
- Park vehicles of different types (car, motorcycle, truck)
- Assign the nearest available spot to a vehicle
- Calculate fees based on vehicle type and duration
- Support multiple payment methods
- Display available spots per floor

### Non-Functional Requirements
- Handle concurrent entry/exit
- Fast spot lookup (O(1) for availability check)
- Scalable to multiple parking lots

## Step 2: Identify Core Objects

<CardGroup cols={3}>
  <Card title="Vehicles" icon="car">
    Car, Motorcycle, Truck
  </Card>
  <Card title="Parking Spots" icon="square">
    Compact, Regular, Large
  </Card>
  <Card title="Infrastructure" icon="building">
    ParkingLot, Floor, Entry/Exit
  </Card>
</CardGroup>

## Step 3: Class Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                        ParkingLot                           │
├─────────────────────────────────────────────────────────────┤
│ - id: UUID                                                  │
│ - name: String                                              │
│ - floors: List<Floor>                                       │
│ - entryPanels: List<EntryPanel>                            │
│ - exitPanels: List<ExitPanel>                              │
├─────────────────────────────────────────────────────────────┤
│ + getAvailableSpots(vehicleType): int                      │
│ + parkVehicle(vehicle): ParkingTicket                      │
│ + unparkVehicle(ticket): Payment                           │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ 1..*
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                          Floor                              │
├─────────────────────────────────────────────────────────────┤
│ - floorNumber: int                                         │
│ - spots: Dict[SpotType, List<ParkingSpot>]                 │
├─────────────────────────────────────────────────────────────┤
│ + getAvailableSpots(spotType): List<ParkingSpot>           │
│ + findNearestSpot(spotType): ParkingSpot                   │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ 1..*
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                       ParkingSpot                           │
├─────────────────────────────────────────────────────────────┤
│ - id: UUID                                                  │
│ - spotNumber: String                                        │
│ - spotType: SpotType                                        │
│ - isAvailable: bool                                         │
│ - vehicle: Vehicle                                          │
├─────────────────────────────────────────────────────────────┤
│ + assignVehicle(vehicle): bool                             │
│ + removeVehicle(): Vehicle                                 │
└─────────────────────────────────────────────────────────────┘
```

## Step 4: Implementation

### Enums and Constants

```python
from enum import Enum
from datetime import datetime
from typing import Optional, Dict, List
from dataclasses import dataclass
import uuid

class VehicleType(Enum):
    MOTORCYCLE = 1
    CAR = 2
    TRUCK = 3

class SpotType(Enum):
    COMPACT = 1     # Fits motorcycle, car
    REGULAR = 2     # Fits motorcycle, car
    LARGE = 3       # Fits all vehicles

class TicketStatus(Enum):
    ACTIVE = 1
    PAID = 2
    LOST = 3

# Pricing per hour
HOURLY_RATES = {
    VehicleType.MOTORCYCLE: 1.0,
    VehicleType.CAR: 2.0,
    VehicleType.TRUCK: 4.0
}
```

### Vehicle Classes

```python
class Vehicle:
    def __init__(self, license_plate: str, vehicle_type: VehicleType):
        self.license_plate = license_plate
        self.vehicle_type = vehicle_type
    
    def can_fit_in(self, spot_type: SpotType) -> bool:
        """Check if vehicle fits in spot type"""
        raise NotImplementedError

class Motorcycle(Vehicle):
    def __init__(self, license_plate: str):
        super().__init__(license_plate, VehicleType.MOTORCYCLE)
    
    def can_fit_in(self, spot_type: SpotType) -> bool:
        return True  # Motorcycle fits anywhere

class Car(Vehicle):
    def __init__(self, license_plate: str):
        super().__init__(license_plate, VehicleType.CAR)
    
    def can_fit_in(self, spot_type: SpotType) -> bool:
        return spot_type in [SpotType.COMPACT, SpotType.REGULAR, SpotType.LARGE]

class Truck(Vehicle):
    def __init__(self, license_plate: str):
        super().__init__(license_plate, VehicleType.TRUCK)
    
    def can_fit_in(self, spot_type: SpotType) -> bool:
        return spot_type == SpotType.LARGE  # Only large spots
```

### Parking Spot

```python
class ParkingSpot:
    def __init__(self, spot_id: str, floor_number: int, spot_type: SpotType):
        self.id = spot_id
        self.floor_number = floor_number
        self.spot_type = spot_type
        self._vehicle: Optional[Vehicle] = None
        self._is_available = True
    
    @property
    def is_available(self) -> bool:
        return self._is_available
    
    def can_fit(self, vehicle: Vehicle) -> bool:
        """Check if vehicle can park here"""
        return self._is_available and vehicle.can_fit_in(self.spot_type)
    
    def assign_vehicle(self, vehicle: Vehicle) -> bool:
        """Park a vehicle in this spot"""
        if not self.can_fit(vehicle):
            return False
        
        self._vehicle = vehicle
        self._is_available = False
        return True
    
    def remove_vehicle(self) -> Optional[Vehicle]:
        """Remove vehicle from spot"""
        vehicle = self._vehicle
        self._vehicle = None
        self._is_available = True
        return vehicle
```

### Parking Ticket

```python
@dataclass
class ParkingTicket:
    id: str
    license_plate: str
    spot_id: str
    floor_number: int
    entry_time: datetime
    exit_time: Optional[datetime] = None
    status: TicketStatus = TicketStatus.ACTIVE
    
    @staticmethod
    def create(vehicle: Vehicle, spot: ParkingSpot) -> 'ParkingTicket':
        return ParkingTicket(
            id=str(uuid.uuid4()),
            license_plate=vehicle.license_plate,
            spot_id=spot.id,
            floor_number=spot.floor_number,
            entry_time=datetime.now()
        )
    
    def calculate_fee(self, vehicle_type: VehicleType) -> float:
        """Calculate parking fee based on duration"""
        if self.exit_time is None:
            self.exit_time = datetime.now()
        
        duration = self.exit_time - self.entry_time
        hours = max(1, int(duration.total_seconds() / 3600) + 1)  # Round up
        
        return hours * HOURLY_RATES[vehicle_type]
```

### Floor

```python
class Floor:
    def __init__(self, floor_number: int):
        self.floor_number = floor_number
        self.spots: Dict[SpotType, List[ParkingSpot]] = {
            SpotType.COMPACT: [],
            SpotType.REGULAR: [],
            SpotType.LARGE: []
        }
    
    def add_spot(self, spot: ParkingSpot):
        """Add a parking spot to this floor"""
        self.spots[spot.spot_type].append(spot)
    
    def get_available_count(self, spot_type: SpotType) -> int:
        """Get count of available spots of given type"""
        return sum(1 for spot in self.spots[spot_type] if spot.is_available)
    
    def find_available_spot(self, vehicle: Vehicle) -> Optional[ParkingSpot]:
        """Find first available spot that fits the vehicle"""
        # Try to find the smallest suitable spot
        for spot_type in SpotType:
            for spot in self.spots[spot_type]:
                if spot.can_fit(vehicle):
                    return spot
        return None
    
    def get_display_info(self) -> dict:
        """Get floor availability for display"""
        return {
            "floor": self.floor_number,
            "compact_available": self.get_available_count(SpotType.COMPACT),
            "regular_available": self.get_available_count(SpotType.REGULAR),
            "large_available": self.get_available_count(SpotType.LARGE)
        }
```

### Parking Lot

```python
import threading

class ParkingLot:
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self, name: str, num_floors: int):
        if hasattr(self, '_initialized'):
            return
        
        self.name = name
        self.floors: List[Floor] = []
        self.active_tickets: Dict[str, ParkingTicket] = {}  # ticket_id -> ticket
        self.vehicle_to_spot: Dict[str, ParkingSpot] = {}   # license -> spot
        self._lock = threading.Lock()
        self._initialized = True
        
        # Initialize floors
        for i in range(num_floors):
            self.floors.append(Floor(i + 1))
    
    def add_spots(self, floor_number: int, spot_type: SpotType, count: int):
        """Add parking spots to a floor"""
        floor = self.floors[floor_number - 1]
        for i in range(count):
            spot_id = f"F{floor_number}-{spot_type.name[0]}{i+1}"
            spot = ParkingSpot(spot_id, floor_number, spot_type)
            floor.add_spot(spot)
    
    def park_vehicle(self, vehicle: Vehicle) -> Optional[ParkingTicket]:
        """Park a vehicle and return ticket"""
        with self._lock:
            # Check if vehicle already parked
            if vehicle.license_plate in self.vehicle_to_spot:
                raise ValueError("Vehicle already parked")
            
            # Find available spot
            spot = self._find_available_spot(vehicle)
            if spot is None:
                return None  # No spot available
            
            # Assign vehicle to spot
            spot.assign_vehicle(vehicle)
            
            # Create ticket
            ticket = ParkingTicket.create(vehicle, spot)
            self.active_tickets[ticket.id] = ticket
            self.vehicle_to_spot[vehicle.license_plate] = spot
            
            return ticket
    
    def unpark_vehicle(self, ticket_id: str) -> Optional[float]:
        """Unpark vehicle and return fee"""
        with self._lock:
            ticket = self.active_tickets.get(ticket_id)
            if ticket is None or ticket.status != TicketStatus.ACTIVE:
                return None
            
            # Get spot and vehicle
            spot = self.vehicle_to_spot.get(ticket.license_plate)
            if spot is None:
                return None
            
            vehicle = spot.remove_vehicle()
            
            # Calculate fee
            fee = ticket.calculate_fee(vehicle.vehicle_type)
            ticket.status = TicketStatus.PAID
            
            # Cleanup
            del self.vehicle_to_spot[ticket.license_plate]
            
            return fee
    
    def _find_available_spot(self, vehicle: Vehicle) -> Optional[ParkingSpot]:
        """Find nearest available spot for vehicle"""
        for floor in self.floors:
            spot = floor.find_available_spot(vehicle)
            if spot:
                return spot
        return None
    
    def get_availability(self) -> List[dict]:
        """Get availability info for all floors"""
        return [floor.get_display_info() for floor in self.floors]
```

### Payment System

```python
class PaymentMethod(ABC):
    @abstractmethod
    def process(self, amount: float) -> bool:
        pass

class CashPayment(PaymentMethod):
    def process(self, amount: float) -> bool:
        print(f"Processing cash payment: ${amount:.2f}")
        return True

class CardPayment(PaymentMethod):
    def __init__(self, card_number: str):
        self.card_number = card_number
    
    def process(self, amount: float) -> bool:
        print(f"Processing card payment: ${amount:.2f}")
        return True

class PaymentProcessor:
    def process_payment(self, ticket_id: str, 
                       parking_lot: ParkingLot,
                       payment_method: PaymentMethod) -> bool:
        fee = parking_lot.unpark_vehicle(ticket_id)
        if fee is None:
            return False
        
        return payment_method.process(fee)
```

## Step 5: Usage Example

```python
# Create parking lot
parking_lot = ParkingLot("Downtown Parking", num_floors=3)

# Add spots to each floor
for floor in range(1, 4):
    parking_lot.add_spots(floor, SpotType.COMPACT, 10)
    parking_lot.add_spots(floor, SpotType.REGULAR, 20)
    parking_lot.add_spots(floor, SpotType.LARGE, 5)

# Park vehicles
car = Car("ABC-123")
motorcycle = Motorcycle("XYZ-789")
truck = Truck("TRK-001")

ticket1 = parking_lot.park_vehicle(car)
print(f"Car parked at: {ticket1.spot_id}")

ticket2 = parking_lot.park_vehicle(motorcycle)
print(f"Motorcycle parked at: {ticket2.spot_id}")

# Check availability
print(parking_lot.get_availability())

# Unpark and pay
import time
time.sleep(2)  # Simulate parking duration

processor = PaymentProcessor()
processor.process_payment(ticket1.id, parking_lot, CashPayment())
```

## Key Design Decisions

<AccordionGroup>
  <Accordion title="Why Singleton for ParkingLot?">
    In most real-world scenarios, there's only one parking lot instance per location. Singleton ensures consistent state and prevents duplicate instances.
  </Accordion>
  
  <Accordion title="Why Strategy Pattern for Payment?">
    Allows adding new payment methods (Apple Pay, UPI) without modifying existing code. Each payment method encapsulates its own logic.
  </Accordion>
  
  <Accordion title="Why Thread Locking?">
    Multiple entry/exit panels can operate simultaneously. Locking prevents race conditions when assigning the same spot to multiple vehicles.
  </Accordion>
</AccordionGroup>

<Tip>
**Interview Extension**: Be ready to discuss how you'd handle edge cases like lost tickets, reserved spots, monthly passes, or electric vehicle charging spots.
</Tip>
