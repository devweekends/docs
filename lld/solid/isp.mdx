---
title: "Interface Segregation Principle"
description: "Many small interfaces beat one giant interface - don't force unnecessary stuff!"
icon: "puzzle-piece"
---

## ğŸ§© The ISP Rule

> **"Clients should not be forced to depend on methods they don't use."**

Imagine a **Swiss Army knife** ğŸ”ª vs **specialized tools**:
- Swiss Army knife: Has everything, but each tool is mediocre
- Specialized tools: Each does one thing perfectly

ISP says: **Don't give a fish a bicycle interface!** ğŸŸğŸš²

<Tip>
**Simple Rule**: Split big interfaces into small, focused ones. Classes only implement what they need!
</Tip>

---

## ğŸš¨ The Problem: Fat Interfaces

### âŒ BAD: One Giant Interface

```python
from abc import ABC, abstractmethod

class Worker(ABC):
    """Every worker must do ALL of these... ğŸ˜°"""
    
    @abstractmethod
    def work(self):
        pass
    
    @abstractmethod
    def eat_lunch(self):
        pass
    
    @abstractmethod
    def attend_meeting(self):
        pass
    
    @abstractmethod
    def code(self):
        pass
    
    @abstractmethod
    def design(self):
        pass
    
    @abstractmethod
    def manage_team(self):
        pass

class Developer(Worker):
    def work(self):
        print("Writing code...")
    
    def eat_lunch(self):
        print("Eating pizza...")
    
    def attend_meeting(self):
        print("In standup...")
    
    def code(self):
        print("Coding Python...")
    
    def design(self):
        # ğŸ˜° Developer doesn't design UI!
        raise NotImplementedError("I'm not a designer!")
    
    def manage_team(self):
        # ğŸ˜° Developer doesn't manage!
        raise NotImplementedError("I'm not a manager!")

class Robot(Worker):
    def work(self):
        print("Processing...")
    
    def eat_lunch(self):
        # ğŸ˜° Robots don't eat!
        raise NotImplementedError("I don't eat!")
    
    def attend_meeting(self):
        # ğŸ˜° Robots don't attend meetings!
        raise NotImplementedError("I don't attend meetings!")
    
    def code(self):
        print("Auto-generating code...")
    
    def design(self):
        raise NotImplementedError("I don't design!")
    
    def manage_team(self):
        raise NotImplementedError("I don't manage!")

# ğŸš¨ Most methods throw exceptions - BAD!
```

---

### âœ… GOOD: Small, Focused Interfaces

```python
from abc import ABC, abstractmethod

# Split into small, focused interfaces
class Workable(ABC):
    @abstractmethod
    def work(self):
        pass

class Eatable(ABC):
    @abstractmethod
    def eat(self):
        pass

class Meetable(ABC):
    @abstractmethod
    def attend_meeting(self):
        pass

class Codeable(ABC):
    @abstractmethod
    def code(self):
        pass

class Designable(ABC):
    @abstractmethod
    def design(self):
        pass

class Manageable(ABC):
    @abstractmethod
    def manage_team(self):
        pass

# Now each class implements ONLY what it needs!

class Developer(Workable, Eatable, Meetable, Codeable):
    def work(self):
        print("ğŸ’» Working on features...")
    
    def eat(self):
        print("ğŸ• Eating pizza...")
    
    def attend_meeting(self):
        print("ğŸ—£ï¸ In standup...")
    
    def code(self):
        print("ğŸ Writing Python...")

class Designer(Workable, Eatable, Meetable, Designable):
    def work(self):
        print("ğŸ¨ Creating mockups...")
    
    def eat(self):
        print("ğŸ¥— Eating salad...")
    
    def attend_meeting(self):
        print("ğŸ—£ï¸ In design review...")
    
    def design(self):
        print("ğŸ–Œï¸ Designing UI...")

class Manager(Workable, Eatable, Meetable, Manageable):
    def work(self):
        print("ğŸ“Š Planning sprints...")
    
    def eat(self):
        print("â˜• Coffee meeting...")
    
    def attend_meeting(self):
        print("ğŸ—£ï¸ Leading meeting...")
    
    def manage_team(self):
        print("ğŸ‘¥ Managing team...")

class Robot(Workable, Codeable):
    """Robot only works and codes - no eating or meetings!"""
    
    def work(self):
        print("ğŸ¤– Processing tasks...")
    
    def code(self):
        print("ğŸ¤– Auto-generating code...")

# ğŸ‰ No NotImplementedError needed!
# Each class only has methods it actually uses
```

---

## ğŸ–¨ï¸ Classic Example: Printer Interfaces

### âŒ BAD: Multifunction Monster

```python
class MultifunctionDevice(ABC):
    """All devices must do EVERYTHING!"""
    
    @abstractmethod
    def print_doc(self, document):
        pass
    
    @abstractmethod
    def scan_doc(self, document):
        pass
    
    @abstractmethod
    def fax_doc(self, document):
        pass
    
    @abstractmethod
    def copy_doc(self, document):
        pass
    
    @abstractmethod
    def email_doc(self, document, email):
        pass

class OldPrinter(MultifunctionDevice):
    """Old printer can only print! ğŸ˜¢"""
    
    def print_doc(self, document):
        print(f"ğŸ–¨ï¸ Printing: {document}")
    
    def scan_doc(self, document):
        raise Exception("Can't scan!")  # ğŸ˜°
    
    def fax_doc(self, document):
        raise Exception("Can't fax!")  # ğŸ˜°
    
    def copy_doc(self, document):
        raise Exception("Can't copy!")  # ğŸ˜°
    
    def email_doc(self, document, email):
        raise Exception("Can't email!")  # ğŸ˜°
```

### âœ… GOOD: Segregated Interfaces

```python
from abc import ABC, abstractmethod

class Printer(ABC):
    @abstractmethod
    def print_doc(self, document):
        pass

class Scanner(ABC):
    @abstractmethod
    def scan_doc(self) -> str:
        pass

class Fax(ABC):
    @abstractmethod
    def fax_doc(self, document, number):
        pass

class Copier(ABC):
    @abstractmethod
    def copy_doc(self, document) -> str:
        pass

class Emailer(ABC):
    @abstractmethod
    def email_doc(self, document, email):
        pass

# Simple printer - only prints!
class BasicPrinter(Printer):
    def print_doc(self, document):
        print(f"ğŸ–¨ï¸ Printing: {document}")

# Scanner - only scans!
class BasicScanner(Scanner):
    def scan_doc(self):
        return "ğŸ“„ Scanned document content"

# All-in-one for those who need everything
class AllInOnePrinter(Printer, Scanner, Copier, Fax, Emailer):
    def print_doc(self, document):
        print(f"ğŸ–¨ï¸ Printing: {document}")
    
    def scan_doc(self):
        print("ğŸ“¸ Scanning...")
        return "Scanned content"
    
    def copy_doc(self, document):
        print("ğŸ“‹ Copying...")
        return document
    
    def fax_doc(self, document, number):
        print(f"ğŸ“  Faxing to {number}...")
    
    def email_doc(self, document, email):
        print(f"ğŸ“§ Emailing to {email}...")

# Functions request only what they need
def print_report(printer: Printer, report):
    printer.print_doc(report)

def scan_and_save(scanner: Scanner):
    content = scanner.scan_doc()
    return content

# Works with any device that can print!
print_report(BasicPrinter(), "Sales Report")
print_report(AllInOnePrinter(), "Sales Report")

# Works with any device that can scan!
scan_and_save(AllInOnePrinter())
# scan_and_save(BasicPrinter())  # âŒ Type error - BasicPrinter can't scan
```

---

## ğŸ® Real Example: Game Characters

```python
from abc import ABC, abstractmethod

# Segregated ability interfaces
class Movable(ABC):
    @abstractmethod
    def move(self, direction):
        pass

class Attackable(ABC):
    @abstractmethod
    def attack(self, target):
        pass

class Healable(ABC):
    @abstractmethod
    def heal(self, target):
        pass

class Flyable(ABC):
    @abstractmethod
    def fly(self):
        pass

class Swimmable(ABC):
    @abstractmethod
    def swim(self):
        pass

class Castable(ABC):
    @abstractmethod
    def cast_spell(self, spell, target):
        pass

# Characters implement only what they can do!

class Warrior(Movable, Attackable):
    def move(self, direction):
        print(f"âš”ï¸ Warrior walking {direction}")
    
    def attack(self, target):
        print(f"âš”ï¸ Warrior slashes {target}!")

class Mage(Movable, Attackable, Castable, Healable):
    def move(self, direction):
        print(f"ğŸ§™ Mage walking {direction}")
    
    def attack(self, target):
        print(f"ğŸ§™ Mage hits {target} with staff!")
    
    def cast_spell(self, spell, target):
        print(f"âœ¨ Mage casts {spell} on {target}!")
    
    def heal(self, target):
        print(f"ğŸ’š Mage heals {target}!")

class Dragon(Movable, Attackable, Flyable):
    def move(self, direction):
        print(f"ğŸ‰ Dragon stomping {direction}")
    
    def attack(self, target):
        print(f"ğŸ‰ Dragon breathes fire on {target}!")
    
    def fly(self):
        print("ğŸ‰ Dragon soars into the sky!")

class Fish(Movable, Swimmable):
    def move(self, direction):
        print(f"ğŸŸ Fish swimming {direction}")
    
    def swim(self):
        print("ğŸŸ Fish diving deep!")

class Turret(Attackable):  # Can't move!
    def attack(self, target):
        print(f"ğŸ”« Turret fires at {target}!")

# Game engine uses specific interfaces
def process_flying_units(units: list[Flyable]):
    for unit in units:
        unit.fly()

def process_attackers(units: list[Attackable]):
    for unit in units:
        unit.attack("enemy")

# Usage
flying_units = [Dragon()]  # Only things that can fly
process_flying_units(flying_units)

attackers = [Warrior(), Mage(), Dragon(), Turret()]  # All attackers
process_attackers(attackers)
```

---

## ğŸ“± Real Example: Mobile App Features

```python
from abc import ABC, abstractmethod

# Feature interfaces
class Photographable(ABC):
    @abstractmethod
    def take_photo(self):
        pass

class Callable(ABC):
    @abstractmethod
    def make_call(self, number):
        pass

class Textable(ABC):
    @abstractmethod
    def send_text(self, number, message):
        pass

class GPSEnabled(ABC):
    @abstractmethod
    def get_location(self):
        pass

class BluetoothEnabled(ABC):
    @abstractmethod
    def connect_bluetooth(self, device):
        pass

class NFCEnabled(ABC):
    @abstractmethod
    def nfc_pay(self, amount):
        pass

# Different devices implement different features

class BasicPhone(Callable, Textable):
    """Old flip phone - calls and texts only!"""
    
    def make_call(self, number):
        print(f"ğŸ“ Calling {number}...")
    
    def send_text(self, number, message):
        print(f"ğŸ’¬ Texting {number}: {message}")

class SmartPhone(Callable, Textable, Photographable, GPSEnabled, BluetoothEnabled, NFCEnabled):
    """Modern smartphone - has everything!"""
    
    def make_call(self, number):
        print(f"ğŸ“± Video calling {number}...")
    
    def send_text(self, number, message):
        print(f"ğŸ’¬ iMessaging {number}: {message}")
    
    def take_photo(self):
        print("ğŸ“¸ Taking high-res photo!")
    
    def get_location(self):
        return {"lat": 40.7128, "lng": -74.0060}
    
    def connect_bluetooth(self, device):
        print(f"ğŸ”µ Connecting to {device}...")
    
    def nfc_pay(self, amount):
        print(f"ğŸ’³ Paying ${amount} via NFC...")

class Camera(Photographable):
    """Dedicated camera - only takes photos!"""
    
    def take_photo(self):
        print("ğŸ“· Taking professional photo!")

class GPSDevice(GPSEnabled):
    """Dedicated GPS - only navigation!"""
    
    def get_location(self):
        return {"lat": 40.7128, "lng": -74.0060}

# Functions request only what they need
def take_photos(devices: list[Photographable]):
    for device in devices:
        device.take_photo()

def navigate(device: GPSEnabled):
    loc = device.get_location()
    print(f"ğŸ“ You are at {loc}")

# All of these work!
take_photos([SmartPhone(), Camera()])  # âœ…
navigate(SmartPhone())  # âœ…
navigate(GPSDevice())   # âœ…
# navigate(BasicPhone())  # âŒ Type error - BasicPhone has no GPS
```

---

## ğŸ”„ How to Apply ISP

<Steps>
  <Step title="Identify the fat interface">
    Look for interfaces with many methods that some implementations don't need
  </Step>
  <Step title="Group related methods">
    Which methods are always used together?
  </Step>
  <Step title="Create focused interfaces">
    One interface per group of related methods
  </Step>
  <Step title="Update implementations">
    Each class implements only the interfaces it needs
  </Step>
</Steps>

---

## ğŸ§ª Practice Exercise

<Accordion title="Challenge: Fix the Vehicle Interface" icon="dumbbell">

This interface is too fat. Split it!

```python
class Vehicle(ABC):
    @abstractmethod
    def start_engine(self):
        pass
    
    @abstractmethod
    def stop_engine(self):
        pass
    
    @abstractmethod
    def accelerate(self):
        pass
    
    @abstractmethod
    def brake(self):
        pass
    
    @abstractmethod
    def fly(self):
        pass
    
    @abstractmethod
    def sail(self):
        pass
    
    @abstractmethod
    def submerge(self):
        pass
    
    @abstractmethod
    def refuel(self):
        pass
    
    @abstractmethod
    def recharge(self):
        pass

class Car(Vehicle):
    def fly(self):
        raise NotImplementedError("Cars can't fly!")
    
    def sail(self):
        raise NotImplementedError("Cars can't sail!")
    
    def submerge(self):
        raise NotImplementedError("Cars can't submerge!")
    
    def recharge(self):
        raise NotImplementedError("Gas cars don't recharge!")
    
    # ... lots of NotImplementedError

class Bicycle(Vehicle):
    def start_engine(self):
        raise NotImplementedError("Bicycles have no engine!")
    # ... even more NotImplementedError! ğŸ˜±
```

<details>
<summary>Click for Solution</summary>

```python
from abc import ABC, abstractmethod

# Core movement interfaces
class Driveable(ABC):
    @abstractmethod
    def accelerate(self):
        pass
    
    @abstractmethod
    def brake(self):
        pass

class Flyable(ABC):
    @abstractmethod
    def take_off(self):
        pass
    
    @abstractmethod
    def land(self):
        pass

class Sailable(ABC):
    @abstractmethod
    def sail(self):
        pass

class Submersible(ABC):
    @abstractmethod
    def submerge(self):
        pass
    
    @abstractmethod
    def surface(self):
        pass

# Power interfaces
class EngineVehicle(ABC):
    @abstractmethod
    def start_engine(self):
        pass
    
    @abstractmethod
    def stop_engine(self):
        pass

class FuelPowered(ABC):
    @abstractmethod
    def refuel(self):
        pass

class ElectricPowered(ABC):
    @abstractmethod
    def recharge(self):
        pass

class HumanPowered(ABC):
    @abstractmethod
    def pedal(self):
        pass

# Now vehicles implement only what they need!

class Car(EngineVehicle, FuelPowered, Driveable):
    def start_engine(self):
        print("ğŸš— Vroom!")
    
    def stop_engine(self):
        print("ğŸš— Engine off")
    
    def accelerate(self):
        print("ğŸš— Speeding up!")
    
    def brake(self):
        print("ğŸš— Slowing down!")
    
    def refuel(self):
        print("â›½ Filling up gas...")

class ElectricCar(EngineVehicle, ElectricPowered, Driveable):
    def start_engine(self):
        print("âš¡ Silently starting...")
    
    def stop_engine(self):
        print("âš¡ Powering down...")
    
    def accelerate(self):
        print("âš¡ Instant torque!")
    
    def brake(self):
        print("âš¡ Regenerative braking!")
    
    def recharge(self):
        print("ğŸ”Œ Charging battery...")

class Bicycle(HumanPowered, Driveable):
    def pedal(self):
        print("ğŸš² Pedaling!")
    
    def accelerate(self):
        print("ğŸš² Pedaling faster!")
    
    def brake(self):
        print("ğŸš² Squeezing brakes!")

class Airplane(EngineVehicle, FuelPowered, Flyable, Driveable):
    def start_engine(self):
        print("âœˆï¸ Engines starting!")
    
    def stop_engine(self):
        print("âœˆï¸ Engines stopping!")
    
    def take_off(self):
        print("âœˆï¸ Taking off!")
    
    def land(self):
        print("âœˆï¸ Landing!")
    
    def accelerate(self):
        print("âœˆï¸ Speeding up runway!")
    
    def brake(self):
        print("âœˆï¸ Deploying air brakes!")
    
    def refuel(self):
        print("â›½ Refueling jet fuel...")

class Submarine(EngineVehicle, FuelPowered, Submersible):
    def start_engine(self):
        print("ğŸš¢ Submarine engines on!")
    
    def stop_engine(self):
        print("ğŸš¢ Engines silent!")
    
    def submerge(self):
        print("ğŸš¢ Diving!")
    
    def surface(self):
        print("ğŸš¢ Surfacing!")
    
    def refuel(self):
        print("â›½ Refueling nuclear reactor...")

# ğŸ‰ No NotImplementedError anywhere!
```
</details>
</Accordion>

---

## ğŸ“ Key Takeaways

<CardGroup cols={2}>
  <Card title="Small > Big" icon="minimize">
    Many small interfaces beat one big one
  </Card>
  <Card title="No Forced Methods" icon="ban">
    Classes shouldn't implement what they don't need
  </Card>
  <Card title="Combine as Needed" icon="object-group">
    Classes can implement multiple interfaces
  </Card>
  <Card title="Client-Focused" icon="user">
    Interfaces should fit what clients actually need
  </Card>
</CardGroup>

---

## ğŸƒ Next: Dependency Inversion Principle

Let's learn the final SOLID principle - how to depend on abstractions!

<Card title="Continue to Dependency Inversion â†’" icon="arrow-right" href="/lld/solid/dip">
  Learn how to make your code flexible by depending on abstractions!
</Card>
