---
title: "Encapsulation"
description: "Learn to protect your data like a treasure chest with a lock"
icon: "box"
---

## üì¶ What is Encapsulation?

Imagine you have a **piggy bank** üê∑. You put money IN through a small slot, and you can check how much is inside, but you can't just reach in and grab money whenever you want. The piggy bank **protects** your money.

**Encapsulation** works the same way:
- Put data (like money) inside an object
- Control HOW that data can be accessed or changed
- Protect the data from being messed up accidentally

<Tip>
**Simple Definition**: Encapsulation = **Wrapping data + methods together** and **controlling access** to them.
</Tip>

---

## üèß Real-World Example: Bank Account

Think about your bank account:
- You can **deposit** money ‚úÖ
- You can **withdraw** money (if you have enough) ‚úÖ
- You can **check** your balance ‚úÖ
- You CANNOT directly change your balance to a million dollars ‚ùå

The bank **protects** your balance and only lets you change it through proper methods!

### ‚ùå Bad Code (No Protection)

```python
class BankAccount:
    def __init__(self):
        self.balance = 0  # Anyone can change this directly!

# The problem:
account = BankAccount()
account.balance = 1000000  # üò± Hacked! Changed directly!
account.balance = -500     # üò± Negative balance? That's not right!
```

### ‚úÖ Good Code (With Encapsulation)

```python
class BankAccount:
    def __init__(self, owner_name):
        self.owner = owner_name
        self.__balance = 0  # üîí Private! (notice the __)
    
    # ‚úÖ Controlled way to add money
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            print(f"‚úÖ Deposited ${amount}. New balance: ${self.__balance}")
        else:
            print("‚ùå Amount must be positive!")
    
    # ‚úÖ Controlled way to take money
    def withdraw(self, amount):
        if amount > 0 and amount <= self.__balance:
            self.__balance -= amount
            print(f"‚úÖ Withdrew ${amount}. New balance: ${self.__balance}")
        else:
            print("‚ùå Invalid amount or insufficient funds!")
    
    # ‚úÖ Safe way to check balance
    def get_balance(self):
        return self.__balance

# Now try to hack it!
account = BankAccount("Alice")
account.deposit(500)           # ‚úÖ Works! Balance is 500
account.withdraw(100)          # ‚úÖ Works! Balance is 400
account.withdraw(1000)         # ‚ùå Blocked! Not enough money
print(account.get_balance())   # ‚úÖ Shows 400

# Try to hack directly?
account.__balance = 1000000    # ü§î Seems to work...
print(account.get_balance())   # Still 400! Python protected it! üõ°Ô∏è
```

---

## üîê Public, Private, and Protected

In OOP, we have three levels of access:

| Type | Symbol | Who Can Access? | Real-World Example |
|------|--------|-----------------|-------------------|
| **Public** | `name` | Everyone | Your name on your shirt - everyone can see |
| **Protected** | `_name` | Class + Children | Family secrets - only family knows |
| **Private** | `__name` | Only this class | Your diary with a lock - only YOU can read |

```python
class Student:
    def __init__(self, name, grade, diary_secret):
        self.name = name              # üì¢ Public: Everyone can see
        self._grade = grade           # üè† Protected: For class and children
        self.__diary = diary_secret   # üîí Private: Only for this class
    
    def read_diary(self, password):
        if password == "secret123":
            return self.__diary
        return "Wrong password! üîê"

student = Student("Bob", "A", "I like pizza")
print(student.name)           # ‚úÖ Works: Bob
print(student._grade)         # ‚ö†Ô∏è Works but shouldn't access: A
print(student.__diary)        # ‚ùå Error! Can't access private
print(student.read_diary("secret123"))  # ‚úÖ Works: I like pizza
```

---

## üéÆ Fun Example: Video Game Character

Let's create a game character with proper encapsulation:

```python
class GameCharacter:
    def __init__(self, name, character_class):
        # Public - everyone needs to see
        self.name = name
        self.character_class = character_class
        
        # Private - protect from cheating!
        self.__health = 100
        self.__max_health = 100
        self.__level = 1
        self.__experience = 0
        self.__gold = 50
    
    # üíä Take damage (controlled)
    def take_damage(self, damage):
        if damage < 0:
            print("Nice try, cheater! üôÖ")
            return
        
        self.__health -= damage
        if self.__health <= 0:
            self.__health = 0
            print(f"üíÄ {self.name} has been defeated!")
        else:
            print(f"üò£ {self.name} took {damage} damage! Health: {self.__health}")
    
    # üíö Heal (controlled)
    def heal(self, amount):
        if amount < 0:
            return
        
        self.__health = min(self.__health + amount, self.__max_health)
        print(f"üíö {self.name} healed! Health: {self.__health}")
    
    # ‚≠ê Gain XP (controlled leveling)
    def gain_experience(self, xp):
        if xp < 0:
            return
        
        self.__experience += xp
        print(f"‚≠ê +{xp} XP!")
        
        # Level up every 100 XP
        while self.__experience >= 100:
            self.__experience -= 100
            self.__level += 1
            self.__max_health += 20
            self.__health = self.__max_health
            print(f"üéâ LEVEL UP! Now level {self.__level}!")
    
    # üí∞ Gold management
    def earn_gold(self, amount):
        if amount > 0:
            self.__gold += amount
            print(f"üí∞ +{amount} gold! Total: {self.__gold}")
    
    def spend_gold(self, amount):
        if amount <= self.__gold:
            self.__gold -= amount
            print(f"üí∏ Spent {amount} gold. Remaining: {self.__gold}")
            return True
        print("‚ùå Not enough gold!")
        return False
    
    # üìä Show stats (read-only access)
    def show_stats(self):
        print(f"""
        ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
        ‚ïë  {self.name} the {self.character_class}
        ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
        ‚ïë  ‚ù§Ô∏è  Health: {self.__health}/{self.__max_health}
        ‚ïë  ‚≠ê Level:  {self.__level}
        ‚ïë  üìä XP:     {self.__experience}/100
        ‚ïë  üí∞ Gold:   {self.__gold}
        ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        """)

# Let's play!
hero = GameCharacter("Luna", "Mage")
hero.show_stats()

hero.take_damage(30)
hero.heal(10)
hero.gain_experience(150)  # Should level up!
hero.earn_gold(100)
hero.show_stats()

# Try to cheat?
hero.__health = 9999      # Won't work! 
hero.__gold = 999999      # Won't work!
hero.show_stats()         # Still the same real values!
```

---

## üè† Getters and Setters (Properties)

Sometimes we want to:
- **Read** a private value (Getter)
- **Change** a private value with rules (Setter)

Python has a beautiful way to do this with `@property`:

```python
class Temperature:
    def __init__(self):
        self.__celsius = 0
    
    # GETTER - Read the temperature
    @property
    def celsius(self):
        return self.__celsius
    
    # SETTER - Change temperature with validation
    @celsius.setter
    def celsius(self, value):
        if value < -273.15:  # Absolute zero
            print("‚ùå Temperature can't be below absolute zero!")
        else:
            self.__celsius = value
    
    # Bonus: Auto-calculate Fahrenheit!
    @property
    def fahrenheit(self):
        return (self.__celsius * 9/5) + 32

# Use it like a normal attribute!
temp = Temperature()
temp.celsius = 25           # Uses setter (validated!)
print(temp.celsius)         # Uses getter: 25
print(temp.fahrenheit)      # Auto-calculated: 77.0

temp.celsius = -300         # ‚ùå Blocked! Below absolute zero
print(temp.celsius)         # Still 25
```

---

## ‚úÖ Benefits of Encapsulation

<CardGroup cols={2}>
  <Card title="üõ°Ô∏è Data Protection" icon="shield">
    Prevent invalid or dangerous changes to your data
  </Card>
  <Card title="üîß Easy Maintenance" icon="wrench">
    Change internal code without breaking other parts
  </Card>
  <Card title="üêõ Fewer Bugs" icon="bug">
    Controlled access means fewer places for bugs to hide
  </Card>
  <Card title="üìñ Clear Interface" icon="book">
    Users know exactly how to interact with your object
  </Card>
</CardGroup>

---

## üß™ Practice Exercise

<Accordion title="Challenge: Create a Password Manager" icon="lock">
Try creating a PasswordManager class that:
1. Stores passwords privately (you can't see them directly)
2. Has a method to add a password for a website
3. Has a method to get a password (with master password check)
4. Never allows password to be shorter than 8 characters

```python
class PasswordManager:
    def __init__(self, master_password):
        self.__master = master_password
        self.__passwords = {}  # {website: password}
    
    def add_password(self, website, password):
        # TODO: Check if password is at least 8 characters
        # TODO: Store in __passwords dictionary
        pass
    
    def get_password(self, website, master_password):
        # TODO: Check master password first
        # TODO: Return the password if correct, else "Access Denied"
        pass

# Test it:
pm = PasswordManager("mymaster123")
pm.add_password("google.com", "securepass123")
print(pm.get_password("google.com", "mymaster123"))  # Should work
print(pm.get_password("google.com", "wrongpass"))    # Should fail
```

<details>
<summary>Click for Solution</summary>

```python
class PasswordManager:
    def __init__(self, master_password):
        self.__master = master_password
        self.__passwords = {}
    
    def add_password(self, website, password):
        if len(password) < 8:
            print("‚ùå Password must be at least 8 characters!")
            return False
        self.__passwords[website] = password
        print(f"‚úÖ Password saved for {website}")
        return True
    
    def get_password(self, website, master_password):
        if master_password != self.__master:
            return "üîí Access Denied - Wrong master password!"
        
        if website in self.__passwords:
            return f"üîë Password for {website}: {self.__passwords[website]}"
        return "‚ùå No password found for this website"
```
</details>
</Accordion>

---

## üèÉ Next Up: Inheritance

Now that you know how to protect your data, let's learn how to **share abilities between related objects**!

<Card title="Continue to Inheritance ‚Üí" icon="sitemap" href="/lld/oop/inheritance">
  Learn how child objects can inherit from parent objects - like how a Cat and Dog both inherit from Animal!
</Card>
