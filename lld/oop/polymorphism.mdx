---
title: "Polymorphism"
description: "One interface, many forms - like a shape-shifter in code!"
icon: "shapes"
---

## ü¶é What is Polymorphism?

The word **polymorphism** comes from Greek:
- **Poly** = Many
- **Morph** = Forms

So polymorphism means **"many forms"**!

Imagine a **universal remote control** üì∫. You press the "ON" button and:
- For a **TV**: It turns on the TV
- For a **AC**: It turns on the air conditioner  
- For **Lights**: It turns on the lights

**Same button, different results** based on what you're controlling!

<Tip>
**Simple Definition**: Polymorphism = Same method name, different behavior depending on the object
</Tip>

---

## üîä The Classic Shape Example

```python
class Shape:
    def area(self):
        pass  # Each shape calculates differently
    
    def draw(self):
        pass  # Each shape draws differently

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14159 * self.radius ** 2
    
    def draw(self):
        print("‚≠ï Drawing a circle")

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def draw(self):
        print("‚¨ú Drawing a rectangle")

class Triangle(Shape):
    def __init__(self, base, height):
        self.base = base
        self.height = height
    
    def area(self):
        return 0.5 * self.base * self.height
    
    def draw(self):
        print("üî∫ Drawing a triangle")

# THE MAGIC OF POLYMORPHISM ‚ú®
# Same code works for ANY shape!

shapes = [
    Circle(5),
    Rectangle(4, 6),
    Triangle(3, 8)
]

print("Drawing all shapes and calculating areas:\n")
for shape in shapes:
    shape.draw()  # Same method call
    print(f"   Area: {shape.area():.2f}\n")  # Different results!
```

**Output:**
```
Drawing all shapes and calculating areas:

‚≠ï Drawing a circle
   Area: 78.54

‚¨ú Drawing a rectangle
   Area: 24.00

üî∫ Drawing a triangle
   Area: 12.00
```

---

## üéµ Real-World Example: Music Player

Imagine a music player that can play different types of audio:

```python
class AudioFile:
    def __init__(self, filename):
        self.filename = filename
    
    def play(self):
        raise NotImplementedError("Subclass must implement this!")

class MP3File(AudioFile):
    def play(self):
        print(f"üéµ Playing MP3: {self.filename}")
        print("   Using MP3 decoder...")

class WAVFile(AudioFile):
    def play(self):
        print(f"üéµ Playing WAV: {self.filename}")
        print("   Raw audio, high quality!")

class FLACFile(AudioFile):
    def play(self):
        print(f"üéµ Playing FLAC: {self.filename}")
        print("   Lossless compression!")

class OGGFile(AudioFile):
    def play(self):
        print(f"üéµ Playing OGG: {self.filename}")
        print("   Open source format!")

# Music Player doesn't care about file type!
class MusicPlayer:
    def __init__(self):
        self.playlist = []
    
    def add_to_playlist(self, audio_file):
        self.playlist.append(audio_file)
    
    def play_all(self):
        print("=" * 40)
        print("üéß Now Playing Your Playlist")
        print("=" * 40)
        for track in self.playlist:
            track.play()  # Polymorphism! Same method, different behavior
            print()

# Create playlist with different file types
player = MusicPlayer()
player.add_to_playlist(MP3File("song1.mp3"))
player.add_to_playlist(WAVFile("sound_effect.wav"))
player.add_to_playlist(FLACFile("classical.flac"))
player.add_to_playlist(OGGFile("podcast.ogg"))

player.play_all()
```

---

## üéÆ Fun Example: Game Attacks

Every character attacks differently, but the game just calls `attack()`!

```python
class Character:
    def __init__(self, name, health):
        self.name = name
        self.health = health
    
    def attack(self, target):
        raise NotImplementedError("Each character attacks differently!")
    
    def take_damage(self, amount):
        self.health -= amount
        status = "üíÄ Defeated!" if self.health <= 0 else f"‚ù§Ô∏è {self.health} HP left"
        print(f"   {self.name}: {status}")

class Warrior(Character):
    def attack(self, target):
        print(f"‚öîÔ∏è {self.name} slashes with sword!")
        target.take_damage(25)

class Mage(Character):
    def attack(self, target):
        print(f"üî• {self.name} casts Fireball!")
        target.take_damage(35)

class Archer(Character):
    def attack(self, target):
        print(f"üèπ {self.name} shoots an arrow!")
        target.take_damage(20)

class Healer(Character):
    def attack(self, target):
        print(f"‚ú® {self.name} throws holy light!")
        target.take_damage(10)
    
    def heal(self, target):
        print(f"üíö {self.name} heals {target.name}!")
        target.health += 30

class Ninja(Character):
    def attack(self, target):
        print(f"üåÄ {self.name} appears behind the enemy!")
        print(f"   Triple strike combo!")
        target.take_damage(15)
        target.take_damage(15)
        target.take_damage(15)

# THE BATTLE!
def battle_round(attackers, defender):
    print("\n" + "=" * 50)
    print(f"üéØ Target: {defender.name}")
    print("=" * 50)
    
    for attacker in attackers:
        attacker.attack(defender)  # Same call, different attacks!
        if defender.health <= 0:
            print(f"\nüèÜ {defender.name} has been defeated!")
            return

# Create team
team = [
    Warrior("Conan"),
    Mage("Gandalf"),
    Archer("Legolas"),
    Ninja("Naruto")
]

# Create enemy
dragon = Character("Dragon", 200)
dragon.health = 200

# Battle!
battle_round(team, dragon)
```

---

## üìö Types of Polymorphism

<CardGroup cols={2}>
  <Card title="Method Overriding" icon="rotate">
    **Same method name in parent and child**
    
    Child provides its own version
    ```python
    class Animal:
        def speak(self): pass
    
    class Dog(Animal):
        def speak(self):
            print("Woof!")
    ```
  </Card>
  <Card title="Duck Typing" icon="duck">
    **If it walks like a duck...**
    
    Python doesn't check type, just method
    ```python
    def make_it_speak(thing):
        thing.speak()  # Works if has speak()
    ```
  </Card>
</CardGroup>

### ü¶Ü Duck Typing Explained

> "If it walks like a duck and quacks like a duck, it must be a duck!"

Python doesn't care about the TYPE, only about whether the object has the method:

```python
class Duck:
    def quack(self):
        print("Quack! ü¶Ü")
    
    def walk(self):
        print("Waddle waddle üö∂")

class Person:
    def quack(self):
        print("I'm pretending to be a duck! üó£Ô∏è")
    
    def walk(self):
        print("Walking normally üö∂")

class Robot:
    def quack(self):
        print("QUACK.exe executed ü§ñ")
    
    def walk(self):
        print("*mechanical walking sounds* ü¶ø")

# This function works with ANYTHING that can quack and walk
def do_duck_things(creature):
    creature.quack()
    creature.walk()

# All of these work!
print("=== Real Duck ===")
do_duck_things(Duck())

print("\n=== Person ===")
do_duck_things(Person())

print("\n=== Robot ===")
do_duck_things(Robot())
```

---

## üé® Practical Example: Drawing Application

```python
from abc import ABC, abstractmethod

class Drawable(ABC):
    """Anything that can be drawn on screen"""
    
    @abstractmethod
    def draw(self):
        pass
    
    @abstractmethod
    def get_area(self):
        pass

class Circle(Drawable):
    def __init__(self, x, y, radius, color):
        self.x = x
        self.y = y
        self.radius = radius
        self.color = color
    
    def draw(self):
        print(f"‚≠ï Circle at ({self.x}, {self.y})")
        print(f"   Radius: {self.radius}, Color: {self.color}")
    
    def get_area(self):
        return 3.14159 * self.radius ** 2

class Rectangle(Drawable):
    def __init__(self, x, y, width, height, color):
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.color = color
    
    def draw(self):
        print(f"‚¨ú Rectangle at ({self.x}, {self.y})")
        print(f"   Size: {self.width}x{self.height}, Color: {self.color}")
    
    def get_area(self):
        return self.width * self.height

class Text(Drawable):
    def __init__(self, x, y, content, font_size):
        self.x = x
        self.y = y
        self.content = content
        self.font_size = font_size
    
    def draw(self):
        print(f"üìù Text at ({self.x}, {self.y})")
        print(f"   \"{self.content}\" (size: {self.font_size})")
    
    def get_area(self):
        # Text area is approximate
        return len(self.content) * self.font_size * 0.5

class Canvas:
    def __init__(self, name):
        self.name = name
        self.elements = []
    
    def add(self, drawable):
        self.elements.append(drawable)
    
    def render(self):
        print(f"\nüñºÔ∏è Rendering Canvas: {self.name}")
        print("=" * 40)
        for element in self.elements:
            element.draw()  # Polymorphism!
            print()
    
    def total_area(self):
        return sum(e.get_area() for e in self.elements)

# Create a drawing
canvas = Canvas("My Artwork")
canvas.add(Circle(100, 100, 50, "red"))
canvas.add(Rectangle(200, 50, 80, 60, "blue"))
canvas.add(Text(50, 200, "Hello World!", 24))
canvas.add(Circle(300, 300, 30, "green"))

canvas.render()
print(f"üìê Total covered area: {canvas.total_area():.2f}")
```

---

## üí≥ Example: Payment System

Different payment methods, same interface:

```python
class PaymentMethod:
    def pay(self, amount):
        raise NotImplementedError
    
    def get_name(self):
        raise NotImplementedError

class CreditCard(PaymentMethod):
    def __init__(self, card_number, cvv):
        self.card_number = card_number[-4:]  # Only store last 4
    
    def pay(self, amount):
        print(f"üí≥ Credit Card ending in {self.card_number}")
        print(f"   Processing ${amount:.2f}...")
        print(f"   ‚úÖ Payment successful!")
        return True
    
    def get_name(self):
        return f"Card ***{self.card_number}"

class PayPal(PaymentMethod):
    def __init__(self, email):
        self.email = email
    
    def pay(self, amount):
        print(f"üÖøÔ∏è PayPal ({self.email})")
        print(f"   Redirecting to PayPal...")
        print(f"   ‚úÖ ${amount:.2f} paid via PayPal!")
        return True
    
    def get_name(self):
        return f"PayPal: {self.email}"

class Crypto(PaymentMethod):
    def __init__(self, wallet_address):
        self.wallet = wallet_address[:8] + "..."
    
    def pay(self, amount):
        btc_amount = amount / 50000  # Fake conversion
        print(f"‚Çø Crypto Wallet ({self.wallet})")
        print(f"   Converting ${amount:.2f} to {btc_amount:.6f} BTC...")
        print(f"   ‚è≥ Waiting for blockchain confirmation...")
        print(f"   ‚úÖ Transaction confirmed!")
        return True
    
    def get_name(self):
        return f"Crypto: {self.wallet}"

class ApplePay(PaymentMethod):
    def __init__(self, device_name):
        self.device = device_name
    
    def pay(self, amount):
        print(f"üçé Apple Pay ({self.device})")
        print(f"   Authenticating with Face ID...")
        print(f"   ‚úÖ ${amount:.2f} paid!")
        return True
    
    def get_name(self):
        return f"Apple Pay: {self.device}"

# Checkout system - doesn't care WHICH payment method!
class Checkout:
    def __init__(self):
        self.cart_total = 0
    
    def process_payment(self, payment_method, amount):
        print("\n" + "=" * 50)
        print(f"üõí Checkout - Total: ${amount:.2f}")
        print(f"üì± Using: {payment_method.get_name()}")
        print("=" * 50)
        
        # POLYMORPHISM! Same call, different behavior
        success = payment_method.pay(amount)
        
        if success:
            print("\nüéâ Thank you for your purchase!")
        return success

# Test different payment methods
checkout = Checkout()

# Same checkout process, different payment methods
checkout.process_payment(CreditCard("1234567890123456", "123"), 99.99)
checkout.process_payment(PayPal("user@email.com"), 49.99)
checkout.process_payment(Crypto("bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh"), 199.99)
checkout.process_payment(ApplePay("iPhone 15"), 29.99)
```

---

## ‚úÖ Benefits of Polymorphism

| Benefit | Description |
|---------|-------------|
| **Flexibility** | Add new types without changing existing code |
| **Simplicity** | One interface for many implementations |
| **Maintainability** | Changes in one class don't affect others |
| **Testability** | Easy to swap implementations for testing |

---

## üß™ Practice Exercise

<Accordion title="Challenge: Build a Notification System" icon="bell">

Create a notification system that can send messages through different channels:

1. **EmailNotification**: Sends via email
2. **SMSNotification**: Sends via text message
3. **PushNotification**: Sends to mobile app
4. **SlackNotification**: Sends to Slack channel

All should have a `send(message)` method!

```python
class Notification:
    def send(self, message):
        raise NotImplementedError

class EmailNotification(Notification):
    def __init__(self, email):
        # TODO
        pass
    
    def send(self, message):
        # TODO: Print sending email
        pass

# TODO: Add SMS, Push, Slack notifications

# Test with NotificationService
class NotificationService:
    def notify_all(self, channels, message):
        for channel in channels:
            channel.send(message)

# Test
service = NotificationService()
channels = [
    EmailNotification("user@example.com"),
    SMSNotification("+1234567890"),
    PushNotification("user_device_123"),
    SlackNotification("#general")
]
service.notify_all(channels, "Your order has shipped!")
```

<details>
<summary>Click for Solution</summary>

```python
class Notification:
    def send(self, message):
        raise NotImplementedError

class EmailNotification(Notification):
    def __init__(self, email):
        self.email = email
    
    def send(self, message):
        print(f"üìß Email to {self.email}")
        print(f"   Subject: Notification")
        print(f"   Body: {message}")

class SMSNotification(Notification):
    def __init__(self, phone):
        self.phone = phone
    
    def send(self, message):
        print(f"üì± SMS to {self.phone}")
        print(f"   Message: {message[:160]}")  # SMS limit

class PushNotification(Notification):
    def __init__(self, device_id):
        self.device_id = device_id
    
    def send(self, message):
        print(f"üîî Push to device {self.device_id}")
        print(f"   Alert: {message}")

class SlackNotification(Notification):
    def __init__(self, channel):
        self.channel = channel
    
    def send(self, message):
        print(f"üí¨ Slack to {self.channel}")
        print(f"   Message: {message}")

class NotificationService:
    def notify_all(self, channels, message):
        print("=" * 50)
        print("üì£ Sending Notifications...")
        print("=" * 50)
        for channel in channels:
            channel.send(message)
            print()

# Test
service = NotificationService()
channels = [
    EmailNotification("user@example.com"),
    SMSNotification("+1234567890"),
    PushNotification("device_abc123"),
    SlackNotification("#general")
]
service.notify_all(channels, "Your order has shipped!")
```
</details>
</Accordion>

---

## üèÉ Next Up: Abstraction

Now let's learn how to hide complex details and show only what's necessary!

<Card title="Continue to Abstraction ‚Üí" icon="eye-slash" href="/lld/oop/abstraction">
  Learn how to hide complexity and create simple interfaces - like a car dashboard!
</Card>
