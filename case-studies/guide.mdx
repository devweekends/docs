---
title: "Case Study Guide"
description: "Structure, content checklist, and rubric to write your case study"
icon: "book"
---

## üéØ What Great Case Studies Show

A great case study demonstrates **how you think**, not just what you built. Here's what separates good from great:

| Aspect | Good ‚ùå | Great ‚úÖ |
|--------|---------|----------|
| **Problem** | "Built an e-commerce site" | "Solved inventory sync across 3 warehouses with 99.9% accuracy" |
| **Architecture** | "Used React and Node" | "Chose React for SEO with Next.js SSR, Node for real-time WebSocket support" |
| **Trade-offs** | "Used PostgreSQL" | "PostgreSQL over MongoDB for ACID transactions; accepted slower writes for data integrity" |
| **Impact** | "It works" | "Reduced checkout time by 40%, handled 10K concurrent users" |

<Tip>
**Think like a Staff Engineer**: Every decision should answer "Why this? What were the alternatives? What would you do differently?"
</Tip>

---

## üìã Required Sections

<Steps>
<Step title="Overview" icon="circle-info">
  **Purpose**: Quick snapshot for readers to understand what this is about
  
  - Project name and one‚Äëline value proposition
  - GitHub link(s) with good READMEs
  - Live demo URL (if applicable)
  - Team size and your role
  - Timeline (e.g., "3 months, part-time")
</Step>

<Step title="Goals of the Project" icon="bullseye">
  **Purpose**: Show you understand the business context, not just code
  
  - **Business/User Goals**: What problem does this solve? Who benefits?
  - **Technical Goals**: Performance targets, scalability requirements
  - **Non-Goals**: What's explicitly out of scope? (Shows scoping skill!)
  
  ```markdown
  ## Goals
  - Support 10K concurrent users with <200ms latency
  - Process payments with PCI compliance
  - Real-time inventory updates across warehouses
  
  ## Non-Goals
  - Mobile app (web-responsive for MVP)
  - International shipping (US-only for v1)
  ```
</Step>

<Step title="System Architecture Overview" icon="diagram-project">
  **Purpose**: Give readers the 10,000ft view before diving in
  
  **Tech Stack Table** (required):
  | Layer | Technology | Why This Choice |
  |-------|------------|-----------------|
  | Frontend | Next.js 14 | SSR for SEO, App Router for better DX |
  | Backend | Node.js + Express | Team familiarity, WebSocket support |
  | Database | PostgreSQL | ACID for payments, JSONB for flexibility |
  | Cache | Redis | Session storage, rate limiting |
  | Payments | Stripe | Best docs, webhook reliability |
  
  **Architecture Diagram** (use Mermaid):
  ```mermaid
  flowchart LR
    Client --> CDN --> LoadBalancer
    LoadBalancer --> API1 & API2
    API1 & API2 --> Redis[(Redis)]
    API1 & API2 --> DB[(PostgreSQL)]
    API1 --> Queue[RabbitMQ]
    Queue --> Workers
  ```
</Step>

<Step title="Key Features" icon="star">
  **Purpose**: Show depth in each domain you built
  
  Group by domain with bullet points:
  
  **Authentication & Authorization**
  - JWT with refresh token rotation
  - Role-based access (Buyer, Seller, Admin)
  - OAuth2 with Google and GitHub
  
  **Payments**
  - Stripe Elements for PCI compliance
  - Webhook handling for async confirmations
  - Refund flow with seller approval
</Step>

<Step title="Flows & Diagrams" icon="arrows-turn-to-dots">
  **Purpose**: Show you can visualize complex interactions
  
  Include 2-3 key flows:
  - **User Flow**: Happy path for main use case
  - **System Flow**: How services communicate
  - **Error Flow**: How you handle failures
  
  ```mermaid
  sequenceDiagram
    participant User
    participant Frontend
    participant API
    participant Stripe
    participant DB
    
    User->>Frontend: Clicks "Pay Now"
    Frontend->>API: POST /checkout
    API->>Stripe: Create PaymentIntent
    Stripe-->>API: client_secret
    API-->>Frontend: {clientSecret}
    Frontend->>Stripe: confirmPayment()
    Stripe-->>Frontend: Success
    Frontend->>API: POST /orders/confirm
    API->>DB: Update order status
    API-->>Frontend: Order confirmed
  ```
</Step>

<Step title="API & Data Design" icon="database">
  **Purpose**: Show you can design clean interfaces and data models
  
  **Important Endpoints** (grouped by domain):
  ```
  # Products
  GET  /api/products        ‚Üí List products with filters
  POST /api/products        ‚Üí Create product (seller)
  
  # Orders
  POST /api/orders          ‚Üí Create order
  GET  /api/orders/:id      ‚Üí Get order details
  PATCH /api/orders/:id     ‚Üí Update order status
  ```
  
  **Database ERD**:
  ```mermaid
  erDiagram
    User ||--o{ Order : places
    Order ||--|{ OrderItem : contains
    Product ||--o{ OrderItem : "included in"
    User ||--o{ Product : sells
  ```
</Step>

<Step title="Challenges & Solutions" icon="lightbulb">
  **Purpose**: This is the GOLD - shows your problem-solving ability
  
  Include 5-10 specific challenges with:
  - What was the problem?
  - Why was it hard?
  - How did you solve it?
  - What trade-offs did you make?
  
  | Challenge | Solution | Trade-off |
  |-----------|----------|-----------|
  | Inventory overselling | Optimistic locking with version numbers | Slight UX friction on conflicts |
  | Slow product search | ElasticSearch with async indexing | Added infrastructure complexity |
  | Payment webhook failures | Idempotent handlers + dead letter queue | 5-min delay for failed retries |
</Step>

<Step title="Best Practices" icon="shield-check">
  **Purpose**: Show you know production-grade engineering
  
  - **Security**: CSRF tokens, rate limiting, input sanitization, SQL injection prevention
  - **Performance**: CDN caching, DB indexing, query optimization, lazy loading
  - **DX**: TypeScript, ESLint, Prettier, pre-commit hooks, CI/CD
  - **Observability**: Structured logging, error tracking (Sentry), metrics (Prometheus)
</Step>

<Step title="Conclusion" icon="flag-checkered">
  **Purpose**: Summarize impact and show growth mindset
  
  - **Outcomes/Metrics**: Load time improved 60%, handled 10K users, 99.9% uptime
  - **Learnings**: What would you do differently?
  - **Next Steps**: What features would you add next?
</Step>
</Steps>

---

## üìä Rubric (What Mentors Look For)

| Criteria | Weight | Excellent | Needs Work |
|----------|--------|-----------|------------|
| **Clarity of Writing** | 20% | Clear, concise, well-organized | Rambling, unclear structure |
| **Technical Depth** | 30% | Shows deep understanding of tech choices | Surface-level descriptions |
| **Architecture Reasoning** | 30% | Explains trade-offs, alternatives considered | "I used X because it's popular" |
| **Evidence** | 20% | Diagrams, code refs, metrics, demos | Text-only, no proof |

---

## üí° Pro Tips

<AccordionGroup>
  <Accordion title="Keep it 4-8 pages" icon="file-lines">
    Long enough to be comprehensive, short enough to be readable. Link out to code rather than pasting large snippets.
  </Accordion>
  
  <Accordion title="Lead with Impact" icon="chart-line">
    Start each section with WHY it matters. "Reduced checkout time by 40%" is better than "Implemented checkout flow."
  </Accordion>
  
  <Accordion title="Show Don't Tell" icon="eye">
    Screenshots, GIFs, diagrams > paragraphs of text. A well-labeled architecture diagram is worth 1000 words.
  </Accordion>
  
  <Accordion title="Be Honest About Trade-offs" icon="scale-balanced">
    Saying "MongoDB was wrong for our use case, we migrated to PostgreSQL" shows maturity, not weakness.
  </Accordion>
  
  <Accordion title="Get Feedback" icon="comments">
    Have a mentor or peer review before submitting. Fresh eyes catch unclear explanations.
  </Accordion>
</AccordionGroup>

---

## üöÄ Ready to Write?

<CardGroup cols={2}>
  <Card title="Template" icon="file" href="/case-studies/template">
    Copy this template and fill in your project details
  </Card>
  <Card title="Example" icon="star" href="/case-studies/example-multi-vendor">
    See a complete example for reference
  </Card>
</CardGroup>