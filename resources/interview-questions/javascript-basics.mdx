---
title: "JavaScript (Fundamentals)"
description: "Comprehensive guide to JavaScript interview questions from Easy to Hard"
icon: "js"
---

# JavaScript Interview Questions (Fundamentals)

A comprehensive guide to JavaScript interview questions, organized by difficulty level. This collection covers fundamental concepts to advanced topics commonly asked in web development interviews.

## Easy Level Questions

<AccordionGroup>
<Accordion title="1. What is JavaScript and where is it commonly used?">
**Answer**:
JavaScript is a high-level programming language widely used to create interactive effects within web browsers. A high-level programming language means it's human-understandable and abstracted from machine code.

**Common Uses:**
- Web application development (front-end)
- Server-side development (back-end with Node.js)
- Mobile application development
- Interactive web page features
</Accordion>

<Accordion title="2. What are template literals in JavaScript?">
**Answer**:
Template literals are a feature that combines the dollar sign `$`, curly brackets `{}`, and backticks `` ` `` to make string interpolation easier and more readable.

**Without template literals:**
```javascript
let a = 10;
let b = 20;
console.log("The sum of " + a + " and " + b + " is " + (a + b));
```

**With template literals:**
```javascript
let a = 10;
let b = 20;
console.log(`The sum of ${a} and ${b} is ${a + b}`);
```

**Purpose:**
- Embed variables and expressions directly into strings
- Make code more readable and flexible
- Avoid complex string concatenation
</Accordion>

<Accordion title="3. What is hoisting? Give an example.">
**Answer**:
Hoisting is a JavaScript mechanism where variable and function declarations are moved (or "hoisted") to the top of their scope before code execution.

**Types of Hoisting:**

1. **Function Hoisting:**
```javascript
greet(); // Works! Outputs: "Hello"

function greet() {
    console.log("Hello");
}
```

2. **Variable Hoisting:**
```javascript
console.log(x); // undefined
var x = 10;

console.log(y); // ReferenceError
let y = 20;

console.log(z); // ReferenceError
const z = 30;
```

**Key Points:**
- `var` declarations are hoisted and initialized with `undefined`
- `let` and `const` are hoisted but not initialized (temporal dead zone)
- Function declarations are fully hoisted
</Accordion>

<Accordion title="4. Explain the difference between var, let, and const">
**Answer**:

| Feature | var | let | const |
|---------|-----|-----|-------|
| Scope | Function scope | Block scope | Block scope |
| Reassignment | Yes | Yes | No |
| Re-declaration | Yes | No | No |
| Hoisting | Hoisted with undefined | Hoisted but not initialized | Hoisted but not initialized |

**Example:**
```javascript
if (true) {
    var a = 10;
    let b = 20;
    const c = 30;
}

console.log(a); // 10 (accessible - function scoped)
console.log(b); // ReferenceError (block scoped)
console.log(c); // ReferenceError (block scoped)
```

**Best Practice:**
1. Avoid `var` due to its global accessibility and potential bugs
2. Use `const` by default to prevent accidental reassignment
3. Use `let` only when you need to reassign values
</Accordion>

<Accordion title="5. What are the data types available in JavaScript?">
**Answer**:

**Primitive Data Types** (Immutable):

1. **Number:** Integer and floating-point numbers, including special values (`Infinity`, `-Infinity`, `NaN`)
```javascript
let age = 25;
let pi = 3.14;
let infinity = Infinity;
```

2. **String:** Sequence of characters
```javascript
let name = 'John';
let message = "Hello";
let template = `Welcome`;
```

3. **Boolean:** Logical entity with two values
```javascript
let isActive = true;
let isCompleted = false;
```

4. **Undefined:** Default value for declared but unassigned variables
```javascript
let x;
console.log(x); // undefined
```

5. **Null:** Intentional absence of value
```javascript
let data = null;
```

6. **Symbol:** Unique and immutable identifier
```javascript
let sym1 = Symbol('id');
let sym2 = Symbol('id');
console.log(sym1 === sym2); // false
```

7. **BigInt:** Very large integers beyond Number limit
```javascript
let bigNumber = 1234567890123456789012345678901234567890n;
```

**Non-Primitive Data Types** (Mutable):

1. **Object:** Collection of key-value pairs
```javascript
let person = { name: 'John', age: 30 };
```

2. **Array:** Ordered collection of values (zero-indexed)
```javascript
let numbers = [1, 2, 3, 4, 5];
```

3. **Function:** Reusable block of code
```javascript
function greet() {
    console.log('Hello');
}
```
</Accordion>

<Accordion title="6. What is an array in JavaScript and how do you access its elements?">
**Answer**:
An array is an ordered collection of values or elements. Elements can be of any data type but typically belong to the same type.

**Creating Arrays:**
```javascript
// Array literal syntax
let fruits = ['apple', 'banana', 'orange'];

// Array constructor
let numbers = new Array(1, 2, 3, 4, 5);
```

**Accessing Elements:**
```javascript
// Direct access using index
console.log(fruits[0]); // 'apple'
console.log(fruits[2]); // 'orange'

// Using for loop
for (let i = 0; i < fruits.length; i++) {
    console.log(fruits[i]);
}

// Using forEach
fruits.forEach(fruit => {
    console.log(fruit);
});
```
</Accordion>

<Accordion title="7. Explain the difference between == and === in JavaScript">
**Answer**:

| Operator | Name | Type Coercion | Example |
|----------|------|---------------|---------|
| == | Equality operator | Yes | `'5' == 5` → true |
| === | Strict equality operator | No | `'5' === 5` → false |

**Examples:**
```javascript
// Double equals (==) - performs type coercion
console.log('5' == 5);     // true (string converted to number)
console.log(true == 1);    // true
console.log(null == undefined); // true

// Triple equals (===) - no type coercion
console.log('5' === 5);    // false (different types)
console.log(true === 1);   // false
console.log(null === undefined); // false
```

**Best Practice:** Always use `===` (strict equality) to avoid unexpected type coercion bugs.
</Accordion>

<Accordion title="8. What is the purpose of the isNaN() function?">
**Answer**:
`isNaN()` is a special JavaScript function that checks if a given value is "Not a Number" (NaN). It returns `true` if the value cannot be coerced into a number.

**Examples:**
```javascript
// Returns true (cannot be converted to number)
console.log(isNaN('hello'));      // true
console.log(isNaN(undefined));    // true
console.log(isNaN(NaN));          // true

// Returns false (can be converted to number)
console.log(isNaN('123'));        // false (string converted to 123)
console.log(isNaN(123));          // false
console.log(isNaN(true));         // false (converted to 1)

// Interesting case
console.log(isNaN(null));         // false (null is treated as 0)
console.log(typeof NaN);          // 'number' (NaN is a number type!)
```
</Accordion>

<Accordion title="9. What is null and undefined?">
**Answer**:

| Feature | undefined | null |
|---------|-----------|------|
| Meaning | Default absence of value | Intentional absence of value |
| Assignment | Automatically assigned | Manually assigned |
| Type | `undefined` | `object` (historical bug) |
| Use case | Variable declared but not initialized | Explicitly setting "no value" |

**Examples:**
```javascript
// undefined - declared but not assigned
let a;
console.log(a);           // undefined
console.log(typeof a);    // 'undefined'

// null - intentionally empty
let b = null;
console.log(b);           // null
console.log(typeof b);    // 'object' (known JavaScript quirk)

// Comparison
console.log(null == undefined);  // true (loose equality)
console.log(null === undefined); // false (strict equality)
```
</Accordion>

<Accordion title="10. Explain the use of the typeof operator">
**Answer**:
The `typeof` operator determines the data type of a given value or variable and returns a string indicating the type.

**Examples:**
```javascript
console.log(typeof 42);              // 'number'
console.log(typeof 'hello');         // 'string'
console.log(typeof true);            // 'boolean'
console.log(typeof undefined);       // 'undefined'
console.log(typeof null);            // 'object' (JavaScript quirk)
console.log(typeof Symbol('id'));    // 'symbol'
console.log(typeof 123n);            // 'bigint'
console.log(typeof {});              // 'object'
console.log(typeof []);              // 'object' (arrays are objects)
console.log(typeof function(){});    // 'function'
```

**Use Cases:**
- Input validation
- Conditional logic based on data types
- Debugging and type checking
</Accordion>
</AccordionGroup>

## Medium Level Questions

<AccordionGroup>
<Accordion title="11. What is the purpose of the map() method in JavaScript?">
**Answer**:
The `map()` method creates a new array by applying a specified function to each element of an existing array. It doesn't modify the original array.

**Example:**
```javascript
const numbers = [1, 2, 3, 4, 5];

// Traditional approach
const doubled = [];
for (let i = 0; i < numbers.length; i++) {
    doubled.push(numbers[i] * 2);
}

// Using map (cleaner)
const doubledNumbers = numbers.map(num => num * 2);
console.log(doubledNumbers); // [2, 4, 6, 8, 10]
console.log(numbers);        // [1, 2, 3, 4, 5] (unchanged)
```

**Benefits:**
- Concise one-line transformations
- Doesn't mutate the original array
- Functional programming approach
- More readable than loops
</Accordion>

<Accordion title="12. What is event bubbling and event capturing in JavaScript?">
**Answer**:
Event bubbling and capturing are two phases of event propagation in the DOM.

**Event Capturing (Top to Bottom):**
Events are handled from the outermost element to the innermost element.
- Like information flowing from CEO → Manager → Employee

**Event Bubbling (Bottom to Top):**
Events are handled from the innermost element to the outermost element.
- Like concerns flowing from Employee → Manager → CEO

**Example:**
```javascript
// HTML structure
<div id="outer">
    <div id="mid">
        <div id="inner">Click me</div>
    </div>
</div>

// Event Bubbling (default)
document.getElementById('outer').addEventListener('click', () => {
    console.log('Outer div clicked');
});
document.getElementById('mid').addEventListener('click', () => {
    console.log('Mid div clicked');
});
document.getElementById('inner').addEventListener('click', () => {
    console.log('Inner div clicked');
});

// Click on inner div outputs:
// Inner div clicked
// Mid div clicked
// Outer div clicked

// Event Capturing (set third parameter to true)
document.getElementById('outer').addEventListener('click', () => {
    console.log('Outer div clicked');
}, true);

// Click on inner div outputs:
// Outer div clicked
// Mid div clicked
// Inner div clicked
```
</Accordion>

<Accordion title="13. What are higher-order functions? Can you give an example?">
**Answer**:
A higher-order function is a function that either:
1. Takes another function as an argument, OR
2. Returns a function as a result

**Examples:**
```javascript
// map() is a higher-order function
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(function(num) {
    return num * 2;
});

// Function that accepts a function as argument
function operate(a, b, operation) {
    return operation(a, b);
}

const add = (x, y) => x + y;
const multiply = (x, y) => x * y;

console.log(operate(5, 3, add));      // 8
console.log(operate(5, 3, multiply)); // 15

// Function that returns a function
function createMultiplier(multiplier) {
    return function(number) {
        return number * multiplier;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5));  // 10
console.log(triple(5));  // 15
```

**Common Higher-Order Functions:**
- `map()`, `filter()`, `reduce()`
- `forEach()`, `find()`, `some()`, `every()`
- `setTimeout()`, `setInterval()`
</Accordion>

<Accordion title="14. What is an IIFE (Immediately Invoked Function Expression) in JavaScript?">
**Answer**:
An IIFE is a JavaScript function that is defined and executed immediately after its creation, without needing to be called explicitly.

**Regular Function:**
```javascript
function greet() {
    console.log("Hello World");
}
greet(); // Must be called manually
```

**IIFE:**
```javascript
(function() {
    console.log("Hello World");
})();
// Executes automatically, outputs: "Hello World"
```

**Benefits:**
- No name needed (anonymous function)
- Executes immediately without calling
- Creates private scope (data encapsulation)
- Avoids polluting global namespace

**Use Cases:**
```javascript
// Private variables
(function() {
    let privateVar = "secret";
    console.log(privateVar); // Accessible here
})();
// console.log(privateVar); // Error: not accessible outside

// Module pattern
const counter = (function() {
    let count = 0;
    return {
        increment: () => ++count,
        getCount: () => count
    };
})();

console.log(counter.increment()); // 1
console.log(counter.getCount());  // 1
```
</Accordion>

<Accordion title="15. What do you understand by closures in JavaScript?">
**Answer**:
A closure is a function that remembers the environment (variables) in which it was created, even after the outer function has finished executing.

**Example:**
```javascript
function outerFunction() {
    let outerVariable = "I'm from outer function";
    
    function innerFunction() {
        console.log(outerVariable); // Accesses outer variable
    }
    
    return innerFunction;
}

const closureFunction = outerFunction();
closureFunction(); // "I'm from outer function"
```

**Practical Use Case - Private Variables:**
```javascript
function createCounter() {
    let count = 0; // Private variable
    
    return {
        increment: function() {
            count++;
            return count;
        },
        decrement: function() {
            count--;
            return count;
        },
        getCount: function() {
            return `Current count: ${count}`;
        }
    };
}

const myCounter = createCounter();
console.log(myCounter.increment());  // 1
console.log(myCounter.increment());  // 2
console.log(myCounter.decrement());  // 1
console.log(myCounter.getCount());   // "Current count: 1"
// console.log(count); // Error: count is not accessible
```

**Why Closures?**
JavaScript doesn't have a built-in way to declare private variables in objects. Closures provide this functionality by maintaining access to variables from their outer scope.
</Accordion>

<Accordion title="16. How do setTimeout() and setInterval() work?">
**Answer**:
Both are Web APIs that schedule code execution after specific time delays.

**`setTimeout()` - Execute once after delay:**
```javascript
setTimeout(() => {
    console.log("Hello after 2 seconds");
}, 2000); // 2000 milliseconds = 2 seconds

// With clearTimeout
const timerId = setTimeout(() => {
    console.log("This won't run");
}, 2000);

clearTimeout(timerId); // Cancels the timeout
```

**`setInterval()` - Execute repeatedly at intervals:**
```javascript
const intervalId = setInterval(() => {
    console.log("Hello every 2 seconds");
}, 2000);

// Stop after 4 seconds using setTimeout
setTimeout(() => {
    clearInterval(intervalId);
    console.log("Interval stopped");
}, 4000);
```

**Practical Example - Clock:**
```javascript
const clockInterval = setInterval(() => {
    const now = new Date();
    console.log(now.toLocaleTimeString());
}, 1000); // Update every second

// Stop clock after 10 seconds
setTimeout(() => {
    clearInterval(clockInterval);
}, 10000);
```

**Use Cases:**
- `setTimeout()`: Notifications, delayed actions, debouncing
- `setInterval()`: Clocks, real-time updates, polling APIs
</Accordion>

<Accordion title="17. Explain the concept of Promises in JavaScript">
**Answer**:
Promises handle asynchronous tasks by providing a structured approach for managing success and failure states, avoiding callback hell.

**Promise States:**
1. **Pending:** Initial state, neither fulfilled nor rejected
2. **Fulfilled:** Operation completed successfully
3. **Rejected:** Operation failed

**Example:**
```javascript
const data = { name: 'John', age: 30 };

function fetchData() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            // Simulate API call
            if (data) {
                resolve(data); // Success
            } else {
                reject('Data not found'); // Failure
            }
        }, 2000);
    });
}

// Using the promise
fetchData()
    .then(data => {
        console.log('Data fetched:', data);
    })
    .catch(error => {
        console.error('Error:', error);
    });
```

**Chaining Promises:**
```javascript
fetchData()
    .then(data => {
        console.log(data);
        return data.name;
    })
    .then(name => {
        console.log('Name:', name);
    })
    .catch(error => {
        console.error('Error:', error);
    });
```

**Benefits:**
- Better error handling than callbacks
- Cleaner code structure
- Avoids callback hell
- Chainable operations
</Accordion>

<Accordion title="18. What is the use of async and await in JavaScript?">
**Answer**:
`async`/`await` provides a cleaner syntax for working with Promises, making asynchronous code look and behave more like synchronous code.

**Key Points:**
- `async` function always returns a Promise
- `await` pauses execution until Promise resolves
- Must use `await` inside `async` function
- Code continues other tasks while waiting (non-blocking)

**Example:**
```javascript
async function fetchData() {
    try {
        // Wait for API response
        const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
        
        // Wait for JSON parsing
        const data = await response.json();
        
        console.log('Data fetched:', data);
        return data;
    } catch (error) {
        console.error('Error:', error);
    }
}

fetchData();
```

**Comparison - Promise vs Async/Await:**
```javascript
// Using Promises
fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error(error));

// Using Async/Await (cleaner)
async function getData() {
    try {
        const response = await fetch('https://api.example.com/data');
        const data = await response.json();
        console.log(data);
    } catch (error) {
        console.error(error);
    }
}
```

**Real-World Analogy:**
Like downloading an app from Play Store - it downloads in the background while you can use other apps. Once downloaded, you get a notification.
</Accordion>

<Accordion title="19. What is the difference between call(), apply(), and bind()?">
**Answer**:
All three methods allow you to set the `this` context for a function, but they differ in how they handle arguments and execution.

**`call()` - Executes immediately, arguments passed individually:**
```javascript
function cook(ingredient1, ingredient2) {
    console.log(`${this.name} is having a meal with ${ingredient1} and ${ingredient2}`);
}

const person = { name: 'Adam' };

cook.call(person, 'rice', 'beans');
// Output: "Adam is having a meal with rice and beans"
```

**`apply()` - Executes immediately, arguments passed as array:**
```javascript
cook.apply(person, ['rice', 'beans']);
// Output: "Adam is having a meal with rice and beans"
```

**`bind()` - Returns new function, executes later:**
```javascript
const cookForAdam = cook.bind(person, 'rice', 'beans');
// Function created but not executed yet

cookForAdam(); // Now it executes
// Output: "Adam is having a meal with rice and beans"
```

**Comparison Table:**

| Method | Execution | Arguments | Returns |
|--------|-----------|-----------|---------|
| `call()` | Immediate | Individual | Result |
| `apply()` | Immediate | Array | Result |
| `bind()` | Later | Individual/Array | New function |

**Restaurant Analogy:**
- **call:** Waiter takes orders one by one, tells chef immediately
- **apply:** Waiter writes all orders in a list, tells chef immediately
- **bind:** Waiter takes orders, tells chef to cook when ready

**Why Use These?**
To explicitly set what `this` refers to, avoiding confusion in complex code.
</Accordion>

<Accordion title="20. What is event delegation?">
**Answer**:
Event delegation is a technique that uses a single event listener on a parent element to manage events for multiple child elements, utilizing event bubbling.

**Without Event Delegation:**
```javascript
// Inefficient - multiple listeners
const items = document.querySelectorAll('li');
items.forEach(item => {
    item.addEventListener('click', function() {
        console.log('Clicked:', this.textContent);
    });
});
```

**With Event Delegation:**
```javascript
// Efficient - single listener on parent
const itemList = document.getElementById('item-list');
itemList.addEventListener('click', function(e) {
    if (e.target.tagName === 'LI') {
        console.log('Clicked:', e.target.textContent);
    }
});
```

**Benefits:**
1. **Better Performance:** One listener instead of many
2. **Handles Dynamic Elements:** Works for elements added later
3. **Less Memory Usage:** Fewer event listeners
4. **Cleaner Code:** Centralized event handling

**Example with Dynamic Elements:**
```html
<ul id="item-list">
    <li>Item 1</li>
    <li>Item 2</li>
</ul>

<script>
document.getElementById('item-list').addEventListener('click', (e) => {
    if (e.target.tagName === 'LI') {
        console.log('Clicked:', e.target.textContent);
    }
});

// Add new item dynamically
const newItem = document.createElement('li');
newItem.textContent = 'Item 3';
document.getElementById('item-list').appendChild(newItem);
// Click still works on new item!
</script>
```
</Accordion>
</AccordionGroup>

## Hard Level Questions

<AccordionGroup>
<Accordion title="21. Explain the event loop in JavaScript">
**Answer**:
The event loop is the mechanism that allows JavaScript to perform non-blocking operations despite being single-threaded. It manages the execution of synchronous and asynchronous code.

**How It Works:**

1. **Call Stack:** Executes synchronous code
2. **Web APIs:** Handle asynchronous operations (setTimeout, fetch, etc.)
3. **Task Queue:** Stores completed async tasks
4. **Event Loop:** Checks if call stack is empty, then moves tasks from queue to stack

**Restaurant Analogy:**
- **Chef** = Main thread (call stack)
- **Boiling water** = Async operation
- **Assistant** = Event loop (checks if tasks are complete)

The chef doesn't wait for water to boil; she chops vegetables. The assistant monitors the water and notifies the chef when it's ready.

**Example:**
```javascript
console.log('1: Start');

setTimeout(() => {
    console.log('2: Timeout');
}, 0);

console.log('3: End');

// Output:
// 1: Start
// 3: End
// 2: Timeout (even with 0ms delay!)
```

**Why this order?**
1. "Start" executes (synchronous)
2. setTimeout sends callback to Web API
3. "End" executes (synchronous)
4. Call stack empty → event loop moves timeout callback to stack
5. "Timeout" executes

**Process Flow:**
```
Call Stack → Web APIs → Task Queue → Event Loop → Call Stack
```
</Accordion>

<Accordion title="22. What is the difference between Promises and async/await?">
**Answer**:
`async`/`await` is syntactic sugar built on top of Promises, providing cleaner syntax while Promises are the underlying mechanism.

**Key Differences:**

| Feature | Promise | Async/Await |
|---------|---------|-------------|
| Syntax | `.then()` chains | Try/catch blocks |
| Readability | Can get messy | Cleaner, synchronous-like |
| Error Handling | `.catch()` | try/catch |
| Relationship | Foundation | Built on Promises |

**Promise Chaining:**
```javascript
fetchData1()
    .then(result1 => {
        return fetchData2(result1);
    })
    .then(result2 => {
        console.log(result2);
    })
    .catch(error => {
        console.error(error);
    });
```

**Async/Await (Cleaner):**
```javascript
async function fetchData() {
    try {
        const result1 = await fetchData1();
        const result2 = await fetchData2(result1);
        console.log(result2);
    } catch (error) {
        console.error(error);
    }
}

fetchData();
```

**When to Use:**
- **Promises:** Simple async operations, library compatibility
- **Async/Await:** Complex async flows, better readability needed

**Important:** Async/await doesn't replace Promises; it works with them!
</Accordion>

<Accordion title="23. Describe the purpose of the reduce() method in arrays">
**Answer**:
The `reduce()` method reduces an array to a single value by applying a function to each element, accumulating the result.

**Syntax:**
```javascript
array.reduce((accumulator, currentValue) => {
    // return updated accumulator
}, initialValue);
```

**How It Works:**
```javascript
const numbers = [1, 2, 3, 4, 5];

const sum = numbers.reduce((accumulator, currentValue) => {
    return accumulator + currentValue;
}, 0);

console.log(sum); // 15
```

**Step-by-Step Execution:**

| Step | Accumulator | Current Value | Result |
|------|-------------|---------------|--------|
| 1 | 0 (initial) | 1 | 1 |
| 2 | 1 | 2 | 3 |
| 3 | 3 | 3 | 6 |
| 4 | 6 | 4 | 10 |
| 5 | 10 | 5 | 15 |

**Common Use Cases:**

```javascript
// Sum of numbers
const total = [1, 2, 3, 4].reduce((acc, num) => acc + num, 0); // 10

// Find maximum
const max = [1, 5, 3, 9, 2].reduce((acc, num) => Math.max(acc, num)); // 9

// Count occurrences
const fruits = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple'];
const count = fruits.reduce((acc, fruit) => {
    acc[fruit] = (acc[fruit] || 0) + 1;
    return acc;
}, {});
// { apple: 3, banana: 2, orange: 1 }

// Flatten array
const nested = [[1, 2], [3, 4], [5, 6]];
const flat = nested.reduce((acc, arr) => acc.concat(arr), []);
// [1, 2, 3, 4, 5, 6]
```

**Benefits:**
- Concise (one line instead of loops)
- Functional programming approach
- Versatile (sum, average, flatten, group, etc.)
- Doesn't mutate original array
</Accordion>

<Accordion title="24. Explain the concept of currying in JavaScript">
**Answer**:
Currying is a functional programming technique where a function with multiple arguments is transformed into a sequence of functions, each taking a single argument.

**Regular Function:**
```javascript
function add(a, b) {
    return a + b;
}
console.log(add(2, 3)); // 5
```

**Curried Function:**
```javascript
function multiply(a) {
    return function(b) {
        return a * b;
    };
}

// Usage
const double = multiply(2); // a is fixed to 2
console.log(double(3));      // 6
console.log(double(5));      // 10

const triple = multiply(3);  // a is fixed to 3
console.log(triple(4));      // 12
```

**PowerPoint Analogy:**
Creating presentations for 5 animals:
- **Template** = Fixed parameter (constant)
- **Animal content** = Variable parameter (dynamic)

Instead of creating 50 slides (10 slides × 5 animals), create one 10-slide template and reuse it for each animal.

**Practical Example:**
```javascript
// Curried logging function
function log(level) {
    return function(message) {
        console.log(`[${level}] ${message}`);
    };
}

const error = log('ERROR');
const info = log('INFO');

error('Database connection failed'); // [ERROR] Database connection failed
info('Server started');              // [INFO] Server started

// Curried discount calculator
function discount(percentage) {
    return function(price) {
        return price - (price * percentage / 100);
    };
}

const tenPercent = discount(10);
const twentyPercent = discount(20);

console.log(tenPercent(100));   // 90
console.log(twentyPercent(100)); // 80
```

**Benefits:**
- **Reusability:** Fix common parameters, reuse function
- **Flexibility:** Create specialized functions from general ones
- **Performance:** Reduce redundant parameter passing
- **Code Organization:** Cleaner, more modular code
</Accordion>

<Accordion title="25. What is a generator function and how is it used?">
**Answer**:
A generator function is a special function that can pause its execution and resume later, returning multiple values over time using the `yield` keyword.

**Syntax:**
```javascript
function* generatorName() {
    yield value1;
    yield value2;
    // ...
}
```

**Basic Example:**
```javascript
function* infiniteSequence() {
    let num = 1;
    while (true) {
        yield num;
        num++;
    }
}

const sequence = infiniteSequence();

console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 2
console.log(sequence.next().value); // 3
```

**Key Difference from Regular Functions:**
- **Regular:** Runs completely, then returns
- **Generator:** Pauses at each `yield`, resumes on `next()`

**Preventing Infinite Loops:**
```javascript
function* controlledSequence() {
    let num = 1;
    while (true) {
        yield num++;
    }
}

const gen = controlledSequence();

// Controlled execution
for (let i = 0; i < 5; i++) {
    console.log(gen.next().value);
}
// Output: 1, 2, 3, 4, 5 (stops after 5)
```

**Practical Use Cases:**

```javascript
// Pagination
function* paginate(items, pageSize) {
    for (let i = 0; i < items.length; i += pageSize) {
        yield items.slice(i, i + pageSize);
    }
}

const data = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const pages = paginate(data, 3);

console.log(pages.next().value); // [1, 2, 3]
console.log(pages.next().value); // [4, 5, 6]
console.log(pages.next().value); // [7, 8, 9]

// ID Generator
function* idGenerator() {
    let id = 1;
    while (true) {
        yield `ID-${id++}`;
    }
}

const ids = idGenerator();
console.log(ids.next().value); // ID-1
console.log(ids.next().value); // ID-2
```

**Benefits:**
- Lazy evaluation (compute only when needed)
- Memory efficient
- Prevents infinite loop crashes
- Useful for iterating large datasets
</Accordion>

<Accordion title="26. What are WeakMap and WeakSet in JavaScript?">
**Answer**:
WeakMap and WeakSet are special collections for storing temporary object references that don't prevent garbage collection.

**WeakMap:**
- Stores key-value pairs where keys must be objects
- Keys are weakly referenced (can be garbage collected)
- Not iterable, no `size` property

**WeakSet:**
- Stores unique object references
- Only accepts objects, not primitives
- Not iterable, no `size` property

**Example - WeakMap:**
```javascript
const weakMap = new WeakMap();
let obj = { name: 'Adam' };

// Add key-value pair
weakMap.set(obj, 'employee');

console.log(weakMap.get(obj)); // 'employee'

// Remove reference - object becomes garbage collected
obj = null;
console.log(weakMap.get(obj)); // undefined
```

**Example - WeakSet:**
```javascript
const weakSet = new WeakSet();
let obj = { id: 1 };

weakSet.add(obj);
console.log(weakSet.has(obj)); // true

obj = null;
console.log(weakSet.has(obj)); // false
```

**Key Differences:**

| Feature | Map/Set | WeakMap/WeakSet |
|---------|---------|-----------------|
| Keys/Values | Any type | Objects only |
| Iteration | Iterable | Not iterable |
| Size property | Yes | No |
| Garbage Collection | Prevents GC | Allows GC |
| Use case | Permanent storage | Temporary/cache |

**Use Cases:**
- **Cache management:** Store temporary data that can be cleaned up
- **Private data:** Associate metadata with objects
- **Memory leaks prevention:** Automatic cleanup when objects are no longer needed

**Why Use Them?**
Regular Maps/Sets hold strong references, preventing garbage collection. WeakMap/WeakSet allow automatic cleanup, improving memory efficiency.
</Accordion>

<Accordion title="27. How does JavaScript handle memory management?">
**Answer**:
JavaScript manages memory automatically through two main processes: memory allocation and garbage collection.

**1. Memory Allocation:**

**Stack Memory (Temporary):**
- Stores primitive data types
- Fixed size, fast access
- Automatically cleaned when out of scope

```javascript
let x = 10;           // Stored in stack
let name = 'John';    // Stored in stack
let flag = true;      // Stored in stack
```

**Heap Memory (Permanent):**
- Stores non-primitive data types (objects, arrays, functions)
- Dynamic size, slower access
- Requires garbage collection

```javascript
let person = { name: 'John' };  // Object in heap
let numbers = [1, 2, 3];        // Array in heap
```

**2. Garbage Collection (Mark and Sweep):**

JavaScript uses the "Mark-and-Sweep" algorithm:

**Step 1 - Mark:**
```javascript
let x = 10;              // References 10
let name = 'Sara';       // References 'Sara'
let flag = true;         // References true
let tableJoker = null;   // References nothing (marked)
let bookData = { title: 'Book' }; // References object
```

**Step 2 - Sweep:**
- Variables referencing `null` or out of scope are garbage collected
- Memory is freed for new allocations

**Visual Example:**
```
Variables → References → Objects
---------------------------------
x          → 10
name       → 'Sara'
flag       → true
tableJoker → null        [MARKED FOR DELETION]
bookData   → { object }
```

**Memory Leaks to Avoid:**
```javascript
// Bad: Global variables never garbage collected
var globalData = new Array(1000000);

// Good: Use local scope
function processData() {
    let localData = new Array(1000000);
    // ... use data
    // Automatically freed when function ends
}

// Bad: Forgotten event listeners
element.addEventListener('click', handler);
// If element removed but listener not removed = memory leak

// Good: Remove listeners
element.removeEventListener('click', handler);
```

**Automatic Process:**
JavaScript handles this automatically, but understanding it helps write memory-efficient code.
</Accordion>

<Accordion title="28. Describe the difference between shallow copy and deep copy">
**Answer**:
Shallow and deep copies differ in how they handle nested objects and references.

**Shallow Copy:**
- Copies main properties
- Nested objects/arrays remain referenced (not copied)
- Changes to nested items affect original

**Deep Copy:**
- Copies everything, including nested objects
- Creates completely independent clone
- Changes don't affect original

**Analogy:**
- **Shallow Copy:** Photo of a tree (change photo, tree changes - cursed photo!)
- **Deep Copy:** Clone of a tree (change clone, original unaffected)

**Shallow Copy Examples:**

```javascript
const original = {
    name: 'John',
    address: {
        city: 'Delhi'
    }
};

// Method 1: Object.assign()
const shallowCopy1 = Object.assign({}, original);

// Method 2: Spread operator
const shallowCopy2 = { ...original };

// Problem: Modifying nested object affects original
shallowCopy2.address.city = 'Mumbai';
console.log(original.address.city); // 'Mumbai' (original changed!)
```

**Deep Copy Examples:**

```javascript
const original = {
    name: 'John',
    address: {
        city: 'Delhi'
    }
};

// Method 1: JSON parse/stringify (most common)
const deepCopy = JSON.parse(JSON.stringify(original));

// Safe: Modifying nested object doesn't affect original
deepCopy.address.city = 'Mumbai';
console.log(original.address.city); // 'Delhi' (original unchanged!)
console.log(deepCopy.address.city); // 'Mumbai'

// Method 2: structuredClone (modern browsers)
const deepCopy2 = structuredClone(original);
```

**Comparison:**

| Operation | Shallow Copy | Deep Copy |
|-----------|--------------|-----------|
| Top-level properties | Copied | Copied |
| Nested objects | Referenced | Copied |
| Independence | Partial | Complete |
| Performance | Fast | Slower |
| Methods | `{...obj}`, `Object.assign()` | `JSON.parse(JSON.stringify())` |

**When to Use:**
- **Shallow:** Simple objects, performance critical
- **Deep:** Complex nested structures, complete independence needed
</Accordion>

<Accordion title="29. What is JavaScript's strict mode and how is it enabled?">
**Answer**:
Strict mode is a way to opt into a restricted variant of JavaScript that catches common coding errors and prevents unsafe actions.

**Enable Strict Mode:**
```javascript
'use strict';
```

**Benefits of Strict Mode:**

**1. Prevents Undeclared Variables:**
```javascript
'use strict';
x = 10; // Error: x is not defined

// Without strict mode
x = 10; // Works, creates global variable (bad!)
```

**2. Prevents Assignment to Read-Only Properties:**
```javascript
'use strict';
const obj = {};
Object.defineProperty(obj, 'prop', {
    value: 40,
    writable: false
});

obj.prop = 50; // Error: Cannot assign to read-only property

// Without strict mode: silently fails (dangerous!)
```

**3. Prevents `this` as Global Object:**
```javascript
'use strict';
function show() {
    console.log(this);
}
show(); // undefined

// Without strict mode
show(); // Window object (data leak risk!)
```

**4. Disallows `with` Statement:**
```javascript
'use strict';
with (Math) {
    console.log(sqrt(4)); // Error: with not allowed
}

// Without strict mode: works but unpredictable
```

**5. Secures `eval()`:**
```javascript
'use strict';
eval('var x = 10');
console.log(x); // Error: x is not defined (contained in eval)

// Without strict mode: x leaks to outer scope
```

**6. Prevents Duplicate Parameters:**
```javascript
'use strict';
function sum(a, a, c) { // Error: Duplicate parameter name
    return a + a + c;
}

// Without strict mode: silently uses last 'a'
```

**How to Enable:**

```javascript
// Global scope (entire file)
'use strict';
function myFunction() {
    // strict mode
}

// Function scope (specific function)
function myFunction() {
    'use strict';
    // strict mode only in this function
}
```

**When to Use:**
- Modern JavaScript development (always recommended)
- Prevents common mistakes
- Makes debugging easier
- Required for ES6 modules (automatic)
</Accordion>

<Accordion title="30. Explain the Observer pattern and how it relates to JavaScript">
**Answer**:
The Observer pattern is a design pattern where an object (subject) maintains a list of dependents (observers) and notifies them automatically of state changes.

**Components:**
1. **Subject:** Object being observed (e.g., YouTube channel)
2. **Observers:** Objects watching the subject (e.g., subscribers)
3. **Notification:** Mechanism to alert observers (e.g., notifications)

**Real-World Analogy:**
- **Influencer** (Subject) posts new content
- **Subscribers** (Observers) get notified
- **YouTube** (Platform) handles notification system

**Implementation Example:**

```javascript
// Subject (Observable)
class YouTubeChannel {
    constructor() {
        this.subscribers = [];
    }
    
    subscribe(observer) {
        this.subscribers.push(observer);
    }
    
    unsubscribe(observer) {
        this.subscribers = this.subscribers.filter(sub => sub !== observer);
    }
    
    notify(video) {
        this.subscribers.forEach(subscriber => {
            subscriber.update(video);
        });
    }
    
    uploadVideo(video) {
        console.log(`Uploading: ${video}`);
        this.notify(video);
    }
}

// Observers
class Subscriber {
    constructor(name) {
        this.name = name;
    }
    
    update(video) {
        console.log(`${this.name} notified: New video "${video}"`);
    }
}

// Usage
const channel = new YouTubeChannel();

const alice = new Subscriber('Alice');
const bob = new Subscriber('Bob');

channel.subscribe(alice);
channel.subscribe(bob);

channel.uploadVideo('JavaScript Tutorial');
// Output:
// Uploading: JavaScript Tutorial
// Alice notified: New video "JavaScript Tutorial"
// Bob notified: New video "JavaScript Tutorial"
```

**JavaScript Event Listener (Observer Pattern):**
```javascript
const button = document.getElementById('myButton');

// Observer 1
button.addEventListener('click', () => {
    console.log('Observer 1 notified');
});

// Observer 2
button.addEventListener('click', () => {
    console.log('Observer 2 notified');
});

// Click button → both observers notified
```

**Benefits:**
- **Loose Coupling:** Subject doesn't need to know observer details
- **Dynamic Relationships:** Add/remove observers at runtime
- **Broadcast Communication:** One-to-many notifications
- **Scalability:** Easy to add new observers

**Use Cases in JavaScript:**
- Event listeners (DOM events)
- State management (Redux, MobX)
- Pub/Sub systems
- Real-time updates (WebSocket notifications)
</Accordion>
</AccordionGroup>
