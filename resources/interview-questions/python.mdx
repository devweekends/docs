---
title: "Python (Core & Backend)"
description: "Core Language, OOP, Asyncio, and Backend Architecture"
icon: "python"
---

# Python Interview Questions (60+ Deep Dive Q&A)

## 1. Core Language & Data Structures

<AccordionGroup>
<Accordion title="1. Python Memory Management (The 3 Pillars)">
**Answer**:
1.  **Private Heap**: Where all objects/data live. Managed by Memory Manager.
2.  **Raw Memory Allocator**: Interaction with OS (malloc).
3.  **Object-Specific Allocators**: Pymalloc (for small objects < 512 bytes). Optimize fragmentation.
**Garbage Collection**: Reference Counting (Primary) + Cyclic GC (Secondary).
</Accordion>

<Accordion title="2. List vs Tuple vs Set vs Dictionary">
**Answer**:
| Type | Mutable | Ordered | Allow Duplicates | Lookup Cost |
| :--- | :--- | :--- | :--- | :--- |
| **List** | Yes | Yes | Yes | O(N) |
| **Tuple** | No | Yes | Yes | O(N) |
| **Set** | Yes | No | No | O(1) |
| **Dict** | Yes | Yes (3.7+) | Keys: No | O(1) |
</Accordion>

<Accordion title="3. `__init__` vs `__new__` (Diagram)">
**Answer**:
*   `__new__`: The **Allocating** phase. Returns the object. (Static method).
*   `__init__`: The **Initializing** phase. Sets attributes. (Instance method).
**Flow**: `Class()` call -> `__new__` -> creates instance -> `__init__(instance)` -> sets props.
</Accordion>

<Accordion title="4. MRO (Method Resolution Order)">
**Answer**:
Algorithm to determine which class method to call in Multiple Inheritance.
**C3 Linearization**.
Ensures subclasses are checked before parents, and order of parents is preserved.
`ClassName.mro()` or `help(ClassName)` calls show the order.
</Accordion>

<Accordion title="5. Decorators (Internals)">
**Answer**:
Functions that modify other functions.
A decorator `wraps` the target.
```python
def log(func):
    def wrapper(*args):
        print("Call")
        return func(*args)
    return wrapper

@log
def add(): pass
# Equivalent to: add = log(add)
```
</Accordion>

<Accordion title="6. Generators vs Iterators">
**Answer**:
All Generators are Iterators, but not vice versa.
*   **Iterator**: Class with `__next__` and `__iter__`. State managed manually.
*   **Generator**: Function with `yield`. State managed auto. Pauses execution. High memory efficiency.
</Accordion>

<Accordion title="7. Context Managers (The `with` statement)">
**Answer**:
Ensures resource cleanup (Files, Locks, DB).
Implements `__enter__` (setup) and `__exit__` (teardown).
**Exception Handling**: `__exit__` receives exception details. Return `True` to suppress.
</Accordion>

<Accordion title="8. Lambdas">
**Answer**:
Anonymous one-line functions.
`lambda x: x * 2`.
Limited: No statements (assignment, while), only expressions.
Used often with `map`, `filter`, `sort(key=...)`.
</Accordion>

<Accordion title="9. `*args` and `**kwargs`">
**Answer**:
Variable length arguments.
*   `*args`: Tuple of positional args.
*   `**kwargs`: Dictionary of keyword args.
**Unpacking**: `func(*my_list)` expands list into args.
</Accordion>

<Accordion title="10. Shallow vs Deep Copy">
**Code**:
```python
l1 = [[1], 2]
l2 = copy.copy(l1)    # Shallow: l2[0] POINTS TO same list as l1[0]
l3 = copy.deepcopy(l1)# Deep: l3[0] is a NEW list
```
</Accordion>
</AccordionGroup>

## 2. Advanced OOP

<AccordionGroup>
<Accordion title="11. Encapsulation (Public, Protected, Private)">
**Answer**:
*   `name`: Public.
*   `_name`: Protected (Convention only). "Internal use".
*   `__name`: Private (Name Mangling). Becomes `_Class__name`. Harder to access.
python has no strict enforcement (we are all consenting adults).
</Accordion>

<Accordion title="12. Abstract Base Classes (ABC)">
**Answer**:
Enforce Interface implementation.
```python
from abc import ABC, abstractmethod
class Animal(ABC):
    @abstractmethod
    def speak(self): pass
```
Cannot instantiate `Animal`. Subclass MUST implement `speak`.
</Accordion>

<Accordion title="13. `__slots__` Optimization">
**Answer**:
By default, objects store attributes in a `__dict__` (dynamic). Uses RAM.
`__slots__ = ['x', 'y']` tells Python "This class ONLY has x and y".
Allocates fixed array. Saves memory for millions of objects.
</Accordion>

<Accordion title="14. Property Decorators (Getters/Setters)">
**Answer**:
Pythonic way to encapsulate.
```python
@property
def age(self): return self._age
@age.setter
def age(self, val): self._age = val
```
Access as `obj.age` (looks like attribute, runs like method).
</Accordion>

<Accordion title="15. Duck Typing vs Static Typing">
**Answer**:
*   **Duck**: "If it has `quack()`, it's a Duck". Runtime check.
*   **Static (Hints)**: `def quack(d: Duck) -> None:`. Analysis tool check (Mypy).
</Accordion>

<Accordion title="16. Composition vs Inheritance">
**Answer**:
*   **Inheritance**: "Is-A". `Car` is a `Vehicle`. Rigid.
*   **Composition**: "Has-A". `Car` has an `Engine`. Flexible.
**Prefer Composition** to avoid Deep Inheritance hierarchies (Fragile Base Class problem).
</Accordion>

<Accordion title="17. Method Overloading?">
**Answer**:
Python does **NOT** support traditional overloading (multiple methods same name, diff args). Last one defined wins.
**Solution**:
1.  Default args (`def f(a, b=None)`).
2.  `*args`.
3.  `@functools.singledispatch`.
</Accordion>

<Accordion title="18. Singletons">
**Answer**:
Ensure one instance exists.
1.  **Module**: Modules are singletons.
2.  **`__new__`**: Check `if cls._instance is None`.
3.  **Decorator**: Wrap class.
</Accordion>

<Accordion title="19. Enum Class">
**Answer**:
`from enum import Enum`.
Immutable constants.
`Color.RED` is distinct from string "RED" and int 1.
</Accordion>

<Accordion title="20. Dataclasses (3.7+)">
**Answer**:
Boilerplate generator.
Auto generates `__init__`, `__repr__`, `__eq__`.
```python
@dataclass
class Point:
    x: int
    y: int
```
</Accordion>
</AccordionGroup>

## 3. Asyncio & Concurrency

<AccordionGroup>
<Accordion title="21. Threading vs Multiprocessing vs Asyncio">
**Answer**:
*   **Threading**: OS Threads. 1 CPU core (GIL). Good for I/O blocking (Network).
*   **Multiprocessing**: OS Processes. All cores. Good for CPU Heavy. High overhead.
*   **Asyncio**: Single Thread. Cooperative Multitasking. Good for Massive I/O (10k connections).
</Accordion>

<Accordion title="22. GIL (Global Interpreter Lock)">
**Answer**:
Mutex protecting Python objects.
Only one thread executes Bytecode at a time.
Why? CPython memory management is not thread-safe.
**Impact**: Multi-threaded CPU tasks (Matrix mult) are SLOWER than single thread.
</Accordion>

<Accordion title="23. Event Loop Explained">
**Answer**:
Infinite loop: "Is new task ready? No. Is IO complete? Yes -> Resume callback".
**Coroutines** (`async def`) yield control (`await`) when blocked.
Loop runs other tasks.
</Accordion>

<Accordion title="24. `await` keyword">
**Answer**:
"Pause execution of this coroutine, yield control to loop, and come back when result is ready".
Can only be used inside `async def`.
</Accordion>

<Accordion title="25. Race Conditions in Asyncio?">
**Answer**:
Yes!
Asyncio is cooperatively scheduled, but if two tasks modify shared state across `awaits`, race happens.
Locking is still needed (`asyncio.Lock`).
</Accordion>

<Accordion title="26. Blocking Code in Async">
**Answer**:
Disaster. `time.sleep(10)` blocks the **entire Loop**. No other interaction possible.
**Fix**: `await asyncio.sleep(10)`.
For CPU logic: `loop.run_in_executor` (Offload to ThreadPool).
</Accordion>

<Accordion title="27. `asyncio.gather`">
**Answer**:
Run multiple awaitables concurrently.
Waits for all to finish.
`results = await asyncio.gather(task1(), task2())`.
</Accordion>

<Accordion title="28. Async Context Managers">
**Answer**:
`async with conn.transaction():`.
Methods `__aenter__` and `__aexit__`.
Needed for async cleanup (e.g., closing DB pool).
</Accordion>

<Accordion title="29. Async Iterators">
**Answer**:
`async for item in fetch_stream():`.
Methods `__aiter__` and `__anext__`.
Used for streaming data.
</Accordion>

<Accordion title="30. UVLoop">
**Answer**:
Fast implementation of Event Loop using `libuv` (Node.js engine).
Makes Python Asyncio 2-4x faster.
</Accordion>
</AccordionGroup>

## 4. Backend & Web (Django/FastAPI)

<AccordionGroup>
<Accordion title="31. WSGI vs ASGI">
**Answer**:
*   **WSGI**: Sync Standard (Flask, Django). Blocking.
*   **ASGI**: Async Standard (FastAPI, Django Channels). Supports WebSockets, HTTP2.
</Accordion>

<Accordion title="32. FastAPI Features">
**Answer**:
1.  **Speed**: Native Async/Starlette.
2.  **Validation**: Pydantic models.
3.  **Docs**: Auto Swagger/OpenAPI.
4.  **DI**: Powerful Dependency Injection system.
</Accordion>

<Accordion title="33. Django ORM N+1 Problem">
**Answer**:
Looping over objects and hitting DB for each relation.
**Code**: `for book in books: print(book.author.name)`.
**Fix**: `select_related` (Join / FK) or `prefetch_related` (M2M / Reverse FK).
</Accordion>

<Accordion title="34. Middleware">
**Answer**:
Hooks processed **Before** view and **After** view.
Use: Auth, Logging, CORS, GZip.
</Accordion>

<Accordion title="35. CSRF in Django">
**Answer**:
Cross Site Request Forgery.
Django checks for `csrf_token` in POST data matching the cookie.
Prevents external forms from posting to your server.
</Accordion>

<Accordion title="36. Gunicorn vs Uvicorn">
**Answer**:
*   **Gunicorn**: Process Manager. For Production. Spawns workers.
*   **Uvicorn**: ASGI Worker. Runs the Async code.
*   **Setup**: Gunicorn manages Uvicorn workers.
</Accordion>

<Accordion title="37. REST vs GraphQL">
**Answer**:
*   **REST**: Multiple endpoints. Fixed structure. Over/Under fetching.
*   **GraphQL**: Single Endpoint. Client defines structure. Exact fetching. Complex caching.
</Accordion>

<Accordion title="38. DB Migrations">
**Answer**:
Version Control for Database Schema.
(Alembic, Django Migrations).
Applying changes (Up) or Reverting (Down) reproducibly.
</Accordion>

<Accordion title="39. Session vs JWT Auth">
**Answer**:
*   **Session**: Server stores state (Memory/Redis). Cookie ID. Revocable.
*   **JWT**: Client stores state (Signature). Stateless. Scalable. Hard to revoke.
</Accordion>

<Accordion title="40. Dependency Injection">
**Answer**:
Passing dependencies (DB connection, Config) to function instead of hardcoding.
FastAPI: `def route(db: Session = Depends(get_db)):`.
Unit testing becomes easy (Pass Mock DB).
</Accordion>
</AccordionGroup>

## 5. Coding Scenarios & Snippets

<AccordionGroup>
<Accordion title="41. Flatten Nested List (Recursive)">
**Code**:
```python
def flatten(l):
    res = []
    for i in l:
        if isinstance(i, list): res.extend(flatten(i))
        else: res.append(i)
    return res
```
</Accordion>

<Accordion title="42. LRU Cache Implementation (Concept)">
**Answer**:
Doubly Linked List (Order) + Hash Map (Lookup).
Get: O(1). Move Node to Head.
Put: O(1). Add Head. If full, Remove Tail.
Python: `@functools.lru_cache`.
</Accordion>

<Accordion title="43. Singleton Decorator">
**Code**:
```python
def singleton(cls):
    instances = {}
    def wrapper(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return wrapper
```
</Accordion>

<Accordion title="44. Reverse String (Slicing)">
**Code**:
`s[::-1]`.
Detailed: `s[start:stop:step]`. Step -1 implies reverse.
</Accordion>

<Accordion title="45. Find Duplicates">
**Code**:
```python
from collections import Counter
counts = Counter(nums)
dups = [k for k,v in counts.items() if v > 1]
```
</Accordion>

<Accordion title="46. Binary Search (Bisect)">
**Answer**:
`import bisect`.
`bisect.bisect_left(arr, x)` returns index.
Array must be sorted.
</Accordion>

<Accordion title="47. Context Manager Class">
**Code**:
```python
class MyFile:
    def __enter__(self):
        self.f = open('a.txt')
        return self.f
    def __exit__(self, type, value, tb):
        self.f.close()
```
</Accordion>

<Accordion title="48. Merge Dictionaries">
**Code**:
`z = {**x, **y}` or `x | y` (Py 3.9).
</Accordion>

<Accordion title="49. Reading Huge File">
**Code**:
Don't use `read()`. Use iterator.
```python
with open('big.log') as f:
    for line in f:
        process(line)
```
</Accordion>

<Accordion title="50. Sort list of dicts by key">
**Code**:
```python
data.sort(key=lambda x: x['age'])
```
</Accordion>
</AccordionGroup>

## 6. Edge Cases & Trivia

<AccordionGroup>
<Accordion title="51. `is` vs `==`">
**Answer**:
*   `==`: Value equality (`__eq__`).
*   `is`: Identity equality (Memory Address).
`a = [1]; b = [1]`. `a == b` (True). `a is b` (False).
</Accordion>

<Accordion title="52. Mutable Default Args">
**Answer**:
Default args evaluated **once** at definition.
`def f(l=[])`: `l` is shared across all calls.
**Fix**: `l=None`.
</Accordion>

<Accordion title="53. Python Bytecode">
**Answer**:
Python compiles `.py` to `.pyc` (Bytecode). Stack-based VM executes it.
`import dis; dis.dis(func)`.
</Accordion>

<Accordion title="54. `__name__ == '__main__'`">
**Answer**:
Guard clause.
Runs code only if script is executed directly (`python app.py`), not when imported (`import app`).
</Accordion>

<Accordion title="55. Monkey Patching">
**Answer**:
Runtime modification of class/module.
Use: Testing (Mocking).
Risk: Hard to debug.
</Accordion>

<Accordion title="56. `pass` vs `...` (Ellipsis)">
**Answer**:
*   `pass`: No-op statement.
*   `...`: Singleton object. Used in Type Hinting (`Callable[..., int]`) or Slicing.
</Accordion>

<Accordion title="57. Pickling security">
**Answer**:
Pickle defines how to construct objects.
Malicious pickle can execute arbitrary code during unpickling.
**Never** unpickle untrusted data.
</Accordion>

<Accordion title="58. `__dict__`">
**Answer**:
Dictionary storing object attributes.
`obj.x` -> `obj.__dict__['x']`.
Classes using `__slots__` don't have this.
</Accordion>

<Accordion title="59. Python Path">
**Answer**:
`sys.path`. List of directories Python searches for imports.
First entry is current directory.
</Accordion>

<Accordion title="60. PyPy vs CPython">
**Answer**:
*   **CPython**: Standard interpreter. C. Uses Ref Counting.
*   **PyPy**: JIT Compiler. Fast. Uses Tracing JIT. Bad for C-Extensions (NumPy).
</Accordion>
</AccordionGroup>
