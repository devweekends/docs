---
title: "Python (Deep Dive)"
description: "Internals, Data Structures, Concurrency, and Low-Level Details"
icon: "python"
---

# Python Interview Questions (60+ Deep Dive Q&A)

## 1. Python Internals (CPython)

<AccordionGroup>
<Accordion title="1. Global Interpreter Lock (GIL)">
**Answer**:
A mutex that prevents multiple native threads from executing Python bytecodes at once.
This means Python threads are **Concurrency** (Task switching) not **Parallelism** (Simultaneous CPU use).
*   **Why?**: Memory management (Reference Counting) is not thread-safe.
*   **Impact**: CPU-bound tasks are slow. IO-bound tasks are fine (GIL releases on IO).
*   **Workaround**: `multiprocessing` or C-extensions (NumPy releases GIL).
</Accordion>

<Accordion title="2. Garbage Collection (Reference Counting + Generational)">
**Answer**:
*   **Primary Mechanism**: **Reference Counting**. Every object tracks references. If count == 0, deallocate immediately.
*   **Secondary**: **Generational GC** (cyclic). Detects cycles (`A->B->A`).
    *   Gen 0 (Young), Gen 1, Gen 2 (Old). Objects promoted if they survive.
    *   `gc.collect()` triggers manual sweep.
</Accordion>

<Accordion title="3. `list` vs `tuple` Memory Implementation">
**Answer**:
| Feature | List | Tuple |
| :--- | :--- | :--- |
| **Mutability** | Mutable | Immutable |
| **Size** | Larger (Over-allocates for resize) | Exact size (Smaller) |
| **Hashable** | No (Cannot be dict key) | Yes |
| **Speed** | Slower (Two pointers) | Faster (Cached by runtime) |

**Code**:
```python
import sys
sys.getsizeof([]) # 56 bytes
sys.getsizeof(()) # 40 bytes
```
</Accordion>

<Accordion title="4. How `dict` works (Hash Table)">
**Answer**:
1.  Compute `hash(key)`.
2.  Index = `hash(key) & (SIZE - 1)`.
3.  **Collision Handling**: Open Addressing (not Chaining). Uses Pseudo-random probing.
4.  **Resize**: When 2/3 full, size doubles. Re-hashes everything.
5.  **Ordering**: As of 3.7+, insertion order is preserved using sparse array indices.
</Accordion>

<Accordion title="5. Mutable Default Arguments">
**Answer**:
**Gotcha**: Default args are evaluated **once** at definition time, not call time.
```python
def append_to(num, target=[]):
    target.append(num)
    return target

print(append_to(1)) # [1]
print(append_to(2)) # [1, 2] !! Shared object
```
**Fix**: Use `None`.
</Accordion>

<Accordion title="6. `__new__` vs `__init__`">
**Answer**:
*   `__new__`: Static method. **Creates** the instance. Returns it. (Used for Singleton, Immutable types like tuple).
*   `__init__`: Instance method. **Initializes** the created instance. Returns None.
</Accordion>

<Accordion title="7. Metaclasses">
**Answer**:
Classes are objects. Metaclasses are the "Classes of Classes".
Control class creation (`type` is the default metaclass).
**Use**: Validation, Auto-registering plugins, ORMs (Django models).
```python
class Meta(type):
    def __new__(cls, name, bases, dct):
        # Validate or Modify class definition
        return super().__new__(cls, name, bases, dct)
```
</Accordion>

<Accordion title="8. Iterator vs Iterable">
**Answer**:
*   **Iterable**: Has `__iter__`. Can be looped over. (`list`, `str`).
*   **Iterator**: Has `__next__`. Keeps state. `next(it)` yields value.
*   Looping calls `iter(obj)` then calls `next()` until `StopIteration`.
</Accordion>

<Accordion title="9. Decorators (Function vs Class)">
**Answer**:
Syntactic sugar for `func = wrapper(func)`.
**Closure**: Inner function remembers outer scope variables.
`@functools.wraps` is needed to preserve metadata (`__name__`, docstring).
</Accordion>

<Accordion title="10. Duck Typing">
**Answer**:
"If it walks like a duck...".
Python doesn't check Type; it checks Methods.
If an object has `__len__`, `len()` works on it.
Use `Protocol` (Python 3.8+) for static duck typing.
</Accordion>
</AccordionGroup>

## 2. Advanced Data Structures & Algo

<AccordionGroup>
<Accordion title="11. `collections.defaultdict`">
**Answer**:
Subclass of dict.
Avoids `KeyError`.
Factory function creates missing values.
**Pattern**: Adjacency List for Graphs.
```python
g = defaultdict(list)
g['A'].append('B')
```
</Accordion>

<Accordion title="12. `heapq` (Min Heap)">
**Answer**:
Binary Heap in array `O(1)` access.
`push`: `O(log n)`. `pop`: `O(log n)`.
**Max Heap**: Push negative numbers `-x`.
**Use**: Priority Queue, Top K elements (`nlargest`).
</Accordion>

<Accordion title="13. `deque` (Doubly Linked List)">
**Answer**:
`collections.deque`.
O(1) append/pop at **both ends**.
List is O(n) for pop(0) (shifting elements).
**Use**: Queue (BFS), Sliding Window.
</Accordion>

<Accordion title="14. Understanding `yield` (Generators)">
**Answer**:
Lazy evaluation.
Pauses function execution, saves state, yields value.
Memory efficient. Infinite sequences.
`yield from`: Delegate to sub-generator.
</Accordion>

<Accordion title="15. LRU Cache (`functools`)">
**Answer**:
Least Recently Used replacement policy.
`@lru_cache(maxsize=128)`.
Memoization for DP problems.
```python
@lru_cache(None)
def fib(n):
    if n < 2: return n
    return fib(n-1) + fib(n-2)
```
</Accordion>

<Accordion title="16. Deep Copy vs Shallow Copy">
**Answer**:
*   `a = b`: Alias. Same ID.
*   `copy.copy(a)`: Shallow. New container, same child objects.
*   `copy.deepcopy(a)`: Recursive. New container, new child objects. Slower.
</Accordion>

<Accordion title="17. `__slots__`">
**Answer**:
Optimization.
Tells Python: "This class only has these attributes".
Prevents creation of `__dict__` for each instance.
Saves RAM. Faster attribute access.
</Accordion>

<Accordion title="18. Context Managers (`with`)">
**Answer**:
Protocol: `__enter__` and `__exit__`.
Ensures cleanup (Close file, Release lock) even if exception occurs.
`contextlib.contextmanager` decorator converts generator to context manager.
</Accordion>

<Accordion title="19. Binary Search (`bisect`)">
**Answer**:
Standard library module.
`bisect_left` (lower_bound), `bisect_right` (upper_bound).
Works on sorted lists. O(log n).
</Accordion>

<Accordion title="20. Sorting Stability (Timsort)">
**Answer**:
Python's sort is Stable (Preserves order of equal elements).
Hybrid: Merge Sort + Insertion Sort.
Worst case O(N log N). Best O(N).
</Accordion>
</AccordionGroup>

## 3. Concurrency (Threading vs AsyncIO)

<AccordionGroup>
<Accordion title="21. Threading vs Multiprocessing Matrix">
**Answer**:
| | Threading | Multiprocessing |
| :--- | :--- | :--- |
| **GIL** | Shared (Locked) | Separate (Bypassed) |
| **Memory** | Shared implementation | Separate Space (Pickling needed) |
| **Best For** | I/O Bound (Network, Disk) | CPU Bound (Math, Image Proc) |
| **Overhead** | Low | High (Process creation) |
</Accordion>

<Accordion title="22. AsyncIO (Event Loop)">
**Answer**:
Single-threaded Cooperative Multitasking.
`async` / `await`.
Tasks yield control when waiting for I/O.
No context switching overhead.
**Code**:
```python
async def main():
    task = asyncio.create_task(fetch_data())
    await task
```
</Accordion>

<Accordion title="23. Race Conditions & Locks">
**Answer**:
Two threads modify shared data. `x += 1` is not atomic (Read, Add, Write).
**Fix**: `threading.Lock`.
`with lock: x += 1`.
</Accordion>

<Accordion title="24. Deadlocks">
**Answer**:
Circular dependency of resources.
T1 holds A, needs B. T2 holds B, needs A.
**Fix**: Acquire locks in same order. Use `timeout`.
</Accordion>

<Accordion title="25. Producer-Consumer Pattern (`queue`)">
**Answer**:
Thread-safe `queue.Queue`.
Producer puts, Consumer gets.
`q.join()` waits for processing.
Handles synchronization automatically.
</Accordion>

<Accordion title="26. ThreadPoolExecutor">
**Answer**:
`concurrent.futures`.
High-level abstraction.
```python
with ThreadPoolExecutor(max_workers=5) as ex:
    results = ex.map(dnl_img, urls)
```
</Accordion>

<Accordion title="27. Coroutines vs Threads">
**Answer**:
*   **Thread**: OS managed. Preemptive (OS interrupts). Heavy stack.
*   **Coroutine**: App managed. Cooperative (Must await). Light stack.
</Accordion>

<Accordion title="28. CPU Binding">
**Answer**:
Multiprocessing doesn't strictly bind to cores.
OS Scheduler decides.
Use `os.sched_setaffinity` to pin process to CPU core.
</Accordion>

<Accordion title="29. What is `uvloop`?">
**Answer**:
Drop-in replacement for asyncio event loop.
Implemented in Cython (libuv, same as Node.js).
Makes Python async 2-4x faster.
</Accordion>

<Accordion title="30. `multiprocessing.Pool` vs `Process`">
**Answer**:
*   **Pool**: Map task to fixed workers. Returns results. Good for Data Parallelism.
*   **Process**: Manual start/join. Good for long-running services.
</Accordion>
</AccordionGroup>

## 4. Coding Scenarios (Snippets)

<AccordionGroup>
<Accordion title="31. Singleton Pattern in Python">
**Answer**:
```python
class Singleton:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
```
Or use a Decorator. Or just a Module (Modules are singletons).
</Accordion>

<Accordion title="32. Flatten Nested List (Recursive vs Iterative)">
**Code**:
```python
def flatten(lst):
    for i in lst:
        if isinstance(i, list):
            yield from flatten(i)
        else:
            yield i
```
</Accordion>

<Accordion title="33. Merge Two Dictionaries">
**Code**:
```python
# Python 3.9+
z = x | y

# Older
z = {**x, **y}
```
</Accordion>

<Accordion title="34. Count Frequencies">
**Code**:
```python
from collections import Counter
c = Counter(words)
top_3 = c.most_common(3)
```
</Accordion>

<Accordion title="35. Remove Duplicates (Stable)">
**Code**:
`list(set(l))` is unstable (Order lost).
**Stable**:
```python
seen = set()
res = [x for x in l if not (x in seen or seen.add(x))]
```
</Accordion>

<Accordion title="36. Transpose Matrix">
**Code**:
`zip` is powerful.
```python
matrix = [[1,2],[3,4]]
transposed = list(zip(*matrix)) # [(1,3), (2,4)]
```
</Accordion>

<Accordion title="37. Measuring Execution Time">
**Code**:
Decorator pattern.
```python
def timeit(func):
    def wrapper(*args, **kwargs):
        t1 = time.time()
        res = func(*args, **kwargs)
        print(f"{time.time()-t1}s")
        return res
    return wrapper
```
</Accordion>

<Accordion title="38. Reading Massive File">
**Code**:
Generator to yield chunks.
```python
def read_chunks(file, size=1024):
    while True:
        data = file.read(size)
        if not data: break
        yield data
```
</Accordion>

<Accordion title="39. JSON Date Serialization">
**Answer**:
`datetime` is not JSON serializable.
Custom encoder:
```python
json.dumps(data, default=str)
```
</Accordion>

<Accordion title="40. Pandas: Apply vs Vectorization">
**Answer**:
*   **Loop**: Slowest.
*   **Apply**: Python level loop. Slow.
*   **Vectorized**: `df['a'] + df['b']`. C-level. Fastest.
</Accordion>
</AccordionGroup>

## 5. System Design (Python context)

<AccordionGroup>
<Accordion title="41. WSGI vs ASGI">
**Answer**:
*   **WSGI**: Sync. (Flask, Django default). One req per thread.
*   **ASGI**: Async. (FastAPI, Django Channels). Handles WebSockets, Long polling.
</Accordion>

<Accordion title="42. Celery (Task Queue)">
**Answer**:
Offload heavy tasks (Email, Report gen).
**Broker**: Redis/RabbitMQ.
**Worker**: Consumes tasks.
**Backend**: Stores results.
</Accordion>

<Accordion title="43. Python Packaging (Poetry vs Pip)">
**Answer**:
*   **Pip**: `requirements.txt`. Simple. No locking dependency resolution (historically).
*   **Poetry**: `pyproject.toml`. Deterministic lock file. Manages Venv. Publisher.
</Accordion>

<Accordion title="44. Testing (Pytest Fixtures)">
**Answer**:
Dependency Injection for tests.
Run `setUp` logic before tests.
Scopes: Function, Class, Module, Session (DB setup).
</Accordion>

<Accordion title="45. Typing (Mypy)">
**Answer**:
Static Type Checker.
Does not affect runtime.
Catches `AttributeError` / `TypeError` at compile time.
</Accordion>

<Accordion title="46. C-Extensions (Cython)">
**Answer**:
Write Python-like code with C types.
Compiles to C.
Huge speedup for tight loops.
</Accordion>

<Accordion title="47. Microservices in Python">
**Answer**:
FastAPI (High perf, Async).
gRPC (protos).
Docker (Small images via Alpine/Slim).
</Accordion>

<Accordion title="48. Dealing with Circular Imports">
**Answer**:
*   Import inside function/method (Runtime).
*   Use `TYPE_CHECKING` block for type hints.
*   Refactor: Extract common shared module.
</Accordion>

<Accordion title="49. Security (Pickle vs YAML)">
**Answer**:
Never unpickle untrusted data (RCE).
Never `SafeLoad` YAML.
Use JSON/Protobuf for serialization.
</Accordion>

<Accordion title="50. NumPy Internals (Strides)">
**Answer**:
Ndarray is contiguous block of memory.
**Strides**: Bytes to step to next element in dimension.
Allows slicing/views `arr[::-1]` without copying memory.
</Accordion>
</AccordionGroup>

## 6. Advanced Edge Cases

<AccordionGroup>
<Accordion title="51. Why is `d[key]` O(1)?">
**Answer**:
Hash calculation is fast. Array access is O(1).
Collision rate is low due to randomization.
Worst case O(N) if all hashes collide (DoS attack). Python 3.4+ randomizes hash seed.
</Accordion>

<Accordion title="52. `sys.setrecursionlimit`">
**Answer**:
Default 1000.
Prevents Stack Overflow (C-stack limit).
Tail Call Optimization (TCO)? No, Python doesn't support it. Stack frames accumulate.
</Accordion>

<Accordion title="53. Monkey Patching">
**Answer**:
Runtime modification of class/module.
Use: Mocking in tests.
Risk: Hard to debug. Spooky action at a distance.
</Accordion>

<Accordion title="54. `__dict__` vs `vars()`">
**Answer**:
`vars(obj)` returns `obj.__dict__`.
But `vars()` without args returns local scope.
</Accordion>

<Accordion title="55. How `super()` works (MRO)">
**Answer**:
Method Resolution Order (C3 Linearization).
`super()` delegates to the *next* class in MRO line, not just the parent.
Crucial for Diamond Inheritance.
</Accordion>

<Accordion title="56. `isinstance` vs `type()`">
**Answer**:
*   `type(x) == A`: Strict. Fails for subclasses.
*   `isinstance(x, A)`: True for subclass. Liskov Substitution Principle compliant.
</Accordion>

<Accordion title="57. Weak References (`weakref`)">
**Answer**:
Reference that doesn't increment ref count.
GC will destroy object if only weak refs exist.
Use: Caching (prevent memory leaks).
</Accordion>

<Accordion title="58. Disassembly (`dis`)">
**Answer**:
Inspect Bytecode.
`import dis; dis.dis(func)`.
Prove operations are atomic or not.
</Accordion>

<Accordion title="59. The `with` statement suppress exception?">
**Answer**:
If `__exit__` returns `True`, exception is suppressed.
Else it re-raises.
</Accordion>

<Accordion title="60. Descriptors">
**Answer**:
Objects defining `__get__`, `__set__`.
Basis for properties, methods, staticmethods, classmethods.
Low level magic.
</Accordion>
</AccordionGroup>
