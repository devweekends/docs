---
title: "Python (DSA & Scripting)"
description: "Data Structures, Agorithms, and Practical Scripting"
icon: "python"
---

# Python DSA & Scripting Questions (50+ Detailed Q&A)

## 1. Built-in Data Structures

<AccordionGroup>
<Accordion title="1. List vs Tuple">
**Answer**:
*   **List**: Mutable `[]`. Slower. Memory overhead.
*   **Tuple**: Immutable `()`. Hashable (Can be dict key). Faster.
</Accordion>

<Accordion title="2. Dict vs Set">
**Answer**:
*   **Dict**: Key-Value pairs. Hash Map. O(1) lookup.
*   **Set**: Unique Keys only. Math operations (Union, Intersection). O(1).
</Accordion>

<Accordion title="3. List Implementation">
**Answer**:
Dynamic Array.
Pointers to objects.
Resize strategy: allocate new block (1.125x growth) and copy. O(N).
Appends are amortized O(1).
</Accordion>

<Accordion title="4. Dictionary Internals">
**Answer**:
Hash Table with Open Addressing (Quadratic probing/Pseudo-random).
Since 3.7+ Insertion Ordered.
Load factor triggers resize.
</Accordion>

<Accordion title="5. Sorting (`Timsort`)">
**Answer**:
Python's `sort()` uses Timsort.
Hybrid of Merge Sort and Insertion Sort.
Stable. O(N log N).
Exploits existing runs in data.
</Accordion>

<Accordion title="6. `collections.deque`">
**Answer**:
Doubly Linked List.
O(1) append/pop at both ends.
List is O(N) for `pop(0)`.
Algorithm: BFS Queue.
</Accordion>

<Accordion title="7. `heapq` (Priority Queue)">
**Answer**:
Min-Heap implementation.
Binary Tree array.
`push`: O(log N). `pop`: O(log N). `min`: O(1).
Dijkstra / K-Top elements.
</Accordion>

<Accordion title="8. `collections.Counter`">
**Answer**:
Dict subclass for counting hashable objects.
`Counter("aabbb").most_common(1)`.
Operations: `+`, `-`, `&`, `|`.
</Accordion>

<Accordion title="9. `defaultdict`">
**Answer**:
Never raises KeyError.
Calls factory function (`int`, `list`) if key missing.
Graph adjacency list: `d = defaultdict(list)`.
</Accordion>

<Accordion title="10. Immutable types used as Keys">
**Answer**:
Only hashable types: int, str, tuple, frozen set.
Lists/Dicts cannot be keys.
</Accordion>
</AccordionGroup>

## 2. Algorithms & Coding Patterns

<AccordionGroup>
<Accordion title="11. Two Pointers">
**Pattern**:
Sorted Array / Linked List.
Left/Right or Slow/Fast.
**Use**: 2Sum Sorted, Palindrome, Cycle Detection (Floyd).
</Accordion>

<Accordion title="12. Sliding Window">
**Pattern**:
Subarray/Substring problems.
Expand Right. Shrink Left if condition breaks.
**Use**: Longest Substring No Repeats, Max Sum Subarray size K.
</Accordion>

<Accordion title="13. Binary Search">
**Pattern**:
Sorted Search space.
`mid = (L+R)//2`.
Time: O(log N).
**Gotcha**: Infinite loop (L <= R vs L < R).
</Accordion>

<Accordion title="14. DFS vs BFS">
**Answer**:
*   **DFS**: Stack (Recursion). Go deep. Path finding (Maze).
*   **BFS**: Queue. Level by level. Shortest path in unweighted graph.
</Accordion>

<Accordion title="15. Backtracking">
**Pattern**:
DFS + Undo.
Constructive problems.
**Use**: Permutations, Subsets, N-Queens, Sudoku.
</Accordion>

<Accordion title="16. Dynamic Programming (Memoization)">
**Pattern**:
Recursion + Cache.
Top-Down.
`@lru_cache`.
**Use**: Fibonacci, Climbing Stairs.
</Accordion>

<Accordion title="17. Dynamic Programming (Tabulation)">
**Pattern**:
Iterative. Bottom-Up.
DP table `dp[i]`.
Space optimization often possible.
</Accordion>

<Accordion title="18. Greedy">
**Pattern**:
Local optimal choice leads to global optimum.
**Use**: Intervals (Merge/Non-overlapping), Huffman codes.
**Proof**: Hard.
</Accordion>

<Accordion title="19. Union Find (Disjoint Set)">
**Pattern**:
Components in Graph.
`find()` and `union()`.
Optimizations: Path Compression, Rank.
**Use**: Kruskal MST, Network Connectivity.
</Accordion>

<Accordion title="20. Trie (Prefix Tree)">
**Answer**:
Tree of characters.
**Use**: Autocomplete, Spell checker.
Space heavy? Use hash map nodes.
</Accordion>
</AccordionGroup>

## 3. Pythonic Scenarios

<AccordionGroup>
<Accordion title="21. Flatten a nested list">
**Code**:
`[item for sublist in lst for item in sublist]`
Or `itertools.chain(*lst)`.
</Accordion>

<Accordion title="22. Reverse string/list">
**Code**:
Slicing `s[::-1]`.
In-place `lst.reverse()`.
</Accordion>

<Accordion title="23. F-strings">
**Answer**:
Formatted String Literals (3.6+). Uses `val = 1; f"{val}"`.
Evaluated at runtime. Faster than `%` or `.format()`.
Supports expressions `f"{2+2}"`.
</Accordion>

<Accordion title="24. Unpacking">
**Code**:
`a, b = b, a` (Swap).
`first, *mid, last = [1, 2, 3, 4]`.
`merged = {**d1, **d2}`.
</Accordion>

<Accordion title="25. `enumerate` vs `zip`">
**Answer**:
*   `enumerate(lst)`: Index and Value.
*   `zip(l1, l2)`: Parallel iteration. Stops at shortest.
</Accordion>

<Accordion title="26. `lambda` functions">
**Answer**:
Anonymous small function.
`sorted(data, key=lambda x: x['age'])`.
Limitation: Single expression.
</Accordion>

<Accordion title="27. `map` and `filter`">
**Answer**:
Functional.
`map(func, iter)` -> Applies func.
`filter(pred, iter)` -> Keeps True.
Lazy iterators in Py3.
List comp preferred often.
</Accordion>

<Accordion title="28. `any` and `all`">
**Answer**:
Short-circuit evaluation.
`all(x > 0 for x in lst)`. Return True if all distinct.
</Accordion>

<Accordion title="29. Shallow vs Deep Copy">
**Answer**:
*   `b = a`: Reference.
*   `b = a[:]` or `copy.copy(a)`: Shallow (New list, same objects).
*   `b = copy.deepcopy(a)`: Recursive copy.
</Accordion>

<Accordion title="30. `is` vs `==`">
**Answer**:
*   `==`: Value equality (`__eq__`).
*   `is`: Identity (`id(a) == id(b)`).
*   `None` check: Always `is None`.
</Accordion>
</AccordionGroup>

## 4. Scripting & Automation tasks

<AccordionGroup>
<Accordion title="31. Reading large file">
**Code**:
```python
with open('big.log') as f:
    for line in f:
        process(line)
```
Memory efficient (Generator).
</Accordion>

<Accordion title="32. JSON parsing">
**Code**:
`json.load(f)` (File) / `json.loads(s)` (String).
`json.dump(obj, f, indent=2)`.
</Accordion>

<Accordion title="33. HTTP Requests">
**Code**:
Standard lib: `urllib`.
Popular: `requests`.
`requests.get(url, params=p).json()`.
</Accordion>

<Accordion title="34. Regex (`re`)">
**Code**:
`re.search(pattern, text)`.
`re.findall(pattern, text)`.
Groups: `Match.group(1)`.
Expensive compilation. Pre-compile `re.compile()`.
</Accordion>

<Accordion title="35. Argument Parsing">
**Code**:
`argparse` library.
CLI tools. `--help` auto-gen.
</Accordion>

<Accordion title="36. Executing Shell commands">
**Code**:
`subprocess.run(["ls", "-l"], capture_output=True)`.
Replace `os.system` (Deprecated).
</Accordion>

<Accordion title="37. File Path manipulation">
**Code**:
`pathlib.Path`.
`p = Path('/usr/bin'); p.name; p.parent`.
OS agnostic joining `/` or `\`.
</Accordion>

<Accordion title="38. Working with Dates">
**Code**:
`datetime` module.
`datetime.now()`.
Formatting: `strftime('%Y-%m-%d')`. Parsing: `strptime`.
Aware (Timezone) vs Naive.
</Accordion>

<Accordion title="39. Error Handling (Try/Except)">
**Answer**:
Catch specific exceptions.
`except (IOError, ValueError) as e:`.
`finally`: Cleanup.
`else`: Run if no exception.
</Accordion>

<Accordion title="40. Logging">
**Code**:
`logging` module.
Levels: DEBUG, INFO, WARNING, ERROR.
Don't use `print` in Prod.
</Accordion>
</AccordionGroup>

## 5. Advanced DSA Concepts

<AccordionGroup>
<Accordion title="41. Graph: Shortest Path (Dijkstra)">
**Answer**:
Min-Heap.
Greedy.
Positive weights only.
O(E log V).
</Accordion>

<Accordion title="42. Graph: Topological Sort">
**Answer**:
Dependency resolution (Build system).
Kahn's Algo (In-degree) or DFS.
DAG only.
</Accordion>

<Accordion title="43. Segment Tree / Fenwick Tree">
**Answer**:
Range Query O(log N). Updates O(log N).
Standard Linear Scan is O(N).
</Accordion>

<Accordion title="44. Balanced BST (AVL/Red-Black)">
**Answer**:
Maintains O(log N) height.
Rotations on insert/delete.
Python lib: `bisect` (on list), no built-in tree set.
</Accordion>

<Accordion title="45. LRU Cache Implementation">
**Answer**:
Map + Doubly Linked List.
Map: Key -> Node.
List: Orders usage. Move to head on access.
Python: `OrderedDict` (Pre-3.7) or just Dict (3.7+) logic.
</Accordion>

<Accordion title="46. String Search (KMP)">
**Answer**:
Knuth-Morris-Pratt.
Avoids backtracking in needle.
LPS Array (Longest Prefix Suffix).
O(N+M).
</Accordion>

<Accordion title="47. Bit Manipulation">
**Answer**:
XOR `^`: Unique number.
`x & (x-1)`: Turn off rightmost 1 bit.
`x << 1`: Multiply by 2.
</Accordion>

<Accordion title="48. Reservoir Sampling">
**Answer**:
Select k items from stream of unknown length N with equal probability.
Keep k. For i-th item, replace existing with prob k/i.
</Accordion>

<Accordion title="49. Bloom Filter">
**Answer**:
Probabilistic set.
Multiple hash functions.
False Positives possible. False Negatives impossible.
Space efficient.
</Accordion>

<Accordion title="50. Complexity Classes (P vs NP)">
**Answer**:
*   **P**: Solvable in Poly time.
*   **NP**: Verifiable in Poly time.
*   **NP-Complete**: Hardest in NP (SAT, TSP).
</Accordion>
</AccordionGroup>
