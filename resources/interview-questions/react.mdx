---
title: "React"
description: "Hooks, Fiber Architecture, Performance, and Patterns"
icon: "react"
---

# React Interview Questions (50+ Detailed Q&A)

## 1. Core Concepts & Rendering

<AccordionGroup>
<Accordion title="1. Real DOM vs Virtual DOM">
**Answer**:
*   **Real DOM**: Heavy. Repainting is expensive.
*   **Virtual DOM (VDOM)**: Lightweight JS object copy of DOM.
*   **Diffing**: React compares new VDOM with old VDOM.
*   **Reconciliation**: Updates ONLY changed nodes in Real DOM (Batch updates).
**Follow-up**: Is VDOM always faster? (No, Svelte drops VDOM for compile-time updates).
</Accordion>

<Accordion title="2. JSX: How does it work?">
**Answer**:
Syntactic sugar for `React.createElement(type, props, ...children)`.
Babel transpiles JSX into these function calls.
Returns a JS Object (The "React Element").
**Follow-up**: Why can't we return two elements? (A function can only return one value/object. Use Fragments).
</Accordion>

<Accordion title="3. React Fiber Architecture">
**Answer**:
The core reconciliation engine rewritten in React 16.
**Goal**: Incremental rendering (Time Slicing).
**How**: Splits work into "Units of Work" (Fibers).
Can **Pause, Abort, or Reuse** work.
Enables: Suspense, Concurrent Mode, Error Boundaries.
</Accordion>

<Accordion title="4. Lifecycle Methods vs Hooks">
**Answer**:
*   **Mount**: `componentDidMount` -> `useEffect([], ...)`
*   **Update**: `componentDidUpdate` -> `useEffect([dep], ...)`
*   **Unmount**: `componentWillUnmount` -> `useEffect return cleanup`.
*   **Error**: `componentDidCatch` -> No Hook equivalent yet.
</Accordion>

<Accordion title="5. Functional vs Class Components">
**Answer**:
*   **Class**: `this`, Lifecycle methods, heavier (OOP).
*   **Functional**: No `this`, Closures, Hooks, Lighter. Mental model: "UI is a function of state".
</Accordion>

<Accordion title="6. Pure Components vs `React.memo`">
**Answer**:
*   **PureComponent** (Class): Implements `shouldComponentUpdate` with shallow prop comparison.
*   **React.memo** (Func): HOC that shallow compares props. Skips re-render if props unchanged.
**Follow-up**: When NOT to use it? (If props change every time, the comparison is wasted cost).
</Accordion>

<Accordion title="7. Synthetic Events">
**Answer**:
React wrapper around native browser events.
**Why**: Cross-browser compatibility.
**Pooling**: (Pre-React 17) Event objects were reused/nulled for performance. (Removed in React 17+).
</Accordion>

<Accordion title="8. Keys in Lists">
**Answer**:
Serve as identity. Help React track elements across re-renders (Add/Remove/Reorder).
**Bad**: Array Index (If list reorders, state gets mixed up).
**Good**: Stable ID from DB.
</Accordion>

<Accordion title="9. One-way Data Flow">
**Answer**:
Parent -> Child (via Props).
Child -> Parent (via Callback functions).
Makes data flow predictable and easier to debug than bidirectional binding (Angular 1.x).
</Accordion>

<Accordion title="10. Portal">
**Answer**:
Renders a child into a DOM node outside the parent hierarchy.
**Use Case**: Modals, Tooltips (to avoid `z-index` / `overflow: hidden` issues).
Event Bubbling still propagates through React tree (even if DOM is separate).
</Accordion>
</AccordionGroup>

## 2. Hooks Deep Dive

<AccordionGroup>
<Accordion title="11. `useState` Internals">
**Answer**:
Returns `[state, dispatch]`.
React keeps an array of hook instructions per component. Order matters (Why hooks cannot be conditional).
Updates are batched.
</Accordion>

<Accordion title="12. `useEffect` vs `useLayoutEffect`">
**Answer**:
*   `useEffect`: Async. Run AFTER paint. (99% use cases).
*   `useLayoutEffect`: Sync. Run AFTER DOM mutation but BEFORE paint. Blocks visual update.
**Use Case**: Measuring DOM element size to prevent flicker.
</Accordion>

<Accordion title="13. `useMemo` vs `useCallback`">
**Answer**:
*   `useMemo`: Caches a **Value**. `const x = useMemo(() => compute(), [deps])`.
*   `useCallback`: Caches a **Function**. `const fn = useCallback(() => {}, [deps])`.
**Why**: To prevent referential changes triggering re-renders in `React.memo` children.
</Accordion>

<Accordion title="14. `useRef` Uses">
**Answer**:
1.  Access DOM (`inputRef.current.focus()`).
2.  Mutable Container: Store values that persist renders but **don't trigger re-render** (Timers, previous values).
</Accordion>

<Accordion title="15. `useReducer` vs `useState`">
**Answer**:
*   `useState`: Simple independent values.
*   `useReducer`: Complex state logic, multiple sub-values, state depends on previous state. (Redux pattern).
</Accordion>

<Accordion title="16. `useContext`">
**Answer**:
Avoids Prop Drilling.
**Performance Pitfall**: If Provider value changes, ALL consumers re-render.
**Fix**: Split context or memoize context value.
</Accordion>

<Accordion title="17. Custom Hooks Rules">
**Answer**:
Must start with `use`.
Mechanism to share **Stateful Logic** (not state itself).
Example: `useFetch`, `useForm`.
</Accordion>

<Accordion title="18. `useImperativeHandle`">
**Answer**:
Used with `forwardRef` to customize the instance value exposed to parents.
Example: Exposing only `focus()` and `scroll()` methods of a child, not the whole DOM node.
</Accordion>

<Accordion title="19. Stale Closures in Hooks">
**Answer**:
Common bug. `useEffect` capturing old state variable because it was missing in dependency array.
**Fix**: Add dependency or use functional update `setState(prev => prev + 1)`.
</Accordion>

<Accordion title="20. `useTransition` & `useDeferredValue` (React 18)">
**Answer**:
Concurrency hooks.
*   `useTransition`: Mark a state update as "Non-urgent" (interruptible).
*   `useDeferredValue`: Like debouncing a value, but React-managed. "Lag behind" the UI.
</Accordion>
</AccordionGroup>

## 3. State Management

<AccordionGroup>
<Accordion title="21. Prop Drilling">
**Answer**:
Passing `props` through 5 layers of components that don't use it, just to reach a grand-child.
**Sol**: Context, Redux, Composition (passing Component as prop).
</Accordion>

<Accordion title="22. Redux: Core Principles">
**Answer**:
1.  Single Source of Truth (Store).
2.  State is Read-Only.
3.  Changes via Pure Functions (Reducers).
</Accordion>

<Accordion title="23. Redux Thunk vs Saga">
**Answer**:
Middleware for Async Actions.
*   **Thunk**: Action creator returns function. Simple. Promise-based.
*   **Saga**: Uses Generators. Declarative. Good for complex flows (Cancel/Race).
</Accordion>

<Accordion title="24. Context vs Redux">
**Answer**:
*   **Context**: Low frequency updates (Theme, Auth). Built-in.
*   **Redux**: High frequency updates. DevTools. Middleware. Strict structure.
</Accordion>

<Accordion title="25. Zustand / Recoil / Jotai">
**Answer**:
Modern atomic state libraries.
Simpler API than Redux (No boilerplate).
Resolve Context re-rendering issues by allowing subscription to slices.
</Accordion>

<Accordion title="26. Server State (React Query / SWR)">
**Answer**:
Manage async data (loading, error, caching, re-fetching).
Separates Client State (UI) from Server State (DB Data).
Features: Cache invalidation, Deduping, background updates.
</Accordion>

<Accordion title="27. Immutability in State">
**Answer**:
React compares references (shallow).
If you mutate `obj.a = 1`, the reference is same -> No Re-render.
Must create new object `const newObj = {...obj, a: 1}`.
</Accordion>

<Accordion title="28. Selector Pattern">
**Answer**:
Deriving data from state.
`const total = state.items.reduce(...)`.
**Reselect**: Memoized selectors in Redux. Recomputes only if input inputs change.
</Accordion>

<Accordion title="29. Normalizing State">
**Answer**:
Storing data like a DB (Flat ID map) instead of nested arrays.
`{ users: { "1": {id: 1, ...} } }`.
Easier to update/lookup.
</Accordion>

<Accordion title="30. Flux Architecture">
**Answer**:
Action -> Dispatcher -> Store -> View.
Cyclic flow. Precursor to Redux.
</Accordion>
</AccordionGroup>

## 4. Performance & Advanced Patterns

<AccordionGroup>
<Accordion title="31. Code Splitting">
**Answer**:
`React.lazy` + `Suspense`.
Webpack splits code into chunks. Loaded on demand.
Route-based splitting is most common.
</Accordion>

<Accordion title="32. Error Boundaries">
**Answer**:
Catch errors in rendering/lifecycle of children.
Must be Class Component (`componentDidCatch`).
Displays Fallback UI instead of White Screen.
</Accordion>

<Accordion title="33. HOC (Higher Order Component)">
**Answer**:
Function taking a Component -> Returning enhanced Component.
`withAuth(Profile)`.
**Issues**: Prop collisions, Wrapper Hell. Replaced mostly by Hooks.
</Accordion>

<Accordion title="34. Render Props">
**Answer**:
Component takes a function as a prop (`children` or `render`) to control rendering.
`<Mouse render={({x,y}) => <Pos x={x} y={y}/> } />`.
Logic reuse.
</Accordion>

<Accordion title="35. Compound Components">
**Answer**:
Groups components share state implicitly.
Reference: `<Select><Option...></Select>`.
Uses `Context` internally or `React.Children.map`.
</Accordion>

<Accordion title="36. Controlled vs Uncontrolled Components">
**Answer**:
*   **Controlled**: React state drives value (`value={state}`). Source of truth is React.
*   **Uncontrolled**: DOM drives value (`ref`). Source of truth is DOM.
</Accordion>

<Accordion title="37. Strict Mode">
**Answer**:
Dev-tool.
1.  Double-invokes render (detect side effects).
2.  Warns deprecated APIs.
3.  Checks legacy string ref.
</Accordion>

<Accordion title="38. Optimization Tricks">
**Answer**:
1.  Virtualization (`react-window`) for long lists.
2.  Memoization (`React.memo`, `useMemo`).
3.  Throttling handlers.
4.  Image optimization.
</Accordion>

<Accordion title="39. Forward Ref">
**Answer**:
Passing a `ref` through a component to its child DOM node.
Required because function components don't have instances.
`React.forwardRef((props, ref) => ...)`
</Accordion>

<Accordion title="40. Batching Updates">
**Answer**:
React 18 Automatic Batching.
Updates inside Promises/Timeouts are now batched into single render.
</Accordion>
</AccordionGroup>

## 5. SSR & Testing

<AccordionGroup>
<Accordion title="41. SSR (Server Side Rendering)">
**Answer**:
Server sends full HTML (content visible immediately). JS hydrates later.
**Pros**: SEO, FCP (First Contentful Paint).
**Cons**: TTFB (Time To First Byte), Server load.
</Accordion>

<Accordion title="42. Hydration">
**Answer**:
Process where browser connects event listeners to the static HTML received from server.
Mismatch errors (Text content did not match) if server HTML != Client initial render.
</Accordion>

<Accordion title="43. Next.js: `getStaticProps` vs `getServerSideProps`">
**Answer**:
*   **Static**: Build time. Fast. Cached.
*   **Server**: Request time. Fresh data. Slower.
</Accordion>

<Accordion title="44. Testing: Unit vs Integration">
**Answer**:
*   **Jest**: Runner & Assertions.
*   **RTL (React Testing Library)**: Test behavior/user-perspective (Click button, find text), not implementation (State value).
</Accordion>

<Accordion title="45. Shallow Rendering (Enzyme)">
**Answer**:
Renders component one level deep. OLD practice.
Modern practice: Render full tree (RTL) or isolate with mocks.
</Accordion>

<Accordion title="46. Snapshot Testing">
**Answer**:
Saves rendered JSON output to file. Fails if output changes.
Good for regression, but can be brittle.
</Accordion>

<Accordion title="47. Mocking">
**Answer**:
Mocking modules (API clients) or components to isolate the unit under test.
`jest.mock('./api')`.
</Accordion>

<Accordion title="48. Accessibility (A11y)">
**Answer**:
`aria-*` attributes.
Semantic HTML.
Keyboard navigation support.
</Accordion>

<Accordion title="49. Security (XSS)">
**Answer**:
React escapes data in `{}` automatically.
**Danger**: `dangerouslySetInnerHTML`. Requires sanitized input (DOMPurify).
</Accordion>

<Accordion title="50. Component Design Patterns">
**Answer**:
*   Container/Presentation (Logic vs UI).
*   Composition > Inheritance.
*   Custom Hooks for logic extraction.
</Accordion>
</AccordionGroup>
