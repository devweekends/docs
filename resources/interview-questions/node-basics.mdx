---
title: "Node.js (Fundamentals)"
description: "Event Loop, Streams, CPU Intensive Tasks, and Core Concepts"
icon: "node"
---

# Node.js Event Loop & Core Concepts

This guide provides a foundational understanding of how Node.js works, its architecture, and how it handles asynchronous operations.

## 1. Introduction to Node.js

Node.js is a **JavaScript Runtime Environment** that allows JavaScript to run outside the browser. It is built by wrapping the Google V8 engine and the Libuv library to enable server-side development.

**Core Principle:**
> **Node.js is a SINGLE-THREADED environment**
> While JavaScript execution happens on a single thread, Node.js offloads complex tasks to the operating system or its internal thread pool.

**Primary Use Cases:**
- **I/O Operations**: Reading/Writing files, Database calls.
- **Real-time Applications**: Chat apps, Game servers.
- **REST APIs**: Fast, scalable web services.

---

## 2. Event Loop Architecture

The Event Loop is the "heart" of Node.js. It monitors for pending tasks and manages asynchronous operations, enabling non-blocking I/O.

### How Node.js Reads Code
1.  **Top-to-bottom**: Executes synchronous code immediately.
2.  **Delegation**: Asynchronous tasks (like timers or network calls) are sent to the Event Loop.
3.  **Callback Queue**: Once a task is done, its callback is queued and processed when the main thread is free.

---

## 3. Blocking vs Non-Blocking

<AccordionGroup>
<Accordion title="Blocking Code Example">
**Blocking**: The thread is "locked" until the operation completes. No other code can run.

```javascript
const fs = require('fs');

// BLOCKING - Thread waits for file to be read
const data = fs.readFileSync('test.txt', 'utf-8');
console.log(data);
console.log('This waits for file read to complete');
```
</Accordion>

<Accordion title="Non-Blocking Code Example">
**Non-Blocking**: The operation is delegated. The thread continues working on other things.

```javascript
const fs = require('fs');

// NON-BLOCKING - Thread continues execution
fs.readFile('test.txt', 'utf-8', (err, data) => {
  if (err) throw err;
  console.log(data); // Executes when ready
});
console.log('This executes immediately');
```
</Accordion>
</AccordionGroup>

---

## 4. Event Loop Phases & Priority

The Event Loop executes tasks in a specific hierarchical order:

| Phase | Priority | Tasks |
| :--- | :--- | :--- |
| **Microtask Queue** | Highest | `process.nextTick()`, `Promise.resolve()` |
| **Timers** | 1st Macrotask | `setTimeout()`, `setInterval()` |
| **I/O Callbacks** | 2nd Macrotask | Network / File System results |
| **Poll** | 3rd Macrotask | New I/O events |
| **Check** | 4th Macrotask | `setImmediate()` |
| **Close** | 5th Macrotask | Socket closures, cleanup |

**Output Prediction Example:**
```javascript
console.log('Start');
setTimeout(() => console.log('setTimeout'), 0);
Promise.resolve().then(() => console.log('Promise'));
process.nextTick(() => console.log('nextTick'));
console.log('End');

// Output: Start -> End -> nextTick -> Promise -> setTimeout
```

---

## 5. CPU Intensive Tasks & Multi-Threading

Because of its single-threaded nature, CPU-intensive tasks (like heavy loops) can **block** the entire server, making it unresponsive to other requests.

### Solution 1: Child Processes (`fork`)
Creates a **separate instance** of Node.js with its own memory. Good for isolated scripts.

### Solution 2: Worker Threads
Threads that share memory with the main process. More lightweight and efficient for mathematical calculations.

### Thread Pool
Node.js uses **Libuv** to maintain a thread pool (default size: 4) for operations like file I/O, hash generation (`crypto`), and compression (`zlib`).

---

## 6. Streams & Buffers

Processing large data efficiently.

| Feature | Stream | Buffer |
| :--- | :--- | :--- |
| **Mechanism** | Processes data in chunks | Loads everything into memory |
| **Memory** | Efficient (low footprint) | High (can crash on large files) |
| **Use Case** | Video, big logs, file uploads | Small, fixed-size data |

**Example (Piping Streams):**
```javascript
const fs = require('fs');
const readStream = fs.createReadStream('source.mp4');
const writeStream = fs.createWriteStream('dest.mp4');

// Transfers data chunk by chunk automatically
readStream.pipe(writeStream);
```

---

## 7. Rate Limiting

Crucial for protecting your server from **DDoS** attacks and **Resource Exhaustion**.

**Implementation:**
Use libraries like `express-rate-limit` to restrict requests per IP address.
```javascript
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 mins
  max: 100 // Limit each IP to 100 requests
});
```

---

## 8. Event-Driven Architecture

Using the `EventEmitter` to create decoupled, scalable applications.

```javascript
const EventEmitter = require('events');
const emitter = new EventEmitter();

// 1. Register listener
emitter.on('paymentSuccess', (data) => {
  console.log(`Sending email to ${data.email}...`);
});

// 2. Emit event
emitter.emit('paymentSuccess', { email: 'user@example.com' });
```

---

## 9. Common Interview Questions

<AccordionGroup>
<Accordion title="Q1: Difference between setImmediate() and process.nextTick()?">
**Answer**:
- `process.nextTick()` is a **Microtask**. It runs immediately after the current operation and before any other phase of the event loop.
- `setImmediate()` is a **Macrotask**. It runs in the "Check" phase of the event loop.
*Warning: Excessive nextTick can cause "starvation" of the event loop.*
</Accordion>

<Accordion title="Q2: What is the Thread Pool in Node.js?">
**Answer**:
Node.js uses **Libuv** to manage a pool of background threads. While the event loop handles networking, the thread pool is used for:
- File System operations (`fs`)
- Cryptography (`crypto`)
- DNS lookups
- Compression (`zlib`)
</Accordion>

<Accordion title="Q3: fork() vs spawn()?">
**Answer**:
- `fork()`: Specialized for Node.js. Creates a new Node engine instance and an IPC channel for easy communication.
- `spawn()`: General purpose. Used to run any system command (like `python` or `git`) as a separate process.
</Accordion>

<Accordion title="Q4: Why is Node.js not ideal for heavy computation?">
**Answer**:
Since it's single-threaded, a single heavy computation (e.g., image resizing) will block the thread, making the server unresponsive for all other users. For such tasks, it's better to use **Worker Threads** or offload the work to a specialized service (like a Python microservice).
</Accordion>
</AccordionGroup>
