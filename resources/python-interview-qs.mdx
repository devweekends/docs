---
title: "Python Interview Questions"
description: "Complete preparation guide covering Python basics, data structures, OOP, advanced concepts, web development, and data science"
icon: "python"
---

<hr />

## 1. Python Basics

<AccordionGroup>
  <Accordion title="What is Python and its key features?">
    Python is a high-level, interpreted, general-purpose programming language created by Guido van Rossum. Key features include: easy-to-learn syntax, interpreted nature (no compilation), dynamic typing, object-oriented capabilities, extensive standard library, cross-platform compatibility, large community support, and open-source nature.
  </Accordion>

  <Accordion title="What are Python's built-in data types?">
    Python has several built-in data types: **Numeric** (int, float, complex), **Sequence** (list, tuple, range, str), **Mapping** (dict), **Set** (set, frozenset), **Boolean** (bool), **Binary** (bytes, bytearray, memoryview), and **None Type** (NoneType). Each serves specific purposes in data handling and manipulation.
  </Accordion>

  <Accordion title="What is the difference between lists and tuples?">
    **Lists** are mutable (can be modified after creation) and use square brackets []. **Tuples** are immutable (cannot be changed) and use parentheses (). Lists are slower than tuples but have more built-in methods. Use lists when data needs to change, tuples for fixed data that shouldn't be modified.
  </Accordion>

  <Accordion title="Explain Python's mutable and immutable types">
    **Mutable types** can be modified after creation: lists, dictionaries, sets, and custom objects. **Immutable types** cannot be changed: integers, floats, strings, tuples, and frozensets. Example: `list_a = [1, 2, 3]; list_a[0] = 10` works, but `string_a = 'hello'; string_a[0] = 'H'` raises TypeError.
  </Accordion>

  <Accordion title="What are Python's identity operators?">
    Python has two identity operators: `is` and `is not`. They check if two variables reference the same object in memory, not just equal values. Example: `a = [1,2,3]; b = a; c = [1,2,3]`. Here `a is b` returns True, but `a is c` returns False even though `a == c` returns True.
  </Accordion>
</AccordionGroup>

<hr />

## 2. Data Structures

<AccordionGroup>
  <Accordion title="How do you create and manipulate lists?">
    Lists are created using square brackets: `my_list = [1, 2, 3]` or `list()` constructor. Common operations: `append()` adds element at end, `insert(index, item)` inserts at position, `remove(item)` removes first occurrence, `pop()` removes and returns last element, `extend()` adds elements from another list, `sort()` sorts in place, `reverse()` reverses order.
  </Accordion>

  <Accordion title="What are list comprehensions?">
    List comprehensions provide a concise way to create lists. Syntax: `[expression for item in iterable if condition]`. Examples: `squares = [x**2 for x in range(10)]`, `evens = [x for x in range(20) if x % 2 == 0]`, `matrix = [[i*j for j in range(3)] for i in range(3)]`.
  </Accordion>

  <Accordion title="Explain Python dictionaries and their methods">
    Dictionaries are unordered collections of key-value pairs using curly braces {}. Keys must be immutable and unique. Common methods: `get(key, default)`, `keys()`, `values()`, `items()`, `update()`, `pop(key)`, `popitem()`, `clear()`, `setdefault()`. Example: `person = {'name': 'John', 'age': 30}`.
  </Accordion>

  <Accordion title="What is the difference between sets and frozensets?">
    **Sets** are mutable unordered collections of unique elements created with {} or `set()`. **Frozensets** are immutable versions created with `frozenset()`. Sets support `add()`, `remove()`, `discard()` while frozensets don't. Frozensets can be used as dictionary keys or elements of other sets.
  </Accordion>

  <Accordion title="How do you perform set operations?">
    Sets support mathematical operations: union (`|`), intersection (`&`), difference (`-`), symmetric difference (`^`). Also available as methods: `union()`, `intersection()`, `difference()`, `symmetric_difference()`. Example: `set1 = {1, 2, 3}; set2 = {3, 4, 5}; union = set1 | set2` returns `{1,2,3,4,5}`.
  </Accordion>
</AccordionGroup>

<hr />

## 3. Object-Oriented Programming

<AccordionGroup>
  <Accordion title="What are the four pillars of OOP in Python?">
    The four pillars are: **Encapsulation** - bundling data and methods together, hiding internal details; **Abstraction** - hiding complex implementation, showing only necessary features; **Inheritance** - creating new classes from existing ones; **Polymorphism** - same interface for different data types.
  </Accordion>

  <Accordion title="How do you create a class in Python?">
    Use the `class` keyword followed by class name (PascalCase). Define `__init__` method as constructor. Use `self` parameter to refer to instance. Example:
    ```python
    class Person:
        def __init__(self, name, age):
            self.name = name
            self.age = age
        def greet(self):
            return f'Hello, I am {self.name}'
    p = Person('John', 30)
    ```
  </Accordion>

  <Accordion title="Explain instance, class, and static methods">
    **Instance methods** take `self`, operate on instance data. **Class methods** take `cls`, decorated with `@classmethod`, operate on class-level data. **Static methods** take neither, decorated with `@staticmethod`, utility functions logically grouped with class.
  </Accordion>

  <Accordion title="What is inheritance?">
    Inheritance allows class to acquire properties and methods from another class. **Single inheritance**: child class inherits from one parent. **Multiple inheritance**: child inherits from multiple parents. Use `super()` to call parent methods. Python uses Method Resolution Order (MRO) for multiple inheritance.
  </Accordion>

  <Accordion title="What are magic methods (dunder methods)?">
    Magic methods are special methods with double underscores (e.g., `__init__`, `__str__`). They enable operator overloading and customize class behavior. Common ones: `__init__` (constructor), `__str__` (string representation), `__repr__` (official representation), `__len__`, `__add__`, `__eq__`.
  </Accordion>
</AccordionGroup>

<hr />

## 4. Functions and Decorators

<AccordionGroup>
  <Accordion title="What are *args and **kwargs?">
    `*args` allows function to accept variable number of positional arguments as tuple. `**kwargs` allows variable number of keyword arguments as dictionary. Useful for flexible function signatures. Example: `func(1, 2, 3, name='John', age=30)` where args=`(1, 2, 3)` and kwargs=`{'name': 'John', 'age': 30}`.
  </Accordion>

  <Accordion title="What are lambda functions?">
    Lambda functions are anonymous, small functions defined with `lambda` keyword. Limited to single expression. Syntax: `lambda arguments: expression`. Commonly used with `map()`, `filter()`, `sorted()`. Example: `square = lambda x: x**2`, `evens = list(filter(lambda x: x % 2 == 0, numbers))`.
  </Accordion>

  <Accordion title="What are decorators in Python?">
    Decorators are functions that modify behavior of other functions without changing their code. Use `@decorator` syntax. Take function as argument, return modified function. Used for logging, timing, authentication, caching. Example:
    ```python
    def my_decorator(func):
        def wrapper(*args, **kwargs):
            print('Before')
            result = func(*args, **kwargs)
            print('After')
            return result
        return wrapper
    ```
  </Accordion>

  <Accordion title="What is a closure?">
    Closure is a function that remembers values from enclosing scope even after outer function finishes executing. Inner function has access to outer function's variables. Useful for data hiding and factory functions. Example:
    ```python
    def outer(x):
        def inner(y):
            return x + y
        return inner
    add_5 = outer(5)
    print(add_5(10))  # 15
    ```
  </Accordion>

  <Accordion title="What are generator functions and yield?">
    Generator functions use `yield` instead of `return` to produce values lazily, one at a time. They maintain state between calls. More memory efficient for large sequences. Example:
    ```python
    def count_up_to(n):
        i = 1
        while i <= n:
            yield i
            i += 1
    for num in count_up_to(5):
        print(num)
    ```
  </Accordion>
</AccordionGroup>

<hr />

## 5. File Handling and I/O

<AccordionGroup>
  <Accordion title="How do you read and write files?">
    Use `open()` function with mode: 'r' for read, 'w' for write, 'a' for append, 'r+' for read/write. Use `with` statement for automatic cleanup. `read()` reads entire file, `readline()` reads one line, `readlines()` returns list of lines. Example:
    ```python
    with open('file.txt', 'r') as f:
        content = f.read()
    with open('file.txt', 'w') as f:
        f.write('Hello World')
    ```
  </Accordion>

  <Accordion title="What is the difference between 'w' and 'a' file modes?">
    **'w' mode** creates new file or truncates existing file to zero length, overwrites all content. **'a' mode** creates new file if doesn't exist, adds content at end of existing file without deleting. Both allow writing but handle existing content differently.
  </Accordion>

  <Accordion title="How do you work with CSV files?">
    Use `csv` module. `csv.reader()` reads CSV files, `csv.writer()` writes. `csv.DictReader()` and `csv.DictWriter()` work with dictionaries. Example:
    ```python
    import csv
    with open('data.csv', 'r') as f:
        reader = csv.reader(f)
        for row in reader:
            print(row)
    ```
  </Accordion>

  <Accordion title="How do you work with JSON?">
    Use `json` module. `json.dumps()` converts Python object to JSON string. `json.loads()` parses JSON string to Python object. `json.dump()` writes to file. `json.load()` reads from file. Example:
    ```python
    import json
    data = {'name': 'John', 'age': 30}
    json_str = json.dumps(data)
    parsed = json.loads(json_str)
    ```
  </Accordion>

  <Accordion title="What are context managers?">
    Context managers handle resource allocation and cleanup automatically. `with` statement ensures proper acquisition and release of resources. Implements `__enter__` and `__exit__` methods. Commonly used for file operations, database connections, locks.
  </Accordion>
</AccordionGroup>

<hr />

## 6. Exception Handling

<AccordionGroup>
  <Accordion title="What is exception handling?">
    Exception handling manages runtime errors gracefully without crashing program. Use `try-except` blocks. `try` block contains code that might raise exception. `except` block handles specific exceptions. Multiple except blocks possible. Prevents program termination.
  </Accordion>

  <Accordion title="What are common built-in exceptions?">
    Common exceptions: `ZeroDivisionError` (division by zero), `ValueError` (invalid value), `TypeError` (wrong type), `IndexError` (invalid index), `KeyError` (key not found in dict), `FileNotFoundError` (file doesn't exist), `AttributeError` (invalid attribute), `ImportError` (import fails).
  </Accordion>

  <Accordion title="What is try-except-else-finally?">
    **try**: code that might raise exception. **except**: handles exceptions. **else**: executes if no exception occurred. **finally**: always executes regardless of exception, used for cleanup. Order must be: try-except-else-finally.
  </Accordion>

  <Accordion title="How do you create custom exceptions?">
    Create custom exception by inheriting from `Exception` class. Add custom attributes and methods. Raise with `raise` keyword. Example:
    ```python
    class InvalidAgeError(Exception):
        def __init__(self, age, message='Age must be >= 0'):
            self.age = age
            self.message = message
            super().__init__(self.message)
    ```
  </Accordion>

  <Accordion title="What are assertions?">
    Assertions test conditions during development using `assert` statement. If condition false, raises `AssertionError`. Disabled when optimization flag used. Use for debugging, not error handling. Syntax: `assert condition, message`. Example: `assert len(numbers) > 0, 'List cannot be empty'`.
  </Accordion>
</AccordionGroup>

<hr />

## 7. Modules and Packages

<AccordionGroup>
  <Accordion title="What is the difference between module and package?">
    **Module** is single Python file containing functions, classes, variables. **Package** is directory containing multiple modules and `__init__.py` file. Packages organize related modules hierarchically. Import modules with import statement, packages with dot notation.
  </Accordion>

  <Accordion title="How do you import modules?">
    Several ways: `import module` imports entire module, `from module import name` imports specific items, `from module import *` imports all (not recommended), `import module as alias` creates alias. Example: `import math`, `from datetime import datetime`, `import pandas as pd`.
  </Accordion>

  <Accordion title="What is __init__.py?">
    `__init__.py` makes directory a Python package. Can be empty or contain initialization code. Executed when package imported. Defines what's exported with `__all__`. In Python 3.3+, namespace packages don't require `__init__.py`, but it's still recommended for clarity.
  </Accordion>

  <Accordion title="What is the __name__ variable?">
    `__name__` is special variable set by Python. When file executed directly, `__name__ == '__main__'`. When imported as module, `__name__` equals module name. Common pattern: `if __name__ == '__main__':` allows code to run only when file executed directly, not when imported.
  </Accordion>

  <Accordion title="How do you create virtual environments?">
    Virtual environments isolate Python dependencies per project. Create with `python -m venv env_name`. Activate: `source env_name/bin/activate` (Linux/Mac) or `env_name\Scripts\activate` (Windows). Deactivate with `deactivate`. Install packages with pip in activated environment.
  </Accordion>
</AccordionGroup>

<hr />

## 8. Advanced Python Concepts

<AccordionGroup>
  <Accordion title="What are iterators and iterables?">
    **Iterable** is any object that can return iterator (implements `__iter__`). **Iterator** is object that returns next value (implements `__next__`). Lists, tuples, strings are iterables. `iter()` creates iterator from iterable. `next()` gets next value. `StopIteration` raised when exhausted.
  </Accordion>

  <Accordion title="What is multithreading vs multiprocessing?">
    **Multithreading**: Multiple threads in single process, good for I/O-bound tasks. GIL limits true parallelism. Use `threading` module. **Multiprocessing**: Separate processes, true parallelism, good for CPU-bound tasks. Use `multiprocessing` module. Heavier than threads.
  </Accordion>

  <Accordion title="What is the Global Interpreter Lock (GIL)?">
    GIL is mutex that protects Python objects, preventing multiple threads from executing Python bytecode simultaneously. One thread executes at a time. Impacts CPU-bound multithreaded programs. Doesn't affect I/O-bound or multiprocessing. Trade-off for memory management simplicity.
  </Accordion>

  <Accordion title="What are metaclasses?">
    Metaclasses are classes of classes. They define how classes behave. `type` is default metaclass. Classes are instances of metaclasses. Used for class creation customization, ORMs, API frameworks. Advanced concept, rarely needed. Define by inheriting from `type`.
  </Accordion>

  <Accordion title="What are coroutines and async/await?">
    Coroutines are functions that can pause and resume execution. Defined with `async def`. Use `await` to pause until result available. Enables asynchronous programming. Non-blocking I/O operations. Use `asyncio` module. More efficient than threads for I/O-bound concurrent tasks.
  </Accordion>
</AccordionGroup>

<hr />

## 9. Web Development with Python

<AccordionGroup>
  <Accordion title="What are popular Python web frameworks?">
    **Django**: Full-featured, batteries-included framework. ORM, admin panel, authentication built-in. Good for large applications. **Flask**: Lightweight, microframework. Flexible, minimal. Good for small to medium apps. **FastAPI**: Modern, fast, async support. Automatic API documentation.
  </Accordion>

  <Accordion title="How do you create a simple Flask application?">
    ```python
    from flask import Flask
    app = Flask(__name__)
    
    @app.route('/')
    def home():
        return 'Hello, World!'
    
    @app.route('/user/<name>')
    def user(name):
        return f'Hello, {name}'
    
    if __name__ == '__main__':
        app.run(debug=True)
    ```
  </Accordion>

  <Accordion title="What is Django ORM?">
    Django ORM (Object-Relational Mapping) abstracts database operations. Maps Python classes to database tables. Define models as Python classes. Automatic SQL generation. Supports multiple databases. QuerySets for complex queries. Migrations handle schema changes.
  </Accordion>

  <Accordion title="How do you handle HTTP requests?">
    Use `requests` library for making HTTP requests. GET, POST, PUT, DELETE methods. Handle responses, status codes, headers, JSON. Example:
    ```python
    import requests
    response = requests.get('https://api.example.com/data')
    if response.status_code == 200:
        data = response.json()
    ```
  </Accordion>

  <Accordion title="What is REST API?">
    REST (Representational State Transfer) is architectural style for APIs. Uses HTTP methods (GET, POST, PUT, DELETE). Stateless, resource-based URLs. JSON commonly used. Create with Flask, Django REST Framework, or FastAPI. Define endpoints for CRUD operations.
  </Accordion>
</AccordionGroup>

<hr />

## 10. Data Science and Libraries

<AccordionGroup>
  <Accordion title="What is NumPy and why is it used?">
    NumPy is fundamental package for scientific computing. Provides multi-dimensional arrays (ndarray). Fast operations on arrays. Broadcasting capability. Linear algebra, random numbers, Fourier transforms. Foundation for pandas, scikit-learn. Written in C, much faster than Python lists.
  </Accordion>

  <Accordion title="What is pandas and its main data structures?">
    pandas is data manipulation and analysis library. Two main structures: **Series** (1D labeled array) and **DataFrame** (2D labeled table). SQL-like operations, groupby, merge, pivot. Handle missing data. Time series functionality. Read/write CSV, Excel, SQL, JSON.
  </Accordion>

  <Accordion title="How do you handle missing data in pandas?">
    Several methods: `isnull()` and `notnull()` detect missing values. `dropna()` removes rows/columns with NaN. `fillna()` fills NaN with value. `interpolate()` fills based on interpolation. `isna()` checks for missing. Different strategies for different scenarios.
  </Accordion>

  <Accordion title="What is matplotlib?">
    matplotlib is plotting library for creating static, animated, interactive visualizations. `pyplot` module provides MATLAB-like interface. Line plots, scatter plots, bar charts, histograms. Customizable colors, labels, legends. Save figures to files.
  </Accordion>

  <Accordion title="What is scikit-learn used for?">
    scikit-learn is machine learning library. Classification, regression, clustering algorithms. Model selection, preprocessing, metrics. Simple consistent API. Built on NumPy, SciPy, matplotlib. Includes datasets, dimensionality reduction, ensemble methods.
  </Accordion>
</AccordionGroup>

<hr />

## 11. Additional Important Topics

<AccordionGroup>
  <Accordion title="What is list slicing?">
    Slicing extracts portion of sequence. Syntax: `sequence[start:end:step]`. start is inclusive, end is exclusive. Negative indices count from end. Omitting values uses defaults. Creates shallow copy. Example: `lst[1:4]` gets elements 1-3, `lst[::-1]` reverses list.
  </Accordion>

  <Accordion title="What is the difference between '==' and 'is'?">
    `==` compares values (equality). `is` checks if objects are same in memory (identity). Use `==` for value comparison. Use `is` primarily with None checks. Example: `a = [1,2]; b = [1,2]; a == b` is True, `a is b` is False.
  </Accordion>

  <Accordion title="What are Python's logical operators?">
    Three logical operators: `and` (returns True if both operands are True), `or` (returns True if at least one is True), `not` (negates boolean value). Short-circuit evaluation: `and` stops at first False, `or` stops at first True.
  </Accordion>

  <Accordion title="What is the enumerate() function?">
    `enumerate()` adds counter to iterable, returns enumerate object yielding tuples of (index, value). Useful in loops when you need both index and value. Start parameter specifies starting index (default 0). Example: `for index, fruit in enumerate(fruits):`
  </Accordion>

  <Accordion title="What is the zip() function?">
    `zip()` combines multiple iterables element-wise into tuples. Returns iterator of tuples. Stops at shortest iterable. Use `zip(*zipped)` to unzip. Useful for parallel iteration. Example: `for name, age in zip(names, ages):`
  </Accordion>
</AccordionGroup>

<hr />

## 12. Core Programming Concepts

<AccordionGroup>
  <Accordion title="What is the difference between append() and extend()?">
    `append()` adds single element to end of list (element can be any type, including list). `extend()` adds all elements from iterable to end of list. `append()` increases length by 1, `extend()` increases by number of elements in iterable.
  </Accordion>

  <Accordion title="What are default arguments in functions?">
    Default arguments have preset values in function definition. Used when argument not provided in call. Must come after non-default arguments. WARNING: Don't use mutable defaults (lists, dicts) as they persist across calls. Example: `def greet(name, message='Hello'):`
  </Accordion>

  <Accordion title="What is the difference between remove(), pop(), and del?">
    `remove(value)` removes first occurrence of value, raises ValueError if not found. `pop(index)` removes and returns item at index, default is last item. `del` statement removes item at index or deletes entire list. All modify list in place.
  </Accordion>

  <Accordion title="What is string formatting?">
    Multiple ways: Old style % formatting, `str.format()` method, f-strings (formatted string literals). f-strings are most modern and readable (Python 3.6+). Support expressions inside {}. Example: `f'{name} is {age} years old'`, `f'{name.upper()} is {age*2}'`.
  </Accordion>

  <Accordion title="What are the any() and all() functions?">
    `any()` returns True if at least one element in iterable is True. `all()` returns True if all elements are True. Short-circuit evaluation. Empty iterable: `any()` returns False, `all()` returns True. Useful for checking conditions on sequences.
  </Accordion>
</AccordionGroup>

<hr />

## Conclusion & Interview Tips

This comprehensive guide covers 100 essential Python interview questions across all major categories including basics, data structures, OOP, functions, file handling, exception handling, modules, advanced concepts, web development, and data science.

### Key Interview Preparation Tips

- **Master Python fundamentals** before diving into frameworks
- **Practice coding problems** on platforms like LeetCode and HackerRank
- **Build real projects** to demonstrate practical skills
- **Understand memory management** and performance implications
- **Study common algorithms** and data structure implementations
- **Review Python's standard library** and popular third-party packages
- **Prepare for both theoretical** and practical coding questions

### During the Interview

- **Read questions carefully** and ask for clarification
- **Explain your thought process** while solving problems
- **Write clean, readable code** with proper variable names
- **Consider edge cases** and error handling
- **Discuss time and space complexity** of your solutions
- **Be honest about what you don't know** but show willingness to learn

### Technical Skills to Demonstrate

- Strong understanding of Python syntax and semantics
- Proficiency with data structures and algorithms
- Object-oriented programming principles
- Error handling and debugging skills
- Knowledge of Python ecosystem and libraries
- Problem-solving and analytical thinking
- Code optimization and performance awareness

<Info>
Python interviews often test not just language knowledge but also problem-solving approach, code quality, and understanding of computer science fundamentals. Practice explaining your code and reasoning clearly.
</Info>

<Check>
Good luck with your Python interviews! Remember that consistent practice and building real projects are the best ways to prepare.
</Check>