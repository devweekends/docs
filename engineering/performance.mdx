---
title: "Performance & Optimization"
description: "Caching, Profiling, Load Testing, and Scaling strategies"
icon: "gauge-high"
---

<img
  className="block rounded-lg"
  src="/images/engineering/performance.png"
  alt="Performance & Optimization"
/>

## Overview

Performance optimization is about making systems faster and more efficient. The key is measuring first, then optimizing the right things.

## Performance Metrics

<CardGroup cols={2}>
  <Card title="Latency" icon="clock">
    - Time to complete one request
    - Measure: p50, p95, p99
    - Target: < 200ms for web APIs
  </Card>
  <Card title="Throughput" icon="gauge">
    - Requests per second (RPS)
    - Transactions per second (TPS)
    - Target: Depends on scale
  </Card>
  <Card title="Availability" icon="heart-pulse">
    - Uptime percentage
    - 99.9% = 8.76 hours downtime/year
    - 99.99% = 52 minutes/year
  </Card>
  <Card title="Resource Usage" icon="microchip">
    - CPU, Memory, Disk, Network
    - Cost efficiency
    - Bottleneck identification
  </Card>
</CardGroup>

## Caching Strategies

### Cache Levels

```
┌─────────────────────────────────────────────────────────┐
│                    Client                               │
│  ┌─────────────────────────────────────────────────┐   │
│  │              Browser Cache                      │   │
│  │         (Static assets, API responses)          │   │
│  └─────────────────────────────────────────────────┘   │
└────────────────────────┬────────────────────────────────┘
                         │
┌────────────────────────┼────────────────────────────────┐
│                        ▼                                │
│  ┌─────────────────────────────────────────────────┐   │
│  │                   CDN                           │   │
│  │      (Edge caching, global distribution)        │   │
│  └─────────────────────────────────────────────────┘   │
│                        │                                │
│                        ▼                                │
│  ┌─────────────────────────────────────────────────┐   │
│  │            Application Cache                    │   │
│  │         (Redis, Memcached - in-memory)          │   │
│  └─────────────────────────────────────────────────┘   │
│                        │                                │
│                        ▼                                │
│  ┌─────────────────────────────────────────────────┐   │
│  │               Database                          │   │
│  │      (Query cache, buffer pool)                 │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

### Caching Patterns

```python
# Cache-Aside (Lazy Loading)
def get_user(user_id):
    # 1. Check cache first
    cached = redis.get(f"user:{user_id}")
    if cached:
        return json.loads(cached)
    
    # 2. Cache miss - fetch from DB
    user = db.query("SELECT * FROM users WHERE id = ?", user_id)
    
    # 3. Store in cache for next time
    redis.setex(f"user:{user_id}", 3600, json.dumps(user))
    
    return user

# Write-Through
def update_user(user_id, data):
    # 1. Update database
    db.update("UPDATE users SET ... WHERE id = ?", data, user_id)
    
    # 2. Update cache immediately
    redis.setex(f"user:{user_id}", 3600, json.dumps(data))

# Cache Invalidation
def delete_user(user_id):
    db.delete("DELETE FROM users WHERE id = ?", user_id)
    redis.delete(f"user:{user_id}")
```

### Cache Invalidation Strategies

| Strategy | Description | Use When |
|----------|-------------|----------|
| **TTL (Time-to-Live)** | Auto-expire after time | Acceptable staleness |
| **Event-based** | Invalidate on update | Real-time consistency |
| **Version tags** | Change key on update | Immutable objects |

## Database Optimization

### Query Optimization

```sql
-- ❌ Slow: Full table scan
SELECT * FROM orders WHERE YEAR(created_at) = 2024;

-- ✅ Fast: Use index-friendly query
SELECT * FROM orders 
WHERE created_at >= '2024-01-01' 
  AND created_at < '2025-01-01';

-- ❌ Slow: SELECT *
SELECT * FROM users WHERE id = 1;

-- ✅ Fast: Select only needed columns
SELECT id, name, email FROM users WHERE id = 1;

-- Explain query plan
EXPLAIN ANALYZE SELECT * FROM orders WHERE user_id = 123;
```

### Indexing Strategy

```sql
-- Single column index
CREATE INDEX idx_users_email ON users(email);

-- Composite index (order matters!)
CREATE INDEX idx_orders_user_status ON orders(user_id, status);
-- This index helps: WHERE user_id = 1 AND status = 'pending'
-- Also helps: WHERE user_id = 1
-- Does NOT help: WHERE status = 'pending'

-- Covering index (includes all needed columns)
CREATE INDEX idx_users_covering ON users(email) INCLUDE (name, created_at);
```

### Connection Pooling

```python
# ❌ Bad: New connection per request
def get_user(user_id):
    conn = psycopg2.connect(...)  # Expensive!
    result = conn.execute(query)
    conn.close()
    return result

# ✅ Good: Connection pool
from sqlalchemy import create_engine

engine = create_engine(
    DATABASE_URL,
    pool_size=20,
    max_overflow=10,
    pool_timeout=30
)
```

## Scaling Strategies

### Vertical vs Horizontal Scaling

```
Vertical Scaling (Scale Up)     Horizontal Scaling (Scale Out)
┌─────────────────────┐         ┌──────┐ ┌──────┐ ┌──────┐
│                     │         │Server│ │Server│ │Server│
│    Bigger Server    │         │  1   │ │  2   │ │  3   │
│                     │         └──────┘ └──────┘ └──────┘
│  More CPU, RAM      │              │       │       │
│                     │              └───────┼───────┘
└─────────────────────┘                      │
                                    ┌────────┴────────┐
                                    │  Load Balancer  │
                                    └─────────────────┘
```

### Load Balancing Algorithms

| Algorithm | Description | Best For |
|-----------|-------------|----------|
| **Round Robin** | Rotate through servers | Equal server capacity |
| **Least Connections** | Send to server with fewest connections | Variable request duration |
| **IP Hash** | Same client → same server | Session affinity |
| **Weighted** | Distribute based on capacity | Mixed server sizes |

### Database Scaling

```
                     Read Replicas
                          │
    ┌─────────────────────┼─────────────────────┐
    │                     │                     │
    ▼                     ▼                     ▼
┌────────┐          ┌────────┐           ┌────────┐
│Replica │          │Replica │           │Replica │
│   1    │          │   2    │           │   3    │
└────────┘          └────────┘           └────────┘
    ▲                     ▲                     ▲
    │                     │                     │
    └─────────────────────┴─────────────────────┘
                          │
                    Replication
                          │
                    ┌─────────┐
                    │ Primary │ ◄── All writes
                    │   DB    │
                    └─────────┘
```

## Profiling & Benchmarking

### Application Profiling

```python
# Python profiling
import cProfile
import pstats

def profile_function(func):
    profiler = cProfile.Profile()
    profiler.enable()
    
    result = func()
    
    profiler.disable()
    stats = pstats.Stats(profiler)
    stats.sort_stats('cumulative')
    stats.print_stats(10)  # Top 10 slowest
    
    return result

# Memory profiling
from memory_profiler import profile

@profile
def memory_intensive_function():
    large_list = [i for i in range(1000000)]
    return sum(large_list)
```

### Load Testing

```python
# Using locust for load testing
from locust import HttpUser, task, between

class WebsiteUser(HttpUser):
    wait_time = between(1, 5)
    
    @task(3)
    def view_homepage(self):
        self.client.get("/")
    
    @task(1)
    def view_product(self):
        self.client.get("/products/1")
    
    @task(1)
    def create_order(self):
        self.client.post("/orders", json={
            "product_id": 1,
            "quantity": 2
        })
```

## Optimization Checklist

<Steps>
  <Step title="Measure First">
    Never optimize without data. Profile your application, identify bottlenecks.
  </Step>
  <Step title="Cache Aggressively">
    Add caching at every level - browser, CDN, application, database.
  </Step>
  <Step title="Optimize Queries">
    Use EXPLAIN, add proper indexes, avoid N+1 queries.
  </Step>
  <Step title="Use Async">
    Don't block on I/O. Use async/await, message queues, background jobs.
  </Step>
  <Step title="Scale Appropriately">
    Start with vertical scaling (simpler), move to horizontal when needed.
  </Step>
</Steps>

<Tip>
**Remember**: "Premature optimization is the root of all evil" - Donald Knuth. Focus on clean code first, then optimize the actual bottlenecks.
</Tip>
