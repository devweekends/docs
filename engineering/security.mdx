---
title: "Security Fundamentals"
description: "Authentication, Authorization, Encryption, and OWASP Top 10"
icon: "shield-halved"
---

## Overview

Security is not optional. Understanding security fundamentals helps you build systems that protect user data and resist attacks.

## Authentication vs Authorization

<CardGroup cols={2}>
  <Card title="Authentication (AuthN)" icon="id-card">
    **Who are you?**
    - Verifies identity
    - Login, passwords, MFA
    - "Prove you are who you claim"
  </Card>
  <Card title="Authorization (AuthZ)" icon="key">
    **What can you do?**
    - Verifies permissions
    - Roles, policies, ACLs
    - "Are you allowed to do this?"
  </Card>
</CardGroup>

## Authentication Methods

### Password-Based (Traditional)

```python
import bcrypt

# Storing passwords
def hash_password(password: str) -> bytes:
    salt = bcrypt.gensalt(rounds=12)
    return bcrypt.hashpw(password.encode(), salt)

# Verifying passwords
def verify_password(password: str, hashed: bytes) -> bool:
    return bcrypt.checkpw(password.encode(), hashed)
```

### JWT (JSON Web Tokens)

```
┌─────────────────────────────────────────────────────┐
│                     JWT Token                        │
├─────────────────┬─────────────────┬─────────────────┤
│     Header      │     Payload     │    Signature    │
│  {"alg":"HS256"}│ {"sub":"12345"} │   HMACSHA256(   │
│                 │ {"exp":16234...}│   header.payload│
│                 │                 │   , secret)     │
└─────────────────┴─────────────────┴─────────────────┘
         ↓                ↓                 ↓
    Base64URL        Base64URL         Base64URL
         ↓                ↓                 ↓
    eyJhbGci....   eyJzdWIi....    SflKxwRJS...
```

```python
import jwt
from datetime import datetime, timedelta

# Creating JWT
def create_token(user_id: str, secret: str) -> str:
    payload = {
        "sub": user_id,
        "iat": datetime.utcnow(),
        "exp": datetime.utcnow() + timedelta(hours=24)
    }
    return jwt.encode(payload, secret, algorithm="HS256")

# Verifying JWT
def verify_token(token: str, secret: str) -> dict:
    try:
        return jwt.decode(token, secret, algorithms=["HS256"])
    except jwt.ExpiredSignatureError:
        raise Exception("Token expired")
    except jwt.InvalidTokenError:
        raise Exception("Invalid token")
```

### OAuth 2.0 Flow

```
┌──────────┐                              ┌──────────────┐
│   User   │                              │Authorization │
│          │                              │   Server     │
└────┬─────┘                              └──────┬───────┘
     │                                           │
     │  1. User clicks "Login with Google"       │
     │──────────────────────────────────────────►│
     │                                           │
     │  2. Redirect to authorization page        │
     │◄──────────────────────────────────────────│
     │                                           │
     │  3. User grants permission                │
     │──────────────────────────────────────────►│
     │                                           │
     │  4. Redirect with authorization code      │
     │◄──────────────────────────────────────────│
     │                                           │
┌────┴─────┐  5. Exchange code for tokens ┌──────┴───────┐
│   App    │──────────────────────────────►│Auth Server   │
│          │◄──────────────────────────────│              │
└──────────┘  6. Access + Refresh tokens   └──────────────┘
```

## OWASP Top 10 (2021)

### 1. Broken Access Control

```python
# ❌ Vulnerable: No authorization check
@app.get("/users/{user_id}/data")
def get_user_data(user_id: int):
    return db.get_user_data(user_id)  # Anyone can access any user's data!

# ✅ Secure: Check authorization
@app.get("/users/{user_id}/data")
def get_user_data(user_id: int, current_user: User = Depends(get_current_user)):
    if current_user.id != user_id and not current_user.is_admin:
        raise HTTPException(403, "Access denied")
    return db.get_user_data(user_id)
```

### 2. Cryptographic Failures

```python
# ❌ Bad: Weak hashing
import hashlib
password_hash = hashlib.md5(password.encode()).hexdigest()

# ✅ Good: Proper password hashing
import bcrypt
password_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt(12))
```

### 3. Injection

```python
# ❌ SQL Injection vulnerable
query = f"SELECT * FROM users WHERE id = {user_id}"

# ✅ Parameterized query
query = "SELECT * FROM users WHERE id = ?"
cursor.execute(query, (user_id,))
```

### 4. Insecure Design

```python
# ❌ Bad: Security question for password reset
def reset_password(email, mothers_maiden_name):
    # Easily guessable/discoverable answers
    pass

# ✅ Good: Token-based password reset
def reset_password(email):
    token = generate_secure_token()
    send_reset_email(email, token)
    store_token_with_expiry(email, token, expiry=30_minutes)
```

### 5. Security Misconfiguration

```python
# ❌ Bad: Debug mode in production
app.run(debug=True)

# ❌ Bad: Default credentials
DATABASE_PASSWORD = "admin123"

# ✅ Good: Secure configuration
app.run(debug=os.getenv("FLASK_DEBUG", False))
DATABASE_PASSWORD = os.getenv("DATABASE_PASSWORD")
```

### 6. Vulnerable Components

```bash
# Regularly audit dependencies
npm audit
pip-audit
snyk test

# Keep dependencies updated
npm update
pip install --upgrade package_name
```

### 7. Authentication Failures

```python
# ❌ Bad: No rate limiting
@app.post("/login")
def login(credentials):
    return authenticate(credentials)

# ✅ Good: Rate limiting + account lockout
from slowapi import Limiter

limiter = Limiter(key_func=get_remote_address)

@app.post("/login")
@limiter.limit("5/minute")
def login(credentials):
    if get_failed_attempts(credentials.email) > 5:
        raise HTTPException(429, "Account locked")
    return authenticate(credentials)
```

## Encryption

### Symmetric vs Asymmetric

| Type | Key | Speed | Use Case |
|------|-----|-------|----------|
| **Symmetric** (AES) | Same key | Fast | Data at rest, bulk encryption |
| **Asymmetric** (RSA) | Public/Private pair | Slow | Key exchange, digital signatures |

### HTTPS/TLS

```
┌──────────┐                          ┌──────────┐
│  Client  │                          │  Server  │
└────┬─────┘                          └────┬─────┘
     │  1. ClientHello (supported ciphers) │
     │─────────────────────────────────────►│
     │                                      │
     │  2. ServerHello + Certificate        │
     │◄─────────────────────────────────────│
     │                                      │
     │  3. Key Exchange (encrypted)         │
     │─────────────────────────────────────►│
     │                                      │
     │  4. Secure connection established    │
     │◄────────────────────────────────────►│
     │     (All traffic encrypted)          │
     └──────────────────────────────────────┘
```

## Security Checklist

<AccordionGroup>
  <Accordion title="Input Validation">
    - Validate all user inputs
    - Use allowlists, not blocklists
    - Sanitize before output (prevent XSS)
  </Accordion>
  
  <Accordion title="Authentication">
    - Hash passwords with bcrypt/Argon2
    - Implement MFA
    - Use secure session management
    - Rate limit login attempts
  </Accordion>
  
  <Accordion title="Authorization">
    - Implement least privilege
    - Check permissions server-side
    - Use role-based access control (RBAC)
  </Accordion>
  
  <Accordion title="Data Protection">
    - Encrypt sensitive data at rest
    - Use HTTPS everywhere
    - Never log sensitive data
    - Implement proper key management
  </Accordion>
</AccordionGroup>

<Warning>
**Security is everyone's job.** Don't assume "someone else will handle security." Build it in from the start.
</Warning>
