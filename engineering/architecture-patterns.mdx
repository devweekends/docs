---
title: "Architecture Patterns"
description: "Microservices, Monolith, Event-Driven, and other architectural patterns"
icon: "building"
---

## Overview

Choosing the right architecture pattern is crucial for building scalable, maintainable systems. Each pattern has trade-offs, and the best choice depends on your specific context: team size, domain complexity, scale requirements, and organizational structure.

<Note>
**Conway's Law**: "Organizations design systems that mirror their own communication structure." Your architecture should align with your team structure.
</Note>

## Monolithic Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Monolith                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   UI     â”‚  Users   â”‚  Orders  â”‚ Payments â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚            Shared Database                  â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

<CardGroup cols={2}>
  <Card title="âœ… Pros" icon="check">
    - Simple to develop & deploy
    - Easy debugging (single process)
    - No network latency between modules
    - ACID transactions easy
  </Card>
  <Card title="âŒ Cons" icon="xmark">
    - Hard to scale individual parts
    - Long deployment cycles
    - Technology lock-in
    - One bug can crash everything
  </Card>
</CardGroup>

**Best For**: Startups, MVPs, small teams, simple domains

## Microservices Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  User   â”‚  â”‚  Order  â”‚  â”‚ Payment â”‚  â”‚  Notif  â”‚
â”‚ Service â”‚  â”‚ Service â”‚  â”‚ Service â”‚  â”‚ Service â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚            â”‚            â”‚            â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚    API Gateway    â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚      Clients      â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

<CardGroup cols={2}>
  <Card title="âœ… Pros" icon="check">
    - Independent scaling
    - Technology diversity
    - Fault isolation
    - Faster deployments
  </Card>
  <Card title="âŒ Cons" icon="xmark">
    - Distributed system complexity
    - Network latency
    - Data consistency challenges
    - Operational overhead
  </Card>
</CardGroup>

**Best For**: Large teams, complex domains, high scale requirements

### Service Communication

```python
# Synchronous (HTTP/REST)
import requests

def get_user_orders(user_id):
    user = requests.get(f"http://user-service/users/{user_id}").json()
    orders = requests.get(f"http://order-service/orders?user={user_id}").json()
    return {"user": user, "orders": orders}

# Asynchronous (Message Queue)
import pika

def publish_order_created(order):
    channel.basic_publish(
        exchange='orders',
        routing_key='order.created',
        body=json.dumps(order)
    )
```

## Event-Driven Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Event Bus                         â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚         â”‚         â”‚         â”‚         â”‚
     â–¼         â–¼         â–¼         â–¼         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Order  â”‚ â”‚Inventoryâ”‚ â”‚ Paymentâ”‚ â”‚ Email  â”‚ â”‚Analyticsâ”‚
â”‚ Serviceâ”‚ â”‚ Service â”‚ â”‚ Serviceâ”‚ â”‚ Serviceâ”‚ â”‚ Serviceâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Event Sourcing

```python
# Store events, not state
class OrderEventStore:
    def append(self, event):
        self.events.append({
            "type": event.type,
            "data": event.data,
            "timestamp": datetime.now()
        })
    
    def get_order_state(self, order_id):
        # Replay events to get current state
        order = Order()
        for event in self.events:
            if event["data"]["order_id"] == order_id:
                order.apply(event)
        return order

# Event types
OrderCreated(order_id="123", items=[...])
PaymentReceived(order_id="123", amount=100)
OrderShipped(order_id="123", tracking="XYZ")
```

### CQRS (Command Query Responsibility Segregation)

```
Commands (Write)              Queries (Read)
     â”‚                              â”‚
     â–¼                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Command â”‚                  â”‚    Query    â”‚
â”‚ Handler â”‚                  â”‚   Handler   â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
     â”‚                              â”‚
     â–¼                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    Sync/         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Write  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º   â”‚   Read    â”‚
â”‚   DB    â”‚   Events         â”‚   DB      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Layered Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Presentation Layer           â”‚  â—„â”€â”€â”€ UI, Controllers
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Application Layer           â”‚  â—„â”€â”€â”€ Use Cases, Services
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚          Domain Layer               â”‚  â—„â”€â”€â”€ Business Logic, Entities
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚        Infrastructure Layer         â”‚  â—„â”€â”€â”€ DB, External APIs
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```python
# Clean Architecture Example

# Domain Layer (innermost - no dependencies)
class Order:
    def __init__(self, id, items):
        self.id = id
        self.items = items
        self.status = "pending"
    
    def calculate_total(self):
        return sum(item.price for item in self.items)

# Application Layer (use cases)
class CreateOrderUseCase:
    def __init__(self, order_repo, payment_service):
        self.order_repo = order_repo
        self.payment_service = payment_service
    
    def execute(self, order_data):
        order = Order(**order_data)
        self.payment_service.process(order.calculate_total())
        self.order_repo.save(order)
        return order

# Infrastructure Layer (outermost)
class PostgresOrderRepository:
    def save(self, order):
        # SQL implementation
        pass

class StripePaymentService:
    def process(self, amount):
        # Stripe API call
        pass
```

## Comparison Matrix

| Pattern | Complexity | Scalability | Team Size | Use Case |
|---------|------------|-------------|-----------|----------|
| Monolith | ğŸŸ¢ Low | ğŸŸ¡ Medium | Small | MVPs, Startups |
| Microservices | ğŸ”´ High | ğŸŸ¢ High | Large | Complex domains |
| Event-Driven | ğŸ”´ High | ğŸŸ¢ High | Medium+ | Real-time, Async |
| Layered | ğŸŸ¢ Low | ğŸŸ¡ Medium | Any | Traditional apps |

## Hexagonal Architecture (Ports and Adapters)

The core business logic is isolated from external concerns through ports (interfaces) and adapters (implementations).

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                                     â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  REST API â”‚â”€â”€â”€â”¼â”€â”€â–ºâ”‚          PORT               â”‚   â”‚   â”‚  Database â”‚
    â”‚  Adapter  â”‚   â”‚   â”‚    (Input Interface)        â”‚   â”‚   â”‚  Adapter  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚               â”‚                     â”‚         â–²
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚               â–¼                     â”‚         â”‚
    â”‚   CLI     â”‚â”€â”€â”€â”¼â”€â”€â–ºâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
    â”‚  Adapter  â”‚   â”‚   â”‚                             â”‚   â”‚   â”‚   PORT    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚      DOMAIN / CORE          â”‚â—„â”€â”€â”¼â”€â”€â”€â”‚  (Output) â”‚
                    â”‚   â”‚    (Business Logic)         â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚                             â”‚   â”‚         â”‚
    â”‚   gRPC    â”‚â”€â”€â”€â”¼â”€â”€â–ºâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚         â–¼
    â”‚  Adapter  â”‚   â”‚               â”‚                     â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚               â–¼                     â”‚   â”‚   Email   â”‚
                    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚  Adapter  â”‚
                    â”‚   â”‚          PORT               â”‚â”€â”€â”€â”¼â”€â”€â–ºâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚   â”‚    (Output Interface)       â”‚   â”‚
                    â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
                    â”‚                                     â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```python
# Port (Interface)
from abc import ABC, abstractmethod

class UserRepository(ABC):
    @abstractmethod
    def save(self, user: User) -> None: pass
    
    @abstractmethod
    def find_by_id(self, user_id: str) -> User: pass

# Adapter (Implementation)
class PostgresUserRepository(UserRepository):
    def __init__(self, connection):
        self.connection = connection
    
    def save(self, user: User) -> None:
        self.connection.execute(
            "INSERT INTO users ...", user.to_dict()
        )
    
    def find_by_id(self, user_id: str) -> User:
        row = self.connection.query("SELECT * FROM users WHERE id = ?", user_id)
        return User.from_dict(row)

# Domain service (core business logic, no external dependencies)
class UserService:
    def __init__(self, user_repo: UserRepository):  # Inject port
        self.user_repo = user_repo
    
    def register_user(self, name: str, email: str) -> User:
        user = User(name=name, email=email)
        user.validate()  # Business rule
        self.user_repo.save(user)
        return user
```

## Domain-Driven Design (DDD) Concepts

### Strategic Design

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        E-Commerce System                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Order Context â”‚  Catalog Contextâ”‚     Shipping Context        â”‚
â”‚                 â”‚                 â”‚                             â”‚
â”‚  - Order        â”‚  - Product      â”‚  - Shipment                 â”‚
â”‚  - OrderItem    â”‚  - Category     â”‚  - Carrier                  â”‚
â”‚  - Customer*    â”‚  - Inventory    â”‚  - TrackingInfo             â”‚
â”‚                 â”‚                 â”‚  - Customer*                â”‚
â”‚                 â”‚                 â”‚                             â”‚
â”‚  * Different    â”‚                 â”‚  * Different view of        â”‚
â”‚    view of      â”‚                 â”‚    Customer than in         â”‚
â”‚    Customer     â”‚                 â”‚    Order Context            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                   â”‚                      â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                   Anti-Corruption Layer
                   (Context Mapping)
```

### Tactical Design Patterns

```python
# Entity (has identity)
class Order:
    def __init__(self, order_id: str):
        self.id = order_id  # Identity
        self.items = []
        self.status = "pending"
    
    def add_item(self, product_id: str, quantity: int, price: Decimal):
        self.items.append(OrderItem(product_id, quantity, price))
    
    def calculate_total(self) -> Decimal:
        return sum(item.subtotal for item in self.items)

# Value Object (no identity, immutable)
@dataclass(frozen=True)
class Money:
    amount: Decimal
    currency: str
    
    def add(self, other: "Money") -> "Money":
        if self.currency != other.currency:
            raise ValueError("Currency mismatch")
        return Money(self.amount + other.amount, self.currency)

# Aggregate (cluster of entities with a root)
class Order:  # Aggregate Root
    def __init__(self, order_id: str, customer_id: str):
        self.id = order_id
        self.customer_id = customer_id
        self._items: List[OrderItem] = []  # Part of aggregate
    
    def add_item(self, product: Product, quantity: int):
        # Business rule: max 10 items per order
        if len(self._items) >= 10:
            raise DomainError("Order cannot have more than 10 items")
        self._items.append(OrderItem(product.id, quantity, product.price))

# Domain Event
@dataclass
class OrderPlaced:
    order_id: str
    customer_id: str
    total: Decimal
    timestamp: datetime

# Repository (persistence abstraction)
class OrderRepository(ABC):
    @abstractmethod
    def save(self, order: Order) -> None: pass
    
    @abstractmethod
    def find_by_id(self, order_id: str) -> Optional[Order]: pass
```

## Saga Pattern (Distributed Transactions)

For maintaining data consistency across microservices without distributed transactions.

### Choreography-Based Saga

```
Order Service         Payment Service       Inventory Service
     â”‚                      â”‚                      â”‚
     â”‚   OrderCreated       â”‚                      â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚                      â”‚
     â”‚                      â”‚   PaymentProcessed   â”‚
     â”‚                      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
     â”‚                      â”‚                      â”‚
     â”‚                      â”‚   InventoryReserved  â”‚
     â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
     â”‚                      â”‚                      â”‚
     â”‚  OrderConfirmed      â”‚                      â”‚
     â”‚                      â”‚                      â”‚

Compensation (if Inventory fails):
     â”‚                      â”‚   InventoryFailed    â”‚
     â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
     â”‚   RefundPayment      â”‚                      â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚                      â”‚
     â”‚   OrderCancelled     â”‚                      â”‚
```

### Orchestration-Based Saga

```python
class OrderSagaOrchestrator:
    def __init__(self, payment_service, inventory_service, notification_service):
        self.payment = payment_service
        self.inventory = inventory_service
        self.notification = notification_service
    
    def execute(self, order: Order):
        try:
            # Step 1: Process payment
            payment_id = self.payment.process(order.total)
            
            # Step 2: Reserve inventory
            try:
                self.inventory.reserve(order.items)
            except InventoryError:
                # Compensate: Refund payment
                self.payment.refund(payment_id)
                raise
            
            # Step 3: Send confirmation
            self.notification.send_confirmation(order)
            
            return SagaResult.success(order.id)
            
        except Exception as e:
            return SagaResult.failure(str(e))
```

## API Gateway Pattern

```
                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                    â”‚  User Service   â”‚
                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Mobile  â”‚â”€â”€â”€â”€â”€â–ºâ”‚                 â”‚â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â–ºâ”‚  Order Service  â”‚
â”‚   App    â”‚      â”‚   API Gateway   â”‚       â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚                 â”‚       â”‚
                  â”‚  â€¢ Auth         â”‚       â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚  â€¢ Rate Limit   â”‚â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â–ºâ”‚ Payment Service â”‚
â”‚   Web    â”‚â”€â”€â”€â”€â”€â–ºâ”‚  â€¢ Routing      â”‚       â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚   App    â”‚      â”‚  â€¢ Aggregation  â”‚       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚  â€¢ Caching      â”‚       â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚  â€¢ SSL Term     â”‚â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â–ºâ”‚  Catalog Serviceâ”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚  â€¢ Logging      â”‚               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  Partner â”‚â”€â”€â”€â”€â”€â–ºâ”‚                 â”‚
â”‚   API    â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Backend for Frontend (BFF)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Mobile  â”‚â”€â”€â”€â”€â”€â–ºâ”‚   Mobile BFF    â”‚â”€â”€â”€â”€â”
â”‚   App    â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                             â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                         â”œâ”€â”€â”€â–ºâ”‚    Services     â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚   Web    â”‚â”€â”€â”€â”€â”€â–ºâ”‚    Web BFF      â”‚â”€â”€â”€â”€â”¤
â”‚   App    â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                             â”‚
                                         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  Admin   â”‚â”€â”€â”€â”€â”€â–ºâ”‚   Admin BFF     â”‚â”€â”€â”€â”€â”˜
â”‚  Panel   â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Circuit Breaker Pattern

Prevent cascading failures in distributed systems.

```python
import time
from enum import Enum

class CircuitState(Enum):
    CLOSED = "closed"      # Normal operation
    OPEN = "open"          # Failing, reject requests
    HALF_OPEN = "half_open"  # Testing if service recovered

class CircuitBreaker:
    def __init__(self, failure_threshold=5, recovery_timeout=30):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = CircuitState.CLOSED
    
    def call(self, func, *args, **kwargs):
        if self.state == CircuitState.OPEN:
            if time.time() - self.last_failure_time > self.recovery_timeout:
                self.state = CircuitState.HALF_OPEN
            else:
                raise CircuitOpenError("Circuit is open")
        
        try:
            result = func(*args, **kwargs)
            self._on_success()
            return result
        except Exception as e:
            self._on_failure()
            raise
    
    def _on_success(self):
        self.failure_count = 0
        self.state = CircuitState.CLOSED
    
    def _on_failure(self):
        self.failure_count += 1
        self.last_failure_time = time.time()
        if self.failure_count >= self.failure_threshold:
            self.state = CircuitState.OPEN

# Usage
circuit = CircuitBreaker(failure_threshold=3, recovery_timeout=60)

try:
    result = circuit.call(external_service.fetch_data)
except CircuitOpenError:
    result = cached_data  # Fallback
```

## Service Mesh

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         Service Mesh                            â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚    Service A        â”‚      â”‚    Service B        â”‚          â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚      â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚          â”‚
â”‚  â”‚  â”‚   App Code  â”‚    â”‚      â”‚  â”‚   App Code  â”‚    â”‚          â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â”‚      â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â”‚          â”‚
â”‚  â”‚         â”‚           â”‚      â”‚         â”‚           â”‚          â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”    â”‚      â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”    â”‚          â”‚
â”‚  â”‚  â”‚   Sidecar   â”‚â—„â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â–ºâ”‚   Sidecar   â”‚    â”‚          â”‚
â”‚  â”‚  â”‚   Proxy     â”‚    â”‚      â”‚  â”‚   Proxy     â”‚    â”‚          â”‚
â”‚  â”‚  â”‚ (Envoy)     â”‚    â”‚      â”‚  â”‚ (Envoy)     â”‚    â”‚          â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚      â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚              â”‚                          â”‚                       â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚
â”‚                         â”‚                                       â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚              â”‚    Control Plane    â”‚                           â”‚
â”‚              â”‚  (Istio, Linkerd)   â”‚                           â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â”‚                                                                 â”‚
â”‚  Features: mTLS, Load Balancing, Circuit Breaking,             â”‚
â”‚           Observability, Traffic Management                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Architecture Decision Records (ADR)

Document important architectural decisions.

```markdown
# ADR-001: Use PostgreSQL for Primary Database

## Status
Accepted

## Context
We need a database for our e-commerce platform that handles:
- Complex queries with JOINs
- ACID transactions for orders
- ~1M daily transactions

## Decision
Use PostgreSQL as our primary database.

## Consequences
### Positive
- Strong ACID compliance
- Rich query capabilities
- Mature ecosystem

### Negative
- Horizontal scaling is complex
- May need read replicas for scale

### Neutral
- Team has moderate PostgreSQL experience
```

## Comparison Matrix

| Pattern | Complexity | Scalability | Team Size | Use Case |
|---------|------------|-------------|-----------|----------|
| Monolith | ğŸŸ¢ Low | ğŸŸ¡ Medium | Small | MVPs, Startups |
| Modular Monolith | ğŸŸ¡ Medium | ğŸŸ¡ Medium | Small-Medium | Growing systems |
| Microservices | ğŸ”´ High | ğŸŸ¢ High | Large | Complex domains |
| Event-Driven | ğŸ”´ High | ğŸŸ¢ High | Medium+ | Real-time, Async |
| Serverless | ğŸŸ¡ Medium | ğŸŸ¢ High | Small-Medium | Sporadic workloads |
| Layered | ğŸŸ¢ Low | ğŸŸ¡ Medium | Any | Traditional apps |
| Hexagonal | ğŸŸ¡ Medium | ğŸŸ¡ Medium | Medium | Testable, maintainable |

<Tip>
**Interview Tip**: Always discuss trade-offs. There's no "best" architectureâ€”only the right one for your context. Consider team size, domain complexity, scale requirements, and time-to-market.
</Tip>

<Warning>
**Common Mistake**: Don't start with microservices. Start with a well-structured monolith, then extract services as needed. Premature decomposition causes more problems than it solves.
</Warning>
