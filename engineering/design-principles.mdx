---
title: "Software Design Principles"
description: "SOLID, DRY, KISS, and Clean Code practices for better software"
icon: "compass-drafting"
---

<img
  className="block rounded-lg"
  src="/images/engineering/design-principles.png"
  alt="Software Design Principles"
/>

## Overview

Good design principles lead to code that is maintainable, testable, and extensible. These principles are fundamental to writing professional-quality software.

## SOLID Principles

### S - Single Responsibility Principle

> A class should have only one reason to change.

```python
# ❌ Bad: Multiple responsibilities
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email
    
    def save_to_database(self):
        # Database logic
        pass
    
    def send_email(self):
        # Email logic
        pass

# ✅ Good: Single responsibility
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email

class UserRepository:
    def save(self, user):
        # Database logic only
        pass

class EmailService:
    def send(self, user, message):
        # Email logic only
        pass
```

### O - Open/Closed Principle

> Open for extension, closed for modification.

```python
# ❌ Bad: Must modify class for new shapes
class AreaCalculator:
    def calculate(self, shape):
        if shape.type == "circle":
            return 3.14 * shape.radius ** 2
        elif shape.type == "rectangle":
            return shape.width * shape.height
        # Must add more elif for each shape!

# ✅ Good: Extend without modifying
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14 * self.radius ** 2

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height

# New shapes just implement Shape interface
class Triangle(Shape):
    def __init__(self, base, height):
        self.base = base
        self.height = height
    
    def area(self):
        return 0.5 * self.base * self.height
```

### L - Liskov Substitution Principle

> Subtypes must be substitutable for their base types.

```python
# ❌ Bad: Square violates Rectangle's contract
class Rectangle:
    def set_width(self, width):
        self.width = width
    
    def set_height(self, height):
        self.height = height

class Square(Rectangle):
    def set_width(self, width):
        self.width = width
        self.height = width  # Violates expectation!
    
    def set_height(self, height):
        self.width = height
        self.height = height

# ✅ Good: Separate abstractions
class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height

class Square(Shape):
    def __init__(self, side):
        self.side = side
    
    def area(self):
        return self.side ** 2
```

### I - Interface Segregation Principle

> Clients should not depend on interfaces they don't use.

```python
# ❌ Bad: Fat interface
class Worker(ABC):
    @abstractmethod
    def work(self):
        pass
    
    @abstractmethod
    def eat(self):
        pass
    
    @abstractmethod
    def sleep(self):
        pass

class Robot(Worker):
    def work(self):
        print("Working...")
    
    def eat(self):
        pass  # Robots don't eat!
    
    def sleep(self):
        pass  # Robots don't sleep!

# ✅ Good: Segregated interfaces
class Workable(ABC):
    @abstractmethod
    def work(self):
        pass

class Eatable(ABC):
    @abstractmethod
    def eat(self):
        pass

class Human(Workable, Eatable):
    def work(self):
        print("Working...")
    
    def eat(self):
        print("Eating...")

class Robot(Workable):
    def work(self):
        print("Working...")
```

### D - Dependency Inversion Principle

> Depend on abstractions, not concretions.

```python
# ❌ Bad: High-level depends on low-level
class MySQLDatabase:
    def save(self, data):
        print("Saving to MySQL...")

class UserService:
    def __init__(self):
        self.db = MySQLDatabase()  # Tight coupling!
    
    def create_user(self, user):
        self.db.save(user)

# ✅ Good: Both depend on abstraction
class Database(ABC):
    @abstractmethod
    def save(self, data):
        pass

class MySQLDatabase(Database):
    def save(self, data):
        print("Saving to MySQL...")

class PostgreSQLDatabase(Database):
    def save(self, data):
        print("Saving to PostgreSQL...")

class UserService:
    def __init__(self, db: Database):  # Inject dependency
        self.db = db
    
    def create_user(self, user):
        self.db.save(user)

# Usage - easy to swap implementations
mysql_service = UserService(MySQLDatabase())
postgres_service = UserService(PostgreSQLDatabase())
```

## Other Important Principles

### DRY - Don't Repeat Yourself

```python
# ❌ Bad: Repeated logic
def calculate_employee_bonus(employee):
    base_salary = employee.salary
    years = employee.years_of_service
    bonus = base_salary * 0.1 * years
    return bonus

def calculate_manager_bonus(manager):
    base_salary = manager.salary
    years = manager.years_of_service
    bonus = base_salary * 0.1 * years  # Same logic!
    bonus += 5000  # Manager extra
    return bonus

# ✅ Good: Extract common logic
def calculate_base_bonus(person):
    return person.salary * 0.1 * person.years_of_service

def calculate_employee_bonus(employee):
    return calculate_base_bonus(employee)

def calculate_manager_bonus(manager):
    return calculate_base_bonus(manager) + 5000
```

### KISS - Keep It Simple, Stupid

```python
# ❌ Over-engineered
class StringReverserFactory:
    def create_reverser(self):
        return StringReverser()

class StringReverser:
    def reverse(self, s):
        return ''.join(reversed(list(s)))

# ✅ Simple
def reverse_string(s):
    return s[::-1]
```

### YAGNI - You Aren't Gonna Need It

> Don't add functionality until you actually need it.

```python
# ❌ Bad: Building for hypothetical future
class User:
    def __init__(self, name):
        self.name = name
        self.middle_name = None
        self.suffix = None
        self.nickname = None
        self.avatar_url = None
        self.theme_preference = None
        self.notification_settings = {}
        # 20 more fields "just in case"

# ✅ Good: Start minimal, add when needed
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email
```

## Clean Code Practices

<CardGroup cols={2}>
  <Card title="Meaningful Names" icon="tag">
    - Use intention-revealing names
    - Avoid abbreviations
    - Be consistent
  </Card>
  <Card title="Small Functions" icon="minimize">
    - Do one thing well
    - Few parameters (≤3)
    - No side effects
  </Card>
  <Card title="Comments" icon="comment">
    - Code should be self-documenting
    - Comment why, not what
    - Keep comments updated
  </Card>
  <Card title="Error Handling" icon="triangle-exclamation">
    - Use exceptions, not error codes
    - Provide context
    - Don't return null
  </Card>
</CardGroup>

<Warning>
**Common Mistake**: Over-applying principles can lead to over-engineering. Use judgment—simple problems need simple solutions.
</Warning>
