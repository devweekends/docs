---
title: "Modern C++"
sidebarTitle: "5. Modern C++"
icon: "star"
---


# Modern C++

Modern C++ (C++11 and beyond) brings features that make code safer, faster, and easier to write. If you learned C++ years ago, these features are game-changers!

---

## Why Modern C++?
- **Safer:** Smart pointers help prevent memory leaks.
- **Cleaner:** Type inference (`auto`), range-based loops, and lambdas reduce boilerplate.
- **Faster:** Move semantics and new algorithms improve performance.

---


## C++20 Features

### Concepts
Concepts let you specify template requirements.

```cpp
#include <concepts>
std::cout << add(2, 3); // 5
concept Numeric = std::is_arithmetic_v<T>;


T add(T a, T b) {
    return a + b;
}
```

### Ranges
Ranges make working with sequences easier.

```cpp
#include <ranges>
std::vector<int> nums = {1,2,3,4,5,6};
auto even = nums | std::views::filter([](int n) { return n % 2 == 0; });
for (int n : even) std::cout << n << " "; // 2 4 6
```

---

## Practical: Using std::filesystem

`std::filesystem` (C++17+) lets you work with files and directories easily.

```cpp
#include <filesystem>
for (const auto& entry : std::filesystem::directory_iterator(".")) {
    std::cout << entry.path() << std::endl;
}
```

---

## Challenge: Threading with std::thread

Write a program that launches two threads, each printing numbers from 1 to 5.
// Move semantics: Efficiently transfer resources
std::vector<int> v1 = {1,2,3};
std::vector<int> v2 = std::move(v1); // v1 is now empty

// Smart pointers: Automatic memory management
#include <memory>
std::unique_ptr<int> up = std::make_unique<int>(42);
```

---

## C++17/20 Features

```cpp
// Structured bindings: Unpack pairs/tuples
std::map<std::string, int> myMap = {{"a", 1}, {"b", 2}};
for (const auto& [key, value] : myMap) {
    std::cout << key << ": " << value << "\n";
}

// std::optional: Express 'maybe' values
#include <optional>
std::optional<int> getValue(bool ok) {
    if (ok) return 42;
    return std::nullopt;
}

// if constexpr (C++17): Compile-time branching
template<typename T>
void printType(const T& x) {
    if constexpr (std::is_integral_v<T>) {
        std::cout << "Integral\n";
    } else {
        std::cout << "Not integral\n";
    }
}
```

---

## Best Practices
- Prefer smart pointers over raw pointers.
- Use `auto` for complex types, but not everywhere.
- Use range-based for loops for readability.

---

## Mini-Exercise
- Write a lambda that multiplies two numbers.
- Use `std::optional` to return a value that might not exist.

---

**Congrats!** You now know the essentials of modern C++.

## C++20 Features
```cpp
// Concepts
template<typename T>
concept Numeric = std::is_arithmetic_v<T>;

template<Numeric T>
T add(T a, T b) {
    return a + b;
}

// Ranges
auto even = nums | std::views::filter([](int n) { return n % 2 == 0; });
```
