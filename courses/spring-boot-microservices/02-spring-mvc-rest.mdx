---
title: "Spring MVC & REST"
description: "Building powerful RESTful APIs"
icon: "server"
---

# Spring MVC & REST

Spring MVC is the web framework built on the Servlet API. In modern microservices, we mostly use it to build **REST APIs**.

## 1. REST Controller Annotations

| Annotation | Purpose |
| :--- | :--- |
| `@RestController` | Combines `@Controller` and `@ResponseBody`. |
| `@RequestMapping` | Base path for the controller (e.g., `/api/v1/users`). |
| `@GetMapping`, `@PostMapping` | Shortcuts for specific HTTP methods. |
| `@PutMapping`, `@DeleteMapping` | Update and Delete mappings. |
| `@PathVariable` | Extract values from the URI path (e.g., `/users/{id}`). |
| `@RequestParam` | Extract query parameters (e.g., `/users?role=admin`). |
| `@RequestBody` | Map the JSON body to a Java Object (POJO). |
| `@ResponseStatus` | Set the HTTP status code (e.g., 201 CREATED). |

## 2. Building a User API

Let's build a CRUD API for a `User` resource.

**The Domain Model (DTO)**

```java
public record UserDto(Long id, String name, String email) {}
```

**The Controller**

```java
@RestController
@RequestMapping("/api/v1/users")
public class UserController {

    // Simulating a DB
    private final List<UserDto> users = new ArrayList<>();

    @GetMapping
    public List<UserDto> getAllUsers() {
        return users;
    }

    @GetMapping("/{id}")
    public UserDto getUserById(@PathVariable Long id) {
        return users.stream()
                .filter(u -> u.id().equals(id))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("User not found"));
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public UserDto createUser(@RequestBody UserDto user) {
        users.add(user);
        return user;
    }
}
```

## 3. Exception Handling with @ControllerAdvice

Don't let raw stack traces leak to the client. Use global exception handling.

```java
@RestControllerAdvice // 1. Global Interceptor
public class GlobalExceptionHandler {

    @ExceptionHandler(RuntimeException.class) // 2. Catch this exception
    @ResponseStatus(HttpStatus.NOT_FOUND) // 3. Return 404
    public ErrorResponse handleNotFound(RuntimeException e) {
        return new ErrorResponse(404, e.getMessage());
    }
}

record ErrorResponse(int status, String message) {}
```

## 4. Bean Validation

Never trust client input. Use **Hibernate Validator** (implementation of Jakarta Bean Validation).

Add dependency `spring-boot-starter-validation`.

**Add Constraints to DTO**

```java
public record UserCreateRequest(
    @NotBlank(message = "Name is required")
    String name,

    @Email(message = "Invalid email format")
    @NotBlank
    String email
) {}
```

**Validate in Controller**

```java
@PostMapping
public UserDto createUser(@Valid @RequestBody UserCreateRequest request) { 
    // If validation fails, Spring throws MethodArgumentNotValidException
    // ... logic
}
```

You can then catch `MethodArgumentNotValidException` in your `@RestControllerAdvice` to return a nice list of validation errors.

## 5. Content Negotiation

Spring Boot uses `Jackson` by default to serialize/deserialize Java Objects to JSON.

- If you want XML, add `jackson-dataformat-xml` dependency.
- Spring will check the `Accept` header of the request to decide whether to return JSON or XML.

## 6. Internal Request Lifecycle (DispatcherServlet)

Spring MVC is designed around the **Front Controller** pattern. The `DispatcherServlet` handles all incoming requests.

<div className="flex justify-center my-4">
  <div className="w-full max-w-3xl">
    ```mermaid
    sequenceDiagram
        participant Client
        participant Tomcat
        participant DispatcherServlet
        participant HandlerMapping
        participant Controller
        participant ViewResolver

        Client->>Tomcat: HTTP GET /users/1
        Tomcat->>DispatcherServlet: Forward Request
        DispatcherServlet->>HandlerMapping: "Who handles /users/1?"
        HandlerMapping-->>DispatcherServlet: UserController.getUserById()
        DispatcherServlet->>Controller: Execute Method
        Controller-->>DispatcherServlet: Return UserDto (JSON)
        DispatcherServlet-->>Client: HTTP 200 OK (JSON)
    ```
  </div>
</div>

## 7. Filters vs Interceptors vs AOP

Interviewers love this question.

| Feature | Filter | Interceptor | AOP |
| :--- | :--- | :--- | :--- |
| **Layer** | Servlet Container (Tomcat) | Spring MVC Framework | Spring Bean (Method Level) |
| **Scope** | Runs for ALL requests (even non-Spring) | Runs only for valid DispatcherServlet requests | Runs for method calls |
| **Access** | Raw `ServletRequest` / `ServletResponse` | `HandlerMethod` (Knows which controller is mapped) | Method Arguments & Return Value |
| **Use Case** | Security, GZip Compression, CORS | Auth Checks, Logging execution time | Transaction mgmt, Audit Logging |

### Implementing an Interceptor

```java
public class LoggingInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        System.out.println("Incoming request: " + request.getRequestURI());
        return true; // Continue processing
    }
}

// Register it
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoggingInterceptor());
    }
}
```

## 8. Asynchronous Requests

If an API takes 10 seconds, you don't want to block a Tomcat thread (default ~200 threads) for 10s.

**CompletableFuture**
```java
@GetMapping("/async")
public CompletableFuture<String> asyncEndpoint() {
    return CompletableFuture.supplyAsync(() -> {
        slowService.process(); // Runs in a separate ForkJoinPool
        return "Done";
    });
}
```
*Tomcat thread is released immediately. The response is sent when the future completes.*

## 9. Spring Security Integration

Spring Security is simply a chain of standard Servlet Filters.

<div className="flex justify-center my-4">
  <div className="w-full max-w-3xl">
    ```mermaid
    graph LR
        Request --> F1[CorsFilter]
        F1 --> F2[CsrfFilter]
        F2 --> F3[AuthenticationFilter]
        F3 --> F4[AuthorizationFilter]
        F4 --> Controller
    ```
  </div>
</div>

If `AuthenticationFilter` fails (e.g., bad token), it throws an exception and the request **never** reaches the Controller.

## 10. Deep Dive: Spring Security Architecture

Spring Security is a lot more than just a few annotations.

### The Big Picture
1. **DelegatingFilterProxy:** A standard Servlet Filter (registered with Tomcat) that delegates to a Spring Bean.
2. **FilterChainProxy:** The Spring Bean that holds all security logic. It contains a list of **SecurityFilterChains**.
3. **SecurityFilterChain:** A chain of filters matching a specific URL pattern.

### The Authentication Flow

<div className="flex justify-center my-4">
  <div className="w-full max-w-3xl">
    ```mermaid
    sequenceDiagram
        participant Client
        participant AuthFilter as AuthenticationFilter
        participant AuthMgr as AuthenticationManager
        participant Provider as AuthenticationProvider
        participant UserSvc as UserDetailsService

        Client->>AuthFilter: POST /login (user, pass)
        AuthFilter->>AuthMgr: authenticate(token)
        AuthMgr->>Provider: authenticate(token)
        Provider->>UserSvc: loadUserByUsername("user")
        UserSvc-->>Provider: UserDetails (DB Hash)
        Provider->>Provider: Check Password (Bcrypt)
        Provider-->>AuthMgr: Success (Authentication Object)
        AuthMgr-->>AuthFilter: Success
        AuthFilter-->>Client: 200 OK + JWT
    ```
  </div>
</div>

### Key Components
- **AuthenticationManager:** The API that defines how Spring Security's Filters perform authentication.
- **ProviderManager:** The standard implementation of `AuthenticationManager`. It delegates to a list of `AuthenticationProvider`s.
- **AuthenticationProvider:** Doing the actual work (e.g., `DaoAuthenticationProvider` talks to DB, `LdapAuthenticationProvider` talks to LDAP).
- **UserDetailsService:** Interface to load user-specific data using a username.


