---
title: "Sonarqube Mastery"
sidebarTitle: "Sonarqube"
description: "Master static code analysis, custom quality gates, and securing your CI/CD pipeline."
icon: "magnifying-glass-chart"
---

# Sonarqube Mastery

SonarQube is the industry standard for automated code analysis. It moves beyond simple linting to provide a comprehensive view of "Code Health" across bugs, vulnerabilities, and maintainability.

<Info>
**Prerequisites**: Basic understanding of CI/CD concepts and Docker.
**Goal**: Transform from "running a scanner" to "managing technical debt" at scale.
</Info>

---

## 1. Architecture & Internals

Understanding how SonarQube works is critical for debugging analysis failures and optimizing performance.

### The Component View
The SonarQube platform is composed of four main components:

1.  **SonarQube Server**:
    *   **Web Server**: Serves the UI and API.
    *   **Search Server**: An embedded Elasticsearch instance. It indexes issues and metrics for instant retrieval.
    *   **Compute Engine (CE)**: The workhorse. It processes reports submitted by scanners. This is where the heavy lifting (diff calculations, issue persistence) happens.

2.  **Database**:
    *   Stores configuration (Quality profiles, user settings).
    *   Stores snapshots of code metrics.
    *   *Supported DBs*: PostgreSQL (Recommended), Oracle, SQL Server.
    *   *Warning*: The embedded `H2` database is for testing **only**. It cannot scale.

3.  **Scanner**:
    *   Runs on your Build Agent (Jenkins, GitHub Actions runner).
    *   Parses source code files.
    *   Runs language specific sensors (e.g., Java Sensor, JS Sensor).
    *   Sends a "Report" bundle to the Server for processing.

4.  **Plugins**:
    *   Language support (Java, C#, Python, etc.).
    *   Integration (LDAP, GitHub Auth).

### The Analysis Lifecycle

1.  **Checkout**: CI Server checks out code.
2.  **Scan**: Scanner runs. It downloads "Quality Profiles" (Rules) from the server.
3.  **Report**: Scanner finds issues locally and bundles them into a report.
4.  **Submit**: Report sent to Server.
5.  **Queue**: Server puts report in a queue.
6.  **Processing**: Compute Engine picks up report, calculates "New Code" diffs, applies Quality Gates.
7.  **Webhook**: Server notifies CI system of Pass/Fail status.

---

## 2. Production Installation (Docker Compose)

Running `docker run sonarqube` is fine for testing, but for production, you need persistence and performance tuning.

### `docker-compose.yml`

```yaml
version: "3"

services:
  sonarqube:
    image: sonarqube:lts-community
    depends_on:
      - db
    environment:
      SONAR_JDBC_URL: jdbc:postgresql://db:5432/sonar
      SONAR_JDBC_USERNAME: sonar
      SONAR_JDBC_PASSWORD: sonar
    volumes:
      - sonarqube_data:/opt/sonarqube/data
      - sonarqube_extensions:/opt/sonarqube/extensions
      - sonarqube_logs:/opt/sonarqube/logs
    ports:
      - "9000:9000"
    ulimits:
      nofile:
        soft: 65536
        hard: 65536

  db:
    image: postgres:15
    environment:
      POSTGRES_USER: sonar
      POSTGRES_PASSWORD: sonar
    volumes:
      - postgresql:/var/lib/postgresql/data
    volumes:
      - postgresql_data:/var/lib/postgresql/data

volumes:
  sonarqube_data:
  sonarqube_extensions:
  sonarqube_logs:
  postgresql_data:
```

### Kernel Tuning (Crucial!)
Elasticsearch requires specific system settings. On the host machine (Linux):

```bash
# Increase mapped memory areas
sysctl -w vm.max_map_count=262144

# Increase file descriptors
ulimit -n 65536
```
If you don't do this, SonarQube will crash on startup with ES errors.

---

## 3. Analysis Strategies

### The Token System
Never use username/password for scanners. Generate tokens:
*   **User Token**: Tied to a user account.
*   **Project Analysis Token**: Specific to a project (Best for automated pipelines).
*   **Global Analysis Token**: Can scan any project (Use sparingly).

### Scanner Selection

| Build Tool | Method | Pros | Cons |
|:---|:---|:---|:---|
| **Maven** | `mvn sonar:sonar` | Auto-detects modules, tests, binaries | Requires full build |
| **Gradle** | `./gradlew sonar` | excellent multi-module support | Slow configuration |
| **NPM** | `sonarqube-scanner` npm package | easy integration for JS apps | Manual config needed |
| **CLI** | `sonar-scanner` | Generic, works for everything | Must download binary |

### Configuration: `sonar-project.properties`
For CLI usage, this file is mandatory.

```properties
sonar.projectKey=my-org_frontend
sonar.organization=my-org
sonar.sources=src
sonar.tests=tests

# Exclusions are CRITICAL for speed and noise reduction
sonar.exclusions=**/*.test.js,**/coverage/**,**/dist/**
sonar.coverage.exclusions=**/config/**,**/dto/**

# LCOV report path (generated by Jest/PyTest)
sonar.javascript.lcov.reportPaths=coverage/lcov.info
```

---

## 4. Quality Gates Strategy

A **Quality Gate** is the boolean PASS/FAIL check.

### The "New Code" Philosophy
The most important metrics are on **New Code**. You cannot fix 5 years of technical debt in a day, but you *can* ensure no **new** debt is added.

**Recommended Setup**:
*   **New Code Definition**: "Previous Version" or "Number of days" (e.g., 30 days).
*   **Gate Conditions**:
    *   Coverage on New Code < 80% → **FAIL**
    *   Duplication on New Code < 3% → **FAIL**
    *   Maintainability Rating on New Code is worse than A → **FAIL**
    *   Blocker Issues on New Code > 0 → **FAIL**

### Monorepo Strategy
If you have one repo with 10 services:
1.  **One Project**: Analyze root. Good for overview, bad for ownership.
2.  **Multiple Projects**: Run scanner separately for `services/a`, `services/b`.
    *   Use `sonar.projectKey=monorepo:service-a`
    *   Use `sonar.sources=services/a`

---

## 5. Security Analysis (SAST) & Clean Code

### Taint Analysis
SonarQube Community Edition includes basic SAST. Developer Edition adds Taint Analysis.
*   **Source**: User input (e.g., `req.query.id`).
*   **Sink**: Sensitive function (e.g., `db.query()`).
*   **Sanitizer**: Code that cleans input.

SonarQube builds a control flow graph to see if data flows from Source to Sink without passing through a Sanitizer.

### Cognitive Complexity vs Cyclomatic Complexity
*   **Cyclomatic**: Number of paths through code. (Math based).
*   **Cognitive**: How hard is it for a human to understand? (Intuition based).

*Example*:
A switch statement with 10 cases has Cyclomatic=10 (high), but Cognitive=1 (low) because it's easy to read.
Nested loops have high Cognitive complexity.

---

## 6. CI/CD Integration (Jenkins & GitHub)

### The "Break The Build" Pattern
We want the pipeline to wait for SonarQube's verdict.

### Jenkins Pipeline

```groovy
pipeline {
    agent any
    stages {
        stage('Build & Test') {
            steps {
                sh 'npm install && npm test' // Generates coverage
            }
        }
        stage('SonarQube Analysis') {
            steps {
                withSonarQubeEnv('SonarQube-Server') {
                    sh 'npm run sonar' // Runs scanner
                }
            }
        }
        stage('Quality Gate') {
            steps {
                timeout(time: 5, unit: 'MINUTES') {
                    // Polls SonarQube for status
                    waitForQualityGate abortPipeline: true
                }
            }
        }
    }
}
```
*Note*: The `waitForQualityGate` step requires the SonarQube Server to define a **Webhook** pointing back to Jenkins.

### GitHub Actions

```yaml
jobs:
  sonar:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0  # REQUIRED: Shallow clones break 'New Code' detection
      
      - name: SonarQube Scan
        uses: sonarsource/sonarqube-scan-action@master
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      
      - name: Quality Gate Check
        uses: sonarsource/sonarqube-quality-gate-action@master
        timeout-minutes: 5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
```

---

## 7. Advanced Administration

### Webhooks for ChatOps
Configure a Webhook in **Administration > Configuration > Webhooks**.
*   **URL**: Your custom bot endpoint.
*   **Event**: Analysis Completed.

**Payload Example**:
```json
{
  "serverUrl": "http://localhost:9000",
  "taskId": "AX123...",
  "status": "SUCCESS",
  "qualityGate": {
    "status": "ERROR",
    "conditions": [
      { "metric": "new_coverage", "operator": "LESS_THAN", "value": "50", "errorThreshold": "80", "status": "ERROR" }
    ]
  }
}
```

### Permission Templates
Don't assign permissions manually. Create a **Template**.
*   **Pattern**: `.*-finance`
*   **Permissions**: Grant `Finance-Group` Admin access.
When a new project `my-app-finance` is created, it auto-inherits these rules.

### Housekeeping
Database size grows fast. Configure **Database Cleaner**:
*   Delete analysis history older than 5 years.
*   Delete closed issues after 30 days.

---
