---
title: "SQL Foundations"
sidebarTitle: "1. SQL Foundations"
description: "Master SQL from basics to advanced queries — the language of data"
icon: "terminal"
---

<Frame>
  <img src="/images/courses/database-engineering/sql-foundations-concept.svg" alt="SQL Foundations - Relational model, query structure, and operations" />
</Frame>

# Module 1: SQL Foundations

SQL (Structured Query Language) is the universal language for interacting with relational databases. This module builds your foundation from the ground up, ensuring you can write any query with confidence.

<Info>
**Estimated Time**: 8-10 hours  
**Hands-On**: 30+ practice exercises  
**Project**: Build queries for an e-commerce analytics dashboard
</Info>

---

## 1.1 Introduction to Relational Databases

### What is a Relational Database? (The Big Picture)

Think of a relational database like a **digital filing cabinet** that's incredibly organized and can find information instantly. Unlike a spreadsheet where data might be scattered, a database stores data in structured **tables** that can be connected to each other.

**Real-World Analogy:**
- A **table** is like a spreadsheet sheet (e.g., "Users", "Orders", "Products")
- A **row** is like one entry in that spreadsheet (e.g., one user's information)
- A **column** is like a field/category (e.g., "name", "email", "age")
- A **relationship** connects tables (e.g., "Orders belong to Users")

**Why Use a Database Instead of Files/Spreadsheets?**
1. **Data Integrity**: Prevents invalid data (e.g., can't create an order for a user that doesn't exist)
2. **Concurrent Access**: Multiple people can read/write simultaneously without conflicts
3. **Query Power**: Find complex patterns across millions of records in milliseconds
4. **Relationships**: Link related data automatically (orders → users → products)
5. **ACID Guarantees**: Transactions ensure data consistency even if something crashes

A relational database organizes data into **tables** (relations) with **rows** (records) and **columns** (attributes). Tables can be linked through **relationships** using keys.

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          RELATIONAL MODEL                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  USERS TABLE                          ORDERS TABLE                      │
│  ┌────┬───────────┬─────────────┐    ┌────┬─────────┬────────┬───────┐ │
│  │ id │   name    │    email    │    │ id │ user_id │ total  │ status│ │
│  ├────┼───────────┼─────────────┤    ├────┼─────────┼────────┼───────┤ │
│  │  1 │ Alice     │ a@email.com │◄───│  1 │    1    │ 150.00 │ done  │ │
│  │  2 │ Bob       │ b@email.com │◄───│  2 │    1    │  75.50 │ done  │ │
│  │  3 │ Charlie   │ c@email.com │◄───│  3 │    2    │ 200.00 │pending│ │
│  └────┴───────────┴─────────────┘    └────┴─────────┴────────┴───────┘ │
│         ▲                                      │                        │
│         │          PRIMARY KEY                 │                        │
│         └──────────────────────────────────────┘                        │
│                     FOREIGN KEY                                         │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Key Concepts

<AccordionGroup>
  <Accordion title="Primary Key" icon="key">
    **What is it?** A column (or combination of columns) that uniquely identifies each row in a table.
    
    **Why do we need it?** Think of it like a Social Security Number or student ID. Every person has a unique one, and you can use it to find exactly that person. In databases, the primary key lets you:
    - Uniquely identify any row (no duplicates allowed!)
    - Link tables together (foreign keys reference primary keys)
    - Make queries faster (databases automatically index primary keys)
    
    **Real-World Example:**
    - In a library: Each book has a unique ISBN (primary key)
    - In a school: Each student has a unique student ID
    - In an e-commerce site: Each user has a unique user ID
    
    ```sql
    CREATE TABLE users (
        id SERIAL PRIMARY KEY,  -- Auto-incrementing unique identifier
        email VARCHAR(255) UNIQUE NOT NULL,
        name VARCHAR(100) NOT NULL
    );
    ```
    
    **Breaking down `SERIAL PRIMARY KEY`:**
    - `SERIAL`: PostgreSQL automatically generates the next number (1, 2, 3, 4...)
    - `PRIMARY KEY`: This column is the unique identifier
    - You don't need to provide the ID when inserting - it's automatic!
    
    **Rules** (Why these matter):
    - **Must be unique**: If two rows had the same ID, how would you tell them apart?
    - **Cannot be NULL**: Every row MUST have an ID (you can't have "unknown" as an identifier)
    - **Should rarely change**: If you change an ID, all foreign keys pointing to it break!
    - **Often auto-incrementing**: Makes it easy - just insert data, ID is assigned automatically
    
    **Common Mistake:**
    ```sql
    -- ❌ BAD: Using email as primary key
    CREATE TABLE users (
        email VARCHAR(255) PRIMARY KEY,  -- What if user changes email?
        name VARCHAR(100)
    );
    
    -- ✅ GOOD: Separate ID as primary key
    CREATE TABLE users (
        id SERIAL PRIMARY KEY,  -- Never changes
        email VARCHAR(255) UNIQUE NOT NULL,  -- Can change, but stays unique
        name VARCHAR(100)
    );
    ```
  </Accordion>
  
  <Accordion title="Foreign Key" icon="link">
    **What is it?** A column that references the primary key of another table, creating a relationship.
    
    **Why do we need it?** Think of it like a pointer or reference. It says "this order belongs to that user" by storing the user's ID.
    
    **Real-World Analogy:**
    - In a library system: A "loan" record has a `book_id` (foreign key) pointing to the "books" table
    - In a school: A "grade" record has a `student_id` (foreign key) pointing to the "students" table
    - In e-commerce: An "order" has a `user_id` (foreign key) pointing to the "users" table
    
    ```sql
    CREATE TABLE orders (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL REFERENCES users(id),  -- This is the foreign key!
        total DECIMAL(10, 2) NOT NULL,
        created_at TIMESTAMP DEFAULT NOW()
    );
    ```
    
    **Breaking down `REFERENCES users(id)`:**
    - `user_id`: The column in the orders table that stores the user's ID
    - `REFERENCES users(id)`: This tells PostgreSQL "user_id must exist in the users table's id column"
    - `NOT NULL`: Every order MUST belong to a user (can't be orphaned)
    
    **What happens with foreign keys?**
    
    1. **Prevents Invalid Data:**
    ```sql
    -- ❌ This will FAIL:
    INSERT INTO orders (user_id, total) VALUES (99999, 100.00);
    -- Error: insert or update on table "orders" violates foreign key constraint
    -- Because user_id 99999 doesn't exist in users table!
    
    -- ✅ This works:
    INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com') RETURNING id;
    -- Returns: id = 1
    INSERT INTO orders (user_id, total) VALUES (1, 100.00);  -- Success!
    ```
    
    2. **Prevents Orphaned Records:**
    ```sql
    -- If you try to delete a user who has orders:
    DELETE FROM users WHERE id = 1;
    -- Error: update or delete on table "users" violates foreign key constraint
    -- PostgreSQL protects you from creating "orphaned" orders with no user!
    
    -- You must delete orders first, or use CASCADE:
    CREATE TABLE orders (
        user_id INTEGER REFERENCES users(id) ON DELETE CASCADE
        -- Now deleting a user automatically deletes their orders
    );
    ```
    
    3. **Makes Queries Powerful:**
    ```sql
    -- Join tables using the foreign key relationship:
    SELECT u.name, o.total, o.created_at
    FROM users u
    JOIN orders o ON u.id = o.user_id;  -- The foreign key makes this join possible!
    ```
    
    **Benefits** (Why this matters):
    - **Enforces referential integrity**: Can't create an order for a non-existent user
    - **Prevents orphaned records**: Can't delete a user if they have orders (unless you handle it)
    - **Documents relationships**: The schema itself shows how tables connect
    - **Enables JOINs**: Foreign keys make it easy to combine related data
    
    **Common Patterns:**
    ```sql
    -- One-to-Many: One user has many orders
    users (1) ──< (many) orders
    
    -- Many-to-Many: Students enroll in courses
    students (many) ──< enrollments >── (many) courses
    -- Need a junction table with foreign keys to both!
    ```
  </Accordion>
  
  <Accordion title="Data Types" icon="shapes">
    Common PostgreSQL data types:
    
    | Type | Description | Example |
    |------|-------------|---------|
    | `INTEGER` | Whole numbers | `42`, `-100` |
    | `BIGINT` | Large whole numbers | User IDs at scale |
    | `SERIAL` | Auto-incrementing integer | Primary keys |
    | `VARCHAR(n)` | Variable-length string | Names, emails |
    | `TEXT` | Unlimited length string | Descriptions |
    | `DECIMAL(p,s)` | Exact numeric | Money: `DECIMAL(10,2)` |
    | `BOOLEAN` | True/False | `is_active` |
    | `TIMESTAMP` | Date and time | `created_at` |
    | `TIMESTAMPTZ` | Timestamp with timezone | Always use for times |
    | `JSONB` | Binary JSON | Flexible data |
    | `UUID` | Universally unique ID | Distributed systems |
  </Accordion>
</AccordionGroup>

---

## 1.2 Basic SELECT Queries

### Your First Query: Understanding SELECT

**What is SELECT?** The `SELECT` statement is how you ask the database questions. It's like saying "Show me..." or "Find me...".

**The Basic Structure:**
```sql
SELECT [what columns] FROM [which table] WHERE [what conditions];
```

**Think of it like a question:**
- "SELECT name, email" = "Show me the name and email"
- "FROM users" = "from the users table"
- "WHERE age > 18" = "where the age is greater than 18"

**Step-by-Step: Your First Query**

Let's say you have a users table:
```
users table:
┌────┬──────────┬─────────────────────┬─────┐
│ id │   name   │       email         │ age │
├────┼──────────┼─────────────────────┼─────┤
│  1 │ Alice    │ alice@example.com   │  25 │
│  2 │ Bob      │ bob@example.com    │  30 │
│  3 │ Charlie  │ charlie@example.com │  18 │
└────┴──────────┴─────────────────────┴─────┘
```

**Query 1: Get everything**
```sql
SELECT * FROM users;
```
**What happens:**
1. Database looks at the `users` table
2. `*` means "all columns"
3. Returns all rows with all columns

**Result:**
```
┌────┬──────────┬─────────────────────┬─────┐
│ id │   name   │       email         │ age │
├────┼──────────┼─────────────────────┼─────┤
│  1 │ Alice    │ alice@example.com   │  25 │
│  2 │ Bob      │ bob@example.com    │  30 │
│  3 │ Charlie  │ charlie@example.com │  18 │
└────┴──────────┴─────────────────────┴─────┘
```

**Query 2: Get specific columns**
```sql
SELECT name, email FROM users;
```
**What happens:**
1. Database looks at the `users` table
2. Only selects `name` and `email` columns
3. Returns all rows, but only those two columns

**Result:**
```
┌──────────┬─────────────────────┐
│   name   │       email         │
├──────────┼─────────────────────┤
│ Alice    │ alice@example.com   │
│ Bob      │ bob@example.com    │
│ Charlie  │ charlie@example.com │
└──────────┴─────────────────────┘
```

**Why specify columns instead of `*`?**
1. **Performance**: Fetching only what you need is faster
2. **Clarity**: Makes it obvious what data you're using
3. **Safety**: If someone adds a huge column later, `SELECT *` would fetch it unnecessarily
4. **Index optimization**: Some queries can use "index-only scans" if you only select indexed columns

The `SELECT` statement retrieves data from tables.

```sql
-- Select all columns from users table
SELECT * FROM users;

-- Select specific columns
SELECT name, email FROM users;

-- Select with column alias
SELECT 
    name AS customer_name,
    email AS contact_email
FROM users;
```

<Warning>
**Avoid `SELECT *` in production code!** It fetches unnecessary data, breaks when schema changes, and prevents index-only scans. Always specify the columns you need.
</Warning>

### Filtering with WHERE: Finding Specific Data

**What is WHERE?** The `WHERE` clause is like a filter. It says "only show me rows that match these conditions."

**Real-World Analogy:**
- Without WHERE: "Show me all books in the library" (thousands of books!)
- With WHERE: "Show me all books published after 2020" (much smaller, relevant list)

**How WHERE Works:**
1. Database looks at each row in the table
2. Checks if the row matches your WHERE condition
3. Only returns rows where the condition is TRUE
4. Skips rows where the condition is FALSE or NULL

**Step-by-Step Example:**

Starting data:
```
users table:
┌────┬──────────┬─────────────────────┬─────┐
│ id │   name   │       email         │ age │
├────┼──────────┼─────────────────────┼─────┤
│  1 │ Alice    │ alice@example.com   │  25 │
│  2 │ Bob      │ bob@example.com    │  30 │
│  3 │ Charlie  │ charlie@example.com │  18 │
│  4 │ Diana    │ diana@example.com  │  22 │
└────┴──────────┴─────────────────────┴─────┘
```

**Query: Find users older than 21**
```sql
SELECT * FROM users WHERE age > 21;
```

**What the database does:**
1. Look at row 1: age = 25, is 25 > 21? YES → Include this row
2. Look at row 2: age = 30, is 30 > 21? YES → Include this row
3. Look at row 3: age = 18, is 18 > 21? NO → Skip this row
4. Look at row 4: age = 22, is 22 > 21? YES → Include this row

**Result:**
```
┌────┬──────────┬─────────────────────┬─────┐
│ id │   name   │       email         │ age │
├────┼──────────┼─────────────────────┼─────┤
│  1 │ Alice    │ alice@example.com   │  25 │
│  2 │ Bob      │ bob@example.com    │  30 │
│  4 │ Diana    │ diana@example.com  │  22 │
└────┴──────────┴─────────────────────┴─────┘
```

**Important: WHERE vs HAVING**
- **WHERE**: Filters rows BEFORE grouping/aggregation
- **HAVING**: Filters groups AFTER grouping/aggregation
- You'll learn HAVING later, but remember: WHERE comes first!

The `WHERE` clause filters rows based on conditions.

```sql
-- Basic equality
SELECT * FROM users WHERE id = 1;

-- String matching
SELECT * FROM users WHERE email = 'alice@example.com';

-- Comparison operators
SELECT * FROM products WHERE price > 100;
SELECT * FROM products WHERE stock <= 10;

-- Not equal
SELECT * FROM users WHERE status != 'deleted';
SELECT * FROM users WHERE status <> 'deleted';  -- Same as !=
```

### Multiple Conditions

Combine conditions with `AND`, `OR`, and `NOT`.

```sql
-- AND: Both conditions must be true
SELECT * FROM products 
WHERE category = 'electronics' 
  AND price < 500;

-- OR: At least one condition must be true
SELECT * FROM products 
WHERE category = 'electronics' 
   OR category = 'computers';

-- NOT: Negates a condition
SELECT * FROM users 
WHERE NOT status = 'banned';

-- Complex combinations (use parentheses!)
SELECT * FROM products 
WHERE (category = 'electronics' OR category = 'computers')
  AND price BETWEEN 100 AND 1000
  AND stock > 0;
```

### Special Operators

```sql
-- IN: Match any value in a list
SELECT * FROM orders 
WHERE status IN ('pending', 'processing', 'shipped');

-- BETWEEN: Range inclusive
SELECT * FROM orders 
WHERE created_at BETWEEN '2024-01-01' AND '2024-12-31';

-- LIKE: Pattern matching
SELECT * FROM users WHERE email LIKE '%@gmail.com';     -- Ends with
SELECT * FROM users WHERE name LIKE 'John%';            -- Starts with
SELECT * FROM users WHERE name LIKE '%son%';            -- Contains

-- ILIKE: Case-insensitive LIKE (PostgreSQL)
SELECT * FROM users WHERE name ILIKE '%john%';

-- IS NULL / IS NOT NULL
SELECT * FROM orders WHERE shipped_at IS NULL;          -- Not yet shipped
SELECT * FROM users WHERE phone IS NOT NULL;            -- Has phone number
```

### Sorting Results

```sql
-- Sort ascending (default)
SELECT * FROM products ORDER BY price;
SELECT * FROM products ORDER BY price ASC;

-- Sort descending
SELECT * FROM products ORDER BY price DESC;

-- Multiple sort columns
SELECT * FROM products 
ORDER BY category ASC, price DESC;

-- Sort with NULL handling
SELECT * FROM products 
ORDER BY discount NULLS LAST;  -- NULLs at the end
```

### Limiting Results

```sql
-- Get first N rows
SELECT * FROM products ORDER BY created_at DESC LIMIT 10;

-- Pagination with OFFSET
SELECT * FROM products 
ORDER BY id 
LIMIT 20 OFFSET 40;  -- Page 3 (rows 41-60)

-- Better pagination with keyset (cursor-based)
SELECT * FROM products 
WHERE id > 1000      -- Last seen ID
ORDER BY id 
LIMIT 20;
```

<Tip>
**Performance Tip**: `OFFSET` becomes slow for large values because the database must scan and discard all skipped rows. Use keyset pagination for better performance on large datasets.
</Tip>

---

## 1.3 Aggregations and Grouping

Aggregate functions compute a single result from multiple rows.

### Aggregate Functions

```sql
-- COUNT: Number of rows
SELECT COUNT(*) FROM orders;                    -- All rows
SELECT COUNT(shipped_at) FROM orders;           -- Non-NULL values only
SELECT COUNT(DISTINCT user_id) FROM orders;     -- Unique users

-- SUM: Total of numeric values
SELECT SUM(total) FROM orders WHERE status = 'completed';

-- AVG: Average
SELECT AVG(price) FROM products WHERE category = 'electronics';

-- MIN / MAX
SELECT MIN(price), MAX(price) FROM products;

-- Combined
SELECT 
    COUNT(*) AS total_orders,
    SUM(total) AS revenue,
    AVG(total) AS avg_order_value,
    MIN(total) AS smallest_order,
    MAX(total) AS largest_order
FROM orders
WHERE status = 'completed';
```

### GROUP BY

Group rows by column values and apply aggregates to each group.

```sql
-- Orders per user
SELECT 
    user_id,
    COUNT(*) AS order_count,
    SUM(total) AS total_spent
FROM orders
GROUP BY user_id;

-- Sales by category
SELECT 
    category,
    COUNT(*) AS product_count,
    AVG(price) AS avg_price,
    SUM(stock) AS total_inventory
FROM products
GROUP BY category;

-- Multiple grouping columns
SELECT 
    EXTRACT(YEAR FROM created_at) AS year,
    EXTRACT(MONTH FROM created_at) AS month,
    COUNT(*) AS order_count,
    SUM(total) AS revenue
FROM orders
GROUP BY 
    EXTRACT(YEAR FROM created_at),
    EXTRACT(MONTH FROM created_at)
ORDER BY year, month;
```

### HAVING: Filter Groups

`WHERE` filters rows before grouping. `HAVING` filters groups after aggregation.

```sql
-- Find users with more than 5 orders
SELECT 
    user_id,
    COUNT(*) AS order_count
FROM orders
GROUP BY user_id
HAVING COUNT(*) > 5;

-- Categories with average price over $100
SELECT 
    category,
    AVG(price) AS avg_price
FROM products
GROUP BY category
HAVING AVG(price) > 100
ORDER BY avg_price DESC;

-- Combined WHERE and HAVING
SELECT 
    user_id,
    SUM(total) AS total_spent
FROM orders
WHERE status = 'completed'           -- Filter rows first
GROUP BY user_id
HAVING SUM(total) > 1000             -- Then filter groups
ORDER BY total_spent DESC;
```

---

## 1.4 JOINs Mastery: Combining Data from Multiple Tables

### Why Do We Need JOINs?

**The Problem:** Data is split across multiple tables for organization, but you often need to see it together.

**Real-World Example:**
- You have a `users` table with names and emails
- You have an `orders` table with order totals and dates
- You want to see: "Show me all orders with the customer's name"

**Without JOINs:** You'd have to:
1. Query orders table → get user_id and total
2. Query users table → get name for each user_id
3. Manually match them in your application code (slow, error-prone!)

**With JOINs:** One query gets everything, matched automatically!

**The Concept:**
JOINs combine rows from multiple tables based on related columns (usually foreign keys). Think of it like a VLOOKUP in Excel, but much more powerful.

### Understanding JOIN Types: A Visual Guide

Before diving in, here's the key difference:

```
INNER JOIN:  "Show me only matches" (intersection)
LEFT JOIN:   "Show me all from left table, plus matches from right"
RIGHT JOIN:  "Show me all from right table, plus matches from left"
FULL JOIN:   "Show me everything from both tables"
```

### INNER JOIN: The Most Common Join

**What it does:** Returns only rows that have matches in BOTH tables.

**Real-World Analogy:** Like a Venn diagram intersection. Only show things that exist in both sets.

**Step-by-Step Example:**

**Starting Data:**

Users table:
```
┌────┬──────────┬─────────────────────┐
│ id │   name   │       email         │
├────┼──────────┼─────────────────────┤
│  1 │ Alice    │ alice@example.com   │
│  2 │ Bob      │ bob@example.com    │
│  3 │ Charlie  │ charlie@example.com│
└────┴──────────┴─────────────────────┘
```

Orders table:
```
┌────┬─────────┬────────┬──────────────┐
│ id │ user_id │ total  │   status    │
├────┼─────────┼────────┼──────────────┤
│  1 │    1    │ 150.00 │ completed   │
│  2 │    1    │  75.50 │ completed   │
│  3 │    2    │ 200.00 │ pending     │
└────┴─────────┴────────┴──────────────┘
```

**Query:**
```sql
SELECT 
    o.id AS order_id,
    o.total,
    o.created_at,
    u.name AS customer_name,
    u.email
FROM orders o
INNER JOIN users u ON o.user_id = u.id;
```

**What happens step-by-step:**

1. **Database starts with the `orders` table** (the "left" table in the JOIN)
2. **For each order row:**
   - Order 1: user_id = 1 → Look for user with id = 1 → Found Alice! → Include this match
   - Order 2: user_id = 1 → Look for user with id = 1 → Found Alice! → Include this match
   - Order 3: user_id = 2 → Look for user with id = 2 → Found Bob! → Include this match
3. **Result:** Only orders that have matching users (all 3 orders in this case)

**Result:**
```
┌──────────┬────────┬──────────────┬──────────────┬─────────────────────┐
│ order_id │ total  │ created_at   │customer_name │       email         │
├──────────┼────────┼──────────────┼──────────────┼─────────────────────┤
│    1     │ 150.00 │ 2024-01-15   │ Alice        │ alice@example.com   │
│    2     │  75.50 │ 2024-01-16   │ Alice        │ alice@example.com   │
│    3     │ 200.00 │ 2024-01-17   │ Bob          │ bob@example.com    │
└──────────┴────────┴──────────────┴──────────────┴─────────────────────┘
```

**Notice:** Charlie doesn't appear because they have no orders. INNER JOIN only shows matches!

**When to use INNER JOIN:**
- When you only want rows that have matches in both tables
- Most common join type (90% of joins are INNER)
- Example: "Show me orders with customer info" (only orders that have customers)

Returns only rows that have matches in both tables.

```sql
-- Get order details with user names
SELECT 
    o.id AS order_id,
    o.total,
    o.created_at,
    u.name AS customer_name,
    u.email
FROM orders o
INNER JOIN users u ON o.user_id = u.id;
```

```
┌─────────────────────────────────────────────────────────────────────┐
│                           INNER JOIN                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   USERS                    ORDERS                 RESULT            │
│   ┌───┬───────┐           ┌───┬─────────┐       ┌───┬───────┬────┐ │
│   │ 1 │ Alice │ ─────────▶│ 1 │ user: 1 │──────▶│ 1 │ Alice │ O1 │ │
│   │ 2 │ Bob   │ ─────────▶│ 2 │ user: 1 │──────▶│ 2 │ Alice │ O2 │ │
│   │ 3 │ Carol │ ✗         │ 3 │ user: 2 │──────▶│ 3 │ Bob   │ O3 │ │
│   └───┴───────┘           └───┴─────────┘       └───┴───────┴────┘ │
│                                                                     │
│   Carol has no orders ──▶ Not in result                            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### LEFT JOIN (LEFT OUTER JOIN): Keep Everything from the Left

**What it does:** Returns ALL rows from the left table, plus matching rows from the right table. If there's no match, the right table columns are NULL.

**Real-World Analogy:** Like a report card. You list ALL students (left table), and show their grades (right table) if they have any. If a student has no grades yet, you still list them but show "No grades" (NULL).

**Why "LEFT"?** The table mentioned first (before JOIN) is the "left" table. The table after JOIN is the "right" table.

**Step-by-Step Example:**

**Starting Data:**

Users table:
```
┌────┬──────────┬─────────────────────┐
│ id │   name   │       email         │
├────┼──────────┼─────────────────────┤
│  1 │ Alice    │ alice@example.com   │
│  2 │ Bob      │ bob@example.com    │
│  3 │ Charlie  │ charlie@example.com│  ← Has no orders!
└────┴──────────┴─────────────────────┘
```

Orders table:
```
┌────┬─────────┬────────┬──────────────┐
│ id │ user_id │ total  │   status    │
├────┼─────────┼────────┼──────────────┤
│  1 │    1    │ 150.00 │ completed   │
│  2 │    1    │  75.50 │ completed   │
│  3 │    2    │ 200.00 │ pending     │
└────┴─────────┴────────┴──────────────┘
```

**Query:**
```sql
SELECT 
    u.id,
    u.name,
    COUNT(o.id) AS order_count,
    COALESCE(SUM(o.total), 0) AS total_spent
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name;
```

**What happens step-by-step:**

1. **Database starts with ALL users** (the left table)
2. **For each user:**
   - Alice (id=1): Find orders with user_id=1 → Found 2 orders → Include with order data
   - Bob (id=2): Find orders with user_id=2 → Found 1 order → Include with order data
   - Charlie (id=3): Find orders with user_id=3 → Found 0 orders → Still include, but order columns are NULL
3. **Result:** All users appear, even if they have no orders!

**Result:**
```
┌────┬──────────┬─────────────┬─────────────┐
│ id │   name   │ order_count │ total_spent │
├────┼──────────┼─────────────┼─────────────┤
│  1 │ Alice    │      2      │   225.50    │
│  2 │ Bob      │      1      │   200.00    │
│  3 │ Charlie  │      0      │     0.00    │  ← Still appears!
└────┴──────────┴─────────────┴─────────────┘
```

**Key Points:**
- `COALESCE(SUM(o.total), 0)`: Converts NULL to 0 (SUM returns NULL when there are no rows)
- `COUNT(o.id)`: Counts 0 for users with no orders (COUNT counts non-NULL values)
- Charlie appears even though they have no orders!

**When to use LEFT JOIN:**
- "Show me all users and their order counts" (including users with 0 orders)
- "List all products and their sales" (including products that never sold)
- "Find customers who haven't placed orders" (use LEFT JOIN + WHERE right_table.id IS NULL)

**Common Pattern: Finding Missing Relationships**
```sql
-- Find users who have never placed an order
SELECT u.name, u.email
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE o.id IS NULL;  -- No matching order found!
```

Returns all rows from the left table, with matching rows from the right (or NULL if no match).

```sql
-- All users, with their orders (if any)
SELECT 
    u.id,
    u.name,
    COUNT(o.id) AS order_count,
    COALESCE(SUM(o.total), 0) AS total_spent
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name;
```

```
┌─────────────────────────────────────────────────────────────────────┐
│                           LEFT JOIN                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   USERS                    ORDERS                 RESULT            │
│   ┌───┬───────┐           ┌───┬─────────┐       ┌───┬───────┬────┐ │
│   │ 1 │ Alice │ ─────────▶│ 1 │ user: 1 │──────▶│ 1 │ Alice │ O1 │ │
│   │ 2 │ Bob   │ ─────────▶│ 2 │ user: 1 │──────▶│ 2 │ Alice │ O2 │ │
│   │ 3 │ Carol │ ─────────▶│ 3 │ user: 2 │──────▶│ 3 │ Bob   │ O3 │ │
│   └───┴───────┘           └───┴─────────┘       │ 4 │ Carol │NULL│ │
│                                                  └───┴───────┴────┘ │
│                                                                     │
│   Carol included with NULL for order data                          │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### RIGHT JOIN and FULL OUTER JOIN

```sql
-- RIGHT JOIN: All rows from right table
SELECT u.name, o.id AS order_id
FROM users u
RIGHT JOIN orders o ON u.id = o.user_id;

-- FULL OUTER JOIN: All rows from both tables
SELECT u.name, o.id AS order_id
FROM users u
FULL OUTER JOIN orders o ON u.id = o.user_id;
```

### Multiple JOINs

```sql
-- Orders with user info and product details
SELECT 
    o.id AS order_id,
    u.name AS customer,
    p.name AS product,
    oi.quantity,
    oi.unit_price,
    oi.quantity * oi.unit_price AS line_total
FROM orders o
INNER JOIN users u ON o.user_id = u.id
INNER JOIN order_items oi ON o.id = oi.order_id
INNER JOIN products p ON oi.product_id = p.id
WHERE o.created_at > '2024-01-01'
ORDER BY o.id, p.name;
```

### Self JOIN

Join a table to itself, useful for hierarchical or comparative data.

```sql
-- Employees with their managers
SELECT 
    e.name AS employee,
    m.name AS manager
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.id;

-- Find products with the same category and similar prices
SELECT 
    p1.name AS product1,
    p2.name AS product2,
    p1.category,
    p1.price AS price1,
    p2.price AS price2
FROM products p1
INNER JOIN products p2 
    ON p1.category = p2.category 
    AND p1.id < p2.id  -- Avoid duplicates
    AND ABS(p1.price - p2.price) < 50;
```

### CROSS JOIN

Cartesian product: every row from first table paired with every row from second.

```sql
-- All possible size/color combinations
SELECT s.name AS size, c.name AS color
FROM sizes s
CROSS JOIN colors c;

-- Generate date series with categories
SELECT 
    d.date,
    c.name AS category
FROM generate_series('2024-01-01', '2024-12-31', '1 day') AS d(date)
CROSS JOIN categories c;
```

---

## 1.5 Subqueries

A subquery is a query nested inside another query.

### Subqueries in WHERE

```sql
-- Users who have placed orders
SELECT * FROM users
WHERE id IN (SELECT DISTINCT user_id FROM orders);

-- Products priced above average
SELECT * FROM products
WHERE price > (SELECT AVG(price) FROM products);

-- Users with more than 5 orders
SELECT * FROM users
WHERE id IN (
    SELECT user_id 
    FROM orders 
    GROUP BY user_id 
    HAVING COUNT(*) > 5
);
```

### Correlated Subqueries

References the outer query — executes once per outer row.

```sql
-- Products with price above their category average
SELECT p1.name, p1.price, p1.category
FROM products p1
WHERE p1.price > (
    SELECT AVG(p2.price)
    FROM products p2
    WHERE p2.category = p1.category  -- References outer query
);

-- Users with their latest order
SELECT 
    u.name,
    (SELECT MAX(created_at) FROM orders o WHERE o.user_id = u.id) AS last_order
FROM users u;
```

### EXISTS and NOT EXISTS

```sql
-- Users who have placed at least one order
SELECT u.name, u.email
FROM users u
WHERE EXISTS (
    SELECT 1 FROM orders o WHERE o.user_id = u.id
);

-- Products that have never been ordered
SELECT p.name, p.price
FROM products p
WHERE NOT EXISTS (
    SELECT 1 FROM order_items oi WHERE oi.product_id = p.id
);
```

<Tip>
**Performance Tip**: `EXISTS` often performs better than `IN` for large subqueries because it can stop as soon as it finds one match.
</Tip>

### Subqueries in FROM (Derived Tables)

```sql
-- Monthly revenue with growth calculation
SELECT 
    current_month.month,
    current_month.revenue,
    prev_month.revenue AS prev_revenue,
    current_month.revenue - COALESCE(prev_month.revenue, 0) AS growth
FROM (
    SELECT 
        DATE_TRUNC('month', created_at) AS month,
        SUM(total) AS revenue
    FROM orders
    GROUP BY DATE_TRUNC('month', created_at)
) current_month
LEFT JOIN (
    SELECT 
        DATE_TRUNC('month', created_at) AS month,
        SUM(total) AS revenue
    FROM orders
    GROUP BY DATE_TRUNC('month', created_at)
) prev_month ON current_month.month = prev_month.month + INTERVAL '1 month'
ORDER BY current_month.month;
```

---

## 1.6 Common Table Expressions (CTEs)

CTEs make complex queries readable by breaking them into named, logical steps.

### Basic CTE Syntax

```sql
WITH monthly_revenue AS (
    SELECT 
        DATE_TRUNC('month', created_at) AS month,
        SUM(total) AS revenue
    FROM orders
    WHERE status = 'completed'
    GROUP BY DATE_TRUNC('month', created_at)
)
SELECT 
    month,
    revenue,
    AVG(revenue) OVER () AS avg_monthly_revenue,
    revenue - AVG(revenue) OVER () AS diff_from_avg
FROM monthly_revenue
ORDER BY month;
```

### Multiple CTEs

```sql
WITH 
-- Step 1: Calculate user order stats
user_stats AS (
    SELECT 
        user_id,
        COUNT(*) AS order_count,
        SUM(total) AS total_spent,
        AVG(total) AS avg_order
    FROM orders
    WHERE status = 'completed'
    GROUP BY user_id
),

-- Step 2: Classify users into tiers
user_tiers AS (
    SELECT 
        user_id,
        order_count,
        total_spent,
        CASE 
            WHEN total_spent >= 10000 THEN 'platinum'
            WHEN total_spent >= 5000 THEN 'gold'
            WHEN total_spent >= 1000 THEN 'silver'
            ELSE 'bronze'
        END AS tier
    FROM user_stats
),

-- Step 3: Count users per tier
tier_summary AS (
    SELECT 
        tier,
        COUNT(*) AS user_count,
        SUM(total_spent) AS tier_revenue
    FROM user_tiers
    GROUP BY tier
)

-- Final result
SELECT 
    tier,
    user_count,
    tier_revenue,
    ROUND(100.0 * tier_revenue / SUM(tier_revenue) OVER (), 2) AS revenue_pct
FROM tier_summary
ORDER BY tier_revenue DESC;
```

### Recursive CTEs

For hierarchical data like org charts, categories, or graphs.

```sql
-- Employee hierarchy (org chart)
WITH RECURSIVE org_chart AS (
    -- Base case: top-level employees (no manager)
    SELECT id, name, manager_id, 1 AS level, name::TEXT AS path
    FROM employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- Recursive case: employees with managers
    SELECT e.id, e.name, e.manager_id, oc.level + 1, oc.path || ' > ' || e.name
    FROM employees e
    INNER JOIN org_chart oc ON e.manager_id = oc.id
)
SELECT * FROM org_chart ORDER BY path;

-- Category tree with all descendants
WITH RECURSIVE category_tree AS (
    SELECT id, name, parent_id, 0 AS depth, ARRAY[id] AS path
    FROM categories
    WHERE parent_id IS NULL
    
    UNION ALL
    
    SELECT c.id, c.name, c.parent_id, ct.depth + 1, ct.path || c.id
    FROM categories c
    INNER JOIN category_tree ct ON c.parent_id = ct.id
)
SELECT 
    REPEAT('  ', depth) || name AS category_tree,
    depth,
    path
FROM category_tree
ORDER BY path;
```

---

## 1.7 Window Functions

Window functions perform calculations across a set of rows related to the current row, without collapsing them into a single output row like aggregates.

### ROW_NUMBER, RANK, DENSE_RANK

```sql
-- Rank products by price within each category
SELECT 
    name,
    category,
    price,
    ROW_NUMBER() OVER (PARTITION BY category ORDER BY price DESC) AS row_num,
    RANK() OVER (PARTITION BY category ORDER BY price DESC) AS rank,
    DENSE_RANK() OVER (PARTITION BY category ORDER BY price DESC) AS dense_rank
FROM products;
```

```
┌──────────────────────────────────────────────────────────────────────┐
│           ROW_NUMBER vs RANK vs DENSE_RANK                           │
├──────────────────────────────────────────────────────────────────────┤
│ Product    │ Price │ ROW_NUMBER │ RANK │ DENSE_RANK                  │
├────────────┼───────┼────────────┼──────┼────────────                  │
│ Laptop     │ 1200  │     1      │  1   │     1                        │
│ Desktop    │ 1000  │     2      │  2   │     2                        │
│ Tablet     │ 1000  │     3      │  2   │     2      ◄── Same price    │
│ Phone      │  800  │     4      │  4   │     3      ◄── RANK skips 3  │
│ Earbuds    │  100  │     5      │  5   │     4                        │
└──────────────────────────────────────────────────────────────────────┘
```

### LAG and LEAD

Access previous or next row values.

```sql
-- Compare each order to the previous order for the same user
SELECT 
    user_id,
    id AS order_id,
    total,
    created_at,
    LAG(total) OVER (PARTITION BY user_id ORDER BY created_at) AS prev_order_total,
    total - LAG(total) OVER (PARTITION BY user_id ORDER BY created_at) AS change,
    LEAD(total) OVER (PARTITION BY user_id ORDER BY created_at) AS next_order_total
FROM orders;

-- Calculate month-over-month revenue growth
WITH monthly_revenue AS (
    SELECT 
        DATE_TRUNC('month', created_at) AS month,
        SUM(total) AS revenue
    FROM orders
    GROUP BY DATE_TRUNC('month', created_at)
)
SELECT 
    month,
    revenue,
    LAG(revenue) OVER (ORDER BY month) AS prev_month,
    ROUND(100.0 * (revenue - LAG(revenue) OVER (ORDER BY month)) / 
          LAG(revenue) OVER (ORDER BY month), 2) AS growth_pct
FROM monthly_revenue;
```

### Running Totals and Moving Averages

```sql
-- Running total of sales
SELECT 
    created_at::date AS date,
    total,
    SUM(total) OVER (ORDER BY created_at) AS running_total
FROM orders;

-- 7-day moving average
SELECT 
    date,
    daily_revenue,
    AVG(daily_revenue) OVER (
        ORDER BY date 
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS moving_avg_7d
FROM daily_sales;

-- Running total within each month
SELECT 
    created_at::date AS date,
    total,
    SUM(total) OVER (
        PARTITION BY DATE_TRUNC('month', created_at) 
        ORDER BY created_at
    ) AS monthly_running_total
FROM orders;
```

### FIRST_VALUE, LAST_VALUE, NTH_VALUE

```sql
-- Compare each product to the most expensive in its category
SELECT 
    name,
    category,
    price,
    FIRST_VALUE(name) OVER (
        PARTITION BY category 
        ORDER BY price DESC
    ) AS top_product,
    FIRST_VALUE(price) OVER (
        PARTITION BY category 
        ORDER BY price DESC
    ) AS top_price,
    ROUND(100.0 * price / FIRST_VALUE(price) OVER (
        PARTITION BY category 
        ORDER BY price DESC
    ), 2) AS pct_of_top
FROM products;
```

### Percentiles and Distribution

```sql
-- Percentile ranks
SELECT 
    name,
    salary,
    PERCENT_RANK() OVER (ORDER BY salary) AS percentile,
    NTILE(4) OVER (ORDER BY salary) AS quartile
FROM employees;

-- Median salary per department
SELECT DISTINCT
    department,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary) OVER (PARTITION BY department) AS median_salary
FROM employees;
```

---

## 1.8 Practice Exercises

### Exercise 1: Basic Queries

Using a products table with columns: `id`, `name`, `category`, `price`, `stock`, `created_at`:

```sql
-- 1. Find all products in the 'Electronics' category priced under $500
-- 2. Find products with low stock (less than 10) that need reordering
-- 3. List the 5 most recently added products
-- 4. Find products with names containing 'Pro' or 'Ultra'
```

<Accordion title="Solutions">
```sql
-- 1
SELECT * FROM products 
WHERE category = 'Electronics' AND price < 500;

-- 2
SELECT name, stock, category FROM products 
WHERE stock < 10 
ORDER BY stock ASC;

-- 3
SELECT * FROM products 
ORDER BY created_at DESC 
LIMIT 5;

-- 4
SELECT * FROM products 
WHERE name ILIKE '%pro%' OR name ILIKE '%ultra%';
```
</Accordion>

### Exercise 2: Aggregations

```sql
-- 1. Count products per category
-- 2. Find the average price per category, only for categories with avg > $200
-- 3. Find the total inventory value (price * stock) per category
-- 4. Find categories with more than 50 products
```

<Accordion title="Solutions">
```sql
-- 1
SELECT category, COUNT(*) as product_count 
FROM products 
GROUP BY category 
ORDER BY product_count DESC;

-- 2
SELECT category, AVG(price) as avg_price 
FROM products 
GROUP BY category 
HAVING AVG(price) > 200;

-- 3
SELECT category, SUM(price * stock) as inventory_value 
FROM products 
GROUP BY category 
ORDER BY inventory_value DESC;

-- 4
SELECT category, COUNT(*) as count 
FROM products 
GROUP BY category 
HAVING COUNT(*) > 50;
```
</Accordion>

### Exercise 3: JOINs

```sql
-- 1. List all orders with customer name and email
-- 2. Find customers who have never placed an order
-- 3. Get the top 10 customers by total spending
-- 4. List products that have been ordered more than 100 times
```

<Accordion title="Solutions">
```sql
-- 1
SELECT o.id, o.total, o.created_at, u.name, u.email
FROM orders o
INNER JOIN users u ON o.user_id = u.id
ORDER BY o.created_at DESC;

-- 2
SELECT u.name, u.email
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE o.id IS NULL;

-- 3
SELECT u.name, u.email, SUM(o.total) as total_spent
FROM users u
INNER JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name, u.email
ORDER BY total_spent DESC
LIMIT 10;

-- 4
SELECT p.name, COUNT(oi.id) as times_ordered
FROM products p
INNER JOIN order_items oi ON p.id = oi.product_id
GROUP BY p.id, p.name
HAVING COUNT(oi.id) > 100
ORDER BY times_ordered DESC;
```
</Accordion>

### Exercise 4: Window Functions

```sql
-- 1. Rank products by price within each category
-- 2. For each order, show the running total for that user
-- 3. Calculate the percentage each product contributes to its category's total stock
-- 4. Find the second-highest priced product in each category
```

<Accordion title="Solutions">
```sql
-- 1
SELECT 
    name, category, price,
    RANK() OVER (PARTITION BY category ORDER BY price DESC) as price_rank
FROM products;

-- 2
SELECT 
    user_id, id as order_id, total, created_at,
    SUM(total) OVER (PARTITION BY user_id ORDER BY created_at) as running_total
FROM orders;

-- 3
SELECT 
    name, category, stock,
    ROUND(100.0 * stock / SUM(stock) OVER (PARTITION BY category), 2) as stock_pct
FROM products;

-- 4
WITH ranked AS (
    SELECT 
        name, category, price,
        ROW_NUMBER() OVER (PARTITION BY category ORDER BY price DESC) as rn
    FROM products
)
SELECT name, category, price
FROM ranked
WHERE rn = 2;
```
</Accordion>

---

## Next Module

<Card title="Module 2: Database Design & Modeling" icon="arrow-right" href="/courses/database-engineering/database-design">
  Learn to design schemas that scale and maintain data integrity
</Card>
