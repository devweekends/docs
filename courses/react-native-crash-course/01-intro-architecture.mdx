---
title: "01. Introduction & Architecture"
description: "Understanding React Native's architecture, the bridge, new architecture, and when to choose React Native"
---

<Frame>
  <img src="/images/courses/react-native-crash-course/rn-architecture.svg" alt="React Native Architecture" />
</Frame>

## Module Overview

<Info>
**Estimated Time**: 2-3 hours | **Difficulty**: Beginner | **Prerequisites**: JavaScript, React basics
</Info>

Before writing any code, it's crucial to understand how React Native works under the hood. This knowledge will help you debug issues, optimize performance, and make better architectural decisions throughout your React Native journey.

**What You'll Learn:**
- What React Native is and how it differs from other solutions
- The JavaScript-to-Native bridge architecture
- The new architecture (Fabric, TurboModules, JSI)
- Hermes JavaScript engine
- When to choose React Native for your project

---

## What is React Native?

React Native is an open-source framework created by Meta (Facebook) in 2015 that allows developers to build **truly native mobile applications** using JavaScript and React. Unlike hybrid frameworks that use WebViews, React Native renders actual native UI components.

<CardGroup cols={2}>
  <Card title="True Native" icon="mobile">
    Renders to real native components (UIView, TextView), not web views
  </Card>
  <Card title="Cross-Platform" icon="layer-group">
    One codebase for iOS and Android with 90%+ code reuse
  </Card>
  <Card title="Hot Reloading" icon="fire">
    See changes instantly without rebuilding the entire app
  </Card>
  <Card title="JavaScript" icon="js">
    Use the language and ecosystem you already know
  </Card>
  <Card title="Large Ecosystem" icon="npm">
    Access to npm packages and React libraries
  </Card>
  <Card title="Active Community" icon="users">
    Backed by Meta with millions of developers worldwide
  </Card>
</CardGroup>

### Who Uses React Native?

<CardGroup cols={4}>
  <Card title="Meta" icon="facebook">
    Facebook, Instagram, Messenger
  </Card>
  <Card title="Microsoft" icon="microsoft">
    Office, Outlook, Teams
  </Card>
  <Card title="Shopify" icon="shopify">
    Shop app, Point of Sale
  </Card>
  <Card title="Discord" icon="discord">
    Mobile apps
  </Card>
</CardGroup>

Other notable companies: Coinbase, Pinterest, Bloomberg, Walmart, Tesla, and thousands more.

---

## How React Native Works

### The Rendering Pipeline

When you write React Native code, here's what happens:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    React Native Rendering Pipeline                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   1. Your React Code                                                         │
│      ┌──────────────────────────────────────────────────────────────────┐   │
│      │  const App = () => (                                              │   │
│      │    <View style={styles.container}>                                │   │
│      │      <Text>Hello, World!</Text>                                   │   │
│      │    </View>                                                        │   │
│      │  );                                                               │   │
│      └──────────────────────────────────────────────────────────────────┘   │
│                              │                                               │
│                              ▼                                               │
│   2. React Reconciliation                                                    │
│      ┌──────────────────────────────────────────────────────────────────┐   │
│      │  React creates a virtual DOM tree and calculates the minimal     │   │
│      │  set of changes needed (diffing algorithm)                       │   │
│      └──────────────────────────────────────────────────────────────────┘   │
│                              │                                               │
│                              ▼                                               │
│   3. Bridge / JSI Communication                                              │
│      ┌──────────────────────────────────────────────────────────────────┐   │
│      │  Changes are serialized and sent to the native side              │   │
│      │  (Legacy: JSON over bridge | New: Direct JSI calls)              │   │
│      └──────────────────────────────────────────────────────────────────┘   │
│                              │                                               │
│                              ▼                                               │
│   4. Native Rendering                                                        │
│      ┌──────────────────────────────────────────────────────────────────┐   │
│      │  iOS: UIView, UILabel, UIImageView                               │   │
│      │  Android: View, TextView, ImageView                              │   │
│      └──────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Component Mapping

React Native components map directly to native platform components:

| React Native | iOS (UIKit) | Android | Web Equivalent |
|-------------|-------------|---------|----------------|
| `<View>` | `UIView` | `android.view.View` | `<div>` |
| `<Text>` | `UILabel` | `TextView` | `<p>`, `<span>` |
| `<Image>` | `UIImageView` | `ImageView` | `<img>` |
| `<TextInput>` | `UITextField` | `EditText` | `<input>` |
| `<ScrollView>` | `UIScrollView` | `ScrollView` | `<div>` with overflow |
| `<FlatList>` | `UITableView` | `RecyclerView` | Virtual list |

---

## The Legacy Bridge Architecture

The original React Native architecture uses a "bridge" for communication between JavaScript and native code:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      Legacy Bridge Architecture                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   JavaScript Thread                    Native Thread                         │
│   ─────────────────                    ─────────────                         │
│                                                                              │
│   ┌─────────────────┐                  ┌─────────────────┐                  │
│   │  Your React     │                  │  Native UI      │                  │
│   │  Components     │                  │  Components     │                  │
│   │                 │                  │                 │                  │
│   │  - App.tsx      │                  │  - UIView       │                  │
│   │  - Screens      │                  │  - TextView     │                  │
│   │  - Components   │                  │  - ImageView    │                  │
│   └────────┬────────┘                  └────────▲────────┘                  │
│            │                                    │                            │
│            │         ┌──────────────┐           │                            │
│            └────────►│    Bridge    │───────────┘                            │
│                      │              │                                        │
│                      │  - Async     │                                        │
│                      │  - JSON      │                                        │
│                      │  - Batched   │                                        │
│                      └──────────────┘                                        │
│                                                                              │
│   ┌─────────────────┐                  ┌─────────────────┐                  │
│   │  JS Engine      │                  │  Native Modules │                  │
│   │                 │                  │                 │                  │
│   │  - Hermes       │                  │  - Camera       │                  │
│   │  - JSC          │                  │  - GPS          │                  │
│   │                 │                  │  - Storage      │                  │
│   └─────────────────┘                  └─────────────────┘                  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### How the Bridge Works

1. **JavaScript Thread**: Your React code runs here, handling business logic, state management, and UI declarations
2. **Bridge**: Serializes messages to JSON and passes them asynchronously between threads
3. **Native Thread**: Receives commands and renders actual native UI components
4. **Shadow Thread**: Calculates layout using Yoga (Flexbox engine)

### Bridge Limitations

<Warning>
The legacy bridge has several limitations that can impact performance:

- **Asynchronous Only**: All communication is async, causing delays for time-sensitive operations
- **Serialization Overhead**: Data must be serialized to JSON, adding CPU overhead
- **Single Bottleneck**: All communication goes through one bridge
- **No Direct Access**: JavaScript can't directly call native methods
</Warning>

```tsx
// Example: Bridge latency issue with animations
// This animation might feel janky because each frame
// requires a round-trip through the bridge

const opacity = useRef(new Animated.Value(0)).current;

Animated.timing(opacity, {
  toValue: 1,
  duration: 300,
  useNativeDriver: true, // This helps! Runs animation on native thread
}).start();
```

---

## The New Architecture

React Native's new architecture (available since RN 0.68, default in 0.74+) addresses bridge limitations with three key components:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         New Architecture Overview                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                    JavaScript Interface (JSI)                        │   │
│   │   ─────────────────────────────────────────────────────────────────  │   │
│   │   • Direct C++ bindings between JS and Native                        │   │
│   │   • No serialization needed                                          │   │
│   │   • Synchronous calls possible                                       │   │
│   │   • Enables Fabric and TurboModules                                  │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│   ┌───────────────────────────┐    ┌───────────────────────────────────┐   │
│   │      Fabric Renderer      │    │         TurboModules              │   │
│   │   ─────────────────────   │    │         ────────────              │   │
│   │                           │    │                                   │   │
│   │   • New rendering system  │    │   • New native module system      │   │
│   │   • Synchronous layout    │    │   • Lazy loading                  │   │
│   │   • Concurrent features   │    │   • Type-safe (Codegen)           │   │
│   │   • Better performance    │    │   • Direct JS-Native calls        │   │
│   │                           │    │                                   │   │
│   └───────────────────────────┘    └───────────────────────────────────┘   │
│                                                                              │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                          Codegen                                     │   │
│   │   ─────────────────────────────────────────────────────────────────  │   │
│   │   • Generates native code from TypeScript/Flow specs                 │   │
│   │   • Type-safe bridge between JS and Native                           │   │
│   │   • Compile-time validation                                          │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### JavaScript Interface (JSI)

JSI is the foundation of the new architecture—a lightweight C++ layer that allows JavaScript to hold references to native objects and call methods directly:

```tsx
// Conceptual example of JSI benefits
// Old Bridge: Async, serialized
bridge.call('NativeModule', 'getData', { id: 123 })
  .then(data => console.log(data));

// New JSI: Direct, can be sync
const data = NativeModule.getData({ id: 123 }); // Direct call!
```

**JSI Benefits:**
- **No Serialization**: Objects are passed by reference, not serialized to JSON
- **Synchronous Calls**: When needed, JS can call native code synchronously
- **Lazy Loading**: Native modules load only when first accessed
- **Multiple Engines**: JSI abstracts the JS engine, enabling Hermes, JSC, or V8

### Fabric Renderer

Fabric is the new rendering system that replaces the old UI Manager:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Fabric vs Legacy Rendering                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Legacy Rendering:                                                          │
│   ─────────────────                                                          │
│   JS Thread ──► Bridge ──► Shadow Thread ──► Bridge ──► UI Thread           │
│   (Async)       (JSON)     (Layout)          (JSON)     (Render)            │
│                                                                              │
│   Fabric Rendering:                                                          │
│   ─────────────────                                                          │
│   JS Thread ──► JSI ──► C++ Shadow Tree ──► UI Thread                       │
│   (Can be sync)  (Direct)  (Shared)          (Render)                       │
│                                                                              │
│   Benefits:                                                                  │
│   • Synchronous layout measurements                                          │
│   • Concurrent React features (Suspense, Transitions)                        │
│   • Better priority handling                                                 │
│   • Improved memory management                                               │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### TurboModules

TurboModules replace the old Native Modules system:

```tsx
// Old Native Module (loaded at startup)
import { NativeModules } from 'react-native';
const { MyModule } = NativeModules; // Loaded immediately

// TurboModule (lazy loaded)
import { TurboModuleRegistry } from 'react-native';
const MyModule = TurboModuleRegistry.get('MyModule'); // Loaded on first access
```

**TurboModule Benefits:**
- **Lazy Loading**: Modules load only when needed, improving startup time
- **Type Safety**: Codegen creates type-safe interfaces from specs
- **Direct Calls**: Uses JSI for direct native method invocation
- **Better Performance**: No JSON serialization overhead

### Codegen

Codegen generates native code from TypeScript/Flow specifications:

```tsx
// NativeMyModule.ts - TypeScript spec
import type { TurboModule } from 'react-native';
import { TurboModuleRegistry } from 'react-native';

export interface Spec extends TurboModule {
  multiply(a: number, b: number): number;
  getString(): string;
  getObject(): { name: string; value: number };
}

export default TurboModuleRegistry.getEnforcing<Spec>('MyModule');

// Codegen generates:
// - iOS: Objective-C++ interface
// - Android: Java/Kotlin interface
// - Type-safe bindings
```

---

## Hermes JavaScript Engine

Hermes is a JavaScript engine optimized specifically for React Native:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Hermes vs JavaScriptCore                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   JavaScriptCore (JSC):                                                      │
│   ─────────────────────                                                      │
│   Source Code ──► Parse ──► Compile (JIT) ──► Execute                       │
│                   (Runtime)  (Runtime)         (Runtime)                     │
│                                                                              │
│   Hermes:                                                                    │
│   ───────                                                                    │
│   Source Code ──► Parse ──► Compile ──► Bytecode ──► Execute                │
│                   (Build)    (Build)     (Ship)       (Runtime)             │
│                                                                              │
│   Hermes compiles JavaScript to bytecode at BUILD time,                     │
│   not at runtime. This means:                                                │
│   • Faster app startup (no parsing/compiling at launch)                     │
│   • Lower memory usage                                                       │
│   • Smaller app size (bytecode is smaller than source)                      │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Hermes Performance Benefits

| Metric | JavaScriptCore | Hermes | Improvement |
|--------|---------------|--------|-------------|
| Time to Interactive | 4.3s | 2.0s | **53% faster** |
| Memory Usage | 185 MB | 136 MB | **26% less** |
| App Size | 41 MB | 22 MB | **46% smaller** |

*Benchmarks from Meta's testing on a mid-range Android device*

### Enabling Hermes

Hermes is enabled by default in new React Native projects (0.70+). To verify or enable:

```json
// app.json (Expo)
{
  "expo": {
    "jsEngine": "hermes"
  }
}
```

```ruby
# ios/Podfile (React Native CLI)
:hermes_enabled => true
```

```groovy
// android/app/build.gradle (React Native CLI)
project.ext.react = [
    enableHermes: true
]
```

---

## React Native vs Alternatives

### Comparison Matrix

| Feature | React Native | Native (Swift/Kotlin) | Flutter | Ionic/Cordova |
|---------|--------------|----------------------|---------|---------------|
| **Language** | JavaScript/TypeScript | Swift/Kotlin | Dart | HTML/CSS/JS |
| **UI Rendering** | Native components | Native | Custom (Skia) | WebView |
| **Performance** | Near-native | Best | Near-native | Slower |
| **Code Reuse** | 90%+ | 0% | 95%+ | 95%+ |
| **Hot Reload** | ✅ Yes | ❌ No | ✅ Yes | ✅ Yes |
| **Community** | Huge | Largest | Growing fast | Declining |
| **Learning Curve** | Easy (if you know React) | Steep | Medium | Easy |
| **App Size** | Medium (10-20MB) | Small (5-10MB) | Larger (15-25MB) | Small |
| **Native Access** | Via bridge/JSI | Direct | Via channels | Via plugins |
| **Web Support** | React Native Web | N/A | Flutter Web | Built-in |

### When to Choose React Native

<Tabs>
  <Tab title="Choose React Native If">
    ✅ Your team knows JavaScript/TypeScript and React
    
    ✅ You need to ship iOS and Android apps quickly
    
    ✅ You want near-native performance with code reuse
    
    ✅ You need access to the npm ecosystem
    
    ✅ You're building a startup MVP or enterprise app
    
    ✅ You want to share code with a React web app
    
    ✅ You need over-the-air updates (CodePush/EAS Update)
  </Tab>
  
  <Tab title="Choose Native If">
    ✅ You need absolute best performance (games, AR/VR)
    
    ✅ You're building complex animations/graphics
    
    ✅ Your app requires cutting-edge platform features immediately
    
    ✅ You have separate iOS and Android teams
    
    ✅ You're building platform-specific experiences
    
    ✅ App size is critical (React Native adds ~10MB)
  </Tab>
  
  <Tab title="Choose Flutter If">
    ✅ You want pixel-perfect custom UI everywhere
    
    ✅ Your team doesn't have JavaScript experience
    
    ✅ You need excellent animation performance out of the box
    
    ✅ You're building from scratch (no existing React code)
    
    ✅ You prefer strongly-typed languages (Dart)
    
    ✅ You want a single rendering engine across platforms
  </Tab>
</Tabs>

### Real-World Decision Framework

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Technology Decision Framework                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Question 1: Does your team know React/JavaScript?                          │
│   ├── Yes ──► Strong candidate for React Native                             │
│   └── No ──► Consider Flutter or Native                                     │
│                                                                              │
│   Question 2: Do you need to share code with web?                           │
│   ├── Yes ──► React Native + React Native Web                               │
│   └── No ──► Any option works                                               │
│                                                                              │
│   Question 3: Is performance absolutely critical?                           │
│   ├── Yes (games, AR) ──► Native or Flutter                                 │
│   └── No (most apps) ──► React Native is fine                               │
│                                                                              │
│   Question 4: Do you need OTA updates?                                      │
│   ├── Yes ──► React Native (CodePush/EAS Update)                            │
│   └── No ──► Any option works                                               │
│                                                                              │
│   Question 5: Timeline and budget?                                          │
│   ├── Fast & Limited ──► React Native or Flutter                            │
│   └── Flexible ──► Any option works                                         │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## React Native Ecosystem

### Core Tools

<CardGroup cols={2}>
  <Card title="Expo" icon="box">
    Managed workflow with pre-built native modules, OTA updates, and cloud builds
  </Card>
  <Card title="React Navigation" icon="route">
    The standard navigation library for React Native apps
  </Card>
  <Card title="React Native CLI" icon="terminal">
    Bare workflow with full native code access
  </Card>
  <Card title="Metro" icon="bolt">
    JavaScript bundler optimized for React Native
  </Card>
</CardGroup>

### Popular Libraries

| Category | Library | Purpose |
|----------|---------|---------|
| **State** | Redux Toolkit, Zustand, Jotai | Global state management |
| **Data Fetching** | TanStack Query, SWR | Server state and caching |
| **Forms** | React Hook Form, Formik | Form handling and validation |
| **UI** | React Native Paper, Tamagui | Component libraries |
| **Animation** | Reanimated, Moti | High-performance animations |
| **Storage** | MMKV, AsyncStorage | Local data persistence |
| **Testing** | Jest, Detox | Unit and E2E testing |

---

## Understanding the Threads

React Native runs on multiple threads:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         React Native Threads                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   1. JavaScript Thread                                                       │
│      ─────────────────                                                       │
│      • Runs your React code                                                  │
│      • Handles business logic                                                │
│      • Manages state and props                                               │
│      • Single-threaded (one JS thread)                                       │
│                                                                              │
│   2. Main/UI Thread                                                          │
│      ─────────────────                                                       │
│      • Renders native UI                                                     │
│      • Handles touch events                                                  │
│      • Must stay responsive (60 FPS = 16ms per frame)                       │
│      • Platform's main thread                                                │
│                                                                              │
│   3. Shadow Thread (Legacy) / C++ Thread (New Arch)                         │
│      ─────────────────────────────────────────────────                       │
│      • Calculates layout using Yoga                                          │
│      • Determines component positions and sizes                              │
│      • Runs Flexbox calculations                                             │
│                                                                              │
│   4. Native Modules Thread                                                   │
│      ─────────────────────                                                   │
│      • Runs native module code                                               │
│      • Handles async operations                                              │
│      • Camera, GPS, file system, etc.                                        │
│                                                                              │
│   Performance Tip:                                                           │
│   Keep the JS thread free for UI updates. Heavy computations                │
│   should be moved to native modules or web workers.                         │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Thread Communication Example

```tsx
// This runs on JS thread
const handlePress = () => {
  // This computation blocks the JS thread
  const result = heavyComputation(); // ❌ Bad - blocks UI updates
  
  // Better: Use native module or InteractionManager
  InteractionManager.runAfterInteractions(() => {
    const result = heavyComputation(); // ✅ Runs after animations complete
  });
};

// Even better: Use useNativeDriver for animations
Animated.timing(opacity, {
  toValue: 1,
  duration: 300,
  useNativeDriver: true, // ✅ Animation runs on UI thread, not JS thread
}).start();
```

---

## Key Takeaways

<CardGroup cols={2}>
  <Card title="React Native Renders Native" icon="mobile">
    Unlike hybrid apps, React Native renders actual native UI components
  </Card>
  <Card title="Bridge is Being Replaced" icon="bridge">
    The new architecture (JSI, Fabric, TurboModules) eliminates bridge bottlenecks
  </Card>
  <Card title="Hermes Improves Performance" icon="bolt">
    Hermes compiles JS to bytecode at build time for faster startup
  </Card>
  <Card title="Choose Based on Team" icon="users">
    React Native is ideal if your team knows React/JavaScript
  </Card>
</CardGroup>

---

## Practice Exercise

<Steps>
  <Step title="Research">
    Look up 3 apps you use daily and check if they're built with React Native (hint: check their job postings or tech blogs)
  </Step>
  <Step title="Compare">
    Download the same app on iOS and Android. Notice any differences in UI or behavior? React Native apps should feel native on each platform.
  </Step>
  <Step title="Explore">
    Visit the [React Native Directory](https://reactnative.directory/) and browse popular libraries. Note which categories have the most options.
  </Step>
</Steps>

---

## Quiz

<AccordionGroup>
  <Accordion title="Q1: What makes React Native different from hybrid frameworks like Ionic?">
    **Answer**: React Native renders to actual native UI components (UIView, TextView), while hybrid frameworks render to WebViews. This gives React Native near-native performance and platform-specific look and feel.
  </Accordion>
  
  <Accordion title="Q2: What are the three main components of the new architecture?">
    **Answer**: 
    1. **JSI (JavaScript Interface)**: Direct C++ bindings between JS and native
    2. **Fabric**: New rendering system with synchronous layout
    3. **TurboModules**: Lazy-loaded, type-safe native modules
  </Accordion>
  
  <Accordion title="Q3: Why is Hermes faster than JavaScriptCore?">
    **Answer**: Hermes compiles JavaScript to bytecode at build time (ahead-of-time compilation), while JSC compiles at runtime. This means Hermes apps start faster because they skip parsing and compilation at launch.
  </Accordion>
  
  <Accordion title="Q4: When should you NOT choose React Native?">
    **Answer**: Avoid React Native for:
    - Performance-critical apps (games, AR/VR)
    - Apps requiring immediate access to cutting-edge platform features
    - When app size is critical (RN adds ~10MB)
    - When you have dedicated native teams
  </Accordion>
</AccordionGroup>

---

## Next Steps

<Card title="Module 2: Environment Setup" icon="arrow-right" href="/courses/react-native-crash-course/02-environment-setup">
  Set up your development environment for iOS and Android development
</Card>
