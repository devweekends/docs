---
title: "Dependency Injection"
sidebarTitle: "2. DI & Modules"
icon: "puzzle-piece"
---


# Chapter 2: Dependency Injection & Modules

> **Dependency Injection (DI)** is a core principle in NestJS, enabling loose coupling, testability, and modularity. This chapter explores DI in depth, including provider types, scopes, custom providers, and advanced module patterns.

---

## 2.1 What is Dependency Injection?

Dependency Injection is a design pattern where dependencies (services, repositories, etc.) are provided to a class, rather than the class creating them itself. This allows for easier testing, maintenance, and flexibility.

**Benefits:**
- Decouples components
- Enables easy mocking for tests
- Supports modular and scalable architecture

---

## 2.2 Providers in NestJS

Providers are the backbone of DI in NestJS. Any class annotated with `@Injectable()` can be injected as a dependency.

```typescript
@Injectable()
export class LoggerService {
  log(message: string) {
    console.log(message);
  }
}

@Injectable()
export class AppService {
  constructor(private logger: LoggerService) {}

  doWork() {
    this.logger.log('Work done!');
  }
}
```

---

## 2.3 Provider Scopes

NestJS supports three provider scopes:

- **Default (Singleton):** One instance per application.
- **Request:** New instance per HTTP request.
- **Transient:** New instance every time it’s injected.

```typescript
@Injectable({ scope: Scope.REQUEST })
export class RequestService {}

@Injectable({ scope: Scope.TRANSIENT })
export class TransientService {}
```

**Diagram: Provider Scopes**

```text
Singleton   → App-wide (default)
Request     → Per HTTP request
Transient   → Every injection
```

---

## 2.4 Custom Providers

Custom providers allow you to control how dependencies are created and injected. Useful for configuration, factories, and value injection.

### Value Provider
```typescript
{
  provide: 'CONFIG',
  useValue: { apiKey: 'secret', dbHost: 'localhost' },
}
```

### Factory Provider
```typescript
{
  provide: 'ASYNC_CONFIG',
  useFactory: async () => {
    const config = await loadConfigFromRemote();
    return config;
  },
}
```

### Class Provider
```typescript
{
  provide: LoggerService,
  useClass: AdvancedLoggerService,
}
```

---

## 2.5 Injection Tokens

Tokens are used to identify providers. By default, the class itself is the token, but you can use strings or symbols for custom providers.

```typescript
@Inject('CONFIG')
constructor(@Inject('CONFIG') private config) {}
```

---

## 2.6 Dynamic Modules

Dynamic modules allow you to configure modules at runtime, useful for libraries and shared infrastructure.

```typescript
@Module({})
export class DatabaseModule {
  static forRoot(options): DynamicModule {
    return {
      module: DatabaseModule,
      providers: [
        {
          provide: 'DB_OPTIONS',
          useValue: options,
        },
        DatabaseService,
      ],
      exports: [DatabaseService],
    };
  }
}
```

**Usage:**
```typescript
@Module({
  imports: [DatabaseModule.forRoot({ host: 'localhost' })],
})
export class AppModule {}
```

---

## 2.7 Module Architecture

Modules group related providers and controllers. Use feature modules to organize code by domain. Shared modules can export common providers.

**Best Practices:**
- Keep modules focused
- Export only what’s needed
- Avoid circular dependencies

---

## 2.8 Real-World Example: Config Service

```typescript
// config.service.ts
@Injectable()
export class ConfigService {
  private readonly config = {
    apiKey: process.env.API_KEY,
    dbHost: process.env.DB_HOST,
  };

  get(key: string) {
    return this.config[key];
  }
}

// app.module.ts
@Module({
  providers: [ConfigService],
  exports: [ConfigService],
})
export class AppModule {}

// usage in another service
@Injectable()
export class SomeService {
  constructor(private config: ConfigService) {}

  doSomething() {
    const apiKey = this.config.get('apiKey');
    // ...
  }
}
```

---

## 2.9 Summary

You’ve learned how dependency injection powers modular, testable, and scalable applications in NestJS. Next, we’ll explore controllers, routing, and request handling in depth.
