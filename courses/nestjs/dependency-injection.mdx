---
title: "Dependency Injection"
sidebarTitle: "2. DI & Modules"
icon: "puzzle-piece"
---



# Chapter 2: Dependency Injection & Modules

> **Dependency Injection (DI)** is like having a smart assistant who brings you the tools you need, when you need them, instead of you having to build or find them yourself. In NestJS, DI is the backbone of modular, testable, and maintainable code. This chapter explores DI in depth, including provider types, scopes, custom providers, advanced module patterns, and real-world testing.

---


## 2.1 What is Dependency Injection?

Dependency Injection is a design pattern where dependencies (services, repositories, etc.) are provided to a class, rather than the class creating them itself. This allows for easier testing, maintenance, and flexibility.

**Analogy:**
> Imagine a chef (your class) who needs ingredients (dependencies). Instead of growing or buying them, a supplier (NestJS DI system) delivers fresh ingredients to the kitchen. The chef can focus on cooking, and you can swap suppliers for testing or upgrades.

**Benefits:**
- Decouples components (swap implementations easily)
- Enables easy mocking for tests (inject fake services)
- Supports modular and scalable architecture (plug-and-play modules)

---


## 2.2 Providers in NestJS

Providers are the backbone of DI in NestJS. Any class annotated with `@Injectable()` can be injected as a dependency. Providers can be services, repositories, factories, or even values.

```typescript
@Injectable()
export class LoggerService {
  log(message: string) {
    console.log(message);
  }
}

@Injectable()
export class AppService {
  constructor(private logger: LoggerService) {}

  doWork() {
    this.logger.log('Work done!');
  }
}
```

**Diagram: DI Flow**
```text
AppService <-- LoggerService
   |             ^
   |             |
   +--- NestJS DI Container ---+
```

**Tip:** Use `@Injectable()` on any class you want to inject elsewhere.

---


## 2.3 Provider Scopes

NestJS supports three provider scopes:

- **Default (Singleton):** One instance per application (default, most common).
- **Request:** New instance per HTTP request (useful for request-specific data).
- **Transient:** New instance every time it’s injected (useful for stateless, short-lived logic).

```typescript
@Injectable({ scope: Scope.REQUEST })
export class RequestService {}

@Injectable({ scope: Scope.TRANSIENT })
export class TransientService {}
```

**Diagram: Provider Scopes**
```text
Singleton   → App-wide (default)
Request     → Per HTTP request
Transient   → Every injection
```

**When to use each?**
- Use Singleton for most services (stateless, shared logic).
- Use Request for per-request data (e.g., user context).
- Use Transient for stateless, short-lived helpers.

---


## 2.4 Custom Providers

Custom providers allow you to control how dependencies are created and injected. This is useful for configuration, factories, and swapping implementations (e.g., for testing or environment-specific logic).

### Value Provider
Inject a static value (e.g., config object):
```typescript
{
  provide: 'CONFIG',
  useValue: { apiKey: 'secret', dbHost: 'localhost' },
}
```

### Factory Provider
Inject a value created by a function (can be async):
```typescript
{
  provide: 'ASYNC_CONFIG',
  useFactory: async () => {
    const config = await loadConfigFromRemote();
    return config;
  },
}
```

### Class Provider
Swap one class for another (e.g., for testing or advanced logging):
```typescript
{
  provide: LoggerService,
  useClass: AdvancedLoggerService,
}
```

**Tip:** Use custom providers for environment configs, third-party integrations, or when you need to mock dependencies in tests.

---


## 2.5 Injection Tokens

Tokens are used to identify providers. By default, the class itself is the token, but you can use strings or symbols for custom providers. This is especially useful for injecting values or interfaces.

```typescript
@Inject('CONFIG')
constructor(@Inject('CONFIG') private config) {}
```

**Best Practice:** Use string tokens for values, and class tokens for services.

---


## 2.6 Dynamic Modules

Dynamic modules allow you to configure modules at runtime, useful for libraries and shared infrastructure. They let you pass options (like database configs) when importing a module.

```typescript
@Module({})
export class DatabaseModule {
  static forRoot(options): DynamicModule {
    return {
      module: DatabaseModule,
      providers: [
        {
          provide: 'DB_OPTIONS',
          useValue: options,
        },
        DatabaseService,
      ],
      exports: [DatabaseService],
    };
  }
}
```

**Usage:**
```typescript
@Module({
  imports: [DatabaseModule.forRoot({ host: 'localhost' })],
})
export class AppModule {}
```

**Analogy:**
> Think of dynamic modules as "configurable blueprints"—you can build the same house with different paint, windows, or doors, depending on your needs.

---



## 2.7 Module Architecture & Advanced Patterns

Modules group related providers and controllers. Use feature modules to organize code by domain. Shared modules can export common providers for reuse across the app.

### Feature Modules
Organize your code by business domain (e.g., UsersModule, OrdersModule). Each module should encapsulate its own providers, controllers, and entities. This keeps your codebase clean and maintainable.

### Shared Modules
Shared modules export common providers (e.g., ConfigService, LoggerService) for use in other modules. Always use the `exports` array to make providers available outside the module.

```typescript
@Module({
  providers: [LoggerService],
  exports: [LoggerService],
})
export class SharedModule {}
```

### Re-exporting Modules
You can re-export entire modules to compose features:
```typescript
@Module({
  imports: [SharedModule],
  exports: [SharedModule],
})
export class CoreModule {}
```

### Handling Circular Dependencies
Circular dependencies can occur when two providers depend on each other. Use `forwardRef` to resolve them:
```typescript
@Module({
  imports: [forwardRef(() => UsersModule)],
  providers: [AuthService],
})
export class AuthModule {}

@Module({
  imports: [forwardRef(() => AuthModule)],
  providers: [UsersService],
})
export class UsersModule {}
```

**Diagram: Module Relationships**
```text
AppModule
  ├── UsersModule
  ├── AuthModule
  └── SharedModule (exports LoggerService, ConfigService)
```

**Best Practices:**
- Keep modules focused and cohesive
- Export only what’s needed
- Use shared modules for cross-cutting concerns
- Avoid circular dependencies; use `forwardRef` only when necessary

---

---



## 2.8 Real-World Example: Config Service & Advanced Providers

Let’s see how to build a flexible configuration system using DI and custom providers.

```typescript
// config.service.ts
@Injectable()
export class ConfigService {
  private readonly config = {
    apiKey: process.env.API_KEY,
    dbHost: process.env.DB_HOST,
    logLevel: process.env.LOG_LEVEL || 'info',
  };

  get<T = any>(key: string): T {
    return this.config[key];
  }
}

// app.module.ts
@Module({
  providers: [ConfigService],
  exports: [ConfigService],
})
export class AppModule {}

// usage in another service
@Injectable()
export class SomeService {
  constructor(private config: ConfigService) {}

  doSomething() {
    const apiKey = this.config.get<string>('apiKey');
    // ...
  }
}

// Advanced: Async Factory Provider for Config
@Module({
  providers: [
    {
      provide: 'ASYNC_CONFIG',
      useFactory: async () => {
        // Load config from remote or file
        return await fetchRemoteConfig();
      },
    },
  ],
  exports: ['ASYNC_CONFIG'],
})
export class ConfigAsyncModule {}

// Usage in another module
@Injectable()
export class AnotherService {
  constructor(@Inject('ASYNC_CONFIG') private config) {}
}
```

---


## 2.9 Testing Providers & Modules

Testing DI is easy with Nest’s testing utilities. Use `Test.createTestingModule` to mock providers and test modules in isolation. This makes it simple to write unit and integration tests for your services and modules.

```typescript
import { Test, TestingModule } from '@nestjs/testing';

describe('ConfigService', () => {
  let service: ConfigService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [ConfigService],
    }).compile();
    service = module.get<ConfigService>(ConfigService);
  });

  it('should return config value', () => {
    expect(service.get('apiKey')).toBe(process.env.API_KEY);
  });
});
```

**Mocking Providers:**
```typescript
const mockConfig = { get: jest.fn().mockReturnValue('mocked') };
const module = await Test.createTestingModule({
  providers: [
    { provide: ConfigService, useValue: mockConfig },
  ],
}).compile();
const service = module.get<ConfigService>(ConfigService);
```

**Tip:** Always mock external dependencies (like databases or APIs) in your tests for speed and reliability.

---

---


## 2.10 Summary

You’ve learned how dependency injection powers modular, testable, and scalable applications in NestJS. With DI, you can build flexible, maintainable systems that are easy to test and extend. Next, we’ll explore controllers, routing, and request handling in depth.
