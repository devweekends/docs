---
title: "Controllers & Routing"
sidebarTitle: "3. Controllers"
icon: "route"
---


# Chapter 3: Controllers & Routing

> Controllers are the entry point for handling client requests in NestJS. This chapter explores routing, request/response handling, decorators, middleware, guards, interceptors, and best practices for building robust APIs.

---

## 3.1 What is a Controller?

A controller is responsible for receiving incoming requests, delegating work to services, and returning responses. Controllers define the routes and HTTP methods for your API.

```typescript
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get()
  findAll() {
    return this.usersService.findAll();
  }
}
```

---

## 3.2 Routing in NestJS

Routes are defined using decorators like `@Get`, `@Post`, `@Put`, `@Delete`, etc. The path can include parameters and wildcards.

### Route Parameters
```typescript
@Get(':id')
findOne(@Param('id') id: string) {
  return this.usersService.findOne(Number(id));
}
```

### Query Parameters
```typescript
@Get()
findByQuery(@Query('role') role: string) {
  return this.usersService.findByRole(role);
}
```

### Request Body
```typescript
@Post()
create(@Body() createDto: CreateUserDto) {
  return this.usersService.create(createDto);
}
```

---

## 3.3 Request Lifecycle

1. Client sends HTTP request
2. NestJS matches route and method
3. Controller method is invoked
4. Service is called for business logic
5. Response is returned

**Diagram: Request Flow**

```text
Client → Controller → Service → (Repository/Database) → Response
```

---

## 3.4 Validation & DTOs

Use Data Transfer Objects (DTOs) and class-validator to validate incoming data.

```typescript
import { IsString, IsEmail } from 'class-validator';

export class CreateUserDto {
  @IsString()
  name: string;

  @IsEmail()
  email: string;
}
```

Apply validation globally in `main.ts`:

```typescript
import { ValidationPipe } from '@nestjs/common';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());
  await app.listen(3000);
}
```

---

## 3.5 Middleware

Middleware is executed before the route handler. Use it for logging, authentication, etc.

```typescript
import { Injectable, NestMiddleware } from '@nestjs/common';

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: Function) {
    console.log(`[${req.method}] ${req.url}`);
    next();
  }
}
```

Register middleware in a module:

```typescript
import { MiddlewareConsumer, Module, RequestMethod } from '@nestjs/common';

@Module({})
export class AppModule {
  configure(consumer: MiddlewareConsumer) {
    consumer.apply(LoggerMiddleware).forRoutes({ path: 'users', method: RequestMethod.ALL });
  }
}
```

---

## 3.6 Guards

Guards determine whether a request should be handled by the route. Use them for authentication and authorization.

```typescript
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';

@Injectable()
export class AuthGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    return Boolean(request.headers['authorization']);
  }
}

@UseGuards(AuthGuard)
@Get('profile')
getProfile(@Request() req) {
  return req.user;
}
```

---

## 3.7 Interceptors

Interceptors can transform the result returned from a function, extend basic method behavior, or handle cross-cutting concerns like logging and caching.

```typescript
import { CallHandler, ExecutionContext, Injectable, NestInterceptor } from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

@Injectable()
export class TransformInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(map(data => ({ data, success: true })));
  }
}
```

Apply globally in `main.ts`:

```typescript
app.useGlobalInterceptors(new TransformInterceptor());
```

---

## 3.8 Best Practices

- Keep controllers thin, delegate logic to services
- Use DTOs and validation for all input
- Organize routes by feature modules
- Use middleware, guards, and interceptors for cross-cutting concerns
- Document your API with Swagger (`@nestjs/swagger`)

---

## 3.9 Summary

You’ve learned how to build robust, maintainable APIs using controllers, routing, middleware, guards, and interceptors. Next, we’ll explore providers, services, and advanced service patterns.
