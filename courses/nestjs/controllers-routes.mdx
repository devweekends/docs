---
title: "Controllers & Routing"
sidebarTitle: "3. Controllers"
icon: "route"
---



# Chapter 3: Controllers & Routing

> Controllers are the entry point for handling client requests in NestJS. Think of them as the "reception desk" of your application—they receive requests, ask the right service for help, and send back a response. This chapter explores routing, request/response handling, decorators, middleware, guards, interceptors, error handling, and best practices for building robust APIs.

---


## 3.1 What is a Controller?

A controller is responsible for receiving incoming requests, delegating work to services, and returning responses. Controllers define the routes and HTTP methods for your API.

**Analogy:**
> Imagine a restaurant: the controller is the waiter, the service is the chef, and the client is the customer.

```typescript
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get()
  findAll() {
    return this.usersService.findAll();
  }
}
```

**Diagram: Request Flow**
```text
Client → Controller → Service → (Repository/Database) → Response
```

---


## 3.2 Routing in NestJS

Routes are defined using decorators like `@Get`, `@Post`, `@Put`, `@Delete`, etc. The path can include parameters and wildcards. You can handle all types of HTTP requests and extract data from the URL, query string, body, or headers.

### Route Parameters
```typescript
@Get(':id')
findOne(@Param('id') id: string) {
  return this.usersService.findOne(Number(id));
}
```

### Query Parameters
```typescript
@Get()
findByQuery(@Query('role') role: string) {
  return this.usersService.findByRole(role);
}
```

### Request Body
```typescript
@Post()
create(@Body() createDto: CreateUserDto) {
  return this.usersService.create(createDto);
}
```

### Error Handling
Use built-in exceptions for error handling:
```typescript
import { NotFoundException } from '@nestjs/common';

@Get(':id')
findOne(@Param('id') id: string) {
  const user = this.usersService.findOne(Number(id));
  if (!user) throw new NotFoundException('User not found');
  return user;
}
```
```

### Query Parameters
```typescript
@Get()
findByQuery(@Query('role') role: string) {
  return this.usersService.findByRole(role);
}
```

### Request Body
```typescript
@Post()
create(@Body() createDto: CreateUserDto) {
  return this.usersService.create(createDto);
}
```

---


## 3.3 Request Lifecycle

1. Client sends HTTP request
2. NestJS matches route and method
3. Middleware (if any) runs
4. Guards (if any) check permissions
5. Controller method is invoked
6. Service is called for business logic
7. Interceptors (if any) transform the response
8. Response is returned

**Diagram: Full Request Lifecycle**
```text
Client
  ↓
Middleware → Guards → Controller → Service → Interceptors → Response
```

---


## 3.4 Validation & DTOs

Use Data Transfer Objects (DTOs) and class-validator to validate incoming data. This ensures your API only accepts well-formed requests.

```typescript
import { IsString, IsEmail } from 'class-validator';

export class CreateUserDto {
  @IsString()
  name: string;

  @IsEmail()
  email: string;
}
```

Apply validation globally in `main.ts`:

```typescript
import { ValidationPipe } from '@nestjs/common';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());
  await app.listen(3000);
}
```

**Tip:** Always validate input to prevent security issues and bugs.

---


## 3.5 Middleware

Middleware is executed before the route handler. Use it for logging, authentication, request transformation, etc.

```typescript
import { Injectable, NestMiddleware } from '@nestjs/common';

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: Function) {
    console.log(`[${req.method}] ${req.url}`);
    next();
  }
}
```

Register middleware in a module:

```typescript
import { MiddlewareConsumer, Module, RequestMethod } from '@nestjs/common';

@Module({})
export class AppModule {
  configure(consumer: MiddlewareConsumer) {
    consumer.apply(LoggerMiddleware).forRoutes({ path: 'users', method: RequestMethod.ALL });
  }
}
```

**Tip:** Use middleware for cross-cutting concerns that apply to many routes.

---


## 3.6 Guards

Guards determine whether a request should be handled by the route. Use them for authentication and authorization. Guards run before the controller method.

```typescript
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';

@Injectable()
export class AuthGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    return Boolean(request.headers['authorization']);
  }
}

@UseGuards(AuthGuard)
@Get('profile')
getProfile(@Request() req) {
  return req.user;
}
```

**Tip:** Use guards for permission checks, roles, and authentication logic.

---


## 3.7 Interceptors

Interceptors can transform the result returned from a function, extend basic method behavior, or handle cross-cutting concerns like logging, caching, or response shaping.

```typescript
import { CallHandler, ExecutionContext, Injectable, NestInterceptor } from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

@Injectable()
export class TransformInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(map(data => ({ data, success: true })));
  }
}
```

Apply globally in `main.ts`:

```typescript
app.useGlobalInterceptors(new TransformInterceptor());
```

**Tip:** Use interceptors for logging, response formatting, and error transformation.

---


## 3.8 Best Practices

- Keep controllers thin, delegate logic to services
- Use DTOs and validation for all input
- Organize routes by feature modules
- Use middleware, guards, and interceptors for cross-cutting concerns
- Document your API with Swagger (`@nestjs/swagger`)
- Handle errors with built-in exceptions
- Return consistent response shapes (use interceptors)

---


## 3.9 Summary

You’ve learned how to build robust, maintainable APIs using controllers, routing, middleware, guards, interceptors, and error handling. Next, we’ll explore providers, services, and advanced service patterns.
