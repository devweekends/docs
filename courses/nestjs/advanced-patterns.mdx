---
title: "Advanced Patterns"
sidebarTitle: "10. Advanced"
icon: "star"
---


# Chapter 10: Advanced Patterns

> Mastering advanced patterns unlocks the full power of NestJS. This chapter covers CQRS, GraphQL, WebSockets, event sourcing, and real-world case studies for building scalable, modern applications.

---

## 10.1 CQRS (Command Query Responsibility Segregation)

CQRS separates read and write operations for better scalability and maintainability. Use the `@nestjs/cqrs` package for implementing CQRS in NestJS.

### Example: Command Handler
```typescript
@CommandHandler(CreateUserCommand)
export class CreateUserHandler implements ICommandHandler<CreateUserCommand> {
  async execute(command: CreateUserCommand) {
    const user = new User(command.name);
    await this.repository.save(user);
    return user;
  }
}
```

**Best Practices:**
- Use separate models for reads and writes
- Implement event sourcing for auditability

---

## 10.2 GraphQL APIs

NestJS supports GraphQL out of the box. Use code-first or schema-first approaches.

### Example: GraphQL Resolver
```typescript
@Resolver(() => User)
export class UsersResolver {
  @Query(() => [User])
  users() {
    return this.service.findAll();
  }

  @Mutation(() => User)
  createUser(@Args('input') input: CreateUserInput) {
    return this.service.create(input);
  }
}
```

**Best Practices:**
- Use DTOs for input validation
- Leverage GraphQL subscriptions for real-time updates

---

## 10.3 WebSockets & Real-Time Communication

WebSockets enable real-time, bidirectional communication. Use `@nestjs/websockets` for gateways and event handling.

### Example: WebSocket Gateway
```typescript
@WebSocketGateway()
export class ChatGateway {
  @SubscribeMessage('message')
  handleMessage(client: Socket, payload: any) {
    this.server.emit('message', payload);
  }
}
```

**Use Cases:**
- Chat applications
- Live dashboards
- Multiplayer games

---

## 10.4 Event Sourcing

Event sourcing stores state as a sequence of events. Useful for audit logs, undo/redo, and complex business flows.

**Pattern:**
- Store every change as an event
- Rebuild state by replaying events

---

## 10.5 Real-World Case Study: Scalable Chat App

**Features:**
- REST API for user management
- WebSocket gateway for real-time messaging
- CQRS for separating chat commands and queries
- Event sourcing for message history

**Diagram:**
```text
Client → REST API (NestJS) → CQRS Command → Event Store
      ↕
   WebSocket Gateway ← Event Stream
```

---

## 10.6 Best Practices

- Use advanced patterns only when needed
- Keep code modular and testable
- Document architecture decisions
- Monitor and profile performance

---

## 10.7 Summary

You’ve mastered advanced patterns in NestJS, including CQRS, GraphQL, WebSockets, and event sourcing. Continue building modern, scalable applications with confidence!
