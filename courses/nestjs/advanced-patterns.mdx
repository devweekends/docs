---
title: "Advanced Patterns"
sidebarTitle: "10. Advanced"
icon: "star"
---



# Chapter 10: Advanced Patterns

> Mastering advanced patterns unlocks the full power of NestJS. This chapter covers CQRS, GraphQL, WebSockets, event sourcing, and real-world case studies for building scalable, modern applications. We’ll walk through practical examples and explain when to use each pattern.

---


## 10.1 CQRS (Command Query Responsibility Segregation)

CQRS separates read and write operations for better scalability and maintainability. Use the `@nestjs/cqrs` package for implementing CQRS in NestJS.

**Analogy:**
> Think of CQRS as having two separate desks: one for taking orders (commands), and one for answering questions (queries).

### Example: Command Handler
```typescript
@CommandHandler(CreateUserCommand)
export class CreateUserHandler implements ICommandHandler<CreateUserCommand> {
  async execute(command: CreateUserCommand) {
    const user = new User(command.name);
    await this.repository.save(user);
    return user;
  }
}
```

**Best Practices:**
- Use separate models for reads and writes
- Implement event sourcing for auditability
- Use CQRS for complex domains, not simple CRUD

---


## 10.2 GraphQL APIs

NestJS supports GraphQL out of the box. Use code-first or schema-first approaches. GraphQL lets clients request exactly the data they need.

### Example: GraphQL Resolver
```typescript
@Resolver(() => User)
export class UsersResolver {
  @Query(() => [User])
  users() {
    return this.service.findAll();
  }

  @Mutation(() => User)
  createUser(@Args('input') input: CreateUserInput) {
    return this.service.create(input);
  }
}
```

**Diagram: GraphQL Flow**
```text
Client → GraphQL Resolver → Service → DB
```

**Best Practices:**
- Use DTOs for input validation
- Leverage GraphQL subscriptions for real-time updates
- Document your schema for frontend teams

---


## 10.3 WebSockets & Real-Time Communication

WebSockets enable real-time, bidirectional communication. Use `@nestjs/websockets` for gateways and event handling. This is ideal for chat, live dashboards, and games.

### Example: WebSocket Gateway
```typescript
@WebSocketGateway()
export class ChatGateway {
  @SubscribeMessage('message')
  handleMessage(client: Socket, payload: any) {
    this.server.emit('message', payload);
  }
}
```

**Diagram: WebSocket Flow**
```text
Client ⇄ WebSocket Gateway ⇄ Service
```

**Use Cases:**
- Chat applications
- Live dashboards
- Multiplayer games

---


## 10.4 Event Sourcing

Event sourcing stores state as a sequence of events. Useful for audit logs, undo/redo, and complex business flows.

**Pattern:**
- Store every change as an event
- Rebuild state by replaying events

**Tip:** Use event sourcing for systems where you need a full history of changes.

---


## 10.5 Real-World Case Study: Scalable Chat App

Let’s see how these patterns work together in a real-world scenario:

**Features:**
- REST API for user management
- WebSocket gateway for real-time messaging
- CQRS for separating chat commands and queries
- Event sourcing for message history

**Diagram:**
```text
Client → REST API (NestJS) → CQRS Command → Event Store
    ↕
  WebSocket Gateway ← Event Stream
```

---


## 10.6 Best Practices

- Use advanced patterns only when needed (don’t over-engineer)
- Keep code modular and testable
- Document architecture decisions
- Monitor and profile performance
- Start simple, add complexity as needed

---



## 10.7 Common Pitfalls

- Overengineering: Don’t use CQRS, event sourcing, or GraphQL unless your use case truly needs them.
- Poor separation: Mixing command and query logic in CQRS defeats the purpose.
- Not documenting message/event formats: Leads to confusion between teams.
- Forgetting to secure WebSocket endpoints.
- Not monitoring or profiling advanced features (can cause hidden performance issues).

## 10.8 FAQ

**Q: When should I use CQRS?**
A: Use CQRS for complex domains with high write/read separation, not for simple CRUD apps.

**Q: Is GraphQL always better than REST?**
A: Not always. Use GraphQL when clients need flexible queries or you have many frontend teams.

**Q: How do I debug event sourcing issues?**
A: Log every event, and provide tools to replay or inspect the event store.

**Q: Can I combine these patterns?**
A: Yes! Many real-world systems use CQRS + Event Sourcing + GraphQL or WebSockets together.

## 10.9 Further Reading

- [NestJS CQRS Docs](https://docs.nestjs.com/recipes/cqrs)
- [NestJS GraphQL Docs](https://docs.nestjs.com/graphql/quick-start)
- [NestJS WebSockets Docs](https://docs.nestjs.com/websockets/gateways)
- [Event Sourcing Patterns](https://martinfowler.com/eaaDev/EventSourcing.html)
- [CQRS Explained](https://martinfowler.com/bliki/CQRS.html)

## 10.10 Practice Exercises

- Refactor a CRUD service to use CQRS (separate command and query handlers).
- Add a GraphQL resolver to an existing REST API.
- Implement a simple WebSocket gateway for real-time notifications.
- Design an event store for a simple order management system.

## 10.11 Summary

You’ve mastered advanced patterns in NestJS, including CQRS, GraphQL, WebSockets, and event sourcing. With these tools, you can build modern, scalable applications with confidence!
