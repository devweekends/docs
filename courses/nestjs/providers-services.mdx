---

# Chapter 4: Providers & Services

  async findAll() {

---

## 4.1 What is a Provider?

In NestJS, a provider is any class annotated with `@Injectable()`. Providers can be injected into controllers, other providers, or modules. The most common provider is a service, which contains business logic and data access code.

---

## 4.2 The Service Layer

The service layer encapsulates business logic and orchestrates data flow between controllers and repositories.

```typescript
@Injectable()
export class UsersService {
  constructor(private readonly userRepository: UserRepository) {}

  async create(dto: CreateUserDto) {
    // Business rules, validation, etc.
    return this.userRepository.create(dto);
  }

  async findAll() {
    return this.userRepository.findAll();
  }
}
```

**Best Practice:** Keep services focused on business logic, not HTTP or database details.

---

## 4.3 Repository Pattern

Repositories abstract data access, making it easy to swap databases or mock for tests. Use `@InjectRepository` with TypeORM or custom repositories for other ORMs.

```typescript
@Injectable()
export class UserRepository {
  constructor(@InjectRepository(User) private repo: Repository<User>) {}

  async create(dto: CreateUserDto) {
    const user = this.repo.create(dto);
    return this.repo.save(user);
  }

  async findAll() {
    return this.repo.find();
  }
}
```

---

## 4.4 Domain-Driven Design (DDD)

For complex applications, consider using DDD principles:
- **Entities:** Represent core business objects (e.g., User)
- **Value Objects:** Immutable objects with no identity (e.g., Email)
- **Aggregates:** Groups of related entities
- **Services:** Business logic that doesn’t fit in entities
- **Repositories:** Data access abstraction

**Diagram: Service & Repository Layers**

```text
Controller → Service → Repository → Database
```

---

## 4.5 Dependency Injection in Services

Services can depend on other services, repositories, or configuration providers. Use constructor injection for clarity and testability.

```typescript
@Injectable()
export class NotificationService {
  constructor(private readonly mailer: MailerService) {}

  async sendWelcome(user: User) {
    await this.mailer.send(user.email, 'Welcome!');
  }
}
```

---

## 4.6 Real-World Example: User Registration

```typescript
@Injectable()
export class AuthService {
  constructor(
    private readonly usersService: UsersService,
    private readonly mailer: MailerService,
  ) {}

  async register(dto: RegisterDto) {
    const user = await this.usersService.create(dto);
    await this.mailer.send(user.email, 'Welcome!');
    return user;
  }
}
```

---

## 4.7 Best Practices

- Keep services stateless when possible
- Use repositories for all data access
- Favor constructor injection
- Write unit tests for services and repositories
- Use interfaces for testability and flexibility

---

## 4.8 Summary

You’ve learned how to structure business logic using providers, services, and repositories. Next, we’ll explore advanced database integration and ORM usage.
    return this.repo.find();
  }
}
```
