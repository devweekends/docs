---


# Chapter 4: Providers & Services

> Providers are the backbone of NestJS’s dependency injection system. They enable you to write modular, testable, and maintainable code. The most common provider is a service, which contains business logic and data access code. Think of providers as the “workers” in your application—they do the heavy lifting behind the scenes.

---

## 4.1 What is a Provider?

In NestJS, a provider is any class annotated with `@Injectable()`. Providers can be injected into controllers, other providers, or modules. They can be services, repositories, factories, or even values.

---


## 4.2 The Service Layer

The service layer encapsulates business logic and orchestrates data flow between controllers and repositories. Services should be focused on business rules, not HTTP or database details.

**Analogy:**
> If your app is a restaurant, the service is the chef, the controller is the waiter, and the repository is the pantry.

```typescript
@Injectable()
export class UsersService {
  constructor(private readonly userRepository: UserRepository) {}

  async create(dto: CreateUserDto) {
    // Business rules, validation, etc.
    return this.userRepository.create(dto);
  }

  async findAll() {
    return this.userRepository.findAll();
  }
}
```

**Best Practice:** Keep services focused on business logic, not HTTP or database details. Services should be stateless when possible.

---


## 4.3 Repository Pattern

Repositories abstract data access, making it easy to swap databases or mock for tests. Use `@InjectRepository` with TypeORM or custom repositories for other ORMs. This pattern keeps your business logic decoupled from the database implementation.

```typescript
@Injectable()
export class UserRepository {
  constructor(@InjectRepository(User) private repo: Repository<User>) {}

  async create(dto: CreateUserDto) {
    const user = this.repo.create(dto);
    return this.repo.save(user);
  }

  async findAll() {
    return this.repo.find();
  }
}
```

**Tip:** Always use repositories for data access. This makes your code easier to test and maintain.

---


## 4.4 Domain-Driven Design (DDD)

For complex applications, consider using DDD principles:
- **Entities:** Represent core business objects (e.g., User)
- **Value Objects:** Immutable objects with no identity (e.g., Email)
- **Aggregates:** Groups of related entities
- **Services:** Business logic that doesn’t fit in entities
- **Repositories:** Data access abstraction

**Diagram: Service & Repository Layers**
```text
Controller → Service → Repository → Database
```

**Tip:** DDD helps you keep your codebase organized as your app grows.

---


## 4.5 Dependency Injection in Services

Services can depend on other services, repositories, or configuration providers. Use constructor injection for clarity and testability. This makes it easy to mock dependencies in tests.

```typescript
@Injectable()
export class NotificationService {
  constructor(private readonly mailer: MailerService) {}

  async sendWelcome(user: User) {
    await this.mailer.send(user.email, 'Welcome!');
  }
}
```

**Tip:** Favor constructor injection over property injection for better testability.

---


## 4.6 Real-World Example: User Registration

Let’s see how services and repositories work together in a real-world scenario:

```typescript
@Injectable()
export class AuthService {
  constructor(
    private readonly usersService: UsersService,
    private readonly mailer: MailerService,
  ) {}

  async register(dto: RegisterDto) {
    const user = await this.usersService.create(dto);
    await this.mailer.send(user.email, 'Welcome!');
    return user;
  }
}
```

**Diagram: Registration Flow**
```text
Controller → AuthService → UsersService → UserRepository → Database
                        ↓
                  MailerService
```

---


## 4.7 Best Practices

- Keep services stateless when possible
- Use repositories for all data access
- Favor constructor injection
- Write unit tests for services and repositories
- Use interfaces for testability and flexibility
- Avoid circular dependencies (use `forwardRef` if needed)
- Separate business logic from data access

---


## 4.8 Summary

You’ve learned how to structure business logic using providers, services, and repositories. With these patterns, your code will be modular, testable, and easy to maintain. Next, we’ll explore advanced database integration and ORM usage.
    return this.repo.find();
  }
}
```
