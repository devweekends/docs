---
title: "Testing"
sidebarTitle: "7. Testing"
icon: "flask"
---



# Chapter 7: Testing

> Testing is essential for building reliable, maintainable applications. This chapter covers unit, integration, and end-to-end (E2E) testing in NestJS, including mocking, CI/CD, and best practices. We’ll walk through practical examples and explain how to build a robust test suite.

---


## 7.1 Why Test?

- Catch bugs early
- Refactor with confidence
- Ensure business logic correctness
- Enable continuous delivery
- Document expected behavior

**Analogy:**
> Think of tests as safety nets for your code—if something breaks, you’ll know right away.

---


## 7.2 Unit Testing

Unit tests verify individual components (services, controllers) in isolation. Use Jest (default with NestJS) for writing tests. Unit tests should be fast and not depend on external systems.

### Example: UsersService
```typescript
import { Test, TestingModule } from '@nestjs/testing';

describe('UsersService', () => {
  let service: UsersService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [UsersService],
    }).compile();

    service = module.get<UsersService>(UsersService);
  });

  it('should find all users', async () => {
    expect(await service.findAll()).toEqual([]);
  });
});
```

**Diagram: Unit Test Flow**
```text
Test → Service (mocked dependencies) → Result
```

---


## 7.3 Mocking Dependencies

Mock dependencies to isolate the unit under test. This lets you test your service logic without hitting a real database or API.

```typescript
const mockRepo = { find: jest.fn().mockReturnValue([]) };

const module = await Test.createTestingModule({
  providers: [
    UsersService,
    { provide: UserRepository, useValue: mockRepo },
  ],
}).compile();
```

**Tip:** Use mocks for unit tests, but real dependencies for integration tests.

---


## 7.4 Integration Testing

Integration tests verify how components work together (e.g., service + database). They are slower than unit tests but catch more real-world issues.

**Tip:** Use an in-memory database (e.g., sqlite) for fast, isolated tests. Clean up data between tests to avoid side effects.

---


## 7.5 End-to-End (E2E) Testing

E2E tests simulate real user scenarios by making HTTP requests to your app. They test the entire stack, from HTTP layer to database.

### Example: AppController
```typescript
import * as request from 'supertest';

describe('AppController (e2e)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const moduleFixture = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200);
  });
});
```

**Diagram: E2E Test Flow**
```text
Test → HTTP Request → App (Controllers → Services → DB) → Response
```

---


## 7.6 CI/CD Integration

Automate tests in your CI pipeline (GitHub Actions, GitLab CI, etc.). This ensures your code is always tested before deployment.

**Example: GitHub Actions Workflow**
```yaml
name: CI
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install dependencies
        run: npm ci
      - name: Run unit tests
        run: npm run test
      - name: Run E2E tests
        run: npm run test:e2e
```

---


## 7.7 Best Practices

- Write tests for all business logic
- Use mocks for unit tests, real dependencies for integration/E2E
- Keep tests fast and isolated
- Use coverage reports to identify gaps (`npm run test:cov`)
- Run tests on every commit and pull request
- Name tests clearly and organize by feature
- Clean up resources after each test (close DB connections, etc.)

---


## 7.8 Summary

You’ve learned how to test NestJS applications at every level. With a strong test suite, you can ship code with confidence. Next, we’ll cover deployment, production, and monitoring strategies.
