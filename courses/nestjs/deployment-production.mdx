title: "Deployment & Production"
sidebarTitle: "9. Deployment"
icon: "rocket"


# Chapter 9: Deployment & Production
# Chapter 9: Deployment & Production

> Deploying and running your NestJS app in production requires careful planning. This chapter covers Dockerization, CI/CD, environment management, health checks, logging, monitoring, scaling, and troubleshooting.

---

## 9.1 Preparing for Production

- Set `NODE_ENV=production`
- Use environment variables for secrets/config
- Enable CORS and security headers
- Build with `npm run build` (TypeScript → JavaScript)

---

## 9.2 Dockerizing Your App

Containerization makes deployment consistent and portable.

```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build
EXPOSE 3000
CMD ["node", "dist/main"]
```

**Best Practices:**
- Use multi-stage builds for smaller images
- Don’t copy dev dependencies to production
- Use `.dockerignore` to exclude unnecessary files

---

## 9.3 Environment Variables

Store secrets and config in `.env` files or environment variables. Use `@nestjs/config` for loading and validating config.

```typescript
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [ConfigModule.forRoot()],
})
export class AppModule {}
```

---

## 9.4 Health Checks

Monitor app and database health with `@nestjs/terminus`.

```typescript
@Get('health')
@HealthCheck()
check() {
  return this.health.check([
    () => this.db.pingCheck('database'),
  ]);
}
```

---

## 9.5 Logging & Monitoring

Use NestJS’s built-in logger or integrate with tools like Winston, Datadog, or Sentry.

```typescript
import { Logger } from '@nestjs/common';

private readonly logger = new Logger(AppService.name);

doSomething() {
  this.logger.log('Doing something...');
}
```

**Best Practices:**
- Log errors and warnings
- Use structured logs (JSON) for cloud platforms
- Monitor logs and metrics in real time

---

## 9.6 CI/CD Pipelines

Automate build, test, and deploy with GitHub Actions, GitLab CI, or similar.

```yaml
steps:
  - run: npm ci
  - run: npm run build
  - run: docker build -t myapp .
  - run: docker push myapp
  - run: kubectl apply -f k8s/deployment.yaml
```

---

## 9.7 Scaling & High Availability

- Use process managers (PM2, Docker, Kubernetes)
- Run multiple instances behind a load balancer
- Use cloud managed databases
- Enable auto-scaling for traffic spikes

---

## 9.8 Troubleshooting & Maintenance

- Monitor CPU, memory, and response times
- Set up alerts for errors and downtime
- Use health checks for automated restarts
- Regularly update dependencies

---

## 9.9 Summary

You’ve learned how to deploy, monitor, and scale NestJS apps for production. Next, we’ll explore microservices and distributed systems with NestJS.
