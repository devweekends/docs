
---
title: "Deployment & Production"
sidebarTitle: "9. Deployment"
icon: "rocket"
---




# Chapter 9: Deployment & Production

> Deploying and running your NestJS app in production requires careful planning. This chapter covers Dockerization, CI/CD, environment management, health checks, logging, monitoring, scaling, and troubleshooting. We’ll walk through practical steps and explain how to make your app production-ready.

---


## 9.1 Preparing for Production

- Set `NODE_ENV=production`
- Use environment variables for secrets/config
- Enable CORS and security headers (e.g., with `@nestjs/platform-express` and `helmet`)
- Build with `npm run build` (TypeScript → JavaScript)
- Remove unused dependencies and dev tools
- Test your app in a staging environment before going live

---


## 9.2 Dockerizing Your App

Containerization makes deployment consistent and portable. Docker lets you package your app and its dependencies into a single image.

```dockerfile
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app .
RUN npm ci --only=production
EXPOSE 3000
CMD ["node", "dist/main"]
```

**Best Practices:**
- Use multi-stage builds for smaller images
- Keep images minimal (alpine base, no dev dependencies)
- Use `.dockerignore` to exclude unnecessary files
- Don’t copy dev dependencies to production
- Use `.dockerignore` to exclude unnecessary files

---


## 9.3 Environment Variables

Store secrets and config in `.env` files or environment variables. Use `@nestjs/config` for loading and validating config. Never commit secrets to version control.

```typescript
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [ConfigModule.forRoot({ isGlobal: true })],
})
export class AppModule {}
```

**Tip:** Use schema validation (e.g., with `joi`) to ensure required env vars are set.

---


## 9.4 Health Checks

Monitor app and database health with `@nestjs/terminus`. Health checks help load balancers and orchestrators know if your app is healthy.

```typescript
@Get('health')
@HealthCheck()
check() {
  return this.health.check([
    () => this.db.pingCheck('database'),
  ]);
}
```

**Diagram: Health Check Flow**
```text
Load Balancer → /health → App → DB
```

---

doSomething() {

## 9.5 Logging & Monitoring

Use NestJS’s built-in logger or integrate with tools like Winston, Datadog, or Sentry. Logging helps you debug and monitor your app in production.

```typescript
import { Logger } from '@nestjs/common';

private readonly logger = new Logger(AppService.name);

doSomething() {
  this.logger.log('Doing something...');
}
```

**Best Practices:**
- Log errors and warnings
- Use structured logs (JSON) for cloud platforms
- Monitor logs and metrics in real time
- Set up alerts for critical errors

---


## 9.6 CI/CD Pipelines

Automate build, test, and deploy with GitHub Actions, GitLab CI, or similar. This ensures your app is always tested and deployed the same way.

**Example: GitHub Actions Workflow**
```yaml
name: Deploy
on: [push]
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: npm run build
      - run: docker build -t myapp .
      - run: docker push myapp
      - run: kubectl apply -f k8s/deployment.yaml
```

---


## 9.7 Scaling & High Availability

- Use process managers (PM2, Docker, Kubernetes)
- Run multiple instances behind a load balancer (NGINX, AWS ELB, etc.)
- Use cloud managed databases (AWS RDS, Azure SQL, etc.)
- Enable auto-scaling for traffic spikes
- Use CDN for static assets

---


## 9.8 Troubleshooting & Maintenance

- Monitor CPU, memory, and response times
- Set up alerts for errors and downtime
- Use health checks for automated restarts
- Regularly update dependencies
- Test backups and disaster recovery plans

---


## 9.9 Summary

You’ve learned how to deploy, monitor, and scale NestJS apps for production. With these practices, your app will be ready for real-world traffic and failures. Next, we’ll explore microservices and distributed systems with NestJS.
