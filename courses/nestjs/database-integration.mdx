---
title: "Database Integration"
sidebarTitle: "5. Database"
icon: "database"
---


# Chapter 5: Database Integration

> Integrating a database is a core part of any backend application. NestJS supports multiple ORMs, with **TypeORM** and **Prisma** being the most popular. This chapter covers setup, modeling, querying, transactions, migrations, and best practices for both.

---


## 5.1 Setting Up the Database


### TypeORM Setup

```typescript
TypeOrmModule.forRoot({
  type: 'postgres',
  host: 'localhost',
  port: 5432,
  username: 'postgres',
  password: 'password',
  database: 'mydb',
  entities: [User],
  synchronize: true, // Don't use in production
})
```

**Install:**
```bash
npm install @nestjs/typeorm typeorm pg
```

### Prisma Setup

```bash
npm install @prisma/client prisma
npx prisma init
```

`prisma/schema.prisma` example:
```prisma
generator client {
  provider = "prisma-client-js"
}


  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id    Int     @id @default(autoincrement())
  name  String
  posts Post[]
}

model Post {
  id      Int    @id @default(autoincrement())
  title   String
  author  User?  @relation(fields: [authorId], references: [id])
  authorId Int?
}
```

**Generate client:**
```bash
npx prisma generate
```

---


---

## 5.2 Defining Models and Entities

### TypeORM Entity Example
```typescript
@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @OneToMany(() => Post, post => post.author)
  posts: Post[];
}
```

### Prisma Model Example
```prisma
model User {
  id    Int     @id @default(autoincrement())
  name  String
  posts Post[]
}
```


---


---

## 5.3 Service Layer Usage

### TypeORM Service Example
```typescript
@Injectable()
export class UserService {
  constructor(@InjectRepository(User) private repo: Repository<User>) {}

  async createUser(name: string) {
    const user = this.repo.create({ name });
    return this.repo.save(user);
  }

  async getUsers() {
    return this.repo.find({ relations: ['posts'] });
  }
}
```

### Prisma Service Example
```typescript
@Injectable()
export class UserService {
  constructor(private prisma: PrismaService) {}

  async createUser(name: string) {
    return this.prisma.user.create({ data: { name } });
  }

  async getUsers() {
    return this.prisma.user.findMany({ include: { posts: true } });
  }
}
```


---


---

## 5.4 Transactions

### TypeORM Transaction Example
```typescript
await this.dataSource.transaction(async manager => {
  await manager.save(user);
  await manager.save(profile);
});
```

### Prisma Transaction Example
```typescript
await this.prisma.$transaction([
  this.prisma.user.create({ data: { ... } }),
  this.prisma.profile.create({ data: { ... } })
]);
```


---

---

## 5.5 Migrations

**TypeORM:**
- Use CLI to generate and run migrations:
```bash
npx typeorm migration:generate -n CreateUsers
npx typeorm migration:run
```
- Never use `synchronize: true` in production.

**Prisma:**
- Use CLI to create and apply migrations:
```bash
npx prisma migrate dev --name init
```
- Always regenerate the client after schema changes:
```bash
npx prisma generate
```

---

## 5.6 Best Practices & Notes

- Use environment variables for database credentials
- Keep entities/models in a dedicated folder (e.g., `src/entities` or `prisma/schema.prisma`)
- Use migrations for all schema changes
- Write integration tests for your data layer
- Both TypeORM and Prisma support PostgreSQL, MySQL, SQLite, and more
- Choose ORM based on your team's experience, project needs, and ecosystem support

---

## 5.7 Summary

You’ve learned how to integrate databases with NestJS using TypeORM and Prisma, including setup, modeling, querying, transactions, and best practices. Next, we’ll explore authentication, authorization, and security in depth.
