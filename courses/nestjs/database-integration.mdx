---
title: "Database Integration"
sidebarTitle: "5. Database"
icon: "database"
---



# Chapter 5: Database Integration

> Integrating a database is a core part of any backend application. NestJS supports multiple ORMs, with **TypeORM** and **Prisma** being the most popular. This chapter covers setup, modeling, querying, transactions, migrations, and best practices for both. We’ll walk through the process step by step, so you can confidently connect your app to a database.

---



## 5.1 Setting Up the Database

NestJS can work with many databases (PostgreSQL, MySQL, SQLite, etc.) using ORMs. The two most popular are TypeORM and Prisma. Here’s how to get started with each:

### TypeORM Setup (Step-by-Step)
1. **Install dependencies:**
   ```bash
   npm install @nestjs/typeorm typeorm pg
   ```
2. **Configure TypeORM in your module:**
   ```typescript
   TypeOrmModule.forRoot({
     type: 'postgres',
     host: 'localhost',
     port: 5432,
     username: 'postgres',
     password: 'password',
     database: 'mydb',
     entities: [User],
     synchronize: true, // Don't use in production
   })
   ```
3. **Create your entities (see below).**

**Diagram: TypeORM Integration**
```text
AppModule → TypeOrmModule → Entity → Database
```

### Prisma Setup (Step-by-Step)
1. **Install dependencies:**
   ```bash
   npm install @prisma/client prisma
   npx prisma init
   ```
2. **Edit `prisma/schema.prisma`:**
   ```prisma
   generator client {
     provider = "prisma-client-js"
   }

   datasource db {
     provider = "postgresql"
     url      = env("DATABASE_URL")
   }

   model User {
     id    Int     @id @default(autoincrement())
     name  String
     posts Post[]
   }

   model Post {
     id      Int    @id @default(autoincrement())
     title   String
     author  User?  @relation(fields: [authorId], references: [id])
     authorId Int?
   }
   ```
3. **Generate the client:**
   ```bash
   npx prisma generate
   ```

**Diagram: Prisma Integration**
```text
AppModule → PrismaService → Prisma Client → Database
```

---


---


## 5.2 Defining Models and Entities

Entities (TypeORM) and models (Prisma) define your database structure in code.

### TypeORM Entity Example
```typescript
@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @OneToMany(() => Post, post => post.author)
  posts: Post[];
}
```

### Prisma Model Example
```prisma
model User {
  id    Int     @id @default(autoincrement())
  name  String
  posts Post[]
}
```

**Tip:** Keep your entity/model files organized in a dedicated folder (e.g., `src/entities` or `prisma/schema.prisma`).


---


---


## 5.3 Service Layer Usage

Services connect your business logic to the database. Here’s how you’d use each ORM in a service:

### TypeORM Service Example
```typescript
@Injectable()
export class UserService {
  constructor(@InjectRepository(User) private repo: Repository<User>) {}

  async createUser(name: string) {
    const user = this.repo.create({ name });
    return this.repo.save(user);
  }

  async getUsers() {
    return this.repo.find({ relations: ['posts'] });
  }
}
```

### Prisma Service Example
```typescript
@Injectable()
export class UserService {
  constructor(private prisma: PrismaService) {}

  async createUser(name: string) {
    return this.prisma.user.create({ data: { name } });
  }

  async getUsers() {
    return this.prisma.user.findMany({ include: { posts: true } });
  }
}
```

**Tip:** Always keep business logic in services, not controllers.


---


---


## 5.4 Transactions

Transactions let you perform multiple database operations safely—either all succeed, or all fail.

### TypeORM Transaction Example
```typescript
await this.dataSource.transaction(async manager => {
  await manager.save(user);
  await manager.save(profile);
});
```

### Prisma Transaction Example
```typescript
await this.prisma.$transaction([
  this.prisma.user.create({ data: { ... } }),
  this.prisma.profile.create({ data: { ... } })
]);
```

**Tip:** Use transactions for multi-step operations (e.g., user registration + profile creation).


---

---


## 5.5 Migrations

Migrations keep your database schema in sync with your code.

**TypeORM:**
- Use CLI to generate and run migrations:
  ```bash
  npx typeorm migration:generate -n CreateUsers
  npx typeorm migration:run
  ```
- Never use `synchronize: true` in production (it can cause data loss).

**Prisma:**
- Use CLI to create and apply migrations:
  ```bash
  npx prisma migrate dev --name init
  ```
- Always regenerate the client after schema changes:
  ```bash
  npx prisma generate
  ```

**Tip:** Commit your migration files to version control.

---


## 5.6 Best Practices & Notes

- Use environment variables for database credentials (never hard-code secrets)
- Keep entities/models in a dedicated folder (e.g., `src/entities` or `prisma/schema.prisma`)
- Use migrations for all schema changes (never edit the DB manually)
- Write integration tests for your data layer
- Both TypeORM and Prisma support PostgreSQL, MySQL, SQLite, and more
- Choose ORM based on your team's experience, project needs, and ecosystem support
- Use connection pooling in production for performance
- Monitor query performance and optimize indexes

---


## 5.7 Summary

You’ve learned how to integrate databases with NestJS using TypeORM and Prisma, including setup, modeling, querying, transactions, and best practices. With these tools, you can build robust, data-driven applications. Next, we’ll explore authentication, authorization, and security in depth.
