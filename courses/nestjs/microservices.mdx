---
title: "Microservices"
sidebarTitle: "8. Microservices"
icon: "cubes"
---


# Chapter 8: Microservices

> Microservices architecture enables you to build scalable, distributed systems. NestJS provides first-class support for microservices, message brokers, and event-driven design. This chapter covers TCP, Redis, RabbitMQ, message patterns, and distributed tracing.

---

## 8.1 What is a Microservice?

A microservice is a small, independent process that communicates with others over a network. Each service is responsible for a specific business capability and can be deployed, scaled, and updated independently.

**Benefits:**
- Scalability
- Fault isolation
- Technology diversity
- Independent deployment

---

## 8.2 Microservices in NestJS

NestJS supports multiple transport layers:
- TCP (default)
- Redis
- NATS
- RabbitMQ
- MQTT
- gRPC

---

## 8.3 Creating a TCP Microservice

```typescript
const app = await NestFactory.createMicroservice(AppModule, {
  transport: Transport.TCP,
  options: { port: 3001 },
});
await app.listen();
```

---

## 8.4 Message Patterns

Message patterns define how microservices communicate. Use `@MessagePattern` to handle specific messages.

```typescript
@MessagePattern({ cmd: 'sum' })
accumulate(data: number[]): number {
  return data.reduce((a, b) => a + b, 0);
}
```

---

## 8.5 Using RabbitMQ

RabbitMQ is a popular message broker for event-driven systems.

```typescript
const app = await NestFactory.createMicroservice(AppModule, {
  transport: Transport.RMQ,
  options: {
    urls: ['amqp://localhost:5672'],
    queue: 'orders_queue',
    queueOptions: { durable: false },
  },
});
await app.listen();
```

---

## 8.6 Event-Driven Design

- Use events to decouple services
- Publish/subscribe patterns for scalability
- Handle failures with retries and dead-letter queues

---

## 8.7 Distributed Tracing & Monitoring

- Use tools like Jaeger, Zipkin, or OpenTelemetry
- Correlate requests across services
- Monitor latency, errors, and throughput

---

## 8.8 Best Practices

- Keep services small and focused
- Use message brokers for communication
- Handle errors and retries gracefully
- Secure communication between services
- Automate deployment and scaling

---

## 8.9 Summary

You’ve learned how to build and scale microservices with NestJS, using TCP, RabbitMQ, and event-driven patterns. Next, we’ll explore advanced patterns like CQRS, GraphQL, and WebSockets.
