---
title: "Authentication & Authorization"
sidebarTitle: "6. Auth"
icon: "lock"
---



# Chapter 6: Authentication & Authorization

> Securing your application is critical. This chapter covers authentication (verifying identity), authorization (controlling access), JWT, OAuth, RBAC, guards, and best practices for building secure APIs in NestJS. We’ll walk through practical examples and explain the “why” behind each step.

---


## 6.1 Authentication vs Authorization

- **Authentication:** Who are you? (Login, identity verification)
- **Authorization:** What are you allowed to do? (Permissions, roles)

**Analogy:**
> Think of authentication as showing your ID at the door, and authorization as checking if you’re allowed into the VIP section.

---


## 6.2 JWT Authentication

JSON Web Tokens (JWT) are a popular way to implement stateless authentication in APIs. JWTs are signed tokens that clients send with each request to prove their identity.

**How JWT Auth Works:**
1. User logs in with credentials.
2. Server validates credentials and returns a signed JWT.
3. Client stores the JWT (usually in localStorage or cookies).
4. Client sends JWT in the `Authorization` header for future requests.
5. Server verifies the JWT and grants access.

### AuthService Example
```typescript
@Injectable()
export class AuthService {
  constructor(private jwtService: JwtService) {}

  async validateUser(email: string, pass: string): Promise<any> {
    // Validate user credentials (e.g., check DB)
    // Return user object if valid, null otherwise
  }

  async login(user: any) {
    const payload = { email: user.email, sub: user.id };
    return {
      access_token: this.jwtService.sign(payload),
    };
  }
}
```

**Diagram: JWT Flow**
```text
Client → [Login] → Server → [JWT] → Client → [Request w/ JWT] → Server (verifies)
```


### Auth Guard Example
```typescript
@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}

@UseGuards(JwtAuthGuard)
@Get('profile')
getProfile(@Request() req) {
  return req.user;
}
```

**Tip:** Use guards to protect routes and ensure only authenticated users can access them.

---


## 6.3 Authorization: Roles & Permissions

Role-Based Access Control (RBAC) restricts access based on user roles. This lets you control who can do what in your app.

### Roles Decorator & Guard
```typescript
import { SetMetadata, UseGuards } from '@nestjs/common';

export const Roles = (...roles: string[]) => SetMetadata('roles', roles);

@Injectable()
export class RolesGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    const roles = this.reflector.get<string[]>('roles', context.getHandler());
    return roles ? roles.includes(user.role) : true;
  }
}

@Roles('admin')
@UseGuards(RolesGuard)
@Delete(':id')
delete(@Param('id') id: string) {
  return this.service.delete(id);
}
```

**Tip:** Use roles and permissions to enforce business rules and protect sensitive actions.

---


## 6.4 OAuth2 & Social Login

NestJS supports OAuth2 via Passport strategies. This lets users log in with Google, Facebook, GitHub, etc.

**Example: Google Login**
```typescript
@UseGuards(AuthGuard('google'))
@Get('auth/google')
async googleAuth(@Req() req) {}

@UseGuards(AuthGuard('google'))
@Get('auth/google/callback')
googleAuthRedirect(@Req() req) {
  return req.user;
}
```

**Tip:** Always validate and sanitize data from third-party providers.

---


## 6.5 Multi-Factor Authentication (MFA)

Enhance security by requiring a second factor (e.g., OTP, email code) after password login. Implement as a separate guard or service. MFA is highly recommended for sensitive applications.

---


## 6.6 Security Best Practices

- Always hash passwords (e.g., bcrypt)
- Use HTTPS in production
- Store secrets in environment variables
- Set secure HTTP headers (e.g., helmet)
- Limit login attempts to prevent brute force
- Validate and sanitize all input
- Keep dependencies up to date
- Use CORS to restrict allowed origins
- Log authentication events for auditing

---


## 6.7 Real-World Example: Auth Module Structure

Here’s a typical folder structure for a robust authentication module:
```text
auth/
  auth.module.ts
  auth.service.ts
  auth.controller.ts
  jwt.strategy.ts
  local.strategy.ts
  guards/
    jwt-auth.guard.ts
    roles.guard.ts
  dto/
    login.dto.ts
    register.dto.ts
```

---


## 6.8 Summary

You’ve learned how to secure your NestJS APIs with authentication, authorization, JWT, OAuth, and best practices. With these tools, you can protect your app and your users. Next, we’ll cover testing strategies for robust applications.
