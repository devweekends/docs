---
title: "NestJS Fundamentals"
sidebarTitle: "1. Fundamentals"
icon: "book"
---



# Chapter 1: NestJS Fundamentals

> **NestJS** is a progressive Node.js framework for building efficient, reliable, and scalable server-side applications. Think of it as the "Angular for the backend"—it brings structure, modularity, and best practices to Node.js development, making it ideal for both startups and enterprises.

---

## 1.1 Introduction to NestJS

NestJS provides a robust foundation for building enterprise-grade applications. It leverages TypeScript by default, supports modular architecture, and encourages best practices such as dependency injection, testability, and separation of concerns.

**Why NestJS?**
- **TypeScript-first:** Enjoy type safety and modern JavaScript features out of the box.
- **Modular and testable:** Organize your code into logical modules, making it easy to scale and maintain.
- **Dependency Injection (DI):** Write loosely coupled, easily testable code.
- **Versatile:** Build REST APIs, GraphQL endpoints, WebSockets, and microservices—all with the same framework.
- **Ecosystem:** Integrates with popular ORMs (TypeORM, Prisma, Sequelize), validation libraries, and more.
- **Familiarity:** Inspired by Angular, so frontend devs will feel at home.

**Analogy:**
> Imagine building with Lego blocks—each block (module, controller, service) has a clear purpose and fits together to create a robust structure. NestJS gives you the blueprint and the blocks.

---

## 1.2 Setting Up Your Environment

Before you begin, ensure you have Node.js (v16+) and npm installed. You can check your versions with:

```bash
node -v
npm -v
```

Install the NestJS CLI globally:

```bash
npm install -g @nestjs/cli
```

### Creating Your First Project (Hello World)

Let’s create a simple NestJS app:

```bash
nest new hello-nest
cd hello-nest
npm run start:dev
```

Open [http://localhost:3000](http://localhost:3000) in your browser. You should see: `Hello World!`

**Project Structure Overview:**

```text
hello-nest/
├── src/
│   ├── app.controller.ts
│   ├── app.module.ts
│   ├── app.service.ts
│   └── main.ts
├── test/
├── package.json
├── tsconfig.json
└── ...
```

**What do these files do?**
- `main.ts`: Entry point, bootstraps the app.
- `app.module.ts`: Root module, organizes the app.
- `app.controller.ts`: Handles incoming requests.
- `app.service.ts`: Contains business logic.

---

Create a new project:

```bash
nest new my-nestjs-app
```

The CLI will prompt you to choose a package manager. After setup, your project structure will look like:

```text
my-nestjs-app/
├── src/
│   ├── app.controller.ts
│   ├── app.module.ts
│   ├── app.service.ts
│   └── main.ts
├── test/
├── package.json
├── tsconfig.json
└── ...
```

---


## 1.3 Understanding the Core Concepts

NestJS is built around a few core building blocks. Let’s break them down with analogies and examples:

### 1.3.1 Modules
**Modules** are like folders in your computer—they organize related files (controllers, services) together. Every app has at least one root module (`AppModule`).

```typescript
@Module({
  controllers: [UsersController],
  providers: [UsersService],
})
export class UsersModule {}
```

**Best Practice:** Keep modules focused and cohesive. Use feature modules to separate domains (e.g., UsersModule, AuthModule).

### 1.3.2 Controllers
**Controllers** are like receptionists—they receive requests, ask the right service for help, and send back a response. They define routes and delegate business logic to services.

```typescript
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get()
  findAll() {
    return this.usersService.findAll();
  }
}
```

**Tip:** Controllers should be thin—move business logic to services.

### 1.3.3 Providers & Services
**Providers** are classes that can be injected as dependencies. **Services** are a common type of provider, used for business logic, data access, etc.

```typescript
@Injectable()
export class UsersService {
  private users = [{ id: 1, name: 'Alice' }];

  findAll() {
    return this.users;
  }
}
```

**Diagram: NestJS Request Flow**

```text
Client → Controller → Service → (Repository/Database)
```

**Analogy:**
> Think of a restaurant: the client is the customer, the controller is the waiter, the service is the chef, and the repository/database is the pantry.

---


## 1.4 Application Lifecycle

NestJS applications are initialized via the `main.ts` file. This is the entry point that bootstraps the root module and starts the HTTP server.

```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
bootstrap();
```

**Lifecycle Steps:**
1. The app starts (`main.ts`).
2. The root module (`AppModule`) is loaded.
3. Controllers and providers are registered.
4. The server listens for requests.

**Diagram:**
```text
main.ts → AppModule → Controllers/Providers → HTTP Server
```

---


## 1.5 Real-World Example: Building a User API

Let’s build a simple REST API for managing users. This example will show you how the pieces fit together in a real project.

### Step 1: Generate Resources

```bash
nest generate module users
nest generate controller users
nest generate service users
```

### Step 2: Implement the Service

```typescript
// users.service.ts
@Injectable()
export class UsersService {
  private users = [
    { id: 1, name: 'Alice' },
    { id: 2, name: 'Bob' },
  ];

  findAll() {
    return this.users;
  }

  findOne(id: number) {
    return this.users.find(u => u.id === id);
  }

  create(name: string) {
    const id = this.users.length + 1;
    const user = { id, name };
    this.users.push(user);
    return user;
  }
}
```

### Step 3: Implement the Controller

```typescript
// users.controller.ts
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get()
  findAll() {
    return this.usersService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.usersService.findOne(Number(id));
  }

  @Post()
  create(@Body('name') name: string) {
    return this.usersService.create(name);
  }
}
```

**Try it out:**
- `GET /users` returns all users
- `GET /users/1` returns user with id 1
- `POST /users` with `{ "name": "Charlie" }` adds a new user

---


## 1.6 Best Practices & Tips

- Use DTOs (Data Transfer Objects) and validation for request bodies (see `class-validator` and `class-transformer`)
- Keep controllers thin, services fat (business logic in services)
- Organize code by feature modules (e.g., UsersModule, AuthModule)
- Write unit and integration tests early (see the Testing chapter)
- Use environment variables for configuration (with `@nestjs/config`)
- Leverage the CLI for productivity (generate modules, controllers, services)
- Document your API (Swagger integration is easy with `@nestjs/swagger`)
- Handle errors gracefully (use built-in exception filters)

---


## 1.7 Summary

You’ve learned the foundational concepts of NestJS: modules, controllers, services, and the application lifecycle. With these building blocks, you can start building scalable, maintainable Node.js applications. In the next chapters, we’ll dive deeper into dependency injection, advanced routing, and building robust, production-ready APIs.

**Next:** Learn how Dependency Injection powers modular, testable code in NestJS.
