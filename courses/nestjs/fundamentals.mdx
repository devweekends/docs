---
title: "NestJS Fundamentals"
sidebarTitle: "1. Fundamentals"
icon: "book"
---


# Chapter 1: NestJS Fundamentals

> **NestJS** is a progressive Node.js framework for building efficient, reliable, and scalable server-side applications. It combines the best of OOP, FP, and FRP, and is heavily inspired by Angular’s architecture, making it approachable for developers familiar with modern frontend frameworks.

---

## 1.1 Introduction to NestJS

NestJS provides a robust foundation for building enterprise-grade applications. It leverages TypeScript by default, supports modular architecture, and encourages best practices such as dependency injection, testability, and separation of concerns.

**Key Features:**
- TypeScript-first (but supports JavaScript)
- Modular and testable architecture
- Dependency Injection (DI) system
- Built-in support for REST, GraphQL, WebSockets, and Microservices
- Integration with popular ORMs (TypeORM, Prisma, Sequelize)
- Powerful CLI for scaffolding and productivity

---

## 1.2 Setting Up Your Environment

Before you begin, ensure you have Node.js (v16+) and npm installed. You can check your versions with:

```bash
node -v
npm -v
```

Install the NestJS CLI globally:

```bash
npm install -g @nestjs/cli
```

Create a new project:

```bash
nest new my-nestjs-app
```

The CLI will prompt you to choose a package manager. After setup, your project structure will look like:

```text
my-nestjs-app/
├── src/
│   ├── app.controller.ts
│   ├── app.module.ts
│   ├── app.service.ts
│   └── main.ts
├── test/
├── package.json
├── tsconfig.json
└── ...
```

---

## 1.3 Understanding the Core Concepts

NestJS is built around a few core building blocks:

### 1.3.1 Modules
Modules are the organizational unit of NestJS. Every application has at least one root module (`AppModule`). Modules group related controllers and providers (services).

```typescript
@Module({
  controllers: [UsersController],
  providers: [UsersService],
})
export class UsersModule {}
```

**Best Practice:** Keep modules focused and cohesive. Use feature modules to separate domains (e.g., UsersModule, AuthModule).

### 1.3.2 Controllers
Controllers handle incoming HTTP requests and return responses. They define routes and delegate business logic to services.

```typescript
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get()
  findAll() {
    return this.usersService.findAll();
  }
}
```

**Tip:** Controllers should be thin—move business logic to services.

### 1.3.3 Providers & Services
Providers are classes that can be injected as dependencies. Services are a common type of provider, used for business logic, data access, etc.

```typescript
@Injectable()
export class UsersService {
  private users = [{ id: 1, name: 'Alice' }];

  findAll() {
    return this.users;
  }
}
```

**Diagram: NestJS Request Flow**

```text
Client → Controller → Service → (Repository/Database)
```

---

## 1.4 Application Lifecycle

NestJS applications are initialized via the `main.ts` file. The entry point bootstraps the root module:

```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
bootstrap();
```

---

## 1.5 Real-World Example: Building a User API

Let’s build a simple REST API for managing users.

### Step 1: Generate Resources

```bash
nest generate module users
nest generate controller users
nest generate service users
```

### Step 2: Implement the Service

```typescript
// users.service.ts
@Injectable()
export class UsersService {
  private users = [
    { id: 1, name: 'Alice' },
    { id: 2, name: 'Bob' },
  ];

  findAll() {
    return this.users;
  }

  findOne(id: number) {
    return this.users.find(u => u.id === id);
  }
}
```

### Step 3: Implement the Controller

```typescript
// users.controller.ts
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get()
  findAll() {
    return this.usersService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.usersService.findOne(Number(id));
  }
}
```

---

## 1.6 Best Practices & Tips

- Use DTOs (Data Transfer Objects) and validation for request bodies
- Keep controllers thin, services fat
- Organize code by feature modules
- Write unit and integration tests early
- Use environment variables for configuration
- Leverage the CLI for productivity

---

## 1.7 Summary

You’ve learned the foundational concepts of NestJS: modules, controllers, services, and the application lifecycle. In the next chapters, we’ll dive deeper into dependency injection, advanced routing, and building robust, production-ready APIs.
