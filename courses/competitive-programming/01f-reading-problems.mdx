---
title: "The Art of Reading Problems"
sidebarTitle: "1f. Reading Problems"
description: "Transform cryptic problem statements into crystal-clear solutions through systematic reading and visualization"
icon: "glasses"
---

# The Art of Reading Problems

## Why Most People Fail Before They Start

**The problem isn't your algorithm knowledge. It's how you read.**

Most competitive programmers rush through problem statements, miss critical details, and waste 20+ minutes debugging something that was never the right approach.

<Note>
**The best CP players spend 40% of their time understanding the problem and 60% coding. Beginners do the opposite—and that's why they fail.**
</Note>

---

## The 5-Layer Reading System

<img src="/images/courses/cp/reading-layers.svg" alt="5-Layer Reading System" />

### Layer 1: The 30-Second Scan

Before reading anything in detail, scan for:

```
┌─────────────────────────────────────────────────────┐
│                30-SECOND SCAN                       │
├─────────────────────────────────────────────────────┤
│  1. Constraints (n, m values)                       │
│  2. Time limit (1s, 2s, 3s?)                        │
│  3. Number of test cases (T)                        │
│  4. Output format (YES/NO, number, array?)          │
│  5. Problem rating (if visible)                     │
└─────────────────────────────────────────────────────┘
```

**Why this matters:**

| Constraint | Maximum Complexity | Likely Approach |
|-----------|-------------------|-----------------|
| n ≤ 10 | O(n!) | Brute force, all permutations |
| n ≤ 20 | O(2ⁿ) | Bitmask DP, meet in middle |
| n ≤ 100 | O(n³) | Floyd-Warshall, triple loop |
| n ≤ 1,000 | O(n²) | DP, nested loops |
| n ≤ 100,000 | O(n log n) | Sorting, binary search, segment tree |
| n ≤ 1,000,000 | O(n) | Linear scan, two pointers, prefix sum |
| n ≤ 10⁸ | O(log n) or O(1) | Math formula, binary search |

---

### Layer 2: Story Extraction

CF problems often have elaborate stories. Learn to extract the **core problem** from the narrative.

<img src="/images/courses/cp/story-extraction.svg" alt="Story Extraction Process" />

**Example:**

> "Princess Twilight has a magic garden with n flowers arranged in a row. Each flower has a beauty value. The evil Discord wants to steal flowers, but he can only take consecutive flowers. Princess Twilight will be sad if Discord takes flowers with total beauty more than k. Find the maximum number of consecutive flowers Discord can take without making Twilight too sad."

**Translation:**
- Array of n integers (beauty values)
- Find longest subarray with sum ≤ k
- **Pattern: Sliding Window / Two Pointers**

### The Translation Table

| Story Element | Technical Translation |
|--------------|----------------------|
| "Choose k items" | Subset selection |
| "Arrange in order" | Permutation |
| "Consecutive elements" | Subarray / Sliding window |
| "Reach from A to B" | Graph path / BFS |
| "Minimum operations" | BFS / Greedy / DP |
| "Count ways" | DP / Combinatorics |
| "Is it possible" | Yes/No → Often greedy or graph |
| "Maximum/Minimum" | DP / Greedy / Binary search |
| "For all pairs" | Often O(n²) or clever O(n) |

---

### Layer 3: Constraint Implications

Constraints tell you the algorithm before you even understand the problem.

<img src="/images/courses/cp/constraint-analysis.svg" alt="Constraint Analysis Flowchart" />

**Read constraints as a programming hint:**

```cpp
// n ≤ 20 → Think bitmask
for (int mask = 0; mask < (1 << n); mask++) {
    // Process subset
}

// n ≤ 10^5, queries ≤ 10^5 → Think segment tree or prefix sum
// sum of all n ≤ 10^5 → Each test case can be O(n)
// 1 ≤ a[i] ≤ 10^9 → Coordinate compression might help
// n is even → Parity trick possible
// |a[i]| ≤ 10^6 → Can use array instead of map
```

---

### Layer 4: Example Tracing

**Never skip the examples. Trace them by hand.**

<Steps>
  <Step title="Read Input Format">
    Understand what each line/number represents.
  </Step>
  <Step title="Trace Example 1 Manually">
    Work through it step by step, writing on paper.
  </Step>
  <Step title="Verify Against Output">
    Does your manual trace match the expected output?
  </Step>
  <Step title="Read the Note Section">
    This often explains the solution approach!
  </Step>
  <Step title="Create Your Own Test">
    Make a simpler example to verify understanding.
  </Step>
</Steps>

<img src="/images/courses/cp/example-tracing.svg" alt="Example Tracing Process" />

---

### Layer 5: Edge Case Hunting

Before coding, think about edge cases:

```
┌─────────────────────────────────────────────────────┐
│              EDGE CASE CHECKLIST                    │
├─────────────────────────────────────────────────────┤
│  □ n = 1 (single element)                           │
│  □ n = 2 (minimum for "pair" problems)              │
│  □ All elements are the same                        │
│  □ All elements are different                       │
│  □ Already sorted (ascending)                       │
│  □ Reverse sorted (descending)                      │
│  □ Maximum constraint values                        │
│  □ Minimum values (0, 1, -1)                        │
│  □ Empty input (if allowed)                         │
│  □ Answer is 0 or -1                                │
└─────────────────────────────────────────────────────┘
```

---

## Visualization Techniques

### Technique 1: Draw the Data Structure

<img src="/images/courses/cp/draw-data-structure.svg" alt="Drawing Data Structures" />

For every problem, draw what you're working with:
- **Array?** Draw boxes with indices
- **Graph?** Draw nodes and edges
- **Tree?** Draw the hierarchy
- **Grid?** Draw the 2D layout
- **String?** Write it out with indices

### Technique 2: Trace State Changes

For problems involving operations or transitions:

<img src="/images/courses/cp/state-transitions.svg" alt="State Transitions" />

```
Initial: [3, 1, 4, 1, 5]
After op 1: [3, 4, 1, 5] (removed index 1)
After op 2: [4, 1, 5] (removed index 0)
...
```

### Technique 3: The Two-Example Method

If you don't understand the problem:
1. Create the **simplest possible** valid input
2. Create a **slightly more complex** input
3. Solve both by hand
4. Look for patterns in your solutions

---

## Mental Models for Common Patterns

### "Choosing Subset" Problems

<img src="/images/courses/cp/subset-mental-model.svg" alt="Subset Mental Model" />

When you see "choose k elements" or "select some elements":
- Can each element be taken independently? → **Greedy**
- Does order matter? → **Permutation**
- Does taking one affect others? → **DP**

### "Range Query" Problems

<img src="/images/courses/cp/range-query-mental-model.svg" alt="Range Query Mental Model" />

When you see "from index l to r":
- Static array, sum/min/max query? → **Prefix Sum / Sparse Table**
- Array with updates? → **Segment Tree / Fenwick Tree**
- Counting in range? → **Merge Sort Tree / Wavelet Tree**

### "Shortest Path" Problems

<img src="/images/courses/cp/shortest-path-mental-model.svg" alt="Shortest Path Mental Model" />

When you see "minimum steps/moves/cost":
- All edges weight 1? → **BFS**
- Edges have weights? → **Dijkstra**
- Negative weights? → **Bellman-Ford**
- All pairs? → **Floyd-Warshall**

---

## The "What If" Framework

When stuck, ask "What If" questions:

```
What if n was only 10?
  → What brute force would work?
  
What if I sorted the array?
  → Would that make the problem easier?
  
What if I processed elements in a different order?
  → Largest first? Smallest first?
  
What if I thought about this from the answer's perspective?
  → Binary search on answer?
  
What if I reversed the problem?
  → Instead of building up, what if I broke down?
```

---

## Common Reading Mistakes

<Warning>
**Mistake 1: Skipping the Note Section**

The Note section in CF problems often contains the solution approach. Always read it.
</Warning>

<Warning>
**Mistake 2: Assuming Based on Problem Title**

"Binary Search" might not be a binary search problem. Read the actual constraints.
</Warning>

<Warning>
**Mistake 3: Not Verifying Examples**

If your understanding doesn't match Example 1, you don't understand the problem. Stop and re-read.
</Warning>

<Warning>
**Mistake 4: Ignoring "It is guaranteed..."**

These guarantees simplify the problem. "It is guaranteed a solution exists" means no impossible case.
</Warning>

<Warning>
**Mistake 5: Misreading 0-indexed vs 1-indexed**

CF uses 1-indexed. Your code probably uses 0-indexed. Mind the gap.
</Warning>

---

## Practice Exercise: Read Like a Pro

Try reading these problem descriptions and identify:
1. What is the core problem?
2. What pattern does it match?
3. What's the likely complexity?

**Problem A:**
> Given an array of n integers, find the minimum number of operations to make all elements equal. In one operation, you can increase or decrease any element by 1.

<Accordion title="Analysis">
**Core problem:** Find target value that minimizes total distance  
**Pattern:** Median minimizes sum of absolute differences  
**Complexity:** O(n log n) for sorting, O(n) for sum  
**Approach:** Sort and pick median
</Accordion>

**Problem B:**
> You have n items with weights w[i] and values v[i]. Find maximum value of items you can take such that total weight doesn't exceed W.

<Accordion title="Analysis">
**Core problem:** 0/1 Knapsack  
**Pattern:** DP with state (index, remaining capacity)  
**Complexity:** O(n × W)  
**Approach:** DP table or recursive with memoization
</Accordion>

**Problem C:**
> Given a string s of length n, find the longest palindromic substring.

<Accordion title="Analysis">
**Core problem:** Longest palindromic substring  
**Pattern:** Expand from center / DP / Manacher  
**Complexity:** O(n²) naive, O(n) with Manacher  
**Approach:** For CP, usually O(n²) is fine if n ≤ 5000
</Accordion>

---

## The 3-Minute Rule

Before coding anything:

1. **Minute 1**: Scan constraints, identify complexity bound
2. **Minute 2**: Extract core problem from story
3. **Minute 3**: Trace smallest example, verify understanding

If you can't explain the problem to an imaginary friend in simple terms, you don't understand it yet.

---

## Reading Checklist (Print This)

```
┌─────────────────────────────────────────────────────┐
│           BEFORE YOU START CODING                   │
├─────────────────────────────────────────────────────┤
│  □ Checked constraints (what O() is needed?)        │
│  □ Read input format carefully                      │
│  □ Traced Example 1 by hand                         │
│  □ Read the Note section                            │
│  □ Identified the pattern/approach                  │
│  □ Thought about edge cases                         │
│  □ Can explain problem in one sentence              │
└─────────────────────────────────────────────────────┘
```

---

## Key Takeaways

<CardGroup cols={2}>
  <Card title="Constraints First" icon="ruler">
    Constraints tell you the algorithm before the problem does.
  </Card>
  <Card title="Trace Examples" icon="pencil">
    If you can't trace Example 1 by hand, you don't understand the problem.
  </Card>
  <Card title="Translate Stories" icon="language">
    Convert narrative to technical terms: "consecutive" → subarray, "reach" → path.
  </Card>
  <Card title="Visualize Everything" icon="image">
    Draw arrays, graphs, grids. Visual thinking catches errors.
  </Card>
</CardGroup>

---

## Next Steps

<CardGroup cols={2}>
  <Card title="CF Survival Guide" icon="shield" href="/courses/competitive-programming/01b-cf-guide">
    Learn the Codeforces platform specifics.
  </Card>
  <Card title="CF Problem Types" icon="shapes" href="/courses/competitive-programming/01e-problem-types">
    Recognize the 9 most common CF problem types.
  </Card>
</CardGroup>
