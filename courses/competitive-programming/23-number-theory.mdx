---
title: "Number Theory for CP"
sidebarTitle: "23. Number Theory"
description: "Master modular arithmetic, primes, combinatorics, and mathematical techniques for CP"
icon: "square-root-variable"
---

# Number Theory for CP

## Why Number Theory Matters

Many competitive programming problems require mathematical insights. Modular arithmetic, prime factorization, and combinatorics appear in 30%+ of CF problems rated 1400+.

<Note>
**Pattern Recognition Signals**:
- "Output answer modulo 10^9+7" → Modular arithmetic
- "Count ways" → Combinatorics (nCr, nPr)
- "GCD/LCM" → Euclidean algorithm
- "Divisors" → Prime factorization
- Large exponents → Binary exponentiation
</Note>

---

## Modular Arithmetic

### The Basics

When numbers get too large, we work modulo some prime (usually 10^9 + 7).

```cpp
const ll MOD = 1e9 + 7;

// Properties:
// (a + b) % m = ((a % m) + (b % m)) % m
// (a * b) % m = ((a % m) * (b % m)) % m
// (a - b) % m = ((a % m) - (b % m) + m) % m  // Add m to handle negative

ll add(ll a, ll b) { return ((a % MOD) + (b % MOD)) % MOD; }
ll sub(ll a, ll b) { return ((a % MOD) - (b % MOD) + MOD) % MOD; }
ll mul(ll a, ll b) { return ((a % MOD) * (b % MOD)) % MOD; }
```

<Warning>
**Division is Different!**
`(a / b) % m ≠ ((a % m) / (b % m)) % m`

For division, multiply by **modular inverse**: `a / b ≡ a × b^(-1) (mod m)`
</Warning>

### Binary Exponentiation

Compute a^n mod m in O(log n).

```cpp
ll power(ll base, ll exp, ll mod = MOD) {
    ll result = 1;
    base %= mod;
    while (exp > 0) {
        if (exp & 1) result = result * base % mod;
        base = base * base % mod;
        exp >>= 1;
    }
    return result;
}
```

### Modular Inverse

For prime modulus, use Fermat's Little Theorem: `a^(-1) ≡ a^(p-2) (mod p)`

```cpp
ll modinv(ll a, ll mod = MOD) {
    return power(a, mod - 2, mod);
}

ll divide(ll a, ll b, ll mod = MOD) {
    return mul(a, modinv(b, mod));
}
```

### Extended Euclidean Algorithm

Finds x, y such that ax + by = gcd(a, b).

```cpp
ll extgcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) {
        x = 1; y = 0;
        return a;
    }
    ll x1, y1;
    ll g = extgcd(b, a % b, x1, y1);
    x = y1;
    y = x1 - (a / b) * y1;
    return g;
}

// Modular inverse for any coprime a, m (not just prime m)
ll modinv_general(ll a, ll m) {
    ll x, y;
    ll g = extgcd(a, m, x, y);
    if (g != 1) return -1;  // No inverse exists
    return (x % m + m) % m;
}
```

---

## Prime Numbers

### Sieve of Eratosthenes

Find all primes up to N in O(N log log N).

```cpp
const int MAXN = 1e7 + 5;
bool isPrime[MAXN];
vector<int> primes;

void sieve() {
    fill(isPrime, isPrime + MAXN, true);
    isPrime[0] = isPrime[1] = false;
    
    for (int i = 2; i < MAXN; i++) {
        if (isPrime[i]) {
            primes.push_back(i);
            for (ll j = (ll)i * i; j < MAXN; j += i) {
                isPrime[j] = false;
            }
        }
    }
}
```

### Linear Sieve with SPF

O(N) sieve that also computes smallest prime factor.

```cpp
int spf[MAXN];  // Smallest Prime Factor

void linearSieve() {
    for (int i = 2; i < MAXN; i++) {
        if (spf[i] == 0) {
            spf[i] = i;
            primes.push_back(i);
        }
        for (int p : primes) {
            if (p > spf[i] || (ll)i * p >= MAXN) break;
            spf[i * p] = p;
        }
    }
}

// O(log n) factorization using SPF
vector<pair<int, int>> factorize(int n) {
    vector<pair<int, int>> factors;
    while (n > 1) {
        int p = spf[n], cnt = 0;
        while (n % p == 0) {
            n /= p;
            cnt++;
        }
        factors.push_back({p, cnt});
    }
    return factors;
}
```

### Prime Factorization (O(√n))

```cpp
vector<pair<ll, int>> factorize(ll n) {
    vector<pair<ll, int>> factors;
    for (ll p = 2; p * p <= n; p++) {
        if (n % p == 0) {
            int cnt = 0;
            while (n % p == 0) {
                n /= p;
                cnt++;
            }
            factors.push_back({p, cnt});
        }
    }
    if (n > 1) factors.push_back({n, 1});
    return factors;
}
```

### Counting Divisors

If n = p1^a1 × p2^a2 × ... × pk^ak, then:
- Number of divisors = (a1+1) × (a2+1) × ... × (ak+1)
- Sum of divisors = ∏((pi^(ai+1) - 1) / (pi - 1))

```cpp
ll countDivisors(ll n) {
    ll cnt = 1;
    for (ll p = 2; p * p <= n; p++) {
        if (n % p == 0) {
            int exp = 0;
            while (n % p == 0) {
                n /= p;
                exp++;
            }
            cnt *= (exp + 1);
        }
    }
    if (n > 1) cnt *= 2;
    return cnt;
}

// Get all divisors
vector<ll> getDivisors(ll n) {
    vector<ll> divs;
    for (ll i = 1; i * i <= n; i++) {
        if (n % i == 0) {
            divs.push_back(i);
            if (i != n / i) divs.push_back(n / i);
        }
    }
    sort(divs.begin(), divs.end());
    return divs;
}
```

---

## Combinatorics

### Factorial and Inverse Factorial

Precompute for O(1) nCr queries.

```cpp
const int MAXN = 2e5 + 5;
ll fact[MAXN], inv_fact[MAXN];

void precompute() {
    fact[0] = 1;
    for (int i = 1; i < MAXN; i++) {
        fact[i] = fact[i-1] * i % MOD;
    }
    
    inv_fact[MAXN-1] = power(fact[MAXN-1], MOD - 2);
    for (int i = MAXN - 2; i >= 0; i--) {
        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;
    }
}

ll C(int n, int r) {
    if (r < 0 || r > n) return 0;
    return fact[n] * inv_fact[r] % MOD * inv_fact[n-r] % MOD;
}

ll P(int n, int r) {
    if (r < 0 || r > n) return 0;
    return fact[n] * inv_fact[n-r] % MOD;
}
```

### Common Formulas

| Formula | Expression | Use Case |
|---------|------------|----------|
| nCr | n! / (r! × (n-r)!) | Choose r from n |
| nPr | n! / (n-r)! | Arrange r from n |
| Stars and Bars | C(n+r-1, r-1) | Distribute n identical items into r groups |
| Catalan(n) | C(2n, n) / (n+1) | Valid parentheses, BST count |
| Derangements | n! × Σ((-1)^i / i!) | Permutations with no fixed points |

### Pascal's Triangle (Small n, r)

```cpp
const int MAXN = 5005;
ll C[MAXN][MAXN];

void buildPascal() {
    for (int i = 0; i < MAXN; i++) {
        C[i][0] = 1;
        for (int j = 1; j <= i; j++) {
            C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
        }
    }
}
```

### Lucas Theorem (Large n, small p)

When n is huge but p is small prime.

```cpp
ll lucas(ll n, ll r, ll p) {
    if (r == 0) return 1;
    return C(n % p, r % p) * lucas(n / p, r / p, p) % p;
}
```

---

## GCD and LCM

### Basic Functions

```cpp
ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }
ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }  // Prevent overflow
```

### GCD of Array

```cpp
ll gcdArray(vector<ll>& arr) {
    ll g = 0;
    for (ll x : arr) g = gcd(g, x);
    return g;
}
```

### Properties

- gcd(a, b) × lcm(a, b) = a × b
- gcd(a, b, c) = gcd(gcd(a, b), c)
- gcd(a, 0) = a
- If gcd(a, b) = g, then gcd(a/g, b/g) = 1

---

## Euler's Totient Function

φ(n) = count of integers in [1, n] coprime to n.

```cpp
ll phi(ll n) {
    ll result = n;
    for (ll p = 2; p * p <= n; p++) {
        if (n % p == 0) {
            while (n % p == 0) n /= p;
            result -= result / p;
        }
    }
    if (n > 1) result -= result / n;
    return result;
}

// Sieve for phi
int phi_sieve[MAXN];

void computePhi() {
    iota(phi_sieve, phi_sieve + MAXN, 0);
    for (int i = 2; i < MAXN; i++) {
        if (phi_sieve[i] == i) {  // i is prime
            for (int j = i; j < MAXN; j += i) {
                phi_sieve[j] -= phi_sieve[j] / i;
            }
        }
    }
}
```

### Euler's Theorem

If gcd(a, n) = 1, then a^φ(n) ≡ 1 (mod n)

**Application**: a^b mod m when b is huge
- If gcd(a, m) = 1: a^b ≡ a^(b mod φ(m)) (mod m)

---

## Pattern: Counting with Inclusion-Exclusion

Count elements satisfying at least one of k conditions.

```cpp
// Count numbers in [1, n] divisible by at least one prime in list
ll countDivisible(ll n, vector<ll>& primes) {
    int k = primes.size();
    ll result = 0;
    
    for (int mask = 1; mask < (1 << k); mask++) {
        ll product = 1;
        int bits = 0;
        
        for (int i = 0; i < k; i++) {
            if (mask & (1 << i)) {
                product *= primes[i];
                bits++;
                if (product > n) break;
            }
        }
        
        if (product <= n) {
            if (bits % 2 == 1) result += n / product;
            else result -= n / product;
        }
    }
    
    return result;
}
```

---

## Practice Problems

### Beginner (1000-1300)
| Problem | Topic | Link |
|---------|-------|------|
| Exponentiation | Binary exp | [CSES](https://cses.fi/problemset/task/1095) |
| Counting Divisors | Factorization | [CSES](https://cses.fi/problemset/task/1713) |
| GCD Query | GCD | [CF 1350C](https://codeforces.com/problemset/problem/1350/C) |

### Intermediate (1300-1600)
| Problem | Topic | Link |
|---------|-------|------|
| Binomial Coefficients | nCr | [CSES](https://cses.fi/problemset/task/1079) |
| Creating Strings II | Combinatorics | [CSES](https://cses.fi/problemset/task/1715) |
| Sum of Divisors | Number theory | [CSES](https://cses.fi/problemset/task/1082) |

### Advanced (1600-1900)
| Problem | Topic | Link |
|---------|-------|------|
| Counting Coprime Pairs | Euler phi | [CSES](https://cses.fi/problemset/task/2417) |
| Christmas Party | Derangements | [CSES](https://cses.fi/problemset/task/1717) |

---

## Key Takeaways

<CardGroup cols={2}>
  <Card title="Modular Inverse" icon="divide">
    Use a^(p-2) for prime p, or extended GCD for general.
  </Card>
  <Card title="Precompute Factorials" icon="table">
    O(n) precomputation gives O(1) nCr queries.
  </Card>
  <Card title="SPF Sieve" icon="filter">
    Linear sieve enables O(log n) factorization.
  </Card>
  <Card title="Inclusion-Exclusion" icon="circle-nodes">
    Count by adding/subtracting overlaps.
  </Card>
</CardGroup>

---

## Next Up

<Card title="Chapter 24: Advanced Graph Algorithms" icon="arrow-right" href="/courses/competitive-programming/24-advanced-graphs">
  Master SCC, bridges, articulation points, and advanced graph techniques.
</Card>
