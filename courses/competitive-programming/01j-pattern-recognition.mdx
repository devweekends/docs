---
title: "Pattern Recognition"
description: "Learn to instantly recognize common problem patterns and select the right algorithm"
---

import { Icon } from '/snippets/icons.mdx'

# <Icon icon="eye" /> Pattern Recognition

The fastest competitive programmers don't think harderâ€”they **recognize patterns faster**. This chapter trains your pattern recognition to instantly spot which technique to apply.

<img src="/images/courses/cp/pattern-recognition.svg" alt="Pattern Recognition Flow" />

---

## <Icon icon="brain" /> The Recognition Framework

<Warning>
**The Secret:** After solving 500+ problems, you stop "solving" and start "recognizing." This chapter gives you shortcuts to that recognition.
</Warning>

### The 3-Step Recognition Process

<img src="/images/courses/cp/recognition-process.svg" alt="3-Step Recognition" />

<Steps>
  <Step title="Read the Constraint">
    The constraint is the FIRST clue to the algorithm.
  </Step>
  
  <Step title="Identify the Question Type">
    What are they asking? Count, optimize, find, check?
  </Step>
  
  <Step title="Match the Pattern">
    Combine constraint + question type = algorithm pattern.
  </Step>
</Steps>

---

## <Icon icon="ruler" /> Constraint â†’ Algorithm Map

### The Golden Table

<img src="/images/courses/cp/constraint-algo-map.svg" alt="Constraint to Algorithm Map" />

| Constraint (n) | Max Operations | Likely Algorithm |
|----------------|----------------|------------------|
| n â‰¤ 10 | 10! = 3.6M | Brute force, permutations, backtracking |
| n â‰¤ 20 | 2Â²â° = 1M | Bitmask DP, subset enumeration |
| n â‰¤ 100 | nÂ³ = 1M | Floyd-Warshall, O(nÂ³) DP |
| n â‰¤ 500 | nÂ³ = 125M | O(nÂ²) with optimization |
| n â‰¤ 5,000 | nÂ² = 25M | O(nÂ²) DP, all pairs |
| n â‰¤ 10âµ | n log n | Sorting, binary search, segment tree |
| n â‰¤ 10â¶ | O(n) | Linear scan, two pointers, prefix sum |
| n â‰¤ 10â¹ | O(log n) | Binary search, math formula |
| n â‰¤ 10Â¹â¸ | O(1) or O(log n) | Math formula, matrix exponentiation |

---

## <Icon icon="search" /> Question Type Patterns

### Pattern 1: "Count the number of..."

<CardGroup cols={2}>
  <Card title="Count subarrays with property" icon="calculator">
    **Technique:** Prefix sum + hashmap
    ```cpp
    // "Count subarrays with sum = k"
    map<int, int> prefix_count;
    prefix_count[0] = 1;
    int sum = 0, count = 0;
    for (int x : arr) {
        sum += x;
        count += prefix_count[sum - k];
        prefix_count[sum]++;
    }
    ```
  </Card>
  
  <Card title="Count subsequences with property" icon="layer-group">
    **Technique:** DP (usually 1D or 2D)
    ```cpp
    // "Count increasing subsequences of length k"
    // dp[i][j] = count ending at i, length j
    for (int i = 0; i < n; i++) {
        dp[i][1] = 1;
        for (int j = 0; j < i; j++) {
            if (a[j] < a[i]) {
                for (int k = 2; k <= K; k++) {
                    dp[i][k] += dp[j][k-1];
                }
            }
        }
    }
    ```
  </Card>
</CardGroup>

### Pattern 2: "Find the maximum/minimum..."

<img src="/images/courses/cp/optimize-pattern.svg" alt="Optimization Patterns" />

| What to Optimize | First Try | If TLE, Try |
|------------------|-----------|-------------|
| Max sum subarray | Kadane's O(n) | Already optimal |
| Min cost path | Dijkstra O(E log V) | 0-1 BFS if weights 0/1 |
| Max flow | Ford-Fulkerson | Dinic's algorithm |
| Max matching | Hungarian O(nÂ³) | Hopcroft-Karp O(EâˆšV) |
| Min operations | BFS | Binary search on answer |

### Pattern 3: "Check if possible..."

<CardGroup cols={2}>
  <Card title="Can we achieve X?" icon="check">
    **Technique:** Binary search on answer
    ```cpp
    // "Can we split array into k parts 
    // with max sum â‰¤ mid?"
    int lo = max_element, hi = total_sum;
    while (lo < hi) {
        int mid = (lo + hi) / 2;
        if (canSplit(arr, k, mid)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
    return lo;
    ```
  </Card>
  
  <Card title="Does path/assignment exist?" icon="route">
    **Technique:** DFS/BFS or DP
    ```cpp
    // "Can we reach target?"
    bool dfs(int node, int target, 
             vector<bool>& visited) {
        if (node == target) return true;
        visited[node] = true;
        for (int next : adj[node]) {
            if (!visited[next] && 
                dfs(next, target, visited)) {
                return true;
            }
        }
        return false;
    }
    ```
  </Card>
</CardGroup>

### Pattern 4: "Find the kth..."

| Problem Type | Algorithm | Complexity |
|--------------|-----------|------------|
| Kth smallest in array | nth_element / quickselect | O(n) |
| Kth smallest in sorted arrays | Binary search | O(log(min(m,n))) |
| Kth smallest in BST | In-order traversal | O(k) |
| Kth smallest sum | Priority queue | O(k log k) |

---

## <Icon icon="wand-magic-sparkles" /> Keyword â†’ Algorithm Triggers

<img src="/images/courses/cp/keyword-triggers.svg" alt="Keyword Triggers" />

### Instant Recognition Keywords

| Keyword in Problem | Algorithm to Consider |
|--------------------|----------------------|
| "subarray sum" | Prefix sum, sliding window, kadane |
| "longest increasing" | DP, binary search + DP |
| "shortest path" | BFS (unweighted), Dijkstra (weighted) |
| "number of ways" | DP, combinatorics |
| "partition into k" | Binary search on answer |
| "lexicographically smallest" | Greedy, trie |
| "connected components" | DFS, DSU |
| "minimum spanning tree" | Kruskal, Prim |
| "all pairs" | Floyd-Warshall, n Ã— Dijkstra |
| "parentheses/brackets" | Stack |
| "intervals/meetings" | Sort by end, greedy |
| "palindrome" | Two pointers, DP, Manacher |
| "permutation" | Factorial, backtracking |
| "subset" | Bitmask, DP |
| "modulo 10^9+7" | DP (count), use mod everywhere |

---

## <Icon icon="diagram-project" /> Visual Pattern Gallery

### Array Patterns

<img src="/images/courses/cp/array-patterns.svg" alt="Array Pattern Recognition" />

```
PATTERN: Contiguous subarray with property
SIGNALS: "subarray", "contiguous", "consecutive"
TECHNIQUES: 
  - Prefix sum (sum queries)
  - Sliding window (fixed or variable size)
  - Two pointers (sorted or special property)
  - Monotonic deque (min/max in window)

PATTERN: Find elements with relationship
SIGNALS: "pair", "triplet", "two numbers that"
TECHNIQUES:
  - Sort + two pointers
  - Hashmap for complement
  - Binary search after sorting
```

### Tree Patterns

```
PATTERN: Path queries on tree
SIGNALS: "path between nodes", "distance", "LCA"
TECHNIQUES:
  - DFS for simple paths
  - Binary lifting for LCA
  - HLD for path updates

PATTERN: Subtree queries
SIGNALS: "sum in subtree", "count in subtree"
TECHNIQUES:
  - DFS in/out times
  - Euler tour + range queries
```

### Graph Patterns

```
PATTERN: Shortest path
SIGNALS: "minimum distance", "fewest steps"
TECHNIQUES:
  - BFS (unweighted)
  - Dijkstra (positive weights)
  - Bellman-Ford (negative weights)
  - 0-1 BFS (weights 0 or 1)

PATTERN: Cycle detection
SIGNALS: "cycle", "loop", "circular dependency"
TECHNIQUES:
  - DFS with colors (directed)
  - Union-Find (undirected)
  - Check if edges â‰¥ vertices in component
```

---

## <Icon icon="sitemap" /> Decision Trees for Common Problems

### "Given an array..." Decision Tree

<img src="/images/courses/cp/array-decision-tree.svg" alt="Array Problem Decision Tree" />

```
Q: What are you asked to find?
â”œâ”€â”€ Sum/XOR of subarray?
â”‚   â”œâ”€â”€ Single query â†’ Prefix sum/XOR
â”‚   â””â”€â”€ Multiple queries â†’ Prefix sum array
â”‚
â”œâ”€â”€ Maximum/Minimum in range?
â”‚   â”œâ”€â”€ Static array â†’ Sparse table
â”‚   â””â”€â”€ Updates allowed â†’ Segment tree
â”‚
â”œâ”€â”€ Longest subarray with property?
â”‚   â”œâ”€â”€ Two-pointer property â†’ Two pointers
â”‚   â””â”€â”€ Complex property â†’ DP
â”‚
â”œâ”€â”€ Number of subarrays with property?
â”‚   â”œâ”€â”€ Sum = k â†’ Hashmap + prefix sum
â”‚   â”œâ”€â”€ Fixed length â†’ Sliding window
â”‚   â””â”€â”€ Other â†’ DP or combinatorics
â”‚
â””â”€â”€ Reorder/partition array?
    â”œâ”€â”€ Minimize max â†’ Binary search on answer
    â””â”€â”€ Specific order â†’ Greedy or DP
```

### "Given a string..." Decision Tree

```
Q: What are you asked to find?
â”œâ”€â”€ Substring matching?
â”‚   â”œâ”€â”€ Single pattern â†’ KMP, Z-algorithm
â”‚   â””â”€â”€ Multiple patterns â†’ Aho-Corasick, trie
â”‚
â”œâ”€â”€ Palindrome questions?
â”‚   â”œâ”€â”€ Check palindrome â†’ Two pointers
â”‚   â”œâ”€â”€ Longest palindrome â†’ DP, Manacher
â”‚   â””â”€â”€ Count palindromes â†’ DP
â”‚
â”œâ”€â”€ Lexicographically smallest/largest?
â”‚   â”œâ”€â”€ By deletion â†’ Stack-based greedy
â”‚   â””â”€â”€ By rearrangement â†’ Sort characters
â”‚
â””â”€â”€ Edit distance/similarity?
    â””â”€â”€ DP (LCS, edit distance)
```

---

## <Icon icon="dumbbell" /> Pattern Recognition Drills

### Drill 1: Speed Classification

Read each problem description and identify the pattern in <10 seconds:

<Accordion title="Problem Set (Click to expand)">
**P1:** "Given an array of n integers, find the number of pairs (i,j) where i < j and a[i] + a[j] = k."
- **Pattern:** Two Sum â†’ Hashmap

**P2:** "Given a binary tree, find the maximum path sum from any node to any node."
- **Pattern:** Tree DP â†’ DFS with return value

**P3:** "Given n intervals, find the minimum number of points such that each interval contains at least one point."
- **Pattern:** Interval covering â†’ Sort by end + greedy

**P4:** "Given a string, find the longest palindromic substring."
- **Pattern:** Palindrome â†’ DP or expand from center

**P5:** "Given a weighted graph, find if negative cycle exists."
- **Pattern:** Negative cycle â†’ Bellman-Ford

**P6:** "Given array, answer queries for minimum in range [l,r]."
- **Pattern:** Range min query â†’ Sparse table or segment tree

**P7:** "Given n items with weight and value, maximize value with capacity W."
- **Pattern:** 0/1 Knapsack â†’ 2D DP

**P8:** "Given a sequence, count inversions (pairs where i < j but a[i] > a[j])."
- **Pattern:** Inversions â†’ Merge sort or BIT
</Accordion>

### Drill 2: Constraint â†’ Algorithm

| Constraint | Your Answer |
|------------|-------------|
| n â‰¤ 15 | ? |
| n â‰¤ 1000, find shortest path | ? |
| n â‰¤ 10âµ, range sum queries | ? |
| n â‰¤ 10â¶, single pass required | ? |
| n â‰¤ 10Â¹â¸, compute nth Fibonacci | ? |

<Accordion title="Answers">
| Constraint | Algorithm |
|------------|-----------|
| n â‰¤ 15 | Bitmask DP, brute force |
| n â‰¤ 1000, find shortest path | Floyd-Warshall O(nÂ³) or BFS/Dijkstra |
| n â‰¤ 10âµ, range sum queries | Prefix sum or Segment tree |
| n â‰¤ 10â¶, single pass required | O(n) linear scan, two pointers |
| n â‰¤ 10Â¹â¸, compute nth Fibonacci | Matrix exponentiation |
</Accordion>

---

## <Icon icon="bolt" /> Quick Reference Cheat Sheet

### One-Liner Pattern Recognition

```
Array + Sum â†’ Prefix Sum
Array + Sorted + Target â†’ Two Pointers / Binary Search
Array + Window Property â†’ Sliding Window
Array + Subsequence â†’ DP

String + Match â†’ KMP / Hashing
String + Palindrome â†’ DP / Manacher
String + Lexicographic â†’ Greedy / Trie

Graph + Shortest â†’ BFS (unweighted) / Dijkstra (weighted)
Graph + Connectivity â†’ DFS / DSU
Graph + Minimum cost â†’ MST (Kruskal/Prim)
Graph + Flow â†’ Ford-Fulkerson / Dinic

Tree + Path â†’ DFS
Tree + LCA â†’ Binary Lifting
Tree + Subtree â†’ Euler Tour

"Number of ways" â†’ DP + mod
"Minimum steps" â†’ BFS
"Is it possible" â†’ Binary Search on Answer
"Maximum subset" â†’ DP / Greedy
```

---

<Tip>
**Pattern recognition is a skill that develops with practice.**

Every problem you solve adds to your pattern library. After 500 problems, you'll look at a new problem and think "Oh, this is just [pattern] with a twist."

**Keep solving. Keep recognizing. Keep winning!** ğŸ†
</Tip>
