---
title: "Advanced Graph Algorithms"
sidebarTitle: "24. Advanced Graphs"
description: "Master SCC, bridges, articulation points, 2-SAT, and advanced graph techniques"
icon: "circle-nodes"
---

# Advanced Graph Algorithms

## Beyond Basic Graphs

Once you've mastered BFS, DFS, and shortest paths, it's time for advanced graph techniques. These algorithms appear in harder CF problems (1700+) and ICPC regionals.

<Note>
**Pattern Recognition Signals**:
- "Strongly connected" → SCC (Kosaraju/Tarjan)
- "Bridge/cut vertex" → Bridge finding algorithm
- "Boolean satisfiability" → 2-SAT
- "Bipartite matching" → Hungarian/Kuhn's algorithm
- "Maximum flow" → Ford-Fulkerson/Dinic
</Note>

---

## Strongly Connected Components (SCC)

An SCC is a maximal set of vertices where every vertex is reachable from every other.

### Kosaraju's Algorithm

```cpp
class SCC {
public:
    int n, numSCC;
    vector<vector<int>> adj, radj;
    vector<int> order, comp;
    vector<bool> visited;
    
    SCC(int n) : n(n), adj(n), radj(n), comp(n, -1), visited(n, false) {}
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        radj[v].push_back(u);
    }
    
    void dfs1(int u) {
        visited[u] = true;
        for (int v : adj[u]) {
            if (!visited[v]) dfs1(v);
        }
        order.push_back(u);
    }
    
    void dfs2(int u, int c) {
        comp[u] = c;
        for (int v : radj[u]) {
            if (comp[v] == -1) dfs2(v, c);
        }
    }
    
    int findSCC() {
        // First DFS to get finishing order
        for (int i = 0; i < n; i++) {
            if (!visited[i]) dfs1(i);
        }
        
        // Second DFS on reverse graph in reverse order
        numSCC = 0;
        for (int i = n - 1; i >= 0; i--) {
            int u = order[i];
            if (comp[u] == -1) {
                dfs2(u, numSCC);
                numSCC++;
            }
        }
        
        return numSCC;
    }
    
    // Build condensation graph (DAG of SCCs)
    vector<vector<int>> condensation() {
        vector<set<int>> edges(numSCC);
        for (int u = 0; u < n; u++) {
            for (int v : adj[u]) {
                if (comp[u] != comp[v]) {
                    edges[comp[u]].insert(comp[v]);
                }
            }
        }
        
        vector<vector<int>> dag(numSCC);
        for (int i = 0; i < numSCC; i++) {
            for (int j : edges[i]) {
                dag[i].push_back(j);
            }
        }
        return dag;
    }
};
```

### Tarjan's Algorithm

Single DFS, more efficient in practice.

```cpp
class TarjanSCC {
public:
    int n, numSCC, timer;
    vector<vector<int>> adj;
    vector<int> disc, low, comp;
    vector<bool> onStack;
    stack<int> st;
    
    TarjanSCC(int n) : n(n), adj(n), disc(n, -1), low(n), 
                       comp(n, -1), onStack(n, false), numSCC(0), timer(0) {}
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
    }
    
    void dfs(int u) {
        disc[u] = low[u] = timer++;
        st.push(u);
        onStack[u] = true;
        
        for (int v : adj[u]) {
            if (disc[v] == -1) {
                dfs(v);
                low[u] = min(low[u], low[v]);
            } else if (onStack[v]) {
                low[u] = min(low[u], disc[v]);
            }
        }
        
        if (low[u] == disc[u]) {
            while (true) {
                int v = st.top();
                st.pop();
                onStack[v] = false;
                comp[v] = numSCC;
                if (v == u) break;
            }
            numSCC++;
        }
    }
    
    int findSCC() {
        for (int i = 0; i < n; i++) {
            if (disc[i] == -1) dfs(i);
        }
        return numSCC;
    }
};
```

---

## Bridges and Articulation Points

### Finding Bridges

An edge is a bridge if removing it disconnects the graph.

```cpp
class Bridges {
public:
    int n, timer;
    vector<vector<pair<int, int>>> adj;  // {neighbor, edge_id}
    vector<int> disc, low;
    vector<bool> isBridge;
    
    Bridges(int n, int m) : n(n), adj(n), disc(n, -1), low(n), 
                            isBridge(m, false), timer(0) {}
    
    void addEdge(int u, int v, int id) {
        adj[u].push_back({v, id});
        adj[v].push_back({u, id});
    }
    
    void dfs(int u, int parentEdge) {
        disc[u] = low[u] = timer++;
        
        for (auto [v, edgeId] : adj[u]) {
            if (edgeId == parentEdge) continue;
            
            if (disc[v] == -1) {
                dfs(v, edgeId);
                low[u] = min(low[u], low[v]);
                
                if (low[v] > disc[u]) {
                    isBridge[edgeId] = true;
                }
            } else {
                low[u] = min(low[u], disc[v]);
            }
        }
    }
    
    vector<int> findBridges() {
        for (int i = 0; i < n; i++) {
            if (disc[i] == -1) dfs(i, -1);
        }
        
        vector<int> bridges;
        for (int i = 0; i < isBridge.size(); i++) {
            if (isBridge[i]) bridges.push_back(i);
        }
        return bridges;
    }
};
```

### Finding Articulation Points

A vertex is an articulation point if removing it disconnects the graph.

```cpp
class ArticulationPoints {
public:
    int n, timer;
    vector<vector<int>> adj;
    vector<int> disc, low;
    vector<bool> isAP;
    
    ArticulationPoints(int n) : n(n), adj(n), disc(n, -1), 
                                 low(n), isAP(n, false), timer(0) {}
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    void dfs(int u, int parent) {
        disc[u] = low[u] = timer++;
        int children = 0;
        
        for (int v : adj[u]) {
            if (disc[v] == -1) {
                children++;
                dfs(v, u);
                low[u] = min(low[u], low[v]);
                
                // u is AP if:
                // 1. u is root and has 2+ children
                // 2. u is not root and low[v] >= disc[u]
                if (parent == -1 && children > 1) isAP[u] = true;
                if (parent != -1 && low[v] >= disc[u]) isAP[u] = true;
            } else if (v != parent) {
                low[u] = min(low[u], disc[v]);
            }
        }
    }
    
    vector<int> findAPs() {
        for (int i = 0; i < n; i++) {
            if (disc[i] == -1) dfs(i, -1);
        }
        
        vector<int> aps;
        for (int i = 0; i < n; i++) {
            if (isAP[i]) aps.push_back(i);
        }
        return aps;
    }
};
```

---

## 2-SAT

Solve boolean satisfiability with clauses of form (x OR y).

```cpp
class TwoSAT {
public:
    int n;  // Number of variables (0 to n-1)
    SCC scc;
    
    TwoSAT(int n) : n(n), scc(2 * n) {}
    
    // Variable x: true = 2*x, false = 2*x+1
    int var(int x, bool val) { return 2 * x + (val ? 0 : 1); }
    int neg(int x) { return x ^ 1; }
    
    // Add clause: (a OR b)
    // Equivalent to: (NOT a => b) AND (NOT b => a)
    void addClause(int a, bool valA, int b, bool valB) {
        int u = var(a, valA);
        int v = var(b, valB);
        scc.addEdge(neg(u), v);
        scc.addEdge(neg(v), u);
    }
    
    // Add implication: a => b
    void addImplication(int a, bool valA, int b, bool valB) {
        int u = var(a, valA);
        int v = var(b, valB);
        scc.addEdge(u, v);
        scc.addEdge(neg(v), neg(u));
    }
    
    // Force variable to specific value
    void forceValue(int a, bool val) {
        addClause(a, val, a, val);
    }
    
    // Check satisfiability and get assignment
    pair<bool, vector<bool>> solve() {
        scc.findSCC();
        
        vector<bool> assignment(n);
        
        for (int i = 0; i < n; i++) {
            if (scc.comp[2*i] == scc.comp[2*i+1]) {
                return {false, {}};  // x and NOT x in same SCC
            }
            // Assign true if false-node has smaller component number
            // (topologically later = reachable from true-node)
            assignment[i] = scc.comp[2*i] > scc.comp[2*i+1];
        }
        
        return {true, assignment};
    }
};
```

### 2-SAT Example

```cpp
// Variables: 0, 1, 2
// Clauses: (x0 OR x1), (NOT x1 OR x2), (NOT x0 OR NOT x2)

TwoSAT sat(3);
sat.addClause(0, true, 1, true);      // x0 OR x1
sat.addClause(1, false, 2, true);     // NOT x1 OR x2
sat.addClause(0, false, 2, false);    // NOT x0 OR NOT x2

auto [satisfiable, assignment] = sat.solve();
if (satisfiable) {
    for (int i = 0; i < 3; i++) {
        cout << "x" << i << " = " << assignment[i] << "\n";
    }
}
```

---

## Bipartite Matching

### Kuhn's Algorithm (Hungarian)

```cpp
class BipartiteMatching {
public:
    int n, m;  // Left side: n vertices, Right side: m vertices
    vector<vector<int>> adj;
    vector<int> match;
    vector<bool> used;
    
    BipartiteMatching(int n, int m) : n(n), m(m), adj(n), match(m, -1) {}
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
    }
    
    bool dfs(int u) {
        for (int v : adj[u]) {
            if (!used[v]) {
                used[v] = true;
                if (match[v] == -1 || dfs(match[v])) {
                    match[v] = u;
                    return true;
                }
            }
        }
        return false;
    }
    
    int maxMatching() {
        int result = 0;
        for (int u = 0; u < n; u++) {
            used.assign(m, false);
            if (dfs(u)) result++;
        }
        return result;
    }
    
    vector<pair<int, int>> getMatching() {
        vector<pair<int, int>> matching;
        for (int v = 0; v < m; v++) {
            if (match[v] != -1) {
                matching.push_back({match[v], v});
            }
        }
        return matching;
    }
};
```

---

## Maximum Flow (Dinic's Algorithm)

```cpp
struct Dinic {
    struct Edge {
        int to, rev;
        ll cap;
    };
    
    int n;
    vector<vector<Edge>> adj;
    vector<int> level, iter;
    
    Dinic(int n) : n(n), adj(n), level(n), iter(n) {}
    
    void addEdge(int from, int to, ll cap) {
        adj[from].push_back({to, (int)adj[to].size(), cap});
        adj[to].push_back({from, (int)adj[from].size() - 1, 0});
    }
    
    bool bfs(int s, int t) {
        fill(level.begin(), level.end(), -1);
        queue<int> q;
        level[s] = 0;
        q.push(s);
        
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            for (auto& e : adj[u]) {
                if (e.cap > 0 && level[e.to] < 0) {
                    level[e.to] = level[u] + 1;
                    q.push(e.to);
                }
            }
        }
        
        return level[t] >= 0;
    }
    
    ll dfs(int u, int t, ll f) {
        if (u == t) return f;
        
        for (int& i = iter[u]; i < adj[u].size(); i++) {
            Edge& e = adj[u][i];
            if (e.cap > 0 && level[u] < level[e.to]) {
                ll d = dfs(e.to, t, min(f, e.cap));
                if (d > 0) {
                    e.cap -= d;
                    adj[e.to][e.rev].cap += d;
                    return d;
                }
            }
        }
        
        return 0;
    }
    
    ll maxFlow(int s, int t) {
        ll flow = 0;
        while (bfs(s, t)) {
            fill(iter.begin(), iter.end(), 0);
            ll f;
            while ((f = dfs(s, t, LLONG_MAX)) > 0) {
                flow += f;
            }
        }
        return flow;
    }
};
```

---

## Eulerian Path/Circuit

Path that visits every edge exactly once.

```cpp
// Eulerian circuit exists if: all vertices have even degree
// Eulerian path exists if: exactly 0 or 2 vertices have odd degree

vector<int> eulerianPath(int n, vector<pair<int,int>>& edges) {
    vector<vector<pair<int,int>>> adj(n);  // {neighbor, edge_index}
    vector<bool> used(edges.size(), false);
    vector<int> deg(n, 0);
    
    for (int i = 0; i < edges.size(); i++) {
        auto [u, v] = edges[i];
        adj[u].push_back({v, i});
        adj[v].push_back({u, i});
        deg[u]++;
        deg[v]++;
    }
    
    // Find start vertex
    int start = 0;
    int oddCount = 0;
    for (int i = 0; i < n; i++) {
        if (deg[i] % 2 == 1) {
            start = i;
            oddCount++;
        }
    }
    
    if (oddCount != 0 && oddCount != 2) return {};  // No Eulerian path
    
    vector<int> path;
    stack<int> st;
    st.push(start);
    
    while (!st.empty()) {
        int u = st.top();
        bool found = false;
        
        while (!adj[u].empty()) {
            auto [v, idx] = adj[u].back();
            adj[u].pop_back();
            
            if (!used[idx]) {
                used[idx] = true;
                st.push(v);
                found = true;
                break;
            }
        }
        
        if (!found) {
            path.push_back(u);
            st.pop();
        }
    }
    
    reverse(path.begin(), path.end());
    return path;
}
```

---

## Practice Problems

### Intermediate (1400-1700)
| Problem | Topic | Link |
|---------|-------|------|
| Planets and Kingdoms | SCC | [CSES](https://cses.fi/problemset/task/1683) |
| Giant Pizza | 2-SAT | [CSES](https://cses.fi/problemset/task/1684) |
| Coin Collector | SCC + DP | [CSES](https://cses.fi/problemset/task/1686) |

### Advanced (1700-2000)
| Problem | Topic | Link |
|---------|-------|------|
| Flight Routes Check | SCC | [CSES](https://cses.fi/problemset/task/1682) |
| Mail Delivery | Eulerian | [CSES](https://cses.fi/problemset/task/1691) |
| School Dance | Bipartite Matching | [CSES](https://cses.fi/problemset/task/1696) |

---

## Key Takeaways

<CardGroup cols={2}>
  <Card title="SCC" icon="circle-nodes">
    Kosaraju or Tarjan for strongly connected components.
  </Card>
  <Card title="Bridges/APs" icon="bridge">
    Use low-link values from DFS tree.
  </Card>
  <Card title="2-SAT" icon="code-branch">
    Model as implication graph, solve with SCC.
  </Card>
  <Card title="Max Flow" icon="water">
    Dinic's O(V²E) for general, O(E√V) for bipartite.
  </Card>
</CardGroup>

---

## Next Up

<Card title="Back to Overview" icon="arrow-left" href="/courses/competitive-programming/00-overview">
  Return to the complete course curriculum.
</Card>
