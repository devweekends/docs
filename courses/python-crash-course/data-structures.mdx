---
title: "Data Structures"
sidebarTitle: "2. Data Structures"
description: "Lists, Dictionaries, Sets, and Tuples"
icon: "layer-group"
---

<img src="/images/courses/python-crash-course/python-data-structures.svg" alt="Python Data Structures" />

# Data Structures

Python's built-in data structures are incredibly powerful. Unlike C++ or Java where you might need to import special libraries for hash maps or dynamic arrays, Python has them built into the core language syntax.

---

## 1. Lists (Dynamic Arrays)

A `list` is an ordered, mutable sequence of items. It can hold mixed types (integers, strings, other lists).

```python
fruits = ["apple", "banana", "cherry"]

# Access
print(fruits[0])  # apple
print(fruits[-1]) # cherry (Negative indexing counts from the end!)

# Modify
fruits.append("date")      # Add to end
fruits.insert(1, "berry")  # Insert at index 1
fruits.pop()               # Remove and return last item
```

### Slicing `[start:end:step]`
Slicing allows you to extract sub-parts of a list. It creates a **new** list.

```python
nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(nums[0:5])   # [0, 1, 2, 3, 4] (Start is inclusive, End is exclusive)
print(nums[:5])    # [0, 1, 2, 3, 4] (Start defaults to 0)
print(nums[5:])    # [5, 6, 7, 8, 9] (End defaults to length)
print(nums[::2])   # [0, 2, 4, 6, 8] (Step 2: every second item)
print(nums[::-1])  # [9, 8, ..., 0]  (Reverse the list!)
```

### List Comprehensions
This is a "Pythonic" way to create lists based on existing lists. It's often more readable and faster than a for-loop.

```python
# The Old Way
squares = []
for x in range(10):
    squares.append(x**2)

# The Pythonic Way
# [expression for item in iterable]
squares = [x**2 for x in range(10)]

# With a condition (Filter)
evens = [x for x in range(10) if x % 2 == 0]
```

---

## 2. Dictionaries (Hash Maps)

A `dict` stores **Key-Value pairs**. Keys must be immutable (strings, numbers, tuples) and unique. Lookups are extremely fast (O(1)).

```python
user = {
    "name": "Alice",
    "age": 30,
    "is_admin": True
}

# Access
print(user["name"])
# print(user["email"]) # KeyError! Key doesn't exist.

# Safe Access
print(user.get("email"))          # Returns None
print(user.get("email", "N/A"))   # Returns "N/A"

# Modify
user["email"] = "alice@example.com"
del user["is_admin"]

# Iterate
for key, value in user.items():
    print(f"{key}: {value}")
```

### Dict Comprehensions
Just like lists, you can build dictionaries dynamically.

```python
# Map number to its square
squares = {x: x**2 for x in range(5)}
# Result: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
```

---

## 3. Sets (Unique Collection)

A `set` is an unordered collection of **unique** elements. It is implemented as a hash table without values.

**Use Cases**: Removing duplicates, membership testing, and mathematical set operations.

```python
numbers = {1, 2, 2, 3, 3, 3}
print(numbers) # {1, 2, 3} (Duplicates removed automatically)

a = {1, 2, 3}
b = {3, 4, 5}

print(a | b) # Union: {1, 2, 3, 4, 5} (Items in either)
print(a & b) # Intersection: {3} (Items in both)
print(a - b) # Difference: {1, 2} (Items in a but not b)
```

---

## 4. Tuples (Immutable Lists)

A `tuple` is like a list, but it cannot be changed (immutable).

**Why use tuples?**
1.  **Safety**: Guarantees data hasn't changed.
2.  **Performance**: Slightly faster than lists.
3.  **Hashable**: Can be used as dictionary keys (lists cannot).

```python
point = (10, 20)
# point[0] = 30 # TypeError!

# Unpacking
x, y = point
print(x, y) # 10 20
```

---

## 5. The `collections` Module

The standard library `collections` module provides specialized data structures that go beyond the basics.

### `Counter`
A dictionary subclass for counting hashable objects.

```python
from collections import Counter

colors = ["red", "blue", "red", "green", "blue", "blue"]
c = Counter(colors)

print(c) # Counter({'blue': 3, 'red': 2, 'green': 1})
print(c.most_common(1)) # [('blue', 3)]
```

### `defaultdict`
A dictionary that provides a default value for missing keys. This avoids `KeyError` and manual checks.

```python
from collections import defaultdict

# Default value is list() -> []
groups = defaultdict(list)

groups["A"].append("Alice") # Key "A" didn't exist, so it created [], then appended.
groups["B"].append("Bob")
```

---

## Summary

-   **Lists**: Ordered, mutable. Use for sequences of data.
-   **Dicts**: Key-Value. Use for lookups and structured data.
-   **Sets**: Unique. Use for math and deduplication.
-   **Tuples**: Immutable. Use for fixed records.
-   **Comprehensions**: The concise way to build lists and dicts.

Next, we'll organize our code using **Object-Oriented Programming**.
