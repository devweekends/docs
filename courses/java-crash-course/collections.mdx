---
title: "Collections Framework"
sidebarTitle: "3. Collections"
icon: "layer-group"
---

# Collections

Java's Collections Framework provides powerful, flexible data structures for storing and manipulating groups of objects. Collections are generic, type-safe, and highly optimized.

---

## Types of Collections

- **List**: Ordered, allows duplicates (e.g., `ArrayList`, `LinkedList`)
- **Set**: Unordered, no duplicates (e.g., `HashSet`, `TreeSet`)
- **Map**: Key-value pairs (e.g., `HashMap`, `TreeMap`)
- **Queue/Deque**: FIFO/LIFO structures (e.g., `LinkedList`, `ArrayDeque`)

---

## Lists

Lists store ordered elements and allow duplicates.
```java
List<String> names = new ArrayList<>();
names.add("John");
names.add("Jane");
System.out.println(names.get(0)); // John

// Immutable (Java 9+)
List<String> immutable = List.of("a", "b", "c");
```

**Iterating over a list:**
```java
for (String name : names) {
    System.out.println(name);
}

// Using an iterator
Iterator<String> it = names.iterator();
while (it.hasNext()) {
    System.out.println(it.next());
}
```

---

## Sets

Sets store unique elements (no duplicates).
```java
Set<String> fruits = new HashSet<>();
fruits.add("Apple");
fruits.add("Banana");
fruits.add("Apple"); // Duplicate, ignored
System.out.println(fruits.size()); // 2
```

---

## Maps

Maps store key-value pairs.
```java
Map<String, Integer> ages = new HashMap<>();
ages.put("John", 25);
ages.put("Jane", 30);

// Iterate
for (Map.Entry<String, Integer> entry : ages.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}
```

---

## Queues

Queues are FIFO (first-in, first-out) structures.
```java
Queue<String> queue = new LinkedList<>();
queue.add("A");
queue.add("B");
System.out.println(queue.poll()); // A
```

---

## Generics

Collections use generics for type safety:
```java
List<Integer> numbers = new ArrayList<>();
numbers.add(1);
// numbers.add("two"); // Compile error
```

---

## Streams (Java 8+)

Streams process collections in a functional style.
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Filter and map
List<Integer> doubled = numbers.stream()
    .filter(n -> n % 2 == 0)
    .map(n -> n * 2)
    .collect(Collectors.toList());

// Reduce
int sum = numbers.stream()
    .reduce(0, Integer::sum);

// Group by
// Suppose you have: List<Person> people;
Map<Integer, List<Person>> grouped = people.stream()
    .collect(Collectors.groupingBy(Person::getAge));
```

---

## Common Pitfalls
- Forgetting to use generics (raw types)
- Modifying a collection while iterating (use `Iterator.remove()`)
- Using mutable objects as map keys (can break hash-based collections)

---

## Summary

You now know how to use Java's core collections: lists, sets, maps, queues, and streams. Practice by manipulating and transforming data with these tools.

**Next:** Learn about concurrency in Java.
