---
title: "Modern Java Features"
sidebarTitle: "5. Modern Java"
icon: "star"
---


# Modern Java

Modern Java (Java 8+) brings powerful new features for cleaner, more expressive code. These features make Java more functional, concise, and safe. This chapter covers lambdas, streams, Optionals, type inference, records, pattern matching, and more.

---


## Lambda Expressions (Java 8)

Lambdas let you write functions inline, making code concise and readable.

```java
// Traditional
Comparator<String> comp = new Comparator<String>() {
    public int compare(String s1, String s2) {
        return s1.length() - s2.length();
    }
};

// Lambda
Comparator<String> comp = (s1, s2) -> s1.length() - s2.length();

// Method reference
names.forEach(System.out::println);
```

**Functional interfaces:**
A functional interface has a single abstract method. Examples: `Runnable`, `Callable`, `Comparator`, `Function<T,R>`.

```java
@FunctionalInterface
interface MathOp {
    int operate(int a, int b);
}
MathOp add = (a, b) -> a + b;
System.out.println(add.operate(2, 3)); // 5
```

---


## Streams (Java 8)

Streams process collections in a functional style.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> doubled = numbers.stream()
    .filter(n -> n % 2 == 0)
    .map(n -> n * 2)
    .collect(Collectors.toList());
```

**Other stream operations:**
```java
long count = numbers.stream().count();
boolean anyEven = numbers.stream().anyMatch(n -> n % 2 == 0);
int sum = numbers.stream().reduce(0, Integer::sum);
```

---


## Optional (Java 8)

Optional helps avoid `null` pointer errors by representing values that may or may not be present.

```java
Optional<String> optional = Optional.of("value");

// Check if present
if (optional.isPresent()) {
    System.out.println(optional.get());
}

// Or else
String value = optional.orElse("default");

// Map
Optional<Integer> length = optional.map(String::length);
```

**Best practices:**
- Use `Optional` as a return type, not for fields or parameters
- Use `ifPresent`, `orElse`, `orElseGet`, `orElseThrow` for safe handling
```java
optional.ifPresent(System.out::println);
```

---


## Type Inference (var, Java 10+)

`var` lets the compiler infer variable types:

```java
var message = "Hello"; // String
var list = new ArrayList<Integer>(); // ArrayList<Integer>
```

**Limitations:**
- Only for local variables (not fields, method parameters, or return types)

---


---

## Best Practices
- Use lambdas and streams for concise code
- Use `Optional` to avoid nulls
- Prefer `var` for local variables when type is obvious

---

## Common Pitfalls
- Overusing streams for simple loops
- Misusing `Optional` (e.g., for fields)
- Forgetting `var` is only for local variables

---

## Summary

You now know the essentials of modern Java: lambdas, streams, Optionals, type inference, records, pattern matching, and more. Use these features to write clean, modern Java code.

**Congratulations!** You now know the essentials of modern Java.

---

## Text Blocks (Java 15+)
Text blocks make it easy to write multi-line strings:
```java
String json = """
    {
        "name": "John",
        "age": 25
    }
    """;
```

---

## Records (Java 14+)
Records are concise classes for immutable data:
```java
public record Person(String name, int age) {}

Person p = new Person("John", 25);
System.out.println(p.name());
```

---

## Sealed Classes (Java 17+)
Sealed classes restrict which classes can extend them:
```java
public sealed class Shape permits Circle, Square {}
final class Circle extends Shape {}
final class Square extends Shape {}
```

---

## Pattern Matching (Java 16+)
Pattern matching simplifies type checks and switch statements:
```java
// instanceof
if (obj instanceof String s) {
    System.out.println(s.toUpperCase());
}

// Switch (Java 17+)
String result = switch (obj) {
    case Integer i -> "Integer: " + i;
    case String s -> "String: " + s;
    default -> "Unknown";
};
```

## Text Blocks (Java 15)
```java
String json = """
    {
        "name": "John",
        "age": 25
    }
    """;
```

## Records (Java 14)
```java
public record Person(String name, int age) {}

Person p = new Person("John", 25);
System.out.println(p.name());
```

## Pattern Matching (Java 16+)
```java
// instanceof
if (obj instanceof String s) {
    System.out.println(s.toUpperCase());
}

// Switch (Java 17+)
String result = switch (obj) {
    case Integer i -> "Integer: " + i;
    case String s -> "String: " + s;
    default -> "Unknown";
};
```
