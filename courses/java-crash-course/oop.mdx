---
title: "Object-Oriented Programming"
sidebarTitle: "2. OOP"
icon: "object-group"
---

# OOP in Java

Object-Oriented Programming (OOP) is the heart of Java. OOP lets you model real-world things as objects in code. Java is built around four main OOP principles: encapsulation, inheritance, polymorphism, and abstraction.

---

## Classes & Objects

A class is a blueprint for objects. An object is an instance of a class.

```java
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

// Creating an object
Person alice = new Person("Alice", 30);
System.out.println(alice.getName()); // Alice
```


**Explanation:**
- `private` fields hide data from outside code (encapsulation)
- Methods let you interact with the object
- Constructors initialize new objects
- Use `this` to refer to the current object's fields

**Access Modifiers:**
- `private`: only accessible within the class
- `public`: accessible from anywhere
- `protected`: accessible in subclasses

---

## Encapsulation

Encapsulation means hiding internal details and exposing only whatâ€™s necessary. Use `private` fields and `public` getters/setters.

---

---

## Inheritance

Inheritance lets you create new classes based on existing ones.

```java
public abstract class Animal {
    protected String name;

    public Animal(String name) {
        this.name = name;
    }

    public abstract void makeSound();
}

public class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }

    @Override
    public void makeSound() {
        System.out.println("Woof!");
    }
}

Dog dog = new Dog("Buddy");
dog.makeSound(); // Woof!
```


**Abstract Classes vs. Interfaces:**
- Abstract class: can have both abstract and concrete methods, can have fields
- Interface: only method signatures (until Java 8, now can have default/static methods), no fields (except static final)

---

## Polymorphism

Polymorphism lets you use a superclass reference to refer to subclass objects:
```java
Animal animal = new Dog("Rex");
animal.makeSound(); // Woof!
```

---

## Interfaces

Interfaces define contracts for classes to implement. A class can implement multiple interfaces.


```java
interface Drawable {
    void draw();
}

class Circle implements Drawable {
    public void draw() {
        System.out.println("Drawing a circle");
    }
}

Drawable d = new Circle();
d.draw(); // Drawing a circle
```

---

## Generics

Generics let you write classes and methods that work with any type:
```java
class Box<T> {
    private T value;
    public void set(T value) { this.value = value; }
    public T get() { return value; }
}

Box<Integer> intBox = new Box<>();
intBox.set(123);
System.out.println(intBox.get()); // 123
```

---

## Error Handling in OOP

Use exceptions to signal errors in methods:
```java
public void setAge(int age) {
    if (age < 0) throw new IllegalArgumentException("Age must be positive");
    this.age = age;
}
```

---

## Common Pitfalls
- Forgetting to use `@Override` when overriding methods
- Not initializing fields in constructors
- Confusing `abstract` class with `interface`

---

## Summary

You now know how to define classes, use inheritance, interfaces, encapsulation, and generics. Practice by modeling real-world objects and relationships in code.

**Next:** Explore Java's Collections Framework.

---

## Best Practices
- Use `private` for fields, provide getters/setters
- Use `@Override` when overriding methods
- Favor composition over inheritance when possible

---


