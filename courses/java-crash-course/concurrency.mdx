---
title: "Concurrency"
sidebarTitle: "4. Concurrency"
icon: "bolt"
---

# Concurrency

Concurrency lets your program do many things at once—great for performance and responsiveness. It's essential for modern applications (servers, GUIs, games, etc.).

---

## Why Concurrency?

- Improves performance on multi-core CPUs
- Keeps applications responsive (e.g., UI, servers)
- Handles many tasks (networking, file I/O) efficiently

---

---

## Threads

The basic unit of concurrency. Each thread runs code independently.

```java
// Runnable task
Runnable task = () -> {
    System.out.println("Task running");
};

Thread thread = new Thread(task);
thread.start();
```


**Explanation:**
- `Runnable` is a block of code to run
- `Thread.start()` begins execution in a new thread

**Thread lifecycle:**
- New → Runnable → Running → Blocked/Waiting → Terminated

---

## Synchronization

When multiple threads access shared data, use `synchronized` to avoid race conditions:
```java
public synchronized void increment() {
    count++;
}
```

Or use synchronized blocks:
```java
synchronized(this) {
    // critical section
}
```

---

## Deadlocks

Deadlocks happen when threads wait forever for each other. Avoid by always locking resources in the same order.

---

---

## Executors

Executors manage thread pools for you—safer and more scalable than manual threads.

```java
ExecutorService executor = Executors.newFixedThreadPool(4);

executor.submit(() -> {
    System.out.println("Task 1");
});

// Callable returns a result
Future<Integer> future = executor.submit(() -> 42);
int result = future.get(); // blocks until result is ready

executor.shutdown();
```

---

## Concurrent Collections

Special collections for safe use by multiple threads.

```java
Map<String, Integer> map = new ConcurrentHashMap<>();
List<String> list = new CopyOnWriteArrayList<>();
```

---

## Blocking Queues

Blocking queues are thread-safe queues for producer-consumer scenarios:
```java
BlockingQueue<String> queue = new LinkedBlockingQueue<>();
queue.put("item"); // blocks if full
String item = queue.take(); // blocks if empty
```

---

## CompletableFuture (Java 8+)

CompletableFuture makes async programming easier:
```java
CompletableFuture<String> future = CompletableFuture
    .supplyAsync(() -> "Hello")
    .thenApply(s -> s + " World")
    .thenApply(String::toUpperCase);
System.out.println(future.join()); // HELLO WORLD
```

---

## Common Pitfalls
- Not shutting down executors (can cause app to hang)
- Race conditions from unsynchronized access
- Deadlocks from improper locking
- Blocking the main/UI thread

---

## Best Practices
- Always shut down executors
- Avoid shared mutable state when possible
- Use concurrent collections for thread safety
- Prefer higher-level concurrency utilities (Executors, CompletableFuture)

---

## Summary

You now know the basics of Java concurrency: threads, synchronization, thread pools, concurrent collections, and async programming. Practice by writing simple multi-threaded programs.

**Next:** Learn about Modern Java features.
String result = future.get(); // "HELLO WORLD"
```
