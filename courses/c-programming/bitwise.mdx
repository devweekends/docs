---
title: "Bitwise Operations"
sidebarTitle: "Bitwise Operations"
description: "Master bit manipulation, flags, masks, and low-level data packing"
icon: "binary"
---

# Bitwise Operations

Bit manipulation is the foundation of systems programming. From hardware registers to network protocols, understanding bits gives you ultimate control.

---

## Why Bits Matter

<CardGroup cols={2}>
  <Card title="Memory Efficiency" icon="memory">
    Pack 8 flags into 1 byte instead of 8 bytes
  </Card>
  <Card title="Performance" icon="bolt">
    Bitwise operations are single CPU instructions
  </Card>
  <Card title="Hardware Control" icon="microchip">
    All hardware registers are bit-manipulated
  </Card>
  <Card title="Protocol Implementation" icon="network-wired">
    Network protocols pack data at bit level
  </Card>
</CardGroup>

---

## Bitwise Operators

### The Six Operators

```c
#include <stdio.h>
#include <stdint.h>

int main(void) {
    uint8_t a = 0b10110100;  // 180
    uint8_t b = 0b01101010;  // 106
    
    // AND (&) - Both bits must be 1
    printf("AND:  %08b\n", a & b);   // 00100000 (32)
    
    // OR (|) - At least one bit must be 1
    printf("OR:   %08b\n", a | b);   // 11111110 (254)
    
    // XOR (^) - Exactly one bit must be 1
    printf("XOR:  %08b\n", a ^ b);   // 11011110 (222)
    
    // NOT (~) - Flip all bits
    printf("NOT:  %08b\n", (uint8_t)~a);  // 01001011 (75)
    
    // Left shift (<<) - Multiply by 2^n
    printf("<<2:  %08b\n", (uint8_t)(a << 2));  // 11010000 (208)
    
    // Right shift (>>) - Divide by 2^n
    printf(">>2:  %08b\n", a >> 2);   // 00101101 (45)
    
    return 0;
}
```

### Truth Tables

```
AND (&)     OR (|)      XOR (^)     NOT (~)
┌───┬───┬───┐  ┌───┬───┬───┐  ┌───┬───┬───┐  ┌───┬───┐
│ A │ B │ R │  │ A │ B │ R │  │ A │ B │ R │  │ A │ R │
├───┼───┼───┤  ├───┼───┼───┤  ├───┼───┼───┤  ├───┼───┤
│ 0 │ 0 │ 0 │  │ 0 │ 0 │ 0 │  │ 0 │ 0 │ 0 │  │ 0 │ 1 │
│ 0 │ 1 │ 0 │  │ 0 │ 1 │ 1 │  │ 0 │ 1 │ 1 │  │ 1 │ 0 │
│ 1 │ 0 │ 0 │  │ 1 │ 0 │ 1 │  │ 1 │ 0 │ 1 │  └───┴───┘
│ 1 │ 1 │ 1 │  │ 1 │ 1 │ 1 │  │ 1 │ 1 │ 0 │
└───┴───┴───┘  └───┴───┴───┘  └───┴───┴───┘
```

---

## Bit Manipulation Patterns

### The Essential Patterns

```c
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>

// SET a bit at position n
#define SET_BIT(x, n)     ((x) |= (1U << (n)))

// CLEAR a bit at position n
#define CLEAR_BIT(x, n)   ((x) &= ~(1U << (n)))

// TOGGLE a bit at position n
#define TOGGLE_BIT(x, n)  ((x) ^= (1U << (n)))

// CHECK if bit at position n is set
#define CHECK_BIT(x, n)   (((x) >> (n)) & 1U)

// GET the value of bit at position n
#define GET_BIT(x, n)     (((x) >> (n)) & 1U)

int main(void) {
    uint8_t flags = 0b00000000;
    
    // Set bit 3
    SET_BIT(flags, 3);
    printf("After SET_BIT(3):    %08b\n", flags);  // 00001000
    
    // Set bit 5
    SET_BIT(flags, 5);
    printf("After SET_BIT(5):    %08b\n", flags);  // 00101000
    
    // Check bit 3
    printf("Bit 3 is: %d\n", CHECK_BIT(flags, 3)); // 1
    printf("Bit 4 is: %d\n", CHECK_BIT(flags, 4)); // 0
    
    // Toggle bit 3
    TOGGLE_BIT(flags, 3);
    printf("After TOGGLE_BIT(3): %08b\n", flags);  // 00100000
    
    // Clear bit 5
    CLEAR_BIT(flags, 5);
    printf("After CLEAR_BIT(5):  %08b\n", flags);  // 00000000
    
    return 0;
}
```

### Multi-Bit Operations

```c
#include <stdint.h>

// Create a mask of n bits
#define MASK(n)           ((1U << (n)) - 1)

// Extract n bits starting at position p
#define EXTRACT_BITS(x, p, n)  (((x) >> (p)) & MASK(n))

// Insert value into x at position p, replacing n bits
#define INSERT_BITS(x, p, n, v) \
    (((x) & ~(MASK(n) << (p))) | (((v) & MASK(n)) << (p)))

// Clear the lowest set bit
#define CLEAR_LOWEST_SET(x)    ((x) & ((x) - 1))

// Isolate the lowest set bit
#define LOWEST_SET_BIT(x)      ((x) & -(x))

// Check if x is power of 2
#define IS_POWER_OF_2(x)       ((x) && !((x) & ((x) - 1)))

int main(void) {
    uint16_t value = 0b1101011010110100;
    
    // Extract 4 bits starting at position 4
    uint16_t extracted = EXTRACT_BITS(value, 4, 4);
    // Result: 1011 (11)
    
    // Insert 0xF at position 8, replacing 4 bits
    uint16_t modified = INSERT_BITS(value, 8, 4, 0xF);
    // Result: 1111011010110100
    
    // Power of 2 checks
    printf("8 is power of 2: %d\n", IS_POWER_OF_2(8));   // 1
    printf("12 is power of 2: %d\n", IS_POWER_OF_2(12)); // 0
    
    return 0;
}
```

---

## Bit Flags and Enums

### Flag Patterns

```c
#include <stdio.h>
#include <stdint.h>

// Define flags as powers of 2
typedef enum {
    FLAG_NONE       = 0,
    FLAG_READ       = (1 << 0),  // 0x01
    FLAG_WRITE      = (1 << 1),  // 0x02
    FLAG_EXECUTE    = (1 << 2),  // 0x04
    FLAG_HIDDEN     = (1 << 3),  // 0x08
    FLAG_SYSTEM     = (1 << 4),  // 0x10
    FLAG_ARCHIVE    = (1 << 5),  // 0x20
    
    // Combinations
    FLAG_RW         = FLAG_READ | FLAG_WRITE,
    FLAG_RWX        = FLAG_READ | FLAG_WRITE | FLAG_EXECUTE,
    FLAG_ALL        = 0x3F
} FileFlags;

void print_flags(FileFlags flags) {
    printf("Flags: ");
    if (flags & FLAG_READ)    printf("READ ");
    if (flags & FLAG_WRITE)   printf("WRITE ");
    if (flags & FLAG_EXECUTE) printf("EXECUTE ");
    if (flags & FLAG_HIDDEN)  printf("HIDDEN ");
    if (flags & FLAG_SYSTEM)  printf("SYSTEM ");
    if (flags & FLAG_ARCHIVE) printf("ARCHIVE ");
    printf("\n");
}

int main(void) {
    FileFlags perms = FLAG_NONE;
    
    // Set read and write
    perms |= FLAG_RW;
    print_flags(perms);  // READ WRITE
    
    // Add execute
    perms |= FLAG_EXECUTE;
    print_flags(perms);  // READ WRITE EXECUTE
    
    // Remove write
    perms &= ~FLAG_WRITE;
    print_flags(perms);  // READ EXECUTE
    
    // Check permissions
    if (perms & FLAG_READ) {
        printf("File is readable\n");
    }
    
    // Check if has ALL of required permissions
    FileFlags required = FLAG_READ | FLAG_EXECUTE;
    if ((perms & required) == required) {
        printf("Has all required permissions\n");
    }
    
    // Check if has ANY of the permissions
    FileFlags any_of = FLAG_WRITE | FLAG_HIDDEN;
    if (perms & any_of) {
        printf("Has at least one of the permissions\n");
    }
    
    return 0;
}
```

### Real-World Example: Unix File Permissions

```c
#include <stdio.h>
#include <sys/stat.h>

// Unix permission bits (from <sys/stat.h>)
/*
S_IRUSR  0400  owner read
S_IWUSR  0200  owner write
S_IXUSR  0100  owner execute
S_IRGRP  0040  group read
S_IWGRP  0020  group write
S_IXGRP  0010  group execute
S_IROTH  0004  others read
S_IWOTH  0002  others write
S_IXOTH  0001  others execute
*/

void print_permissions(mode_t mode) {
    char perms[10];
    
    perms[0] = (mode & S_IRUSR) ? 'r' : '-';
    perms[1] = (mode & S_IWUSR) ? 'w' : '-';
    perms[2] = (mode & S_IXUSR) ? 'x' : '-';
    perms[3] = (mode & S_IRGRP) ? 'r' : '-';
    perms[4] = (mode & S_IWGRP) ? 'w' : '-';
    perms[5] = (mode & S_IXGRP) ? 'x' : '-';
    perms[6] = (mode & S_IROTH) ? 'r' : '-';
    perms[7] = (mode & S_IWOTH) ? 'w' : '-';
    perms[8] = (mode & S_IXOTH) ? 'x' : '-';
    perms[9] = '\0';
    
    printf("%s (octal: %04o)\n", perms, mode & 0777);
}

int main(void) {
    // rwxr-xr-x = 755
    mode_t mode = S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH;
    print_permissions(mode);  // rwxr-xr-x (octal: 0755)
    
    // Remove world read
    mode &= ~S_IROTH;
    print_permissions(mode);  // rwxr-x--x (octal: 0751)
    
    return 0;
}
```

---

## Data Packing

### Packing Multiple Values

```c
#include <stdio.h>
#include <stdint.h>

// Pack RGBA color into 32 bits
// Layout: [AAAA AAAA][RRRR RRRR][GGGG GGGG][BBBB BBBB]
typedef uint32_t Color;

Color make_color(uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
    return ((uint32_t)a << 24) |
           ((uint32_t)r << 16) |
           ((uint32_t)g << 8)  |
           ((uint32_t)b);
}

uint8_t get_red(Color c)   { return (c >> 16) & 0xFF; }
uint8_t get_green(Color c) { return (c >> 8) & 0xFF; }
uint8_t get_blue(Color c)  { return c & 0xFF; }
uint8_t get_alpha(Color c) { return (c >> 24) & 0xFF; }

// Pack IP address
uint32_t ip_to_int(uint8_t a, uint8_t b, uint8_t c, uint8_t d) {
    return ((uint32_t)a << 24) |
           ((uint32_t)b << 16) |
           ((uint32_t)c << 8)  |
           ((uint32_t)d);
}

void int_to_ip(uint32_t ip, uint8_t *a, uint8_t *b, uint8_t *c, uint8_t *d) {
    *a = (ip >> 24) & 0xFF;
    *b = (ip >> 16) & 0xFF;
    *c = (ip >> 8) & 0xFF;
    *d = ip & 0xFF;
}

int main(void) {
    Color red = make_color(255, 0, 0, 255);
    printf("Red color: 0x%08X\n", red);
    printf("R=%d, G=%d, B=%d, A=%d\n",
           get_red(red), get_green(red), get_blue(red), get_alpha(red));
    
    uint32_t ip = ip_to_int(192, 168, 1, 1);
    printf("IP as int: %u\n", ip);  // 3232235777
    
    uint8_t a, b, c, d;
    int_to_ip(ip, &a, &b, &c, &d);
    printf("IP: %d.%d.%d.%d\n", a, b, c, d);  // 192.168.1.1
    
    return 0;
}
```

### Bit Fields (Compiler-Managed Packing)

```c
#include <stdio.h>
#include <stdint.h>

// Bit fields let the compiler pack bits for you
struct PackedFlags {
    uint8_t read    : 1;  // 1 bit
    uint8_t write   : 1;  // 1 bit
    uint8_t execute : 1;  // 1 bit
    uint8_t hidden  : 1;  // 1 bit
    uint8_t system  : 1;  // 1 bit
    uint8_t archive : 1;  // 1 bit
    uint8_t padding : 2;  // 2 bits (explicit padding)
};

// Network protocol header (TCP flags)
struct TCPFlags {
    uint16_t fin : 1;
    uint16_t syn : 1;
    uint16_t rst : 1;
    uint16_t psh : 1;
    uint16_t ack : 1;
    uint16_t urg : 1;
    uint16_t ece : 1;
    uint16_t cwr : 1;
    uint16_t ns  : 1;
    uint16_t reserved : 3;
    uint16_t data_offset : 4;
};

// Date packed into 16 bits (DOS format)
struct DOSDate {
    uint16_t day   : 5;   // 1-31
    uint16_t month : 4;   // 1-12
    uint16_t year  : 7;   // 0-127 (offset from 1980)
};

int main(void) {
    printf("sizeof(PackedFlags) = %zu\n", sizeof(struct PackedFlags));  // 1
    printf("sizeof(DOSDate) = %zu\n", sizeof(struct DOSDate));          // 2
    
    struct PackedFlags flags = {
        .read = 1,
        .write = 1,
        .execute = 0,
        .hidden = 0,
        .system = 0,
        .archive = 1
    };
    
    printf("read=%d, write=%d, archive=%d\n",
           flags.read, flags.write, flags.archive);
    
    struct DOSDate date = {
        .day = 15,
        .month = 7,
        .year = 44  // 1980 + 44 = 2024
    };
    
    printf("Date: %d/%d/%d\n", date.month, date.day, 1980 + date.year);
    
    return 0;
}
```

<Warning>
**Bit Field Portability Warning**: The ordering of bit fields (MSB first vs LSB first) is implementation-defined. For portable network protocols or file formats, use explicit shift operations instead.
</Warning>

---

## Common Bit Manipulation Algorithms

### Count Set Bits (Population Count)

```c
#include <stdio.h>
#include <stdint.h>

// Naive approach - O(number of bits)
int popcount_naive(uint32_t n) {
    int count = 0;
    while (n) {
        count += n & 1;
        n >>= 1;
    }
    return count;
}

// Brian Kernighan's algorithm - O(number of set bits)
int popcount_kernighan(uint32_t n) {
    int count = 0;
    while (n) {
        n &= (n - 1);  // Clear lowest set bit
        count++;
    }
    return count;
}

// Lookup table - O(1) with preprocessing
static const uint8_t PopCountTable[256] = {
    0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,
    1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,
    // ... (256 entries total)
};

int popcount_table(uint32_t n) {
    return PopCountTable[n & 0xFF] +
           PopCountTable[(n >> 8) & 0xFF] +
           PopCountTable[(n >> 16) & 0xFF] +
           PopCountTable[(n >> 24) & 0xFF];
}

// Using compiler builtin (fastest)
int popcount_builtin(uint32_t n) {
    return __builtin_popcount(n);  // GCC/Clang
}

int main(void) {
    uint32_t n = 0b10110111001011010110101101101101;
    
    printf("Naive:     %d\n", popcount_naive(n));
    printf("Kernighan: %d\n", popcount_kernighan(n));
    printf("Builtin:   %d\n", popcount_builtin(n));
    
    return 0;
}
```

### Find First/Last Set Bit

```c
#include <stdio.h>
#include <stdint.h>

// Find position of lowest set bit (1-indexed, 0 if none)
int find_first_set(uint32_t n) {
    if (n == 0) return 0;
    return __builtin_ffs(n);  // GCC/Clang builtin
}

// Find position of highest set bit (0-indexed)
int find_last_set(uint32_t n) {
    if (n == 0) return -1;
    return 31 - __builtin_clz(n);  // Count leading zeros
}

// Count trailing zeros
int count_trailing_zeros(uint32_t n) {
    if (n == 0) return 32;
    return __builtin_ctz(n);
}

// Count leading zeros
int count_leading_zeros(uint32_t n) {
    if (n == 0) return 32;
    return __builtin_clz(n);
}

// Log base 2 (floor)
int log2_floor(uint32_t n) {
    if (n == 0) return -1;
    return 31 - __builtin_clz(n);
}

// Next power of 2 (>= n)
uint32_t next_power_of_2(uint32_t n) {
    if (n == 0) return 1;
    n--;
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8;
    n |= n >> 16;
    return n + 1;
}

int main(void) {
    uint32_t n = 0b00101000;  // 40
    
    printf("First set bit: position %d\n", find_first_set(n));  // 4 (1-indexed)
    printf("Last set bit: position %d\n", find_last_set(n));    // 5 (0-indexed)
    printf("Trailing zeros: %d\n", count_trailing_zeros(n));    // 3
    printf("Leading zeros: %d\n", count_leading_zeros(n));      // 26
    printf("log2(40) = %d\n", log2_floor(40));                  // 5
    printf("Next power of 2 after 40: %u\n", next_power_of_2(40)); // 64
    
    return 0;
}
```

### Bit Reversal

```c
#include <stdio.h>
#include <stdint.h>

// Reverse bits in a byte
uint8_t reverse_byte(uint8_t b) {
    b = (b & 0xF0) >> 4 | (b & 0x0F) << 4;
    b = (b & 0xCC) >> 2 | (b & 0x33) << 2;
    b = (b & 0xAA) >> 1 | (b & 0x55) << 1;
    return b;
}

// Reverse bits in 32-bit word
uint32_t reverse_bits(uint32_t n) {
    n = (n >> 16) | (n << 16);
    n = ((n & 0xFF00FF00) >> 8) | ((n & 0x00FF00FF) << 8);
    n = ((n & 0xF0F0F0F0) >> 4) | ((n & 0x0F0F0F0F) << 4);
    n = ((n & 0xCCCCCCCC) >> 2) | ((n & 0x33333333) << 2);
    n = ((n & 0xAAAAAAAA) >> 1) | ((n & 0x55555555) << 1);
    return n;
}

// Swap adjacent bits
uint32_t swap_adjacent_bits(uint32_t n) {
    return ((n & 0xAAAAAAAA) >> 1) | ((n & 0x55555555) << 1);
}
```

---

## Bit Manipulation in Practice

### Hardware Register Access

```c
#include <stdint.h>

// Simulated hardware register (in real code, this would be memory-mapped)
volatile uint32_t *GPIO_CONTROL = (volatile uint32_t *)0x40020000;

// Register bit definitions
#define GPIO_PIN0_OUTPUT  (1 << 0)
#define GPIO_PIN0_HIGH    (1 << 1)
#define GPIO_PIN1_OUTPUT  (1 << 2)
#define GPIO_PIN1_HIGH    (1 << 3)
#define GPIO_PULLUP_EN    (1 << 16)
#define GPIO_FAST_MODE    (1 << 17)

// Set pin 0 as output, high, with pullup
void configure_gpio(void) {
    *GPIO_CONTROL = GPIO_PIN0_OUTPUT | GPIO_PIN0_HIGH | GPIO_PULLUP_EN;
}

// Set pin 0 low without affecting other bits
void set_pin0_low(void) {
    *GPIO_CONTROL &= ~GPIO_PIN0_HIGH;
}

// Toggle pin 0
void toggle_pin0(void) {
    *GPIO_CONTROL ^= GPIO_PIN0_HIGH;
}

// Read-Modify-Write pattern (atomic in single-threaded context)
void enable_fast_mode(void) {
    uint32_t reg = *GPIO_CONTROL;  // Read
    reg |= GPIO_FAST_MODE;          // Modify
    *GPIO_CONTROL = reg;            // Write
}
```

### Network Protocol Parsing

```c
#include <stdio.h>
#include <stdint.h>
#include <arpa/inet.h>

// IPv4 header (20 bytes minimum)
struct IPv4Header {
    uint8_t  version_ihl;      // 4 bits version, 4 bits header length
    uint8_t  tos;
    uint16_t total_length;
    uint16_t identification;
    uint16_t flags_fragment;   // 3 bits flags, 13 bits fragment offset
    uint8_t  ttl;
    uint8_t  protocol;
    uint16_t checksum;
    uint32_t src_addr;
    uint32_t dst_addr;
};

void parse_ipv4(const uint8_t *packet) {
    const struct IPv4Header *ip = (const struct IPv4Header *)packet;
    
    // Extract version (upper 4 bits)
    uint8_t version = (ip->version_ihl >> 4) & 0x0F;
    
    // Extract header length (lower 4 bits, in 32-bit words)
    uint8_t ihl = ip->version_ihl & 0x0F;
    uint8_t header_len = ihl * 4;
    
    // Extract flags (upper 3 bits of flags_fragment)
    uint16_t flags_frag = ntohs(ip->flags_fragment);
    uint8_t flags = (flags_frag >> 13) & 0x07;
    uint16_t fragment_offset = flags_frag & 0x1FFF;
    
    // Flag meanings
    int reserved = (flags >> 2) & 1;
    int dont_fragment = (flags >> 1) & 1;
    int more_fragments = flags & 1;
    
    printf("IP Version: %d\n", version);
    printf("Header Length: %d bytes\n", header_len);
    printf("TTL: %d\n", ip->ttl);
    printf("Protocol: %d\n", ip->protocol);
    printf("Flags: DF=%d, MF=%d\n", dont_fragment, more_fragments);
    printf("Fragment Offset: %d\n", fragment_offset * 8);
}
```

---

## Exercises

<Accordion title="Exercise 1: Implement a Bitset" icon="code">
Implement a bitset data structure that can store N bits efficiently:

```c
typedef struct {
    uint64_t *data;
    size_t num_bits;
} Bitset;

Bitset *bitset_create(size_t num_bits);
void bitset_destroy(Bitset *bs);
void bitset_set(Bitset *bs, size_t index);
void bitset_clear(Bitset *bs, size_t index);
bool bitset_test(Bitset *bs, size_t index);
void bitset_toggle(Bitset *bs, size_t index);
size_t bitset_count(Bitset *bs);  // Count set bits
void bitset_and(Bitset *dst, const Bitset *src);  // dst &= src
void bitset_or(Bitset *dst, const Bitset *src);   // dst |= src
```
</Accordion>

<Accordion title="Exercise 2: Base64 Encoder" icon="code">
Implement Base64 encoding using bit manipulation:

```c
// Base64 packs 3 bytes (24 bits) into 4 characters (6 bits each)
// Alphabet: A-Z, a-z, 0-9, +, /

char *base64_encode(const uint8_t *data, size_t len);
uint8_t *base64_decode(const char *encoded, size_t *out_len);
```
</Accordion>

<Accordion title="Exercise 3: Bit-Packed Date" icon="code">
Pack a date into 32 bits with validation:

```c
// Layout:
// - Year: 12 bits (0-4095)
// - Month: 4 bits (1-12)
// - Day: 5 bits (1-31)
// - Hour: 5 bits (0-23)
// - Minute: 6 bits (0-59)

typedef uint32_t PackedDateTime;

PackedDateTime pack_datetime(int year, int month, int day, 
                             int hour, int minute);
void unpack_datetime(PackedDateTime dt, int *year, int *month, 
                     int *day, int *hour, int *minute);
bool is_valid_datetime(PackedDateTime dt);
```
</Accordion>

---

## Key Takeaways

<CardGroup cols={2}>
  <Card title="Use Named Constants" icon="check">
    Always use `#define` or `enum` for bit positions. Never use magic numbers.
  </Card>
  <Card title="Prefer Unsigned Types" icon="check">
    Right-shift on signed integers is implementation-defined. Use unsigned.
  </Card>
  <Card title="Use Compiler Builtins" icon="check">
    `__builtin_popcount`, `__builtin_clz`, etc. compile to single instructions.
  </Card>
  <Card title="Document Bit Layouts" icon="check">
    Always comment the bit layout for packed structures.
  </Card>
</CardGroup>
