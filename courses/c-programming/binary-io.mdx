---
title: "Binary I/O & File Formats"
sidebarTitle: "Binary I/O"
description: "Master binary file handling, endianness, serialization, and file format design"
icon: "file-binary"
---

# Binary I/O & File Formats

Reading and writing binary data is essential for systems programmingâ€”from file formats to network protocols. Learn to handle endianness, struct packing, and serialization correctly.

---

## Binary vs Text Files

<CardGroup cols={2}>
  <Card title="Text Files" icon="file-lines">
    Human-readable, portable, larger size, slower to parse
  </Card>
  <Card title="Binary Files" icon="file-binary">
    Machine-readable, compact, fast, platform-dependent
  </Card>
</CardGroup>

### When to Use Binary

| Use Binary | Use Text |
|------------|----------|
| Performance critical | Configuration files |
| Fixed-format data | Logs |
| Image/audio/video | Human-edited data |
| Network protocols | Interchange formats (JSON/XML) |
| Memory dumps | Debugging output |

---

## Basic Binary I/O

### Writing Binary Data

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

struct Record {
    uint32_t id;
    float value;
    char name[32];
};

int write_records(const char *filename, const struct Record *records, size_t count) {
    FILE *fp = fopen(filename, "wb");  // "wb" = write binary
    if (!fp) {
        perror("fopen");
        return -1;
    }
    
    // Write header
    uint32_t magic = 0x52454344;  // "RECD"
    uint32_t version = 1;
    uint32_t num_records = (uint32_t)count;
    
    fwrite(&magic, sizeof(magic), 1, fp);
    fwrite(&version, sizeof(version), 1, fp);
    fwrite(&num_records, sizeof(num_records), 1, fp);
    
    // Write records
    size_t written = fwrite(records, sizeof(struct Record), count, fp);
    if (written != count) {
        perror("fwrite");
        fclose(fp);
        return -1;
    }
    
    fclose(fp);
    return 0;
}

int read_records(const char *filename, struct Record **records, size_t *count) {
    FILE *fp = fopen(filename, "rb");  // "rb" = read binary
    if (!fp) {
        perror("fopen");
        return -1;
    }
    
    // Read and validate header
    uint32_t magic, version, num_records;
    fread(&magic, sizeof(magic), 1, fp);
    fread(&version, sizeof(version), 1, fp);
    fread(&num_records, sizeof(num_records), 1, fp);
    
    if (magic != 0x52454344) {
        fprintf(stderr, "Invalid file format\n");
        fclose(fp);
        return -1;
    }
    
    if (version != 1) {
        fprintf(stderr, "Unsupported version: %u\n", version);
        fclose(fp);
        return -1;
    }
    
    // Allocate and read records
    *records = malloc(num_records * sizeof(struct Record));
    if (!*records) {
        fclose(fp);
        return -1;
    }
    
    size_t read_count = fread(*records, sizeof(struct Record), num_records, fp);
    if (read_count != num_records) {
        free(*records);
        fclose(fp);
        return -1;
    }
    
    *count = num_records;
    fclose(fp);
    return 0;
}
```

---

## Endianness

### The Problem

```c
#include <stdio.h>
#include <stdint.h>

// Number 0x12345678 in memory:
// 
// Big-endian (network byte order):    [12] [34] [56] [78]
// Little-endian (x86, most systems):  [78] [56] [34] [12]

int main(void) {
    uint32_t value = 0x12345678;
    uint8_t *bytes = (uint8_t *)&value;
    
    printf("Byte order: ");
    for (int i = 0; i < 4; i++) {
        printf("%02X ", bytes[i]);
    }
    printf("\n");
    
    // On little-endian (x86): "78 56 34 12"
    // On big-endian:          "12 34 56 78"
    
    // Detect endianness at runtime
    if (bytes[0] == 0x78) {
        printf("System is little-endian\n");
    } else {
        printf("System is big-endian\n");
    }
    
    return 0;
}
```

### Byte Swapping

```c
#include <stdint.h>

// Swap bytes for 16-bit value
uint16_t swap16(uint16_t value) {
    return ((value & 0xFF00) >> 8) |
           ((value & 0x00FF) << 8);
}

// Swap bytes for 32-bit value
uint32_t swap32(uint32_t value) {
    return ((value & 0xFF000000) >> 24) |
           ((value & 0x00FF0000) >> 8)  |
           ((value & 0x0000FF00) << 8)  |
           ((value & 0x000000FF) << 24);
}

// Swap bytes for 64-bit value
uint64_t swap64(uint64_t value) {
    return ((value & 0xFF00000000000000ULL) >> 56) |
           ((value & 0x00FF000000000000ULL) >> 40) |
           ((value & 0x0000FF0000000000ULL) >> 24) |
           ((value & 0x000000FF00000000ULL) >> 8)  |
           ((value & 0x00000000FF000000ULL) << 8)  |
           ((value & 0x0000000000FF0000ULL) << 24) |
           ((value & 0x000000000000FF00ULL) << 40) |
           ((value & 0x00000000000000FFULL) << 56);
}

// Using compiler builtins (faster, uses BSWAP instruction)
#ifdef __GNUC__
#define bswap16(x) __builtin_bswap16(x)
#define bswap32(x) __builtin_bswap32(x)
#define bswap64(x) __builtin_bswap64(x)
#endif

// Standard POSIX/BSD functions
#include <arpa/inet.h>  // For network byte order functions

uint32_t host_to_network32(uint32_t hostval) {
    return htonl(hostval);  // Host to network long
}

uint32_t network_to_host32(uint32_t netval) {
    return ntohl(netval);  // Network to host long
}

uint16_t host_to_network16(uint16_t hostval) {
    return htons(hostval);  // Host to network short
}

uint16_t network_to_host16(uint16_t netval) {
    return ntohs(netval);  // Network to host short
}
```

### Portable Serialization

```c
#include <stdio.h>
#include <stdint.h>
#include <string.h>

// Write integer in big-endian (network byte order)
void write_be32(uint8_t *buf, uint32_t value) {
    buf[0] = (value >> 24) & 0xFF;
    buf[1] = (value >> 16) & 0xFF;
    buf[2] = (value >> 8) & 0xFF;
    buf[3] = value & 0xFF;
}

void write_be16(uint8_t *buf, uint16_t value) {
    buf[0] = (value >> 8) & 0xFF;
    buf[1] = value & 0xFF;
}

// Read integer from big-endian
uint32_t read_be32(const uint8_t *buf) {
    return ((uint32_t)buf[0] << 24) |
           ((uint32_t)buf[1] << 16) |
           ((uint32_t)buf[2] << 8)  |
           ((uint32_t)buf[3]);
}

uint16_t read_be16(const uint8_t *buf) {
    return ((uint16_t)buf[0] << 8) |
           ((uint16_t)buf[1]);
}

// Little-endian versions
void write_le32(uint8_t *buf, uint32_t value) {
    buf[0] = value & 0xFF;
    buf[1] = (value >> 8) & 0xFF;
    buf[2] = (value >> 16) & 0xFF;
    buf[3] = (value >> 24) & 0xFF;
}

uint32_t read_le32(const uint8_t *buf) {
    return ((uint32_t)buf[3] << 24) |
           ((uint32_t)buf[2] << 16) |
           ((uint32_t)buf[1] << 8)  |
           ((uint32_t)buf[0]);
}

// Write float in big-endian
void write_be_float(uint8_t *buf, float value) {
    uint32_t bits;
    memcpy(&bits, &value, sizeof(bits));  // Type-safe bit conversion
    write_be32(buf, bits);
}

float read_be_float(const uint8_t *buf) {
    uint32_t bits = read_be32(buf);
    float value;
    memcpy(&value, &bits, sizeof(value));
    return value;
}
```

---

## Struct Packing

### The Padding Problem

```c
#include <stdio.h>
#include <stdint.h>
#include <stddef.h>

// Natural alignment - compiler adds padding
struct Unpacked {
    uint8_t  a;   // 1 byte
    // 3 bytes padding (align next to 4-byte boundary)
    uint32_t b;   // 4 bytes
    uint8_t  c;   // 1 byte
    // 1 byte padding (align next to 2-byte boundary)
    uint16_t d;   // 2 bytes
    uint8_t  e;   // 1 byte
    // 3 bytes padding (align struct to largest member)
};  // Total: 16 bytes (not 9!)

int main(void) {
    printf("sizeof(Unpacked) = %zu\n", sizeof(struct Unpacked));  // 16
    
    printf("Offsets:\n");
    printf("  a: %zu\n", offsetof(struct Unpacked, a));  // 0
    printf("  b: %zu\n", offsetof(struct Unpacked, b));  // 4
    printf("  c: %zu\n", offsetof(struct Unpacked, c));  // 8
    printf("  d: %zu\n", offsetof(struct Unpacked, d));  // 10
    printf("  e: %zu\n", offsetof(struct Unpacked, e));  // 12
    
    return 0;
}
```

### Packing Structs

```c
#include <stdio.h>
#include <stdint.h>

// Method 1: GCC/Clang packed attribute
struct __attribute__((packed)) PackedStruct {
    uint8_t  a;
    uint32_t b;
    uint8_t  c;
    uint16_t d;
    uint8_t  e;
};  // Exactly 9 bytes

// Method 2: #pragma pack (more portable)
#pragma pack(push, 1)  // Push current alignment, set to 1-byte
struct PragmaPacked {
    uint8_t  a;
    uint32_t b;
    uint8_t  c;
    uint16_t d;
    uint8_t  e;
};
#pragma pack(pop)  // Restore previous alignment

// Method 3: Explicit byte array + accessors (most portable)
struct FileHeader {
    uint8_t raw[12];
};

// Accessors avoid alignment issues entirely
uint32_t header_get_magic(const struct FileHeader *h) {
    return read_be32(h->raw + 0);
}

void header_set_magic(struct FileHeader *h, uint32_t value) {
    write_be32(h->raw + 0, value);
}

uint32_t header_get_size(const struct FileHeader *h) {
    return read_be32(h->raw + 4);
}

int main(void) {
    printf("sizeof(PackedStruct) = %zu\n", sizeof(struct PackedStruct));  // 9
    printf("sizeof(PragmaPacked) = %zu\n", sizeof(struct PragmaPacked));  // 9
    
    return 0;
}
```

<Warning>
**Packed structs have downsides**:
- Unaligned access is slower (up to 10x on some architectures)
- May cause crashes on architectures that don't support unaligned access (ARM, SPARC)
- Prefer explicit byte-by-byte serialization for portability
</Warning>

---

## File Format Design

### Header Design

```c
#include <stdio.h>
#include <stdint.h>
#include <string.h>

// Good file format header
#pragma pack(push, 1)
struct FileHeader {
    // Magic number - identifies file type
    uint8_t magic[4];      // "MYFT" (0x4D594654)
    
    // Version info - enables forward compatibility
    uint8_t version_major;
    uint8_t version_minor;
    
    // Flags for optional features
    uint16_t flags;
    
    // Size information
    uint32_t header_size;  // Allows header extension
    uint32_t data_offset;  // Where data starts
    uint32_t data_size;    // Size of data section
    
    // Integrity check
    uint32_t checksum;     // CRC32 of data section
    
    // Reserved for future use
    uint8_t reserved[16];
};
#pragma pack(pop)

#define MAGIC "MYFT"
#define VERSION_MAJOR 1
#define VERSION_MINOR 0

// Flag definitions
#define FLAG_COMPRESSED  (1 << 0)
#define FLAG_ENCRYPTED   (1 << 1)
#define FLAG_CHECKSUM    (1 << 2)

int validate_header(const struct FileHeader *h) {
    // Check magic number
    if (memcmp(h->magic, MAGIC, 4) != 0) {
        fprintf(stderr, "Invalid file format\n");
        return -1;
    }
    
    // Check version compatibility
    if (h->version_major > VERSION_MAJOR) {
        fprintf(stderr, "File format too new (v%d.%d, we support v%d.%d)\n",
                h->version_major, h->version_minor,
                VERSION_MAJOR, VERSION_MINOR);
        return -1;
    }
    
    // Validate header size
    if (h->header_size < sizeof(struct FileHeader)) {
        fprintf(stderr, "Header too small\n");
        return -1;
    }
    
    return 0;
}
```

### Chunk-Based Format

```c
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// Chunk-based format (like PNG, RIFF, IFF)
// Flexible, extensible, easy to skip unknown chunks

#pragma pack(push, 1)
struct ChunkHeader {
    uint8_t type[4];    // Chunk type ID
    uint32_t length;    // Length of data (not including header)
    // data follows...
    // optional: CRC after data
};
#pragma pack(pop)

// Chunk type constants
#define CHUNK_META  "META"
#define CHUNK_DATA  "DATA"
#define CHUNK_INDX  "INDX"
#define CHUNK_END   "END\0"

// Read chunk
int read_chunk(FILE *fp, struct ChunkHeader *header, void **data) {
    if (fread(header, sizeof(*header), 1, fp) != 1) {
        return -1;
    }
    
    uint32_t length = ntohl(header->length);  // Convert from big-endian
    
    if (length > 0) {
        *data = malloc(length);
        if (!*data) return -1;
        
        if (fread(*data, 1, length, fp) != length) {
            free(*data);
            return -1;
        }
    } else {
        *data = NULL;
    }
    
    return 0;
}

// Write chunk
int write_chunk(FILE *fp, const char type[4], const void *data, uint32_t length) {
    struct ChunkHeader header;
    memcpy(header.type, type, 4);
    header.length = htonl(length);  // Convert to big-endian
    
    if (fwrite(&header, sizeof(header), 1, fp) != 1) {
        return -1;
    }
    
    if (length > 0 && data) {
        if (fwrite(data, 1, length, fp) != length) {
            return -1;
        }
    }
    
    return 0;
}

// Process chunks
int process_file(const char *filename) {
    FILE *fp = fopen(filename, "rb");
    if (!fp) return -1;
    
    struct ChunkHeader header;
    void *data;
    
    while (read_chunk(fp, &header, &data) == 0) {
        uint32_t length = ntohl(header.length);
        
        if (memcmp(header.type, CHUNK_META, 4) == 0) {
            printf("Metadata: %.*s\n", (int)length, (char*)data);
        } else if (memcmp(header.type, CHUNK_DATA, 4) == 0) {
            printf("Data chunk: %u bytes\n", length);
        } else if (memcmp(header.type, CHUNK_END, 4) == 0) {
            printf("End of file\n");
            free(data);
            break;
        } else {
            printf("Unknown chunk '%.4s', skipping %u bytes\n", 
                   header.type, length);
        }
        
        free(data);
    }
    
    fclose(fp);
    return 0;
}
```

---

## Memory-Mapped I/O

### Using mmap for Large Files

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <string.h>

// Map file into memory for efficient access
void *map_file(const char *filename, size_t *size, int writable) {
    int fd = open(filename, writable ? O_RDWR : O_RDONLY);
    if (fd < 0) {
        perror("open");
        return NULL;
    }
    
    struct stat st;
    if (fstat(fd, &st) < 0) {
        perror("fstat");
        close(fd);
        return NULL;
    }
    
    *size = st.st_size;
    
    int prot = PROT_READ | (writable ? PROT_WRITE : 0);
    int flags = writable ? MAP_SHARED : MAP_PRIVATE;
    
    void *addr = mmap(NULL, st.st_size, prot, flags, fd, 0);
    close(fd);  // Can close fd after mmap
    
    if (addr == MAP_FAILED) {
        perror("mmap");
        return NULL;
    }
    
    return addr;
}

void unmap_file(void *addr, size_t size) {
    munmap(addr, size);
}

// Example: Search binary file using mmap
int64_t find_pattern(const char *filename, const uint8_t *pattern, size_t pattern_len) {
    size_t file_size;
    uint8_t *data = map_file(filename, &file_size, 0);
    if (!data) return -1;
    
    // Advise kernel about access pattern
    madvise(data, file_size, MADV_SEQUENTIAL);
    
    for (size_t i = 0; i + pattern_len <= file_size; i++) {
        if (memcmp(data + i, pattern, pattern_len) == 0) {
            unmap_file(data, file_size);
            return i;  // Found at offset i
        }
    }
    
    unmap_file(data, file_size);
    return -1;  // Not found
}

// Example: Modify file in-place
int patch_file(const char *filename, size_t offset, 
               const uint8_t *data, size_t len) {
    size_t file_size;
    uint8_t *mapped = map_file(filename, &file_size, 1);
    if (!mapped) return -1;
    
    if (offset + len > file_size) {
        unmap_file(mapped, file_size);
        return -1;
    }
    
    memcpy(mapped + offset, data, len);
    
    // Flush changes to disk
    msync(mapped + offset, len, MS_SYNC);
    
    unmap_file(mapped, file_size);
    return 0;
}
```

---

## Serialization Patterns

### Generic Serializer

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

// Serialization buffer
typedef struct {
    uint8_t *data;
    size_t size;
    size_t capacity;
    size_t position;  // For reading
} Buffer;

Buffer *buffer_create(size_t initial_capacity) {
    Buffer *buf = malloc(sizeof(Buffer));
    if (!buf) return NULL;
    
    buf->data = malloc(initial_capacity);
    if (!buf->data) {
        free(buf);
        return NULL;
    }
    
    buf->size = 0;
    buf->capacity = initial_capacity;
    buf->position = 0;
    return buf;
}

void buffer_destroy(Buffer *buf) {
    if (buf) {
        free(buf->data);
        free(buf);
    }
}

int buffer_ensure_capacity(Buffer *buf, size_t additional) {
    if (buf->size + additional > buf->capacity) {
        size_t new_capacity = buf->capacity * 2;
        while (new_capacity < buf->size + additional) {
            new_capacity *= 2;
        }
        
        uint8_t *new_data = realloc(buf->data, new_capacity);
        if (!new_data) return -1;
        
        buf->data = new_data;
        buf->capacity = new_capacity;
    }
    return 0;
}

// Write primitives
int buffer_write_u8(Buffer *buf, uint8_t value) {
    if (buffer_ensure_capacity(buf, 1) < 0) return -1;
    buf->data[buf->size++] = value;
    return 0;
}

int buffer_write_u16(Buffer *buf, uint16_t value) {
    if (buffer_ensure_capacity(buf, 2) < 0) return -1;
    write_be16(buf->data + buf->size, value);
    buf->size += 2;
    return 0;
}

int buffer_write_u32(Buffer *buf, uint32_t value) {
    if (buffer_ensure_capacity(buf, 4) < 0) return -1;
    write_be32(buf->data + buf->size, value);
    buf->size += 4;
    return 0;
}

int buffer_write_string(Buffer *buf, const char *str) {
    size_t len = strlen(str);
    if (len > UINT16_MAX) return -1;
    
    if (buffer_write_u16(buf, (uint16_t)len) < 0) return -1;
    if (buffer_ensure_capacity(buf, len) < 0) return -1;
    memcpy(buf->data + buf->size, str, len);
    buf->size += len;
    return 0;
}

int buffer_write_bytes(Buffer *buf, const void *data, size_t len) {
    if (buffer_ensure_capacity(buf, len) < 0) return -1;
    memcpy(buf->data + buf->size, data, len);
    buf->size += len;
    return 0;
}

// Read primitives
int buffer_read_u8(Buffer *buf, uint8_t *value) {
    if (buf->position + 1 > buf->size) return -1;
    *value = buf->data[buf->position++];
    return 0;
}

int buffer_read_u16(Buffer *buf, uint16_t *value) {
    if (buf->position + 2 > buf->size) return -1;
    *value = read_be16(buf->data + buf->position);
    buf->position += 2;
    return 0;
}

int buffer_read_u32(Buffer *buf, uint32_t *value) {
    if (buf->position + 4 > buf->size) return -1;
    *value = read_be32(buf->data + buf->position);
    buf->position += 4;
    return 0;
}

int buffer_read_string(Buffer *buf, char **str) {
    uint16_t len;
    if (buffer_read_u16(buf, &len) < 0) return -1;
    
    if (buf->position + len > buf->size) return -1;
    
    *str = malloc(len + 1);
    if (!*str) return -1;
    
    memcpy(*str, buf->data + buf->position, len);
    (*str)[len] = '\0';
    buf->position += len;
    return 0;
}

// Example usage
struct Person {
    char *name;
    uint32_t age;
    float height;
};

int serialize_person(Buffer *buf, const struct Person *p) {
    if (buffer_write_string(buf, p->name) < 0) return -1;
    if (buffer_write_u32(buf, p->age) < 0) return -1;
    
    // Float as uint32
    uint32_t height_bits;
    memcpy(&height_bits, &p->height, sizeof(height_bits));
    if (buffer_write_u32(buf, height_bits) < 0) return -1;
    
    return 0;
}

int deserialize_person(Buffer *buf, struct Person *p) {
    if (buffer_read_string(buf, &p->name) < 0) return -1;
    if (buffer_read_u32(buf, &p->age) < 0) return -1;
    
    uint32_t height_bits;
    if (buffer_read_u32(buf, &height_bits) < 0) return -1;
    memcpy(&p->height, &height_bits, sizeof(p->height));
    
    return 0;
}
```

---

## Exercises

<Accordion title="Exercise 1: BMP Image Writer" icon="code">
Write a function that creates a valid BMP image file:

```c
int write_bmp(const char *filename, 
              const uint8_t *pixels,  // RGB data
              int width, int height);

// BMP format:
// - 14-byte file header
// - 40-byte DIB header (BITMAPINFOHEADER)
// - Pixel data (bottom-up, padded to 4-byte rows)
```
</Accordion>

<Accordion title="Exercise 2: WAV Audio Generator" icon="code">
Generate a WAV file with a sine wave:

```c
int write_wav(const char *filename,
              float frequency,
              float duration_seconds,
              int sample_rate);

// WAV format:
// - RIFF header
// - fmt chunk (audio format info)
// - data chunk (samples)
```
</Accordion>

<Accordion title="Exercise 3: Cross-Platform Config File" icon="code">
Design a binary config file format that:
- Works on 32-bit and 64-bit systems
- Works on big-endian and little-endian systems
- Supports versioning for forward compatibility
- Includes a checksum for integrity

```c
struct ConfigFile {
    // Your design here
};

int config_write(const char *filename, const struct ConfigFile *cfg);
int config_read(const char *filename, struct ConfigFile *cfg);
int config_validate(const struct ConfigFile *cfg);
```
</Accordion>

---

## Key Takeaways

<CardGroup cols={2}>
  <Card title="Always Handle Endianness" icon="shuffle">
    Use explicit byte-order conversion for portable binary files.
  </Card>
  <Card title="Avoid Packed Structs" icon="warning">
    Prefer explicit serialization over packed structs for portability.
  </Card>
  <Card title="Include Magic Numbers" icon="wand-magic">
    Start files with a magic number for format identification.
  </Card>
  <Card title="Version Your Formats" icon="code-branch">
    Include version info to enable forward compatibility.
  </Card>
</CardGroup>
