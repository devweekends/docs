---
title: "Function Pointers & Callbacks"
sidebarTitle: "Function Pointers"
description: "Master function pointers, callbacks, vtables, and plugin architectures"
icon: "arrow-right-arrow-left"
---

# Function Pointers & Callbacks

Function pointers are C's mechanism for polymorphism and runtime dispatch. They enable callbacks, plugins, and object-oriented patterns in a language without classes.

---

## Function Pointer Basics

### Syntax and Declaration

```c
#include <stdio.h>

// Function to point to
int add(int a, int b) { return a + b; }
int subtract(int a, int b) { return a - b; }
int multiply(int a, int b) { return a * b; }

int main(void) {
    // Declare a function pointer
    // Syntax: return_type (*pointer_name)(parameter_types)
    int (*operation)(int, int);
    
    // Assign function to pointer (& is optional)
    operation = add;        // or: operation = &add;
    
    // Call through function pointer (* is optional)
    int result = operation(5, 3);      // or: (*operation)(5, 3)
    printf("5 + 3 = %d\n", result);    // 8
    
    // Change what we're pointing to
    operation = subtract;
    printf("5 - 3 = %d\n", operation(5, 3));  // 2
    
    operation = multiply;
    printf("5 * 3 = %d\n", operation(5, 3));  // 15
    
    return 0;
}
```

### Typedef for Readability

```c
#include <stdio.h>

// Without typedef (hard to read)
int (*get_operation(char op))(int, int);

// With typedef (much cleaner)
typedef int (*BinaryOp)(int, int);

int add(int a, int b) { return a + b; }
int subtract(int a, int b) { return a - b; }
int multiply(int a, int b) { return a * b; }
int divide(int a, int b) { return b != 0 ? a / b : 0; }

// Return a function pointer
BinaryOp get_operation(char op) {
    switch (op) {
        case '+': return add;
        case '-': return subtract;
        case '*': return multiply;
        case '/': return divide;
        default:  return NULL;
    }
}

// Accept a function pointer as parameter
int apply(BinaryOp op, int a, int b) {
    if (op == NULL) return 0;
    return op(a, b);
}

int main(void) {
    BinaryOp op = get_operation('*');
    printf("Result: %d\n", apply(op, 6, 7));  // 42
    
    return 0;
}
```

---

## Callback Patterns

### Basic Callback

```c
#include <stdio.h>
#include <stdlib.h>

// Callback type
typedef void (*EventCallback)(int event_code, void *user_data);

// Event system
struct EventHandler {
    EventCallback callback;
    void *user_data;
};

void register_callback(struct EventHandler *handler, 
                       EventCallback cb, void *data) {
    handler->callback = cb;
    handler->user_data = data;
}

void trigger_event(struct EventHandler *handler, int event_code) {
    if (handler->callback) {
        handler->callback(event_code, handler->user_data);
    }
}

// User code
void my_handler(int code, void *data) {
    const char *name = (const char *)data;
    printf("Event %d received by %s\n", code, name);
}

int main(void) {
    struct EventHandler handler = {0};
    
    register_callback(&handler, my_handler, "MyApp");
    
    trigger_event(&handler, 100);  // "Event 100 received by MyApp"
    trigger_event(&handler, 200);  // "Event 200 received by MyApp"
    
    return 0;
}
```

### Multiple Callbacks (Observer Pattern)

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_OBSERVERS 10

typedef void (*Observer)(const char *event, void *user_data);

struct Subject {
    struct {
        Observer callback;
        void *user_data;
    } observers[MAX_OBSERVERS];
    size_t count;
};

void subject_init(struct Subject *s) {
    memset(s, 0, sizeof(*s));
}

int subject_subscribe(struct Subject *s, Observer cb, void *data) {
    if (s->count >= MAX_OBSERVERS) return -1;
    
    s->observers[s->count].callback = cb;
    s->observers[s->count].user_data = data;
    s->count++;
    return 0;
}

void subject_unsubscribe(struct Subject *s, Observer cb) {
    for (size_t i = 0; i < s->count; i++) {
        if (s->observers[i].callback == cb) {
            // Shift remaining elements
            memmove(&s->observers[i], &s->observers[i + 1],
                    (s->count - i - 1) * sizeof(s->observers[0]));
            s->count--;
            return;
        }
    }
}

void subject_notify(struct Subject *s, const char *event) {
    for (size_t i = 0; i < s->count; i++) {
        s->observers[i].callback(event, s->observers[i].user_data);
    }
}

// Observers
void logger(const char *event, void *data) {
    printf("[LOG] %s: %s\n", (char*)data, event);
}

void alerter(const char *event, void *data) {
    printf("[ALERT] Event: %s\n", event);
}

int main(void) {
    struct Subject subject;
    subject_init(&subject);
    
    subject_subscribe(&subject, logger, "FileSystem");
    subject_subscribe(&subject, logger, "Network");
    subject_subscribe(&subject, alerter, NULL);
    
    subject_notify(&subject, "Connection established");
    // [LOG] FileSystem: Connection established
    // [LOG] Network: Connection established
    // [ALERT] Event: Connection established
    
    return 0;
}
```

---

## Jump Tables (Dispatch Tables)

### Basic Jump Table

```c
#include <stdio.h>

typedef int (*OpFunc)(int, int);

// Operations
int op_add(int a, int b) { return a + b; }
int op_sub(int a, int b) { return a - b; }
int op_mul(int a, int b) { return a * b; }
int op_div(int a, int b) { return b ? a / b : 0; }
int op_mod(int a, int b) { return b ? a % b : 0; }
int op_and(int a, int b) { return a & b; }
int op_or(int a, int b)  { return a | b; }
int op_xor(int a, int b) { return a ^ b; }

// Jump table (array of function pointers)
static const OpFunc operations[] = {
    [0] = op_add,
    [1] = op_sub,
    [2] = op_mul,
    [3] = op_div,
    [4] = op_mod,
    [5] = op_and,
    [6] = op_or,
    [7] = op_xor,
};

#define NUM_OPS (sizeof(operations) / sizeof(operations[0]))

int execute_op(int op_code, int a, int b) {
    if (op_code < 0 || (size_t)op_code >= NUM_OPS) {
        return 0;  // Invalid operation
    }
    return operations[op_code](a, b);
}

// Why jump tables?
// 1. O(1) dispatch instead of O(n) if-else chain
// 2. Cleaner code, easier to extend
// 3. Often compiles to single indirect jump instruction
```

### State Machine with Function Pointers

```c
#include <stdio.h>
#include <stdbool.h>

// State machine states
typedef enum {
    STATE_IDLE,
    STATE_RUNNING,
    STATE_PAUSED,
    STATE_STOPPED,
    STATE_COUNT
} State;

// Events
typedef enum {
    EVENT_START,
    EVENT_PAUSE,
    EVENT_RESUME,
    EVENT_STOP,
    EVENT_COUNT
} Event;

// Forward declaration
struct StateMachine;

// State handler function type
typedef State (*StateHandler)(struct StateMachine *sm, Event event);

struct StateMachine {
    State current_state;
    int data;
    StateHandler handlers[STATE_COUNT];
};

// State handlers
State handle_idle(struct StateMachine *sm, Event event) {
    switch (event) {
        case EVENT_START:
            printf("Starting...\n");
            return STATE_RUNNING;
        default:
            return STATE_IDLE;
    }
}

State handle_running(struct StateMachine *sm, Event event) {
    switch (event) {
        case EVENT_PAUSE:
            printf("Pausing...\n");
            return STATE_PAUSED;
        case EVENT_STOP:
            printf("Stopping from running...\n");
            return STATE_STOPPED;
        default:
            return STATE_RUNNING;
    }
}

State handle_paused(struct StateMachine *sm, Event event) {
    switch (event) {
        case EVENT_RESUME:
            printf("Resuming...\n");
            return STATE_RUNNING;
        case EVENT_STOP:
            printf("Stopping from paused...\n");
            return STATE_STOPPED;
        default:
            return STATE_PAUSED;
    }
}

State handle_stopped(struct StateMachine *sm, Event event) {
    switch (event) {
        case EVENT_START:
            printf("Restarting...\n");
            return STATE_RUNNING;
        default:
            return STATE_STOPPED;
    }
}

void sm_init(struct StateMachine *sm) {
    sm->current_state = STATE_IDLE;
    sm->data = 0;
    sm->handlers[STATE_IDLE] = handle_idle;
    sm->handlers[STATE_RUNNING] = handle_running;
    sm->handlers[STATE_PAUSED] = handle_paused;
    sm->handlers[STATE_STOPPED] = handle_stopped;
}

void sm_handle_event(struct StateMachine *sm, Event event) {
    StateHandler handler = sm->handlers[sm->current_state];
    sm->current_state = handler(sm, event);
}

int main(void) {
    struct StateMachine sm;
    sm_init(&sm);
    
    sm_handle_event(&sm, EVENT_START);   // Starting...
    sm_handle_event(&sm, EVENT_PAUSE);   // Pausing...
    sm_handle_event(&sm, EVENT_RESUME);  // Resuming...
    sm_handle_event(&sm, EVENT_STOP);    // Stopping from running...
    
    return 0;
}
```

---

## Virtual Tables (OOP in C)

### Basic Virtual Table

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Virtual table structure
typedef struct ShapeVTable {
    double (*area)(const void *self);
    double (*perimeter)(const void *self);
    void (*draw)(const void *self);
    void (*destroy)(void *self);
} ShapeVTable;

// Base "class" - all shapes have a vtable pointer
typedef struct {
    const ShapeVTable *vtable;
    int x, y;  // Common fields
} Shape;

// Circle "class"
typedef struct {
    Shape base;  // Inheritance (base must be first!)
    double radius;
} Circle;

// Rectangle "class"
typedef struct {
    Shape base;
    double width, height;
} Rectangle;

// Circle methods
static double circle_area(const void *self) {
    const Circle *c = self;
    return 3.14159 * c->radius * c->radius;
}

static double circle_perimeter(const void *self) {
    const Circle *c = self;
    return 2 * 3.14159 * c->radius;
}

static void circle_draw(const void *self) {
    const Circle *c = self;
    printf("Drawing circle at (%d, %d) with radius %.2f\n",
           c->base.x, c->base.y, c->radius);
}

static void circle_destroy(void *self) {
    printf("Destroying circle\n");
    free(self);
}

// Circle vtable (single shared instance)
static const ShapeVTable circle_vtable = {
    .area = circle_area,
    .perimeter = circle_perimeter,
    .draw = circle_draw,
    .destroy = circle_destroy,
};

// Circle constructor
Circle *circle_create(int x, int y, double radius) {
    Circle *c = malloc(sizeof(Circle));
    if (!c) return NULL;
    
    c->base.vtable = &circle_vtable;
    c->base.x = x;
    c->base.y = y;
    c->radius = radius;
    return c;
}

// Rectangle methods
static double rect_area(const void *self) {
    const Rectangle *r = self;
    return r->width * r->height;
}

static double rect_perimeter(const void *self) {
    const Rectangle *r = self;
    return 2 * (r->width + r->height);
}

static void rect_draw(const void *self) {
    const Rectangle *r = self;
    printf("Drawing rectangle at (%d, %d) size %.2fx%.2f\n",
           r->base.x, r->base.y, r->width, r->height);
}

static void rect_destroy(void *self) {
    printf("Destroying rectangle\n");
    free(self);
}

static const ShapeVTable rect_vtable = {
    .area = rect_area,
    .perimeter = rect_perimeter,
    .draw = rect_draw,
    .destroy = rect_destroy,
};

Rectangle *rectangle_create(int x, int y, double w, double h) {
    Rectangle *r = malloc(sizeof(Rectangle));
    if (!r) return NULL;
    
    r->base.vtable = &rect_vtable;
    r->base.x = x;
    r->base.y = y;
    r->width = w;
    r->height = h;
    return r;
}

// Polymorphic functions work on any Shape
void shape_draw(Shape *s) {
    s->vtable->draw(s);
}

double shape_area(Shape *s) {
    return s->vtable->area(s);
}

void shape_destroy(Shape *s) {
    s->vtable->destroy(s);
}

int main(void) {
    // Array of base class pointers (polymorphism!)
    Shape *shapes[3];
    shapes[0] = (Shape *)circle_create(10, 20, 5.0);
    shapes[1] = (Shape *)rectangle_create(0, 0, 4.0, 3.0);
    shapes[2] = (Shape *)circle_create(5, 5, 2.5);
    
    // Polymorphic iteration
    for (int i = 0; i < 3; i++) {
        shape_draw(shapes[i]);
        printf("  Area: %.2f\n", shape_area(shapes[i]));
    }
    
    // Cleanup
    for (int i = 0; i < 3; i++) {
        shape_destroy(shapes[i]);
    }
    
    return 0;
}
```

---

## Plugin Architecture

### Dynamic Loading (dlopen)

```c
#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>  // For dlopen, dlsym, dlclose

// Plugin interface (shared between host and plugins)
typedef struct {
    const char *name;
    const char *version;
    int (*init)(void);
    void (*shutdown)(void);
    int (*process)(const char *input, char *output, size_t output_size);
} Plugin;

// Plugin loader
typedef struct {
    void *handle;       // dlopen handle
    Plugin *plugin;     // Plugin interface
} LoadedPlugin;

LoadedPlugin *load_plugin(const char *path) {
    LoadedPlugin *lp = malloc(sizeof(LoadedPlugin));
    if (!lp) return NULL;
    
    // Load shared library
    lp->handle = dlopen(path, RTLD_NOW);
    if (!lp->handle) {
        fprintf(stderr, "dlopen failed: %s\n", dlerror());
        free(lp);
        return NULL;
    }
    
    // Get plugin symbol
    lp->plugin = dlsym(lp->handle, "plugin");
    if (!lp->plugin) {
        fprintf(stderr, "dlsym failed: %s\n", dlerror());
        dlclose(lp->handle);
        free(lp);
        return NULL;
    }
    
    // Initialize plugin
    if (lp->plugin->init && lp->plugin->init() != 0) {
        fprintf(stderr, "Plugin init failed\n");
        dlclose(lp->handle);
        free(lp);
        return NULL;
    }
    
    printf("Loaded plugin: %s v%s\n", lp->plugin->name, lp->plugin->version);
    return lp;
}

void unload_plugin(LoadedPlugin *lp) {
    if (!lp) return;
    
    if (lp->plugin && lp->plugin->shutdown) {
        lp->plugin->shutdown();
    }
    
    if (lp->handle) {
        dlclose(lp->handle);
    }
    
    free(lp);
}

// Example usage
int main(void) {
    LoadedPlugin *plugin = load_plugin("./my_plugin.so");
    if (!plugin) return 1;
    
    char output[256];
    plugin->plugin->process("Hello", output, sizeof(output));
    printf("Output: %s\n", output);
    
    unload_plugin(plugin);
    return 0;
}
```

### Plugin Implementation

```c
// my_plugin.c - Compile with: gcc -shared -fPIC -o my_plugin.so my_plugin.c

#include <stdio.h>
#include <string.h>

static int plugin_init(void) {
    printf("MyPlugin initializing...\n");
    return 0;
}

static void plugin_shutdown(void) {
    printf("MyPlugin shutting down...\n");
}

static int plugin_process(const char *input, char *output, size_t size) {
    snprintf(output, size, "Processed: %s", input);
    return 0;
}

// Export plugin interface
__attribute__((visibility("default")))
struct {
    const char *name;
    const char *version;
    int (*init)(void);
    void (*shutdown)(void);
    int (*process)(const char*, char*, size_t);
} plugin = {
    .name = "MyPlugin",
    .version = "1.0.0",
    .init = plugin_init,
    .shutdown = plugin_shutdown,
    .process = plugin_process,
};
```

---

## Comparison Functions (qsort, bsearch)

### Using qsort

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Comparison function signature for qsort
// Returns: negative if a < b, zero if a == b, positive if a > b

// Compare integers
int compare_int(const void *a, const void *b) {
    int ia = *(const int *)a;
    int ib = *(const int *)b;
    return (ia > ib) - (ia < ib);  // Avoids overflow
}

// Compare strings
int compare_string(const void *a, const void *b) {
    const char *sa = *(const char **)a;
    const char *sb = *(const char **)b;
    return strcmp(sa, sb);
}

// Compare structs
struct Person {
    char name[32];
    int age;
};

int compare_person_by_age(const void *a, const void *b) {
    const struct Person *pa = a;
    const struct Person *pb = b;
    return (pa->age > pb->age) - (pa->age < pb->age);
}

int compare_person_by_name(const void *a, const void *b) {
    const struct Person *pa = a;
    const struct Person *pb = b;
    return strcmp(pa->name, pb->name);
}

int main(void) {
    // Sort integers
    int nums[] = {5, 2, 9, 1, 7, 3};
    qsort(nums, 6, sizeof(int), compare_int);
    
    // Sort strings
    const char *words[] = {"zebra", "apple", "mango", "banana"};
    qsort(words, 4, sizeof(char *), compare_string);
    
    // Sort structs
    struct Person people[] = {
        {"Alice", 30},
        {"Bob", 25},
        {"Charlie", 35}
    };
    
    qsort(people, 3, sizeof(struct Person), compare_person_by_age);
    printf("By age: %s, %s, %s\n", 
           people[0].name, people[1].name, people[2].name);
    
    qsort(people, 3, sizeof(struct Person), compare_person_by_name);
    printf("By name: %s, %s, %s\n",
           people[0].name, people[1].name, people[2].name);
    
    return 0;
}
```

### Using bsearch

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    int key;
    const char *value;
};

int compare_entry(const void *key, const void *element) {
    int search_key = *(const int *)key;
    const struct Entry *entry = element;
    return (search_key > entry->key) - (search_key < entry->key);
}

int main(void) {
    // Array MUST be sorted for bsearch!
    struct Entry table[] = {
        {100, "one hundred"},
        {200, "two hundred"},
        {300, "three hundred"},
        {400, "four hundred"},
        {500, "five hundred"},
    };
    size_t table_size = sizeof(table) / sizeof(table[0]);
    
    int key = 300;
    struct Entry *found = bsearch(&key, table, table_size, 
                                   sizeof(struct Entry), compare_entry);
    
    if (found) {
        printf("Found: %d = %s\n", found->key, found->value);
    } else {
        printf("Not found\n");
    }
    
    return 0;
}
```

---

## Advanced Patterns

### Function Pointer Arrays with Context

```c
#include <stdio.h>

// Command pattern with context
typedef struct Command Command;

struct Command {
    void (*execute)(Command *self);
    void (*undo)(Command *self);
    // Command-specific data follows...
};

// Specific command types
typedef struct {
    Command base;
    int *target;
    int old_value;
    int new_value;
} SetValueCommand;

void set_value_execute(Command *cmd) {
    SetValueCommand *self = (SetValueCommand *)cmd;
    self->old_value = *self->target;
    *self->target = self->new_value;
    printf("Set value to %d\n", self->new_value);
}

void set_value_undo(Command *cmd) {
    SetValueCommand *self = (SetValueCommand *)cmd;
    *self->target = self->old_value;
    printf("Restored value to %d\n", self->old_value);
}

SetValueCommand *create_set_command(int *target, int new_value) {
    SetValueCommand *cmd = malloc(sizeof(SetValueCommand));
    cmd->base.execute = set_value_execute;
    cmd->base.undo = set_value_undo;
    cmd->target = target;
    cmd->new_value = new_value;
    return cmd;
}

// Command history for undo
#define MAX_HISTORY 100
Command *history[MAX_HISTORY];
int history_count = 0;

void execute_command(Command *cmd) {
    cmd->execute(cmd);
    if (history_count < MAX_HISTORY) {
        history[history_count++] = cmd;
    }
}

void undo_last(void) {
    if (history_count > 0) {
        Command *cmd = history[--history_count];
        cmd->undo(cmd);
    }
}

int main(void) {
    int value = 10;
    printf("Initial value: %d\n", value);
    
    execute_command((Command *)create_set_command(&value, 42));
    printf("After execute: %d\n", value);  // 42
    
    undo_last();
    printf("After undo: %d\n", value);  // 10
    
    return 0;
}
```

### Type-Safe Callbacks with Macro

```c
#include <stdio.h>

// Type-safe callback registration using macro
#define DECLARE_CALLBACK(name, ret, ...)  \
    typedef ret (*name##_fn)(__VA_ARGS__); \
    struct name##_callback {               \
        name##_fn fn;                      \
        void *user_data;                   \
    }

#define REGISTER_CALLBACK(cb, func, data) \
    do { (cb)->fn = func; (cb)->user_data = data; } while(0)

#define INVOKE_CALLBACK(cb, ...) \
    ((cb)->fn ? (cb)->fn(__VA_ARGS__) : 0)

// Declare specific callback types
DECLARE_CALLBACK(on_click, void, int x, int y, void *data);
DECLARE_CALLBACK(on_key, int, char key, void *data);

// User handlers
void my_click_handler(int x, int y, void *data) {
    const char *name = data;
    printf("Click at (%d, %d) in %s\n", x, y, name);
}

int my_key_handler(char key, void *data) {
    printf("Key '%c' pressed\n", key);
    return key == 'q' ? 1 : 0;  // Quit on 'q'
}

int main(void) {
    struct on_click_callback click_cb;
    struct on_key_callback key_cb;
    
    REGISTER_CALLBACK(&click_cb, my_click_handler, "MainWindow");
    REGISTER_CALLBACK(&key_cb, my_key_handler, NULL);
    
    INVOKE_CALLBACK(&click_cb, 100, 200, click_cb.user_data);
    
    int quit = INVOKE_CALLBACK(&key_cb, 'a', key_cb.user_data);
    printf("Quit: %d\n", quit);  // 0
    
    quit = INVOKE_CALLBACK(&key_cb, 'q', key_cb.user_data);
    printf("Quit: %d\n", quit);  // 1
    
    return 0;
}
```

---

## Exercises

<Accordion title="Exercise 1: Generic Iterator" icon="code">
Implement a generic iterator using function pointers:

```c
typedef struct {
    void *collection;
    size_t current;
    void *(*next)(void *iter);
    bool (*has_next)(void *iter);
    void (*reset)(void *iter);
} Iterator;

// Create iterators for arrays, linked lists, and trees
Iterator *array_iterator_create(void *array, size_t count, size_t elem_size);
Iterator *list_iterator_create(struct List *list);
```
</Accordion>

<Accordion title="Exercise 2: Strategy Pattern" icon="code">
Implement different compression strategies:

```c
typedef struct {
    const char *name;
    int (*compress)(const void *in, size_t in_len, void *out, size_t *out_len);
    int (*decompress)(const void *in, size_t in_len, void *out, size_t *out_len);
} CompressionStrategy;

// Implement: no_compression, rle_compression, huffman_compression
// Allow switching strategies at runtime
```
</Accordion>

<Accordion title="Exercise 3: Event Emitter" icon="code">
Build a type-safe event emitter:

```c
// Should support:
// - Multiple event types
// - Multiple listeners per event
// - Listener removal
// - Event data passing

emitter_on(emitter, "data", on_data_handler, user_data);
emitter_on(emitter, "error", on_error_handler, user_data);
emitter_emit(emitter, "data", &some_data);
emitter_off(emitter, "data", on_data_handler);
```
</Accordion>

---

## Key Takeaways

<CardGroup cols={2}>
  <Card title="Use Typedef" icon="code">
    Always typedef function pointer types for readability.
  </Card>
  <Card title="Include Context" icon="user">
    Callbacks should accept a `void *user_data` for context.
  </Card>
  <Card title="Check for NULL" icon="check">
    Always check if function pointer is NULL before calling.
  </Card>
  <Card title="VTables are Powerful" icon="table">
    Function pointer tables enable polymorphism in C.
  </Card>
</CardGroup>
