---
title: "Variables and Types"
sidebarTitle: "2. Variables & Types"
description: "Understanding Go's type system, variables, constants, and zero values"
icon: "cube"
---

# Variables and Types

Go is a statically typed language, meaning variable types are known at compile time. However, its syntax is designed to be concise, often inferring types for you.

## Variable Declaration

There are three main ways to declare variables in Go.

### 1. `var` keyword (Explicit Type)

Use this when you want to declare a variable without initializing it immediately, or when you want to be explicit about the type.

```go
var name string = "Gopher"
var age int = 10
```

### 2. `var` keyword (Type Inferred)

If you provide an initial value, you can omit the type.

```go
var name = "Gopher" // inferred as string
var age = 10        // inferred as int
```

### 3. Short Declaration `:=`

Inside functions, you can use the `:=` operator. This is the most common and idiomatic way to declare and initialize variables in Go.

```go
func main() {
    name := "Gopher"  // Type inferred as string
    age := 10         // Type inferred as int
    isCool := true    // Type inferred as bool
}
```

**Why `:=` is Preferred**: It's concise and lets the compiler infer types, making code cleaner while maintaining type safety.

<Warning>
**Restriction**: The `:=` syntax can **only** be used inside functions. At the package level (outside functions), you must use `var`.

**Common Gotcha**: `:=` declares a new variable. If you want to reassign an existing variable, use `=` instead:
```go
name := "Alice"  // Declares new variable
name = "Bob"     // Reassigns existing variable
name := "Charlie" // ERROR: no new variable on left side of :=
```
</Warning>

---

## Basic Types

Go has a rich set of built-in types.

### Integers
-   `int`, `int8`, `int16`, `int32`, `int64`
-   `uint`, `uint8`, `uint16`, `uint32`, `uint64`, `uintptr`

**Note**: `int` and `uint` are platform-dependent (32-bit on 32-bit systems, 64-bit on 64-bit systems). In 99% of cases, just use `int`.

### Floats
-   `float32`, `float64`

**Note**: `float64` is the default for floating-point numbers.

### Booleans
-   `bool` (true or false)

### Strings
-   `string` (immutable sequence of bytes, UTF-8 encoded)

### Complex Numbers
-   `complex64`, `complex128`

---

## Zero Values

Variables declared without an initial value are given their **zero value**. This is a key safety feature: **Go does not have uninitialized variables**. Every variable always has a well-defined value.

| Type | Zero Value |
|------|------------|
| `int` | `0` |
| `float` | `0.0` |
| `bool` | `false` |
| `string` | `""` (empty string) |
| pointers | `nil` |
| slices | `nil` |
| maps | `nil` |
| channels | `nil` |

```go
var i int
var s string
var p *int
fmt.Printf("%d %q %v\n", i, s, p) // Output: 0 "" <nil>
```

**Why This Matters**: Zero values make Go code more predictable and safer. You can rely on variables having sensible defaults:

```go
var counter int  // Automatically 0, ready to use
counter++        // Now 1

var buffer bytes.Buffer  // Ready to use immediately, no initialization needed
buffer.WriteString("Hello")
```

---

## Constants

Constants are declared using `const`. They can be character, string, boolean, or numeric values.

```go
const Pi = 3.14
const World = "世界"
```

Constants cannot be declared using the `:=` syntax.

### Iota

`iota` is a special identifier used to create enumerated constants. It resets to 0 whenever `const` appears and increments by 1 for each line.

```go
const (
    Red = iota   // 0
    Green        // 1
    Blue         // 2
)
```

**Practical Use Cases**:

```go
// File permissions (powers of 2 for bitwise operations)
const (
    Read = 1 << iota  // 1 << 0 = 1
    Write             // 1 << 1 = 2
    Execute           // 1 << 2 = 4
)

// Skip values
const (
    _ = iota  // Skip 0
    KB = 1 << (10 * iota)  // 1024
    MB                      // 1048576
    GB                      // 1073741824
)
```

---

## Type Conversion

Go requires explicit type conversion. There is no implicit casting (e.g., you cannot assign an `int` to a `float64` variable without casting).

```go
var i int = 42
var f float64 = float64(i)
var u uint = uint(f)
```

If you try `f = i`, the compiler will throw an error.
