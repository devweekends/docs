---
title: "11. Authentication with JWT"
description: "Implement secure authentication using JSON Web Tokens (JWT) and bcrypt."
---

# Authentication with JWT

Most web applications need to know **who** is making requests. Authentication verifies user identity, while **authorization** determines what they can access. In this chapter, we'll implement a complete authentication system using industry-standard practices.

## Authentication vs. Authorization

| Concept | Question It Answers | Example |
|---------|--------------------|---------|
| **Authentication** | "Who are you?" | Login with username/password |
| **Authorization** | "What can you do?" | Can this user delete posts? |

## Understanding JWT (JSON Web Tokens)

Traditional session-based authentication stores user data on the server. This works, but has challenges:

- **Scalability**: Sessions must be shared across multiple servers
- **Mobile apps**: Cookies don't work well on native apps
- **Microservices**: Each service needs access to session store

**JWT** solves these problems with **stateless authentication**. Instead of storing session data on the server, the server issues a signed token that the client stores and sends with each request.

### How JWT Works

```
1. User logs in with credentials
2. Server verifies credentials
3. Server creates a signed JWT containing user info
4. Client stores the token (localStorage, cookie)
5. Client sends token with every request
6. Server verifies token signature and extracts user info
```

### JWT Structure

A JWT consists of three parts separated by dots:

```
header.payload.signature
```

- **Header**: Algorithm and token type
- **Payload**: User data (claims) like user ID, role, expiration
- **Signature**: Ensures the token hasn't been tampered with

<Tip>
Never store sensitive information (passwords, credit cards) in the JWT payload. The payload is Base64-encoded, not encryptedâ€”anyone can decode and read it.
</Tip>

## Prerequisites

Install the necessary packages:

```bash
npm install jsonwebtoken bcryptjs
```

- **jsonwebtoken**: To sign and verify tokens.
- **bcryptjs**: To hash passwords securely.

## 1. User Registration (Hashing Passwords)

Never store passwords in plain text. Use `bcryptjs` to hash them.

```javascript
const bcrypt = require('bcryptjs');

// ... inside your register route
const { username, password } = req.body;

// Check if user exists...

// Hash password
const salt = await bcrypt.genSalt(10);
const hashedPassword = await bcrypt.hash(password, salt);

// Save user with hashedPassword...
```

## 2. User Login (Comparing Passwords)

When a user logs in, compare the provided password with the hashed password in the database.

```javascript
const validPassword = await bcrypt.compare(password, user.password);

if (!validPassword) {
  return res.status(400).json({ msg: 'Invalid credentials' });
}
```

## 3. Generating a JWT

If the password is valid, generate a token and send it to the client.

```javascript
const jwt = require('jsonwebtoken');

const payload = {
  user: {
    id: user.id
  }
};

jwt.sign(
  payload,
  process.env.JWT_SECRET,
  { expiresIn: '1h' },
  (err, token) => {
    if (err) throw err;
    res.json({ token });
  }
);
```

**Note**: Store `JWT_SECRET` in your `.env` file.

## 4. Protecting Routes (Middleware)

Create middleware to verify the token on protected routes.

**middleware/auth.js**
```javascript
const jwt = require('jsonwebtoken');

module.exports = function(req, res, next) {
  // Get token from header
  const token = req.header('x-auth-token');

  // Check if not token
  if (!token) {
    return res.status(401).json({ msg: 'No token, authorization denied' });
  }

  // Verify token
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded.user;
    next();
  } catch (err) {
    res.status(401).json({ msg: 'Token is not valid' });
  }
};
```

## 5. Using the Middleware

```javascript
const auth = require('./middleware/auth');

// Protected route
app.get('/api/auth/user', auth, async (req, res) => {
  try {
    // Fetch user from DB using req.user.id
    // ...
    res.json(user);
  } catch (err) {
    res.status(500).send('Server Error');
  }
});
```

## Summary

- **bcryptjs**: Use `hash()` to encrypt passwords and `compare()` to validate them.
- **JWT**: Use `sign()` to create a token and `verify()` to check it.
- **Middleware**: Create a custom middleware to protect private routes.
- **Stateless**: The server doesn't store session data; the token contains all necessary info.

**Next Step**: See **React Chapter 11** to learn how to consume this auth API on the frontend.
