---
title: "03. File System"
description: "Learn how to read, write, and manage files using the Node.js fs module."
---

# File System Module (fs)

The `fs` module is one of the most useful built-in modules in Node.js. It allows you to work with the file system on your computer: reading files, creating files, updating files, deleting files, and renaming files.

To use it, you must first require it:

```javascript
const fs = require('fs');
```

## Synchronous vs Asynchronous

Most methods in the `fs` module have both synchronous and asynchronous versions.
- **Asynchronous** methods take a callback function as the last argument. They are non-blocking.
- **Synchronous** methods block the execution until the operation completes. They usually end with `Sync`.

**Recommendation:** Always use asynchronous methods in production to avoid blocking the event loop.

## Reading Files

### Asynchronous Read

```javascript
fs.readFile('example.txt', 'utf8', (err, data) => {
  if (err) {
    console.error(err);
    return;
  }
  console.log(data);
});
```

Note: If you don't specify the encoding ('utf8'), you will get a Buffer object instead of a string.

### Synchronous Read

```javascript
try {
  const data = fs.readFileSync('example.txt', 'utf8');
  console.log(data);
} catch (err) {
  console.error(err);
}
```

## Writing Files

### Asynchronous Write

`fs.writeFile()` replaces the file and content if it exists. If the file doesn't exist, a new file, containing the specified content, will be created.

```javascript
const content = 'Hello, this is new content!';

fs.writeFile('output.txt', content, err => {
  if (err) {
    console.error(err);
    return;
  }
  console.log('File written successfully');
});
```

### Appending to Files

To add content to the end of a file without replacing it, use `fs.appendFile()`.

```javascript
fs.appendFile('output.txt', '\nThis is appended text.', err => {
  if (err) throw err;
  console.log('Content appended!');
});
```

## Directories

### Creating a Directory

```javascript
if (!fs.existsSync('./new-folder')) {
  fs.mkdir('./new-folder', err => {
    if (err) throw err;
    console.log('Directory created');
  });
}
```

### Reading a Directory

```javascript
fs.readdir('./', (err, files) => {
  if (err) console.log(err);
  else console.log(files); // Returns an array of filenames
});
```

### Removing a Directory

```javascript
if (fs.existsSync('./new-folder')) {
  fs.rmdir('./new-folder', err => {
    if (err) console.log(err);
    else console.log('Directory removed');
  });
}
```

## Deleting Files

```javascript
if (fs.existsSync('output.txt')) {
  fs.unlink('output.txt', err => {
    if (err) throw err;
    console.log('File deleted');
  });
}
```

## Promise-based API

Node.js also provides a Promise-based API for `fs`, which is cleaner to use with `async/await`.

```javascript
const fs = require('fs/promises');

async function readFile() {
  try {
    const data = await fs.readFile('example.txt', 'utf8');
    console.log(data);
  } catch (err) {
    console.error(err);
  }
}

readFile();
```

## Streams

For large files, reading the whole file into memory (like `readFile` does) is inefficient. Streams allow you to process data piece by piece.

```javascript
const fs = require('fs');

const readStream = fs.createReadStream('largefile.txt', { encoding: 'utf8' });
const writeStream = fs.createWriteStream('copy.txt');

readStream.on('data', (chunk) => {
  console.log('--- NEW CHUNK ---');
  console.log(chunk);
  writeStream.write(chunk);
});

// Piping (easier way to copy)
// readStream.pipe(writeStream);
```

## Summary

- Use `fs.readFile` and `fs.writeFile` for simple file operations.
- Prefer **asynchronous** methods or the **Promise API** (`fs/promises`) to avoid blocking.
- Use **Streams** for handling large datasets efficiently.
- Always handle errors (e.g., file not found, permission denied).
