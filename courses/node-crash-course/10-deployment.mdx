---
title: "10. Deployment & Best Practices"
description: "Learn how to prepare your Node.js application for production and deploy it."
---

# Deployment & Best Practices

You've built your Node.js application, and it works perfectly on your machine. But **running in production is a completely different challenge**. Production environments face real-world constraints: thousands of concurrent users, security threats, server crashes, and the need for zero-downtime updates.

## Development vs. Production

Understanding the difference is crucial:

| Aspect | Development | Production |
|--------|-------------|------------|
| **Error messages** | Detailed stack traces | Generic user-friendly messages |
| **Performance** | Not optimized | Maximized, gzip compression |
| **Security** | Relaxed (localhost) | Hardened, HTTPS required |
| **Logging** | Console output | Structured logs, monitoring |
| **Restarts** | Manual | Automatic recovery on crash |
| **Configuration** | Hardcoded values OK | Environment variables only |

## Why Production Best Practices Matter

### Real-World Failures

Ignoring production best practices leads to:

- **Security breaches**: Hardcoded API keys leaked in public repositories
- **Downtime**: Single process crashes take down entire application
- **Data loss**: No proper error handling or logging
- **Poor performance**: Uncompressed responses, inefficient code

<Warning>
A single exposed API key or database password can compromise your entire application and user data. Never commit secrets to version control.
</Warning>

Let's go through essential practices to make your application production-ready.

## Environment Variables

Never hardcode sensitive information (API keys, database passwords, ports) in your code. Use environment variables.

1.  Install `dotenv`:
    ```bash
    npm install dotenv
    ```

2.  Create a `.env` file:
    ```
    PORT=5000
    DB_URI=mongodb://localhost:27017/myapp
    SECRET_KEY=mysecretkey
    ```

3.  Use it in your code:
    ```javascript
    require('dotenv').config();
    
    const PORT = process.env.PORT || 3000;
    console.log(process.env.DB_URI);
    ```

4.  **Important**: Add `.env` to your `.gitignore` file so it's not committed to version control.

## Production Best Practices

1.  **Use Gzip Compression**: Use the `compression` middleware to decrease the size of the response body.
    ```javascript
    const compression = require('compression');
    app.use(compression());
    ```

2.  **Security Headers**: Use `helmet` to set various HTTP headers for security.
    ```javascript
    const helmet = require('helmet');
    app.use(helmet());
    ```

3.  **Logging**: Use a logger like `morgan` or `winston` instead of `console.log`.

4.  **Error Handling**: Implement a global error handling middleware.

5.  **Clustering**: Use Node.js Cluster module or a process manager like PM2 to take advantage of multi-core systems.

## Deployment Options

### 1. Heroku (PaaS)

Heroku is a popular platform for deploying Node.js apps.

1.  Create a `Procfile` in the root:
    ```
    web: node server.js
    ```
2.  Install Heroku CLI and login.
3.  `heroku create`
4.  `git push heroku main`

### 2. Vercel / Netlify (Serverless)

Great for static sites and serverless functions. Next.js apps deploy seamlessly on Vercel.

### 3. VPS (DigitalOcean, AWS EC2, Linode)

For full control, you can rent a Virtual Private Server.
- Set up Linux (Ubuntu).
- Install Node.js and Nginx (as a reverse proxy).
- Use **PM2** to keep your app running.

## Using PM2

PM2 is a production process manager for Node.js.

```bash
npm install pm2 -g
pm2 start server.js
```

Commands:
- `pm2 list`: List running processes.
- `pm2 stop <id>`: Stop a process.
- `pm2 restart <id>`: Restart a process.
- `pm2 logs`: View logs.

## Summary

- Use **Environment Variables** for configuration.
- Follow security best practices (Helmet, Compression).
- Use a process manager like **PM2** for VPS deployments.
- Platforms like **Heroku** and **Vercel** offer easy deployment workflows.
