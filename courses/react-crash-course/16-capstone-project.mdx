---
title: "16. Capstone Project: Task Management App"
description: "Apply everything you've learned by building a complete React application from scratch."
---

# Capstone Project: Task Management App

Congratulations on reaching the final chapter! üéâ Now it's time to apply everything you've learned by building a complete, production-ready React application.

## Project Overview

We'll build **TaskFlow** ‚Äî a modern task management application with:

- ‚úÖ User authentication (login/register)
- ‚úÖ CRUD operations for tasks
- ‚úÖ Drag-and-drop task boards (Kanban style)
- ‚úÖ Categories and priority levels
- ‚úÖ Search and filtering
- ‚úÖ Dark mode toggle
- ‚úÖ Responsive design
- ‚úÖ Local storage persistence

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    TaskFlow App                             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  [Logo] TaskFlow           üîç Search...    [üåô] [Avatar]   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ               ‚îÇ                                             ‚îÇ
‚îÇ  üìã My Tasks  ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ
‚îÇ  üìÅ Work      ‚îÇ   ‚îÇ  TODO   ‚îÇ ‚îÇ DOING   ‚îÇ ‚îÇ  DONE   ‚îÇ      ‚îÇ
‚îÇ  üìÅ Personal  ‚îÇ   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§      ‚îÇ
‚îÇ  üìÅ Shopping  ‚îÇ   ‚îÇ Task 1  ‚îÇ ‚îÇ Task 4  ‚îÇ ‚îÇ Task 6  ‚îÇ      ‚îÇ
‚îÇ               ‚îÇ   ‚îÇ Task 2  ‚îÇ ‚îÇ Task 5  ‚îÇ ‚îÇ Task 7  ‚îÇ      ‚îÇ
‚îÇ  ‚ûï Add List  ‚îÇ   ‚îÇ Task 3  ‚îÇ ‚îÇ         ‚îÇ ‚îÇ Task 8  ‚îÇ      ‚îÇ
‚îÇ               ‚îÇ   ‚îÇ + Add   ‚îÇ ‚îÇ + Add   ‚îÇ ‚îÇ         ‚îÇ      ‚îÇ
‚îÇ               ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ
‚îÇ               ‚îÇ                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Step 1: Project Setup

### Initialize Project

```bash
npm create vite@latest taskflow -- --template react-ts
cd taskflow
npm install

# Install dependencies
npm install react-router-dom @dnd-kit/core @dnd-kit/sortable uuid
npm install -D @types/uuid tailwindcss postcss autoprefixer

# Initialize Tailwind
npx tailwindcss init -p
```

### Project Structure

```
src/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ common/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Input.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Modal.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Avatar.tsx
‚îÇ   ‚îú‚îÄ‚îÄ layout/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Header.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Sidebar.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Layout.tsx
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoginForm.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RegisterForm.tsx
‚îÇ   ‚îî‚îÄ‚îÄ tasks/
‚îÇ       ‚îú‚îÄ‚îÄ TaskBoard.tsx
‚îÇ       ‚îú‚îÄ‚îÄ TaskColumn.tsx
‚îÇ       ‚îú‚îÄ‚îÄ TaskCard.tsx
‚îÇ       ‚îú‚îÄ‚îÄ TaskForm.tsx
‚îÇ       ‚îî‚îÄ‚îÄ TaskFilter.tsx
‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îú‚îÄ‚îÄ useLocalStorage.ts
‚îÇ   ‚îú‚îÄ‚îÄ useAuth.ts
‚îÇ   ‚îî‚îÄ‚îÄ useTasks.ts
‚îú‚îÄ‚îÄ context/
‚îÇ   ‚îú‚îÄ‚îÄ AuthContext.tsx
‚îÇ   ‚îú‚îÄ‚îÄ TaskContext.tsx
‚îÇ   ‚îî‚îÄ‚îÄ ThemeContext.tsx
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îî‚îÄ‚îÄ helpers.ts
‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îú‚îÄ‚îÄ Home.tsx
‚îÇ   ‚îú‚îÄ‚îÄ Login.tsx
‚îÇ   ‚îú‚îÄ‚îÄ Register.tsx
‚îÇ   ‚îî‚îÄ‚îÄ Dashboard.tsx
‚îú‚îÄ‚îÄ App.tsx
‚îî‚îÄ‚îÄ main.tsx
```

---

## Step 2: Define Types

```typescript
// src/types/index.ts
export type Priority = 'low' | 'medium' | 'high';
export type Status = 'todo' | 'in-progress' | 'done';

export interface User {
  id: string;
  name: string;
  email: string;
  avatar?: string;
}

export interface Task {
  id: string;
  title: string;
  description: string;
  status: Status;
  priority: Priority;
  categoryId: string;
  dueDate?: string;
  createdAt: string;
  updatedAt: string;
}

export interface Category {
  id: string;
  name: string;
  color: string;
  icon: string;
}

export interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
}
```

---

## Step 3: Create Context Providers

### Theme Context

```tsx
// src/context/ThemeContext.tsx
import { createContext, useContext, useEffect, useState } from 'react';

type Theme = 'light' | 'dark';

interface ThemeContextType {
  theme: Theme;
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<Theme>(() => {
    const saved = localStorage.getItem('theme');
    return (saved as Theme) || 'light';
  });

  useEffect(() => {
    document.documentElement.classList.toggle('dark', theme === 'dark');
    localStorage.setItem('theme', theme);
  }, [theme]);

  const toggleTheme = () => setTheme(t => t === 'light' ? 'dark' : 'light');

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) throw new Error('useTheme must be used within ThemeProvider');
  return context;
}
```

### Auth Context

```tsx
// src/context/AuthContext.tsx
import { createContext, useContext, useReducer, useEffect } from 'react';
import type { User, AuthState } from '../types';

type AuthAction =
  | { type: 'LOGIN'; payload: User }
  | { type: 'LOGOUT' }
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'UPDATE_USER'; payload: Partial<User> };

interface AuthContextType extends AuthState {
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  register: (name: string, email: string, password: string) => Promise<void>;
  updateUser: (data: Partial<User>) => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

const initialState: AuthState = {
  user: null,
  isAuthenticated: false,
  isLoading: true
};

function authReducer(state: AuthState, action: AuthAction): AuthState {
  switch (action.type) {
    case 'LOGIN':
      return { user: action.payload, isAuthenticated: true, isLoading: false };
    case 'LOGOUT':
      return { user: null, isAuthenticated: false, isLoading: false };
    case 'SET_LOADING':
      return { ...state, isLoading: action.payload };
    case 'UPDATE_USER':
      return state.user 
        ? { ...state, user: { ...state.user, ...action.payload } }
        : state;
    default:
      return state;
  }
}

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = useReducer(authReducer, initialState);

  // Check for existing session on mount
  useEffect(() => {
    const savedUser = localStorage.getItem('user');
    if (savedUser) {
      dispatch({ type: 'LOGIN', payload: JSON.parse(savedUser) });
    } else {
      dispatch({ type: 'SET_LOADING', payload: false });
    }
  }, []);

  const login = async (email: string, password: string) => {
    // Simulate API call
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // In real app, validate against API
    const user: User = {
      id: crypto.randomUUID(),
      name: email.split('@')[0],
      email
    };
    
    localStorage.setItem('user', JSON.stringify(user));
    dispatch({ type: 'LOGIN', payload: user });
  };

  const logout = () => {
    localStorage.removeItem('user');
    dispatch({ type: 'LOGOUT' });
  };

  const register = async (name: string, email: string, password: string) => {
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const user: User = { id: crypto.randomUUID(), name, email };
    localStorage.setItem('user', JSON.stringify(user));
    dispatch({ type: 'LOGIN', payload: user });
  };

  const updateUser = (data: Partial<User>) => {
    dispatch({ type: 'UPDATE_USER', payload: data });
    if (state.user) {
      localStorage.setItem('user', JSON.stringify({ ...state.user, ...data }));
    }
  };

  return (
    <AuthContext.Provider value={{ ...state, login, logout, register, updateUser }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) throw new Error('useAuth must be used within AuthProvider');
  return context;
}
```

### Task Context

```tsx
// src/context/TaskContext.tsx
import { createContext, useContext, useReducer, useEffect } from 'react';
import type { Task, Category, Status } from '../types';

interface TaskState {
  tasks: Task[];
  categories: Category[];
  filter: {
    search: string;
    category: string | null;
    priority: string | null;
  };
}

type TaskAction =
  | { type: 'SET_TASKS'; payload: Task[] }
  | { type: 'ADD_TASK'; payload: Task }
  | { type: 'UPDATE_TASK'; payload: Task }
  | { type: 'DELETE_TASK'; payload: string }
  | { type: 'MOVE_TASK'; payload: { taskId: string; status: Status } }
  | { type: 'SET_FILTER'; payload: Partial<TaskState['filter']> }
  | { type: 'ADD_CATEGORY'; payload: Category }
  | { type: 'DELETE_CATEGORY'; payload: string };

interface TaskContextType extends TaskState {
  addTask: (task: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>) => void;
  updateTask: (task: Task) => void;
  deleteTask: (id: string) => void;
  moveTask: (taskId: string, status: Status) => void;
  setFilter: (filter: Partial<TaskState['filter']>) => void;
  addCategory: (category: Omit<Category, 'id'>) => void;
  deleteCategory: (id: string) => void;
  getFilteredTasks: () => Task[];
}

const TaskContext = createContext<TaskContextType | undefined>(undefined);

const defaultCategories: Category[] = [
  { id: '1', name: 'Work', color: '#3B82F6', icon: 'üíº' },
  { id: '2', name: 'Personal', color: '#10B981', icon: 'üè†' },
  { id: '3', name: 'Shopping', color: '#F59E0B', icon: 'üõí' }
];

const initialState: TaskState = {
  tasks: [],
  categories: defaultCategories,
  filter: { search: '', category: null, priority: null }
};

function taskReducer(state: TaskState, action: TaskAction): TaskState {
  switch (action.type) {
    case 'SET_TASKS':
      return { ...state, tasks: action.payload };
    
    case 'ADD_TASK':
      return { ...state, tasks: [...state.tasks, action.payload] };
    
    case 'UPDATE_TASK':
      return {
        ...state,
        tasks: state.tasks.map(t => t.id === action.payload.id ? action.payload : t)
      };
    
    case 'DELETE_TASK':
      return { ...state, tasks: state.tasks.filter(t => t.id !== action.payload) };
    
    case 'MOVE_TASK':
      return {
        ...state,
        tasks: state.tasks.map(t =>
          t.id === action.payload.taskId
            ? { ...t, status: action.payload.status, updatedAt: new Date().toISOString() }
            : t
        )
      };
    
    case 'SET_FILTER':
      return { ...state, filter: { ...state.filter, ...action.payload } };
    
    case 'ADD_CATEGORY':
      return { ...state, categories: [...state.categories, action.payload] };
    
    case 'DELETE_CATEGORY':
      return {
        ...state,
        categories: state.categories.filter(c => c.id !== action.payload)
      };
    
    default:
      return state;
  }
}

export function TaskProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = useReducer(taskReducer, initialState);

  // Load tasks from localStorage on mount
  useEffect(() => {
    const savedTasks = localStorage.getItem('tasks');
    const savedCategories = localStorage.getItem('categories');
    
    if (savedTasks) {
      dispatch({ type: 'SET_TASKS', payload: JSON.parse(savedTasks) });
    }
    if (savedCategories) {
      // Could also restore categories
    }
  }, []);

  // Save tasks to localStorage on change
  useEffect(() => {
    localStorage.setItem('tasks', JSON.stringify(state.tasks));
  }, [state.tasks]);

  const addTask = (task: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>) => {
    const now = new Date().toISOString();
    dispatch({
      type: 'ADD_TASK',
      payload: {
        ...task,
        id: crypto.randomUUID(),
        createdAt: now,
        updatedAt: now
      }
    });
  };

  const updateTask = (task: Task) => {
    dispatch({
      type: 'UPDATE_TASK',
      payload: { ...task, updatedAt: new Date().toISOString() }
    });
  };

  const deleteTask = (id: string) => dispatch({ type: 'DELETE_TASK', payload: id });
  
  const moveTask = (taskId: string, status: Status) => {
    dispatch({ type: 'MOVE_TASK', payload: { taskId, status } });
  };

  const setFilter = (filter: Partial<TaskState['filter']>) => {
    dispatch({ type: 'SET_FILTER', payload: filter });
  };

  const addCategory = (category: Omit<Category, 'id'>) => {
    dispatch({
      type: 'ADD_CATEGORY',
      payload: { ...category, id: crypto.randomUUID() }
    });
  };

  const deleteCategory = (id: string) => {
    dispatch({ type: 'DELETE_CATEGORY', payload: id });
  };

  const getFilteredTasks = () => {
    return state.tasks.filter(task => {
      const matchesSearch = task.title.toLowerCase().includes(state.filter.search.toLowerCase()) ||
                           task.description.toLowerCase().includes(state.filter.search.toLowerCase());
      const matchesCategory = !state.filter.category || task.categoryId === state.filter.category;
      const matchesPriority = !state.filter.priority || task.priority === state.filter.priority;
      
      return matchesSearch && matchesCategory && matchesPriority;
    });
  };

  return (
    <TaskContext.Provider value={{
      ...state,
      addTask, updateTask, deleteTask, moveTask,
      setFilter, addCategory, deleteCategory, getFilteredTasks
    }}>
      {children}
    </TaskContext.Provider>
  );
}

export function useTasks() {
  const context = useContext(TaskContext);
  if (!context) throw new Error('useTasks must be used within TaskProvider');
  return context;
}
```

---

## Step 4: Create Reusable Components

### Button Component

```tsx
// src/components/common/Button.tsx
import { forwardRef } from 'react';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'danger' | 'ghost';
  size?: 'sm' | 'md' | 'lg';
  isLoading?: boolean;
}

const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ variant = 'primary', size = 'md', isLoading, children, className = '', ...props }, ref) => {
    const baseStyles = 'inline-flex items-center justify-center font-medium rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50';
    
    const variants = {
      primary: 'bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500',
      secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300 focus:ring-gray-500 dark:bg-gray-700 dark:text-white',
      danger: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-500',
      ghost: 'bg-transparent hover:bg-gray-100 dark:hover:bg-gray-800'
    };

    const sizes = {
      sm: 'px-3 py-1.5 text-sm',
      md: 'px-4 py-2 text-base',
      lg: 'px-6 py-3 text-lg'
    };

    return (
      <button
        ref={ref}
        className={`${baseStyles} ${variants[variant]} ${sizes[size]} ${className}`}
        disabled={isLoading || props.disabled}
        {...props}
      >
        {isLoading ? (
          <svg className="animate-spin -ml-1 mr-2 h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z" />
          </svg>
        ) : null}
        {children}
      </button>
    );
  }
);

Button.displayName = 'Button';
export default Button;
```

### Input Component

```tsx
// src/components/common/Input.tsx
import { forwardRef } from 'react';

interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  label?: string;
  error?: string;
}

const Input = forwardRef<HTMLInputElement, InputProps>(
  ({ label, error, className = '', ...props }, ref) => {
    return (
      <div className="w-full">
        {label && (
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
            {label}
          </label>
        )}
        <input
          ref={ref}
          className={`
            w-full px-3 py-2 border rounded-lg
            bg-white dark:bg-gray-800
            border-gray-300 dark:border-gray-600
            text-gray-900 dark:text-white
            placeholder-gray-400 dark:placeholder-gray-500
            focus:ring-2 focus:ring-blue-500 focus:border-blue-500
            ${error ? 'border-red-500 focus:ring-red-500' : ''}
            ${className}
          `}
          {...props}
        />
        {error && (
          <p className="mt-1 text-sm text-red-600 dark:text-red-400">{error}</p>
        )}
      </div>
    );
  }
);

Input.displayName = 'Input';
export default Input;
```

### Modal Component

```tsx
// src/components/common/Modal.tsx
import { useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  children: React.ReactNode;
}

export default function Modal({ isOpen, onClose, title, children }: ModalProps) {
  const overlayRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClose();
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEscape);
      document.body.style.overflow = 'hidden';
    }

    return () => {
      document.removeEventListener('keydown', handleEscape);
      document.body.style.overflow = 'unset';
    };
  }, [isOpen, onClose]);

  if (!isOpen) return null;

  return createPortal(
    <div
      ref={overlayRef}
      className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/50"
      onClick={(e) => e.target === overlayRef.current && onClose()}
    >
      <div className="bg-white dark:bg-gray-800 rounded-xl shadow-xl w-full max-w-md animate-scale-in">
        <div className="flex items-center justify-between p-4 border-b dark:border-gray-700">
          <h2 className="text-lg font-semibold text-gray-900 dark:text-white">{title}</h2>
          <button
            onClick={onClose}
            className="p-1 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
        <div className="p-4">{children}</div>
      </div>
    </div>,
    document.body
  );
}
```

---

## Step 5: Build Task Components

### Task Card

```tsx
// src/components/tasks/TaskCard.tsx
import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import type { Task } from '../../types';
import { useTasks } from '../../context/TaskContext';

interface TaskCardProps {
  task: Task;
  onEdit: (task: Task) => void;
}

const priorityColors = {
  low: 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300',
  medium: 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-300',
  high: 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300'
};

export default function TaskCard({ task, onEdit }: TaskCardProps) {
  const { deleteTask, categories } = useTasks();
  const category = categories.find(c => c.id === task.categoryId);

  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging
  } = useSortable({ id: task.id });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      {...attributes}
      {...listeners}
      className="bg-white dark:bg-gray-700 p-4 rounded-lg shadow-sm border border-gray-200 dark:border-gray-600 cursor-grab active:cursor-grabbing"
    >
      <div className="flex items-start justify-between mb-2">
        <h3 className="font-medium text-gray-900 dark:text-white">{task.title}</h3>
        <div className="flex gap-1">
          <button
            onClick={() => onEdit(task)}
            className="p-1 text-gray-400 hover:text-blue-600"
          >
            ‚úèÔ∏è
          </button>
          <button
            onClick={() => deleteTask(task.id)}
            className="p-1 text-gray-400 hover:text-red-600"
          >
            üóëÔ∏è
          </button>
        </div>
      </div>
      
      {task.description && (
        <p className="text-sm text-gray-500 dark:text-gray-400 mb-3">
          {task.description}
        </p>
      )}

      <div className="flex items-center gap-2 flex-wrap">
        <span className={`px-2 py-0.5 text-xs rounded-full ${priorityColors[task.priority]}`}>
          {task.priority}
        </span>
        
        {category && (
          <span
            className="px-2 py-0.5 text-xs rounded-full"
            style={{ backgroundColor: category.color + '20', color: category.color }}
          >
            {category.icon} {category.name}
          </span>
        )}
        
        {task.dueDate && (
          <span className="text-xs text-gray-500">
            üìÖ {new Date(task.dueDate).toLocaleDateString()}
          </span>
        )}
      </div>
    </div>
  );
}
```

### Task Column

```tsx
// src/components/tasks/TaskColumn.tsx
import { useDroppable } from '@dnd-kit/core';
import { SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';
import type { Task, Status } from '../../types';
import TaskCard from './TaskCard';

interface TaskColumnProps {
  status: Status;
  tasks: Task[];
  onAddTask: () => void;
  onEditTask: (task: Task) => void;
}

const statusConfig = {
  'todo': { title: 'To Do', icon: 'üìã', color: 'border-gray-400' },
  'in-progress': { title: 'In Progress', icon: 'üîÑ', color: 'border-blue-400' },
  'done': { title: 'Done', icon: '‚úÖ', color: 'border-green-400' }
};

export default function TaskColumn({ status, tasks, onAddTask, onEditTask }: TaskColumnProps) {
  const { setNodeRef, isOver } = useDroppable({ id: status });
  const config = statusConfig[status];

  return (
    <div
      ref={setNodeRef}
      className={`
        flex flex-col min-w-[300px] max-w-[350px] bg-gray-50 dark:bg-gray-800/50 
        rounded-xl border-t-4 ${config.color}
        ${isOver ? 'ring-2 ring-blue-400' : ''}
      `}
    >
      <div className="p-4 flex items-center justify-between">
        <div className="flex items-center gap-2">
          <span>{config.icon}</span>
          <h2 className="font-semibold text-gray-900 dark:text-white">{config.title}</h2>
          <span className="px-2 py-0.5 text-xs bg-gray-200 dark:bg-gray-700 rounded-full">
            {tasks.length}
          </span>
        </div>
      </div>

      <div className="flex-1 p-2 space-y-2 overflow-y-auto min-h-[200px]">
        <SortableContext items={tasks.map(t => t.id)} strategy={verticalListSortingStrategy}>
          {tasks.map(task => (
            <TaskCard key={task.id} task={task} onEdit={onEditTask} />
          ))}
        </SortableContext>
      </div>

      <div className="p-2">
        <button
          onClick={onAddTask}
          className="w-full p-2 text-gray-500 hover:bg-gray-200 dark:hover:bg-gray-700 rounded-lg text-sm flex items-center justify-center gap-1"
        >
          ‚ûï Add Task
        </button>
      </div>
    </div>
  );
}
```

### Task Board

```tsx
// src/components/tasks/TaskBoard.tsx
import { useState } from 'react';
import { DndContext, DragEndEvent, closestCenter } from '@dnd-kit/core';
import { useTasks } from '../../context/TaskContext';
import type { Task, Status } from '../../types';
import TaskColumn from './TaskColumn';
import TaskForm from './TaskForm';
import Modal from '../common/Modal';

export default function TaskBoard() {
  const { getFilteredTasks, moveTask } = useTasks();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingTask, setEditingTask] = useState<Task | null>(null);
  const [defaultStatus, setDefaultStatus] = useState<Status>('todo');

  const tasks = getFilteredTasks();
  const columns: Status[] = ['todo', 'in-progress', 'done'];

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;
    
    if (over && active.id !== over.id) {
      const taskId = active.id as string;
      const newStatus = over.id as Status;
      
      if (columns.includes(newStatus)) {
        moveTask(taskId, newStatus);
      }
    }
  };

  const handleAddTask = (status: Status) => {
    setDefaultStatus(status);
    setEditingTask(null);
    setIsModalOpen(true);
  };

  const handleEditTask = (task: Task) => {
    setEditingTask(task);
    setIsModalOpen(true);
  };

  const handleCloseModal = () => {
    setIsModalOpen(false);
    setEditingTask(null);
  };

  return (
    <>
      <DndContext collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
        <div className="flex gap-4 p-4 overflow-x-auto">
          {columns.map(status => (
            <TaskColumn
              key={status}
              status={status}
              tasks={tasks.filter(t => t.status === status)}
              onAddTask={() => handleAddTask(status)}
              onEditTask={handleEditTask}
            />
          ))}
        </div>
      </DndContext>

      <Modal
        isOpen={isModalOpen}
        onClose={handleCloseModal}
        title={editingTask ? 'Edit Task' : 'New Task'}
      >
        <TaskForm
          task={editingTask}
          defaultStatus={defaultStatus}
          onClose={handleCloseModal}
        />
      </Modal>
    </>
  );
}
```

---

## Step 6: Create Pages

### Dashboard Page

```tsx
// src/pages/Dashboard.tsx
import { useTasks } from '../context/TaskContext';
import TaskBoard from '../components/tasks/TaskBoard';
import TaskFilter from '../components/tasks/TaskFilter';

export default function Dashboard() {
  const { tasks, categories } = useTasks();

  const stats = {
    total: tasks.length,
    todo: tasks.filter(t => t.status === 'todo').length,
    inProgress: tasks.filter(t => t.status === 'in-progress').length,
    done: tasks.filter(t => t.status === 'done').length
  };

  return (
    <div className="min-h-screen bg-gray-100 dark:bg-gray-900">
      {/* Stats Bar */}
      <div className="bg-white dark:bg-gray-800 border-b dark:border-gray-700 p-4">
        <div className="max-w-7xl mx-auto flex items-center justify-between">
          <div className="flex gap-6">
            <div>
              <span className="text-2xl font-bold text-gray-900 dark:text-white">{stats.total}</span>
              <span className="text-sm text-gray-500 ml-1">Total Tasks</span>
            </div>
            <div className="flex gap-4 text-sm">
              <span className="text-gray-500">üìã {stats.todo} To Do</span>
              <span className="text-blue-500">üîÑ {stats.inProgress} In Progress</span>
              <span className="text-green-500">‚úÖ {stats.done} Done</span>
            </div>
          </div>
          <TaskFilter />
        </div>
      </div>

      {/* Task Board */}
      <TaskBoard />
    </div>
  );
}
```

---

## Step 7: Wire It All Together

### App Component

```tsx
// src/App.tsx
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import { ThemeProvider } from './context/ThemeContext';
import { AuthProvider, useAuth } from './context/AuthContext';
import { TaskProvider } from './context/TaskContext';
import Layout from './components/layout/Layout';
import Home from './pages/Home';
import Login from './pages/Login';
import Register from './pages/Register';
import Dashboard from './pages/Dashboard';

function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const { isAuthenticated, isLoading } = useAuth();
  
  if (isLoading) return <div>Loading...</div>;
  if (!isAuthenticated) return <Navigate to="/login" replace />;
  
  return <>{children}</>;
}

function AppRoutes() {
  return (
    <Routes>
      <Route path="/" element={<Home />} />
      <Route path="/login" element={<Login />} />
      <Route path="/register" element={<Register />} />
      <Route
        path="/dashboard"
        element={
          <ProtectedRoute>
            <Layout>
              <Dashboard />
            </Layout>
          </ProtectedRoute>
        }
      />
    </Routes>
  );
}

export default function App() {
  return (
    <BrowserRouter>
      <ThemeProvider>
        <AuthProvider>
          <TaskProvider>
            <AppRoutes />
          </TaskProvider>
        </AuthProvider>
      </ThemeProvider>
    </BrowserRouter>
  );
}
```

---

## Challenges to Extend the Project

Once you have the basic app working, try adding these features:

<Accordion title="Challenge 1: Add Task Due Date Reminders">
Implement notifications for tasks with approaching due dates. Use the Notification API or create an in-app notification system.
</Accordion>

<Accordion title="Challenge 2: Add Task Comments">
Allow users to add comments to tasks. This requires extending the Task type and creating a comment section in the task detail view.
</Accordion>

<Accordion title="Challenge 3: Implement Subtasks">
Add the ability to create subtasks within a task. Track completion percentage based on completed subtasks.
</Accordion>

<Accordion title="Challenge 4: Add Data Export">
Implement export functionality to download tasks as JSON or CSV files for backup purposes.
</Accordion>

<Accordion title="Challenge 5: Connect to a Real Backend">
Replace localStorage with a real backend API using Firebase, Supabase, or your own REST/GraphQL API.
</Accordion>

---

## Deployment Checklist

Before deploying your app:

- [ ] Test all features thoroughly
- [ ] Ensure responsive design works on mobile
- [ ] Add proper error handling and loading states
- [ ] Optimize bundle size with code splitting
- [ ] Set up proper environment variables
- [ ] Add meta tags for SEO
- [ ] Test in production build (`npm run build && npm run preview`)
- [ ] Deploy to Vercel, Netlify, or your preferred platform

---

## üéâ Congratulations!

You've completed the React Crash Course! You've learned:

| Chapter | Skills Acquired |
|---------|-----------------|
| **1-3** | JSX, Components, Props, State |
| **4-6** | Events, Lists, Forms |
| **7-8** | useEffect, Context API |
| **9-10** | React Router, Performance |
| **11-12** | Authentication, Redux |
| **13-14** | Custom Hooks, Testing |
| **15-16** | TypeScript, Full App |

<Tip>
**What's Next?**
- Build more projects to solidify your skills
- Learn Next.js for server-side rendering
- Explore React Native for mobile development
- Contribute to open-source React projects
- Stay updated with React's latest features
</Tip>

<Card title="Keep Building!" icon="rocket">
The best way to master React is to keep building. Take this capstone project and make it your own. Add features, improve the UI, connect it to a real backend. Every line of code you write makes you a better developer!
</Card>
