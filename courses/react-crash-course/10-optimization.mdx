---
title: "10. Optimization & Deployment"
description: "Learn techniques to optimize React apps and deploy them to production."
---

# Optimization & Deployment

As your React application grows, you may notice performance issues like slow initial load times, laggy interactions, or unnecessary re-renders. Understanding **when and how to optimize** is crucial for delivering a smooth user experience.

## Why Optimization Matters

React is already fast out of the box thanks to its Virtual DOM, but there are scenarios where performance can degrade:

- **Large bundle sizes** slow down initial page loads
- **Unnecessary re-renders** waste CPU cycles and cause UI lag
- **Expensive calculations** on every render block the main thread
- **Unoptimized images and assets** increase load times

<Tip>
**The Golden Rule of Optimization**: Don't optimize prematurely! Always measure first using React DevTools Profiler or browser performance tools. Optimize only when you identify actual bottlenecks.
</Tip>

## Understanding React's Rendering Behavior

Before diving into optimization techniques, it's important to understand how React decides to re-render:

1. When a component's **state changes**, it re-renders
2. When a component's **props change**, it re-renders
3. When a **parent component re-renders**, all its children re-render by default

This cascading behavior is often fine, but in large component trees, it can cause performance issues.

## Performance Optimization

### 1. Code Splitting (Lazy Loading)

By default, React bundles all your code into a single JavaScript file. For large apps, this means users download everything upfrontâ€”even pages they may never visit.

**Code splitting** solves this by loading components only when they are needed.

```javascript
import React, { Suspense, lazy } from 'react';

const About = lazy(() => import('./About'));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <About />
    </Suspense>
  );
}
```

### 2. React.memo

Prevents functional components from re-rendering if their props haven't changed.

```javascript
const MyComponent = React.memo(function MyComponent(props) {
  /* render using props */
});
```

### 3. useCallback & useMemo

- **useCallback**: Memoizes a function definition so it doesn't change on every render (useful when passing functions to child components).
- **useMemo**: Memoizes the result of a calculation.

```javascript
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);

const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

## Deployment

### Building for Production

When you are ready to deploy, run the build command.

```bash
npm run build
```

This creates a `dist` (or `build`) folder with optimized static files (minified HTML, CSS, JS).

### Deploying to Vercel

1.  Push your code to GitHub.
2.  Go to Vercel and import your repository.
3.  Vercel automatically detects Vite/Create React App and configures the build settings.
4.  Click Deploy.

### Deploying to Netlify

1.  Drag and drop your `dist` folder to Netlify Drop.
2.  Or connect to GitHub for continuous deployment.

### Handling Client-Side Routing on Static Hosts

If you use React Router, you might get 404 errors when refreshing a page like `/about`. You need to configure your host to redirect all requests to `index.html`.

- **Netlify**: Create a `_redirects` file in `public`:
  ```
  /*  /index.html  200
  ```
- **Vercel**: Create `vercel.json`:
  ```json
  {
    "rewrites": [{ "source": "/(.*)", "destination": "/" }]
  }
  ```

## Summary

- Use **Lazy Loading** to reduce initial bundle size.
- Use **React.memo**, **useCallback**, and **useMemo** to prevent unnecessary re-renders.
- Run `npm run build` to generate production assets.
- Deploy to static hosts like **Vercel** or **Netlify**.
- Configure **rewrites** for client-side routing support.
