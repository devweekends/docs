---
title: "10. Performance Optimization"
description: "Master React performance optimization, profiling, and production-ready techniques."
---

# Performance Optimization

React is fast by default, but complex applications can slow down. This chapter covers techniques to identify bottlenecks and optimize your React apps.

## When to Optimize

<Warning>
**Premature optimization is the root of all evil.** Always measure first! Only optimize when you:
1. Have actual performance issues users notice
2. Have profiled and identified the bottleneck
3. Can measure the improvement

Most React apps don't need heavy optimization.
</Warning>

## Understanding Re-renders

Every time state or props change, React re-renders components. Understanding this is key to optimization.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Component Re-render Flow                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  State/Props Change                                         â”‚
â”‚         â”‚                                                   â”‚
â”‚         â–¼                                                   â”‚
â”‚  Component function runs again                              â”‚
â”‚         â”‚                                                   â”‚
â”‚         â–¼                                                   â”‚
â”‚  New JSX created                                            â”‚
â”‚         â”‚                                                   â”‚
â”‚         â–¼                                                   â”‚
â”‚  React diffs Virtual DOM                                    â”‚
â”‚         â”‚                                                   â”‚
â”‚         â–¼                                                   â”‚
â”‚  Only actual changes update real DOM                        â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### What Causes Re-renders?

1. **Component's state changes** (`useState`, `useReducer`)
2. **Parent component re-renders**
3. **Context value changes**
4. **Custom hook state changes**

---

## React DevTools Profiler

The Profiler helps identify what's rendering and why.

### Using the Profiler

1. Install React DevTools browser extension
2. Open DevTools â†’ Profiler tab
3. Click "Record" and interact with your app
4. Analyze the flame graph

### What to Look For

- **Frequent re-renders** of the same component
- **Slow components** (long render times)
- **Cascade re-renders** (parent update causing all children to update)

---

## React.memo - Prevent Unnecessary Re-renders

`React.memo` is a higher-order component that memoizes functional components.

### Basic Usage

```javascript
// Without memo - re-renders whenever parent renders
function ExpensiveList({ items }) {
  console.log('ExpensiveList rendered');
  return (
    <ul>
      {items.map(item => <li key={item.id}>{item.name}</li>)}
    </ul>
  );
}

// With memo - only re-renders when `items` changes
const ExpensiveList = React.memo(function ExpensiveList({ items }) {
  console.log('ExpensiveList rendered');
  return (
    <ul>
      {items.map(item => <li key={item.id}>{item.name}</li>)}
    </ul>
  );
});
```

### Custom Comparison

```javascript
const UserCard = React.memo(
  function UserCard({ user, onSelect }) {
    return (
      <div onClick={() => onSelect(user.id)}>
        <h3>{user.name}</h3>
        <p>{user.email}</p>
      </div>
    );
  },
  // Custom comparison function
  (prevProps, nextProps) => {
    return prevProps.user.id === nextProps.user.id &&
           prevProps.user.name === nextProps.user.name;
  }
);
```

<Warning>
`React.memo` does a **shallow comparison** by default. If you pass new object/array references every render, memoization won't work!

```javascript
// âŒ Bad - new array on every render
<MemoizedComponent items={data.filter(x => x.active)} />

// âœ… Good - memoize the filtered data
const activeItems = useMemo(() => data.filter(x => x.active), [data]);
<MemoizedComponent items={activeItems} />
```
</Warning>

---

## useMemo - Memoize Expensive Calculations

`useMemo` caches the result of expensive computations.

```javascript
function ProductList({ products, filter }) {
  // âŒ Without useMemo - runs on every render
  const filteredProducts = products
    .filter(p => p.category === filter)
    .sort((a, b) => a.price - b.price);

  // âœ… With useMemo - only recalculates when dependencies change
  const filteredProducts = useMemo(() => {
    console.log('Filtering and sorting...');
    return products
      .filter(p => p.category === filter)
      .sort((a, b) => a.price - b.price);
  }, [products, filter]);

  return (/* render list */);
}
```

### When to Use useMemo

| Use useMemo | Don't Use useMemo |
|-------------|-------------------|
| Expensive calculations | Simple math/string operations |
| Large array operations | Small arrays (fewer than 100 items) |
| Object creation for memoized children | Objects used once |
| Derived data from props/state | Values passed to native elements |

---

## useCallback - Memoize Functions

`useCallback` caches function references to prevent unnecessary re-renders of child components.

```javascript
function Parent() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');

  // âŒ New function created every render
  const handleClick = () => {
    console.log('Clicked!');
  };

  // âœ… Same function reference unless dependencies change
  const handleClick = useCallback(() => {
    console.log('Clicked!');
  }, []);

  // With dependencies
  const handleSubmit = useCallback(() => {
    submitForm(text);
  }, [text]);

  return (
    <div>
      <input value={text} onChange={e => setText(e.target.value)} />
      <Counter count={count} />
      <MemoizedButton onClick={handleClick} />
    </div>
  );
}

const MemoizedButton = React.memo(function Button({ onClick }) {
  console.log('Button rendered');
  return <button onClick={onClick}>Click me</button>;
});
```

<Tip>
**useCallback + React.memo = Optimization Power Combo**

`useCallback` alone doesn't prevent re-renders. It only helps when:
1. Passed to a `React.memo`-wrapped child component
2. Used as a dependency in other hooks
</Tip>

---

## Code Splitting with React.lazy

Split your bundle so users only download what they need.

```javascript
import { lazy, Suspense } from 'react';

// Lazy load components
const Dashboard = lazy(() => import('./pages/Dashboard'));
const Analytics = lazy(() => import('./pages/Analytics'));
const Settings = lazy(() => import('./pages/Settings'));

function App() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/dashboard" element={<Dashboard />} />
        <Route path="/analytics" element={<Analytics />} />
        <Route path="/settings" element={<Settings />} />
      </Routes>
    </Suspense>
  );
}
```

### Named Exports with Lazy

```javascript
// For named exports, create an intermediate module
// utils/lazyImport.js
export function lazyImport(factory, name) {
  return lazy(() => 
    factory().then(module => ({ default: module[name] }))
  );
}

// Usage
const Dashboard = lazyImport(
  () => import('./pages/Dashboard'),
  'Dashboard'
);
```

---

## Virtualization for Long Lists

Only render visible items in long lists.

### Using react-window

```bash
npm install react-window
```

```javascript
import { FixedSizeList } from 'react-window';

function VirtualizedList({ items }) {
  const Row = ({ index, style }) => (
    <div style={style} className="list-item">
      {items[index].name}
    </div>
  );

  return (
    <FixedSizeList
      height={400}
      width="100%"
      itemCount={items.length}
      itemSize={50}
    >
      {Row}
    </FixedSizeList>
  );
}
```

### Variable Size List

```javascript
import { VariableSizeList } from 'react-window';

function VariableList({ items }) {
  const getItemSize = (index) => {
    return items[index].type === 'header' ? 80 : 50;
  };

  const Row = ({ index, style }) => (
    <div style={style}>
      {items[index].content}
    </div>
  );

  return (
    <VariableSizeList
      height={400}
      width="100%"
      itemCount={items.length}
      itemSize={getItemSize}
    >
      {Row}
    </VariableSizeList>
  );
}
```

---

## Debouncing and Throttling

Limit how often functions are called.

### Debouncing (Wait for pause)

```javascript
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const timer = setTimeout(() => setDebouncedValue(value), delay);
    return () => clearTimeout(timer);
  }, [value, delay]);

  return debouncedValue;
}

// Usage
function SearchInput() {
  const [query, setQuery] = useState('');
  const debouncedQuery = useDebounce(query, 300);

  useEffect(() => {
    if (debouncedQuery) {
      searchAPI(debouncedQuery);
    }
  }, [debouncedQuery]);

  return (
    <input 
      value={query} 
      onChange={e => setQuery(e.target.value)}
      placeholder="Search..."
    />
  );
}
```

### Throttling (Limit frequency)

```javascript
function useThrottle(value, limit) {
  const [throttledValue, setThrottledValue] = useState(value);
  const lastRan = useRef(Date.now());

  useEffect(() => {
    const handler = setTimeout(() => {
      if (Date.now() - lastRan.current >= limit) {
        setThrottledValue(value);
        lastRan.current = Date.now();
      }
    }, limit - (Date.now() - lastRan.current));

    return () => clearTimeout(handler);
  }, [value, limit]);

  return throttledValue;
}
```

---

## Image Optimization

### Lazy Loading Images

```javascript
function LazyImage({ src, alt, ...props }) {
  return (
    <img 
      src={src} 
      alt={alt} 
      loading="lazy"  // Native lazy loading
      {...props}
    />
  );
}
```

### Progressive Loading with Blur

```javascript
function ProgressiveImage({ lowQualitySrc, highQualitySrc, alt }) {
  const [loaded, setLoaded] = useState(false);

  return (
    <div className="progressive-image">
      <img 
        src={lowQualitySrc}
        alt={alt}
        className={`low-quality ${loaded ? 'hidden' : ''}`}
        style={{ filter: 'blur(10px)' }}
      />
      <img 
        src={highQualitySrc}
        alt={alt}
        className={`high-quality ${loaded ? '' : 'hidden'}`}
        onLoad={() => setLoaded(true)}
      />
    </div>
  );
}
```

---

## Web Vitals

Key metrics for user experience:

| Metric | Description | Target |
|--------|-------------|--------|
| **LCP** (Largest Contentful Paint) | Main content visible | < 2.5s |
| **FID** (First Input Delay) | Time to interactive | < 100ms |
| **CLS** (Cumulative Layout Shift) | Visual stability | < 0.1 |
| **TTFB** (Time to First Byte) | Server response time | < 600ms |

### Measuring Web Vitals

```javascript
import { getCLS, getFID, getLCP } from 'web-vitals';

getCLS(console.log);
getFID(console.log);
getLCP(console.log);

// Or send to analytics
function sendToAnalytics({ name, delta, id }) {
  analytics.send({
    metric: name,
    value: delta,
    id
  });
}

getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getLCP(sendToAnalytics);
```

---

## Production Build Optimization

### Vite Production Build

```bash
npm run build
npm run preview  # Preview production build locally
```

### Analyze Bundle Size

```bash
# Install bundle analyzer
npm install -D rollup-plugin-visualizer

# vite.config.js
import { visualizer } from 'rollup-plugin-visualizer';

export default defineConfig({
  plugins: [
    react(),
    visualizer({ open: true })
  ]
});
```

### Environment-Specific Code

```javascript
// Remove development-only code in production
if (import.meta.env.DEV) {
  console.log('Debug info:', data);
}
```

---

## Deployment

### Vercel (Recommended for React)

```bash
npm install -g vercel
vercel
```

Or connect your GitHub repo at [vercel.com](https://vercel.com).

### Netlify

Create `netlify.toml`:

```toml
[build]
  command = "npm run build"
  publish = "dist"

[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200
```

### Docker

```dockerfile
# Build stage
FROM node:18-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Production stage
FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

---

## ğŸ¯ Practice Exercises

<Accordion title="Exercise 1: Optimize a Slow List">
```javascript
// Before: Slow component
function ProductList({ products, onSelect }) {
  const [filter, setFilter] = useState('');

  // Recalculates on every keystroke
  const filtered = products.filter(p => 
    p.name.toLowerCase().includes(filter.toLowerCase())
  );

  return (
    <div>
      <input 
        value={filter} 
        onChange={e => setFilter(e.target.value)} 
      />
      {filtered.map(product => (
        <ProductCard 
          key={product.id}
          product={product}
          onSelect={() => onSelect(product)}
        />
      ))}
    </div>
  );
}

// After: Optimized
const ProductCard = React.memo(function ProductCard({ product, onSelect }) {
  return (
    <div onClick={onSelect}>
      <h3>{product.name}</h3>
      <p>${product.price}</p>
    </div>
  );
});

function ProductList({ products, onSelect }) {
  const [filter, setFilter] = useState('');
  const debouncedFilter = useDebounce(filter, 300);

  const filtered = useMemo(() => 
    products.filter(p => 
      p.name.toLowerCase().includes(debouncedFilter.toLowerCase())
    ),
    [products, debouncedFilter]
  );

  const handleSelect = useCallback((product) => {
    onSelect(product);
  }, [onSelect]);

  return (
    <div>
      <input 
        value={filter} 
        onChange={e => setFilter(e.target.value)} 
      />
      {filtered.map(product => (
        <ProductCard 
          key={product.id}
          product={product}
          onSelect={() => handleSelect(product)}
        />
      ))}
    </div>
  );
}
```
</Accordion>

---

## Summary

| Technique | Use Case |
|-----------|----------|
| **React.memo** | Prevent child re-renders when props unchanged |
| **useMemo** | Cache expensive calculations |
| **useCallback** | Cache function references |
| **React.lazy** | Code split by route/component |
| **Virtualization** | Long lists (100+ items) |
| **Debouncing** | Search inputs, resize handlers |
| **Lazy loading** | Images below the fold |
| **Bundle analysis** | Identify large dependencies |
| **Web Vitals** | Measure real user experience |

<Card title="Next Steps" icon="arrow-right">
In the next chapter, you'll learn about **Authentication & Protected Routes** â€” securing your React applications!
</Card>
