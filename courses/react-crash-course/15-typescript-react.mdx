---
title: "15. TypeScript with React"
description: "Add type safety to your React applications with TypeScript for better developer experience."
---

# TypeScript with React

TypeScript adds static type checking to JavaScript, catching errors at compile time and providing better IDE support. It's now the standard for professional React development.

## Why TypeScript?

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 TypeScript Benefits                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  âœ“ Catch errors before runtime                              â”‚
â”‚  âœ“ Better autocomplete and IntelliSense                     â”‚
â”‚  âœ“ Self-documenting code                                    â”‚
â”‚  âœ“ Easier refactoring                                       â”‚
â”‚  âœ“ Better team collaboration                                â”‚
â”‚  âœ“ Improved IDE support (VS Code)                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Setting Up TypeScript

### New Project

```bash
# Vite (recommended)
npm create vite@latest my-app -- --template react-ts

# Create React App
npx create-react-app my-app --template typescript

# Next.js
npx create-next-app@latest my-app --typescript
```

### Adding to Existing Project

```bash
npm install -D typescript @types/react @types/react-dom

# Generate tsconfig.json
npx tsc --init
```

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
```

---

## Basic TypeScript Concepts

### Type Annotations

```typescript
// Primitives
let name: string = 'John';
let age: number = 25;
let isActive: boolean = true;

// Arrays
let numbers: number[] = [1, 2, 3];
let names: Array<string> = ['a', 'b', 'c'];

// Objects
let user: { name: string; age: number } = {
  name: 'John',
  age: 25
};

// Functions
function greet(name: string): string {
  return `Hello, ${name}!`;
}

// Arrow functions
const add = (a: number, b: number): number => a + b;
```

### Interfaces vs Types

```typescript
// Interface - preferred for objects
interface User {
  id: number;
  name: string;
  email: string;
}

// Type - preferred for unions, primitives, tuples
type Status = 'idle' | 'loading' | 'success' | 'error';
type ID = string | number;
type Point = [number, number];

// Both can be extended
interface Admin extends User {
  role: 'admin';
  permissions: string[];
}

type SuperAdmin = Admin & {
  superPowers: string[];
};
```

### Generics

```typescript
// Generic function
function first<T>(arr: T[]): T | undefined {
  return arr[0];
}

const num = first([1, 2, 3]);     // number
const str = first(['a', 'b']);    // string

// Generic interface
interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
}

const userResponse: ApiResponse<User> = {
  data: { id: 1, name: 'John', email: 'john@example.com' },
  status: 200,
  message: 'Success'
};
```

---

## Typing React Components

### Function Components

```tsx
// Basic component with props
interface GreetingProps {
  name: string;
  age?: number;  // Optional prop
}

function Greeting({ name, age }: GreetingProps) {
  return (
    <div>
      <p>Hello, {name}!</p>
      {age && <p>You are {age} years old.</p>}
    </div>
  );
}

// With children
interface CardProps {
  title: string;
  children: React.ReactNode;
}

function Card({ title, children }: CardProps) {
  return (
    <div className="card">
      <h2>{title}</h2>
      {children}
    </div>
  );
}
```

### Using React.FC (Optional)

```tsx
// React.FC includes children by default and return type
const Button: React.FC<{ onClick: () => void }> = ({ onClick, children }) => {
  return <button onClick={onClick}>{children}</button>;
};

// Without React.FC (often preferred)
interface ButtonProps {
  onClick: () => void;
  children: React.ReactNode;
}

function Button({ onClick, children }: ButtonProps) {
  return <button onClick={onClick}>{children}</button>;
}
```

<Tip>
Many developers prefer not using `React.FC` as it's less explicit. Define props interfaces separately and type children when needed.
</Tip>

---

## Typing Hooks

### useState

```tsx
// Type is inferred
const [count, setCount] = useState(0);  // number
const [name, setName] = useState('');   // string

// Explicit typing for complex types
interface User {
  id: number;
  name: string;
}

const [user, setUser] = useState<User | null>(null);

// Array state
const [items, setItems] = useState<string[]>([]);

// Object state
interface FormData {
  email: string;
  password: string;
}

const [form, setForm] = useState<FormData>({
  email: '',
  password: ''
});
```

### useRef

```tsx
// DOM element ref
const inputRef = useRef<HTMLInputElement>(null);
const divRef = useRef<HTMLDivElement>(null);
const buttonRef = useRef<HTMLButtonElement>(null);

// Mutable value ref
const countRef = useRef<number>(0);
const timerRef = useRef<NodeJS.Timeout | null>(null);

function Example() {
  const inputRef = useRef<HTMLInputElement>(null);

  const focusInput = () => {
    inputRef.current?.focus();  // Optional chaining for null safety
  };

  return <input ref={inputRef} />;
}
```

### useReducer

```tsx
interface State {
  count: number;
  error: string | null;
}

type Action =
  | { type: 'increment' }
  | { type: 'decrement' }
  | { type: 'reset' }
  | { type: 'setCount'; payload: number }
  | { type: 'setError'; payload: string };

function reducer(state: State, action: Action): State {
  switch (action.type) {
    case 'increment':
      return { ...state, count: state.count + 1, error: null };
    case 'decrement':
      return { ...state, count: state.count - 1, error: null };
    case 'reset':
      return { count: 0, error: null };
    case 'setCount':
      return { ...state, count: action.payload };
    case 'setError':
      return { ...state, error: action.payload };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0, error: null });
  
  return (
    <button onClick={() => dispatch({ type: 'increment' })}>
      Count: {state.count}
    </button>
  );
}
```

### useContext

```tsx
interface Theme {
  primaryColor: string;
  secondaryColor: string;
  isDark: boolean;
}

interface ThemeContextType {
  theme: Theme;
  setTheme: (theme: Theme) => void;
  toggleDark: () => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

// Custom hook with type guard
function useTheme(): ThemeContextType {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
}

// Provider component
function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<Theme>({
    primaryColor: '#007bff',
    secondaryColor: '#6c757d',
    isDark: false
  });

  const toggleDark = () => {
    setTheme(t => ({ ...t, isDark: !t.isDark }));
  };

  return (
    <ThemeContext.Provider value={{ theme, setTheme, toggleDark }}>
      {children}
    </ThemeContext.Provider>
  );
}
```

---

## Typing Events

### Common Event Types

```tsx
function Form() {
  // Change event
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    console.log(e.target.value);
  };

  // Form submit event
  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
  };

  // Click event
  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
    console.log(e.clientX, e.clientY);
  };

  // Keyboard event
  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      // Handle enter
    }
  };

  // Focus event
  const handleFocus = (e: React.FocusEvent<HTMLInputElement>) => {
    console.log('Focused');
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        onChange={handleChange}
        onKeyDown={handleKeyDown}
        onFocus={handleFocus}
      />
      <button type="submit" onClick={handleClick}>Submit</button>
    </form>
  );
}
```

### Event Type Reference

| Element | Event | Type |
|---------|-------|------|
| `<input>` | onChange | `React.ChangeEvent<HTMLInputElement>` |
| `<textarea>` | onChange | `React.ChangeEvent<HTMLTextAreaElement>` |
| `<select>` | onChange | `React.ChangeEvent<HTMLSelectElement>` |
| `<form>` | onSubmit | `React.FormEvent<HTMLFormElement>` |
| `<button>` | onClick | `React.MouseEvent<HTMLButtonElement>` |
| `<div>` | onClick | `React.MouseEvent<HTMLDivElement>` |
| `<input>` | onKeyDown | `React.KeyboardEvent<HTMLInputElement>` |
| Any | onDrag | `React.DragEvent<HTMLElement>` |

---

## Typing Props Patterns

### Children Prop

```tsx
// ReactNode - most flexible
interface ContainerProps {
  children: React.ReactNode;
}

// ReactElement - only JSX elements
interface WrapperProps {
  children: React.ReactElement;
}

// Specific elements
interface ListProps {
  children: React.ReactElement<ListItemProps>[];
}

// Function as children (render props)
interface RenderProps {
  children: (data: { count: number }) => React.ReactNode;
}

function Counter({ children }: RenderProps) {
  const [count, setCount] = useState(0);
  return <div>{children({ count })}</div>;
}
```

### Default Props

```tsx
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'sm' | 'md' | 'lg';
  disabled?: boolean;
  children: React.ReactNode;
}

function Button({
  variant = 'primary',
  size = 'md',
  disabled = false,
  children
}: ButtonProps) {
  return (
    <button className={`btn-${variant} btn-${size}`} disabled={disabled}>
      {children}
    </button>
  );
}
```

### Spread Props

```tsx
// Extend HTML button attributes
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary';
  isLoading?: boolean;
}

function Button({ variant = 'primary', isLoading, children, ...rest }: ButtonProps) {
  return (
    <button className={`btn-${variant}`} disabled={isLoading} {...rest}>
      {isLoading ? 'Loading...' : children}
    </button>
  );
}

// Usage - all button props are valid
<Button variant="primary" onClick={handleClick} type="submit">
  Submit
</Button>
```

### Conditional Props

```tsx
// Discriminated unions for conditional props
type ButtonProps =
  | {
      variant: 'link';
      href: string;
      onClick?: never;
    }
  | {
      variant: 'button';
      onClick: () => void;
      href?: never;
    };

function Button(props: ButtonProps) {
  if (props.variant === 'link') {
    return <a href={props.href}>Link</a>;
  }
  return <button onClick={props.onClick}>Button</button>;
}

// Usage
<Button variant="link" href="/about" />      // âœ… Valid
<Button variant="button" onClick={fn} />     // âœ… Valid
<Button variant="link" onClick={fn} />       // âŒ Error
```

---

## Typing Custom Hooks

```tsx
// Simple hook with return type inferred
function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);
  
  const toggle = useCallback(() => setValue(v => !v), []);
  const setTrue = useCallback(() => setValue(true), []);
  const setFalse = useCallback(() => setValue(false), []);

  return { value, toggle, setTrue, setFalse };
}

// Hook with explicit types
interface UseFetchResult<T> {
  data: T | null;
  loading: boolean;
  error: Error | null;
  refetch: () => void;
}

function useFetch<T>(url: string): UseFetchResult<T> {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      const response = await fetch(url);
      const json = await response.json();
      setData(json);
    } catch (e) {
      setError(e as Error);
    } finally {
      setLoading(false);
    }
  }, [url]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return { data, loading, error, refetch: fetchData };
}

// Usage
interface User {
  id: number;
  name: string;
}

function UserProfile() {
  const { data: user, loading, error } = useFetch<User>('/api/user');
  
  if (loading) return <Spinner />;
  if (error) return <Error message={error.message} />;
  
  return <div>{user?.name}</div>;
}
```

---

## Working with APIs

### Typing API Responses

```tsx
// Define API types
interface User {
  id: number;
  name: string;
  email: string;
}

interface Post {
  id: number;
  title: string;
  body: string;
  userId: number;
}

interface PaginatedResponse<T> {
  data: T[];
  total: number;
  page: number;
  perPage: number;
  totalPages: number;
}

// API functions
async function fetchUser(id: number): Promise<User> {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
}

async function fetchPosts(page: number): Promise<PaginatedResponse<Post>> {
  const response = await fetch(`/api/posts?page=${page}`);
  return response.json();
}
```

### Type Guards

```tsx
interface SuccessResponse<T> {
  success: true;
  data: T;
}

interface ErrorResponse {
  success: false;
  error: string;
}

type ApiResponse<T> = SuccessResponse<T> | ErrorResponse;

// Type guard function
function isSuccess<T>(response: ApiResponse<T>): response is SuccessResponse<T> {
  return response.success === true;
}

// Usage
async function handleResponse() {
  const response: ApiResponse<User> = await fetchData();
  
  if (isSuccess(response)) {
    // TypeScript knows response.data exists here
    console.log(response.data.name);
  } else {
    // TypeScript knows response.error exists here
    console.log(response.error);
  }
}
```

---

## Typing Redux Toolkit

```tsx
import { createSlice, PayloadAction, configureStore } from '@reduxjs/toolkit';

// State type
interface CounterState {
  value: number;
  status: 'idle' | 'loading' | 'failed';
}

const initialState: CounterState = {
  value: 0,
  status: 'idle'
};

// Slice
const counterSlice = createSlice({
  name: 'counter',
  initialState,
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
    incrementByAmount: (state, action: PayloadAction<number>) => {
      state.value += action.payload;
    }
  }
});

export const { increment, decrement, incrementByAmount } = counterSlice.actions;

// Store
const store = configureStore({
  reducer: {
    counter: counterSlice.reducer
  }
});

// Infer types from store
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

// Typed hooks
import { useDispatch, useSelector, TypedUseSelectorHook } from 'react-redux';

export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;

// Usage in components
function Counter() {
  const count = useAppSelector((state) => state.counter.value);
  const dispatch = useAppDispatch();

  return (
    <button onClick={() => dispatch(incrementByAmount(5))}>
      Count: {count}
    </button>
  );
}
```

---

## Common Patterns & Utility Types

```tsx
// Partial - all properties optional
type PartialUser = Partial<User>;
// { id?: number; name?: string; email?: string }

// Required - all properties required
type RequiredUser = Required<PartialUser>;

// Pick - select specific properties
type UserPreview = Pick<User, 'id' | 'name'>;
// { id: number; name: string }

// Omit - exclude specific properties
type UserWithoutEmail = Omit<User, 'email'>;
// { id: number; name: string }

// Record - create object type
type UserRoles = Record<string, 'admin' | 'user' | 'guest'>;
// { [key: string]: 'admin' | 'user' | 'guest' }

// Extract - extract union members
type Status = 'active' | 'inactive' | 'pending';
type ActiveStatus = Extract<Status, 'active' | 'pending'>;
// 'active' | 'pending'

// Exclude - exclude union members
type InactiveStatus = Exclude<Status, 'active'>;
// 'inactive' | 'pending'

// NonNullable - remove null and undefined
type MaybeString = string | null | undefined;
type DefiniteString = NonNullable<MaybeString>;
// string

// ReturnType - infer function return type
function createUser() {
  return { id: 1, name: 'John' };
}
type CreateUserReturn = ReturnType<typeof createUser>;
// { id: number; name: string }

// Parameters - infer function parameters
type CreateUserParams = Parameters<typeof createUser>;
// []
```

---

## ğŸ¯ Practice Exercises

<Accordion title="Exercise 1: Type a Todo App">
```tsx
// Define types for a Todo app
interface Todo {
  id: string;
  text: string;
  completed: boolean;
  createdAt: Date;
  priority: 'low' | 'medium' | 'high';
}

type TodoAction =
  | { type: 'ADD'; payload: Omit<Todo, 'id' | 'createdAt'> }
  | { type: 'TOGGLE'; payload: string }
  | { type: 'DELETE'; payload: string }
  | { type: 'EDIT'; payload: { id: string; text: string } }
  | { type: 'CLEAR_COMPLETED' };

function todoReducer(state: Todo[], action: TodoAction): Todo[] {
  switch (action.type) {
    case 'ADD':
      return [
        ...state,
        {
          ...action.payload,
          id: crypto.randomUUID(),
          createdAt: new Date()
        }
      ];
    case 'TOGGLE':
      return state.map(todo =>
        todo.id === action.payload
          ? { ...todo, completed: !todo.completed }
          : todo
      );
    case 'DELETE':
      return state.filter(todo => todo.id !== action.payload);
    case 'EDIT':
      return state.map(todo =>
        todo.id === action.payload.id
          ? { ...todo, text: action.payload.text }
          : todo
      );
    case 'CLEAR_COMPLETED':
      return state.filter(todo => !todo.completed);
    default:
      return state;
  }
}
```
</Accordion>

<Accordion title="Exercise 2: Type a Form with Validation">
```tsx
interface FormField<T> {
  value: T;
  error: string | null;
  touched: boolean;
}

interface FormState {
  email: FormField<string>;
  password: FormField<string>;
  age: FormField<number>;
  newsletter: FormField<boolean>;
}

type Validator<T> = (value: T) => string | null;

const validators: Record<keyof FormState, Validator<any>> = {
  email: (value: string) => 
    /\S+@\S+\.\S+/.test(value) ? null : 'Invalid email',
  password: (value: string) => 
    value.length >= 8 ? null : 'Password must be 8+ characters',
  age: (value: number) => 
    value >= 18 ? null : 'Must be 18 or older',
  newsletter: () => null
};

function useForm<T extends Record<string, FormField<any>>>(
  initialState: T
): {
  form: T;
  handleChange: <K extends keyof T>(field: K, value: T[K]['value']) => void;
  handleBlur: <K extends keyof T>(field: K) => void;
  isValid: boolean;
} {
  // Implementation...
}
```
</Accordion>

---

## Summary

| Concept | Example |
|---------|---------|
| **Props** | `interface Props { name: string }` |
| **State** | `useState<User \| null>(null)` |
| **Refs** | `useRef<HTMLInputElement>(null)` |
| **Events** | `React.ChangeEvent<HTMLInputElement>` |
| **Context** | `createContext<ThemeType \| undefined>(undefined)` |
| **Generics** | `useFetch<User>(url)` |

<Card title="Next Steps" icon="arrow-right">
In the final chapter, you'll apply everything you've learned in a **Capstone Project** â€” building a complete React application from scratch!
</Card>
