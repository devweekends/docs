---
title: "14. Testing React Components"
description: "Write reliable tests with Jest and React Testing Library to ensure component quality."
---

# Testing React Components

Testing ensures your React application works correctly and prevents regressions. Modern React testing focuses on testing components from a user's perspective.

## Testing Philosophy

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Testing Pyramid                          â”‚
â”‚                                                             â”‚
â”‚                         /\                                  â”‚
â”‚                        /  \                                 â”‚
â”‚                       / E2E \  (Cypress, Playwright)        â”‚
â”‚                      /â”€â”€â”€â”€â”€â”€\                               â”‚
â”‚                     /        \                              â”‚
â”‚                    /Integration\  (React Testing Library)   â”‚
â”‚                   /â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\                            â”‚
â”‚                  /              \                           â”‚
â”‚                 /     Unit       \  (Jest)                  â”‚
â”‚                /â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\                         â”‚
â”‚                                                             â”‚
â”‚          More tests at bottom, fewer at top                 â”‚
â”‚          Bottom = faster, Top = more realistic              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

<Tip>
**Testing Library Philosophy**: Test your components the way users use them. Query by roles, labels, and text â€” not by implementation details like class names or test IDs.
</Tip>

---

## Setting Up Testing

### Installation

```bash
# For Create React App (included by default)
# For Vite:
npm install -D vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom

# For Next.js:
npm install -D jest @testing-library/react @testing-library/jest-dom @testing-library/user-event jest-environment-jsdom
```

### Vite Configuration (vitest)

```javascript
// vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test/setup.js',
    css: true
  }
});
```

```javascript
// src/test/setup.js
import '@testing-library/jest-dom';
```

### Jest Configuration

```javascript
// jest.config.js
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/src/setupTests.js'],
  moduleNameMapper: {
    '\\.(css|less|scss)$': 'identity-obj-proxy',
    '^@/(.*)$': '<rootDir>/src/$1'
  }
};
```

```javascript
// src/setupTests.js
import '@testing-library/jest-dom';
```

---

## Basic Component Testing

### Your First Test

```javascript
// src/components/Button.jsx
function Button({ children, onClick, disabled }) {
  return (
    <button onClick={onClick} disabled={disabled}>
      {children}
    </button>
  );
}

export default Button;
```

```javascript
// src/components/Button.test.jsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import Button from './Button';

describe('Button', () => {
  it('renders with text', () => {
    render(<Button>Click me</Button>);
    
    expect(screen.getByRole('button', { name: /click me/i })).toBeInTheDocument();
  });

  it('calls onClick when clicked', async () => {
    const handleClick = vi.fn(); // or jest.fn() for Jest
    const user = userEvent.setup();
    
    render(<Button onClick={handleClick}>Click me</Button>);
    
    await user.click(screen.getByRole('button'));
    
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('is disabled when disabled prop is true', () => {
    render(<Button disabled>Click me</Button>);
    
    expect(screen.getByRole('button')).toBeDisabled();
  });

  it('does not call onClick when disabled', async () => {
    const handleClick = vi.fn();
    const user = userEvent.setup();
    
    render(<Button onClick={handleClick} disabled>Click me</Button>);
    
    await user.click(screen.getByRole('button'));
    
    expect(handleClick).not.toHaveBeenCalled();
  });
});
```

---

## Query Methods

React Testing Library provides several ways to query elements:

### Query Priority (Best to Worst)

| Priority | Query | When to Use |
|----------|-------|-------------|
| 1 | `getByRole` | Most accessible queries |
| 2 | `getByLabelText` | Form fields |
| 3 | `getByPlaceholderText` | Inputs without labels |
| 4 | `getByText` | Non-interactive elements |
| 5 | `getByDisplayValue` | Current form field values |
| 6 | `getByAltText` | Images |
| 7 | `getByTitle` | Title attributes |
| 8 | `getByTestId` | Last resort |

### Query Types

| Query | No Match | 1 Match | >1 Match | Async |
|-------|----------|---------|----------|-------|
| `getBy*` | Error | Return | Error | No |
| `queryBy*` | null | Return | Error | No |
| `findBy*` | Error | Return | Error | Yes |
| `getAllBy*` | Error | Array | Array | No |
| `queryAllBy*` | [] | Array | Array | No |
| `findAllBy*` | Error | Array | Array | Yes |

### Query Examples

```javascript
// âœ… Good: Queries by role (accessible)
screen.getByRole('button', { name: /submit/i });
screen.getByRole('heading', { level: 1 });
screen.getByRole('link', { name: /home/i });
screen.getByRole('checkbox', { checked: true });
screen.getByRole('textbox', { name: /email/i });

// âœ… Good: Form elements
screen.getByLabelText(/email address/i);
screen.getByPlaceholderText(/search.../i);
screen.getByDisplayValue('current value');

// âœ… Good: Text content
screen.getByText(/welcome back/i);
screen.getByText((content, element) => {
  return element.tagName === 'P' && content.includes('Hello');
});

// âš ï¸ Last resort: Test ID
screen.getByTestId('custom-element');
```

<Warning>
Avoid using `getByTestId` unless absolutely necessary. It tests implementation details rather than what users see.
</Warning>

---

## Testing User Interactions

### Using userEvent

`userEvent` is preferred over `fireEvent` because it simulates real user behavior:

```javascript
import userEvent from '@testing-library/user-event';

describe('Form interactions', () => {
  it('handles text input', async () => {
    const user = userEvent.setup();
    render(<TextInput />);
    
    const input = screen.getByRole('textbox');
    
    await user.type(input, 'Hello World');
    
    expect(input).toHaveValue('Hello World');
  });

  it('handles keyboard navigation', async () => {
    const user = userEvent.setup();
    render(<Form />);
    
    await user.tab(); // Focus first element
    await user.keyboard('{Enter}'); // Press Enter
    await user.keyboard('{Escape}'); // Press Escape
  });

  it('handles selections', async () => {
    const user = userEvent.setup();
    render(<Select options={['A', 'B', 'C']} />);
    
    await user.selectOptions(screen.getByRole('combobox'), 'B');
    
    expect(screen.getByRole('option', { name: 'B' })).toBeSelected();
  });

  it('handles file uploads', async () => {
    const user = userEvent.setup();
    render(<FileUpload />);
    
    const file = new File(['hello'], 'hello.txt', { type: 'text/plain' });
    const input = screen.getByLabelText(/upload file/i);
    
    await user.upload(input, file);
    
    expect(input.files[0]).toBe(file);
  });

  it('handles double click', async () => {
    const user = userEvent.setup();
    const onDoubleClick = vi.fn();
    
    render(<div onDoubleClick={onDoubleClick}>Double click me</div>);
    
    await user.dblClick(screen.getByText(/double click me/i));
    
    expect(onDoubleClick).toHaveBeenCalled();
  });

  it('handles hover', async () => {
    const user = userEvent.setup();
    render(<Tooltip text="Hello" content="World" />);
    
    await user.hover(screen.getByText('Hello'));
    
    expect(screen.getByText('World')).toBeVisible();
    
    await user.unhover(screen.getByText('Hello'));
    
    expect(screen.queryByText('World')).not.toBeInTheDocument();
  });
});
```

---

## Testing Async Behavior

### Waiting for Elements

```javascript
describe('Async operations', () => {
  it('loads data on mount', async () => {
    render(<UserProfile userId="123" />);
    
    // Wait for loading state to disappear
    expect(screen.getByText(/loading/i)).toBeInTheDocument();
    
    // Wait for content to appear
    const userName = await screen.findByText(/john doe/i);
    expect(userName).toBeInTheDocument();
  });

  it('handles async form submission', async () => {
    const user = userEvent.setup();
    render(<ContactForm />);
    
    await user.type(screen.getByLabelText(/email/i), 'test@example.com');
    await user.type(screen.getByLabelText(/message/i), 'Hello');
    await user.click(screen.getByRole('button', { name: /send/i }));
    
    // Wait for success message
    await screen.findByText(/message sent/i);
  });
});
```

### Using waitFor

```javascript
import { waitFor } from '@testing-library/react';

it('updates after async action', async () => {
  const user = userEvent.setup();
  render(<Counter />);
  
  await user.click(screen.getByRole('button', { name: /increment/i }));
  
  // Wait for assertion to pass
  await waitFor(() => {
    expect(screen.getByText(/count: 1/i)).toBeInTheDocument();
  });
});

it('removes item after delete', async () => {
  const user = userEvent.setup();
  render(<TodoList />);
  
  await user.click(screen.getByRole('button', { name: /delete/i }));
  
  // Wait for element to disappear
  await waitFor(() => {
    expect(screen.queryByText(/buy milk/i)).not.toBeInTheDocument();
  });
});
```

### Using waitForElementToBeRemoved

```javascript
import { waitForElementToBeRemoved } from '@testing-library/react';

it('shows then hides loading indicator', async () => {
  render(<DataLoader />);
  
  await waitForElementToBeRemoved(() => screen.queryByText(/loading/i));
  
  expect(screen.getByText(/data loaded/i)).toBeInTheDocument();
});
```

---

## Mocking

### Mocking Functions

```javascript
// Vitest
const mockFn = vi.fn();

// Jest  
const mockFn = jest.fn();

// With implementation
const mockFn = vi.fn((x) => x * 2);

// With return value
const mockFn = vi.fn().mockReturnValue(42);

// With promise
const mockFn = vi.fn().mockResolvedValue({ data: 'test' });
const mockFn = vi.fn().mockRejectedValue(new Error('Failed'));
```

### Mocking API Calls

```javascript
// Mock fetch globally
beforeEach(() => {
  global.fetch = vi.fn();
});

afterEach(() => {
  vi.restoreAllMocks();
});

it('displays fetched data', async () => {
  global.fetch.mockResolvedValueOnce({
    ok: true,
    json: () => Promise.resolve({ name: 'John Doe' })
  });
  
  render(<UserProfile userId="123" />);
  
  await screen.findByText(/john doe/i);
});

it('displays error on fetch failure', async () => {
  global.fetch.mockRejectedValueOnce(new Error('Network error'));
  
  render(<UserProfile userId="123" />);
  
  await screen.findByText(/error loading user/i);
});
```

### Mocking Modules

```javascript
// Mock an entire module
vi.mock('./api', () => ({
  fetchUsers: vi.fn(),
  createUser: vi.fn()
}));

import { fetchUsers, createUser } from './api';

beforeEach(() => {
  fetchUsers.mockResolvedValue([{ id: 1, name: 'John' }]);
});

it('loads users', async () => {
  render(<UserList />);
  
  await screen.findByText('John');
  
  expect(fetchUsers).toHaveBeenCalledTimes(1);
});
```

### Mocking Hooks

```javascript
// Mock a custom hook
vi.mock('../hooks/useAuth', () => ({
  useAuth: vi.fn()
}));

import { useAuth } from '../hooks/useAuth';

describe('ProtectedRoute', () => {
  it('shows content when authenticated', () => {
    useAuth.mockReturnValue({
      user: { id: 1, name: 'John' },
      isAuthenticated: true
    });
    
    render(<ProtectedRoute><Dashboard /></ProtectedRoute>);
    
    expect(screen.getByText(/dashboard/i)).toBeInTheDocument();
  });

  it('redirects when not authenticated', () => {
    useAuth.mockReturnValue({
      user: null,
      isAuthenticated: false
    });
    
    render(<ProtectedRoute><Dashboard /></ProtectedRoute>);
    
    expect(screen.getByText(/please log in/i)).toBeInTheDocument();
  });
});
```

---

## Testing with Context

```javascript
// Test utilities
function renderWithProviders(ui, { initialState = {} } = {}) {
  function Wrapper({ children }) {
    return (
      <ThemeProvider>
        <AuthProvider initialState={initialState}>
          {children}
        </AuthProvider>
      </ThemeProvider>
    );
  }
  
  return render(ui, { wrapper: Wrapper });
}

// Usage
it('displays user name when logged in', () => {
  renderWithProviders(<Header />, {
    initialState: { user: { name: 'John' } }
  });
  
  expect(screen.getByText(/john/i)).toBeInTheDocument();
});
```

---

## Testing with React Router

```javascript
import { MemoryRouter, Routes, Route } from 'react-router-dom';

function renderWithRouter(ui, { route = '/', initialEntries = [route] } = {}) {
  return render(
    <MemoryRouter initialEntries={initialEntries}>
      {ui}
    </MemoryRouter>
  );
}

describe('Navigation', () => {
  it('navigates to about page', async () => {
    const user = userEvent.setup();
    
    renderWithRouter(
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    );
    
    await user.click(screen.getByRole('link', { name: /about/i }));
    
    expect(screen.getByText(/about us/i)).toBeInTheDocument();
  });

  it('displays 404 for unknown routes', () => {
    renderWithRouter(
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="*" element={<NotFound />} />
      </Routes>,
      { route: '/unknown' }
    );
    
    expect(screen.getByText(/page not found/i)).toBeInTheDocument();
  });
});
```

---

## Testing Forms

```javascript
describe('LoginForm', () => {
  it('submits with valid data', async () => {
    const user = userEvent.setup();
    const onSubmit = vi.fn();
    
    render(<LoginForm onSubmit={onSubmit} />);
    
    await user.type(screen.getByLabelText(/email/i), 'test@example.com');
    await user.type(screen.getByLabelText(/password/i), 'password123');
    await user.click(screen.getByRole('button', { name: /log in/i }));
    
    expect(onSubmit).toHaveBeenCalledWith({
      email: 'test@example.com',
      password: 'password123'
    });
  });

  it('shows validation errors', async () => {
    const user = userEvent.setup();
    render(<LoginForm onSubmit={vi.fn()} />);
    
    // Submit empty form
    await user.click(screen.getByRole('button', { name: /log in/i }));
    
    expect(screen.getByText(/email is required/i)).toBeInTheDocument();
    expect(screen.getByText(/password is required/i)).toBeInTheDocument();
  });

  it('shows error for invalid email', async () => {
    const user = userEvent.setup();
    render(<LoginForm onSubmit={vi.fn()} />);
    
    await user.type(screen.getByLabelText(/email/i), 'invalid-email');
    await user.tab(); // Trigger blur
    
    expect(screen.getByText(/invalid email format/i)).toBeInTheDocument();
  });
});
```

---

## Snapshot Testing

```javascript
import { render } from '@testing-library/react';

describe('Card', () => {
  it('matches snapshot', () => {
    const { container } = render(
      <Card title="Hello" description="World" />
    );
    
    expect(container).toMatchSnapshot();
  });

  it('matches snapshot with inline snapshot', () => {
    const { container } = render(<Badge>New</Badge>);
    
    expect(container.innerHTML).toMatchInlineSnapshot(`
      "<span class="badge badge-primary">New</span>"
    `);
  });
});
```

<Warning>
Use snapshots sparingly. They can become a maintenance burden and may encourage "update all" without reviewing changes.
</Warning>

---

## Common Testing Patterns

### Testing Conditional Rendering

```javascript
describe('Alert', () => {
  it('renders nothing when closed', () => {
    const { container } = render(<Alert isOpen={false} message="Hello" />);
    
    expect(container).toBeEmptyDOMElement();
  });

  it('renders message when open', () => {
    render(<Alert isOpen={true} message="Hello World" />);
    
    expect(screen.getByText(/hello world/i)).toBeInTheDocument();
  });
});
```

### Testing Lists

```javascript
describe('TodoList', () => {
  const todos = [
    { id: 1, text: 'Buy milk', completed: false },
    { id: 2, text: 'Walk dog', completed: true }
  ];

  it('renders all items', () => {
    render(<TodoList items={todos} />);
    
    expect(screen.getAllByRole('listitem')).toHaveLength(2);
  });

  it('shows completed state', () => {
    render(<TodoList items={todos} />);
    
    expect(screen.getByText(/walk dog/i)).toHaveClass('completed');
  });

  it('shows empty message when no items', () => {
    render(<TodoList items={[]} />);
    
    expect(screen.getByText(/no todos yet/i)).toBeInTheDocument();
  });
});
```

### Testing Error Boundaries

```javascript
// Suppress console.error for error boundary tests
beforeEach(() => {
  vi.spyOn(console, 'error').mockImplementation(() => {});
});

afterEach(() => {
  console.error.mockRestore();
});

describe('ErrorBoundary', () => {
  it('catches errors and shows fallback', () => {
    const ThrowError = () => {
      throw new Error('Test error');
    };
    
    render(
      <ErrorBoundary fallback={<div>Something went wrong</div>}>
        <ThrowError />
      </ErrorBoundary>
    );
    
    expect(screen.getByText(/something went wrong/i)).toBeInTheDocument();
  });
});
```

---

## ğŸ¯ Practice Exercises

<Accordion title="Exercise 1: Test a Search Component">
```javascript
// SearchBox.jsx
function SearchBox({ onSearch }) {
  const [query, setQuery] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    if (query.trim()) {
      onSearch(query);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        placeholder="Search..."
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        aria-label="Search"
      />
      <button type="submit">Search</button>
    </form>
  );
}

// SearchBox.test.jsx
describe('SearchBox', () => {
  it('calls onSearch with query when submitted', async () => {
    const user = userEvent.setup();
    const onSearch = vi.fn();
    
    render(<SearchBox onSearch={onSearch} />);
    
    await user.type(screen.getByRole('textbox'), 'react testing');
    await user.click(screen.getByRole('button', { name: /search/i }));
    
    expect(onSearch).toHaveBeenCalledWith('react testing');
  });

  it('does not call onSearch with empty query', async () => {
    const user = userEvent.setup();
    const onSearch = vi.fn();
    
    render(<SearchBox onSearch={onSearch} />);
    
    await user.click(screen.getByRole('button', { name: /search/i }));
    
    expect(onSearch).not.toHaveBeenCalled();
  });

  it('clears input after search', async () => {
    // Your implementation
  });
});
```
</Accordion>

<Accordion title="Exercise 2: Test an Accordion Component">
```javascript
// Accordion.test.jsx
describe('Accordion', () => {
  it('shows title and hides content by default', () => {
    render(<Accordion title="FAQ">Hidden content</Accordion>);
    
    expect(screen.getByText('FAQ')).toBeInTheDocument();
    expect(screen.queryByText('Hidden content')).not.toBeVisible();
  });

  it('shows content when clicked', async () => {
    const user = userEvent.setup();
    
    render(<Accordion title="FAQ">Hidden content</Accordion>);
    
    await user.click(screen.getByRole('button', { name: /faq/i }));
    
    expect(screen.getByText('Hidden content')).toBeVisible();
  });

  it('hides content when clicked again', async () => {
    const user = userEvent.setup();
    
    render(<Accordion title="FAQ">Hidden content</Accordion>);
    
    const button = screen.getByRole('button', { name: /faq/i });
    await user.click(button);
    await user.click(button);
    
    expect(screen.queryByText('Hidden content')).not.toBeVisible();
  });

  it('has proper aria attributes', async () => {
    const user = userEvent.setup();
    
    render(<Accordion title="FAQ">Content</Accordion>);
    
    const button = screen.getByRole('button');
    const content = screen.getByRole('region');
    
    expect(button).toHaveAttribute('aria-expanded', 'false');
    
    await user.click(button);
    
    expect(button).toHaveAttribute('aria-expanded', 'true');
  });
});
```
</Accordion>

---

## Summary

| Concept | Key Points |
|---------|------------|
| **Query Priority** | Role â†’ Label â†’ Text â†’ TestId |
| **userEvent** | Simulates real user behavior |
| **Async Testing** | Use `findBy*` and `waitFor` |
| **Mocking** | Mock functions, modules, and hooks |
| **Context/Router** | Create custom render wrappers |
| **Best Practices** | Test behavior, not implementation |

<Card title="Next Steps" icon="arrow-right">
In the next chapter, you'll learn about **TypeScript with React** â€” adding type safety to your React applications!
</Card>
