---
title: "07. useEffect & Side Effects"
description: "Master the useEffect hook for data fetching, subscriptions, and DOM manipulation."
---

# useEffect & Side Effects

The `useEffect` hook lets you perform side effects in function components. Data fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects.

## Basic Usage

`useEffect` tells React that your component needs to do something after render. React will remember the function you passed (we'll refer to it as our "effect"), and call it later after performing the DOM updates.

```javascript
import { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `You clicked ${count} times`;
  });

  return (
    <button onClick={() => setCount(count + 1)}>
      Click me
    </button>
  );
}
```

## Dependency Array

By default, `useEffect` runs after **every** render. This might be a performance problem. You can tell React to skip applying an effect if certain values haven't changed between re-renders.

### 1. Run on Every Render (No Array)

```javascript
useEffect(() => {
  console.log('Runs on every render');
});
```

### 2. Run Only on Mount (Empty Array)

Equivalent to `componentDidMount` in classes.

```javascript
useEffect(() => {
  console.log('Runs only once on mount');
}, []);
```

### 3. Run When Specific Props/State Change

```javascript
useEffect(() => {
  console.log('Runs when count changes');
}, [count]); // Only re-run the effect if count changes
```

## Cleanup Function

Some effects require cleanup (e.g., subscriptions, timers). To do this, return a function from your effect.

```javascript
useEffect(() => {
  const timer = setInterval(() => {
    console.log('Tick');
  }, 1000);

  // Cleanup function
  return () => {
    clearInterval(timer);
    console.log('Component unmounted or effect re-running');
  };
}, []);
```

## Data Fetching

A common use case for `useEffect` is fetching data from an API.

```javascript
function UserList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then(response => response.json())
      .then(data => {
        setUsers(data);
        setLoading(false);
      });
  }, []); // Empty array ensures this runs only once

  if (loading) return <p>Loading...</p>;

  return (
    <ul>
      {users.map(user => <li key={user.id}>{user.name}</li>)}
    </ul>
  );
}
```

## Summary

- **Side Effects**: Operations that affect something outside the scope of the function being executed (e.g., API calls, DOM updates).
- **useEffect**: The hook to handle side effects.
- **Dependency Array**: Controls when the effect runs.
    - `[]`: Runs once on mount.
    - `[prop]`: Runs when `prop` changes.
    - No array: Runs on every render.
- **Cleanup**: Return a function to clean up resources (like `componentWillUnmount`).
