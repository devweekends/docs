---
title: "12. Redux & State Management"
description: "Master global state management with Redux Toolkit."
---

# Redux & State Management

As your application grows, managing state with just `useState` and `Context` can become complex. **Redux** is a predictable state container for JavaScript apps.

We will use **Redux Toolkit (RTK)**, which is the official, recommended way to write Redux logic.

## Installation

```bash
npm install @reduxjs/toolkit react-redux
```

## 1. Create a Slice

A "slice" contains the reducer logic and actions for a single feature.

**features/counter/counterSlice.js**
```javascript
import { createSlice } from '@reduxjs/toolkit';

export const counterSlice = createSlice({
  name: 'counter',
  initialState: {
    value: 0,
  },
  reducers: {
    increment: (state) => {
      // Redux Toolkit allows us to write "mutating" logic in reducers.
      // It doesn't actually mutate the state because it uses the Immer library.
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload;
    },
  },
});

export const { increment, decrement, incrementByAmount } = counterSlice.actions;

export default counterSlice.reducer;
```

## 2. Configure the Store

Create the Redux store and add your slices.

**app/store.js**
```javascript
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from '../features/counter/counterSlice';

export const store = configureStore({
  reducer: {
    counter: counterReducer,
  },
});
```

## 3. Provide the Store

Wrap your application with the `Provider`.

**main.jsx**
```javascript
import { store } from './app/store';
import { Provider } from 'react-redux';

ReactDOM.createRoot(document.getElementById('root')).render(
  <Provider store={store}>
    <App />
  </Provider>
);
```

## 4. Use State and Dispatch

Use `useSelector` to read data and `useDispatch` to dispatch actions.

**Counter.jsx**
```javascript
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement } from './features/counter/counterSlice';

export function Counter() {
  const count = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();

  return (
    <div>
      <button onClick={() => dispatch(increment())}>Increment</button>
      <span>{count}</span>
      <button onClick={() => dispatch(decrement())}>Decrement</button>
    </div>
  );
}
```

## Async Logic (Thunks)

Redux Toolkit includes `createAsyncThunk` for handling async logic (like API calls).

```javascript
import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';

export const fetchUser = createAsyncThunk(
  'users/fetchById',
  async (userId, thunkAPI) => {
    const response = await fetch(\`/api/users/\${userId}\`);
    return response.json();
  }
);

const usersSlice = createSlice({
  name: 'users',
  initialState: { entities: [], loading: 'idle' },
  extraReducers: (builder) => {
    builder.addCase(fetchUser.fulfilled, (state, action) => {
      state.entities.push(action.payload);
    });
  },
});
```

## Other Options

While Redux is popular, other libraries exist:
- **Zustand**: Minimalist, hook-based state management.
- **Recoil / Jotai**: Atomic state management.
- **TanStack Query (React Query)**: Best for server state (caching API responses).

## Summary

- **Redux Toolkit** simplifies Redux setup.
- **Slices** organize logic by feature.
- **Provider** makes the store available to the app.
- **useSelector** reads state.
- **useDispatch** sends actions to update state.
