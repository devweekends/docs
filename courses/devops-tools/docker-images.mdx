---
title: "Building Docker Images"
sidebarTitle: "Images"
description: "Mastering Dockerfiles, layers, and multi-stage builds"
icon: "layer-group"
---

# Building Docker Images

Learn to create efficient, secure, and production-ready Docker images using Dockerfiles.

---

## The Dockerfile

A `Dockerfile` is a text document that contains all the commands a user could call on the command line to assemble an image.

### Basic Structure

```dockerfile
# 1. Base Image
FROM node:18-alpine

# 2. Working Directory
WORKDIR /app

# 3. Copy Dependencies
COPY package*.json ./

# 4. Install Dependencies
RUN npm ci --only=production

# 5. Copy Source Code
COPY . .

# 6. Expose Port
EXPOSE 3000

# 7. Define User (Security)
USER node

# 8. Startup Command
CMD ["node", "server.js"]
```

### Key Instructions

| Instruction | Description | Example |
|-------------|-------------|---------|
| `FROM` | Base image to start from | `FROM ubuntu:22.04` |
| `WORKDIR` | Sets working directory | `WORKDIR /app` |
| `COPY` | Copies files from host to image | `COPY . .` |
| `RUN` | Executes command during build | `RUN apt-get update` |
| `ENV` | Sets environment variables | `ENV NODE_ENV=production` |
| `EXPOSE` | Documents listening ports | `EXPOSE 80` |
| `CMD` | Default command to run | `CMD ["npm", "start"]` |
| `ENTRYPOINT` | Main executable | `ENTRYPOINT ["python"]` |

---

## Image Layers & Caching

Docker images are built from layers. Each instruction creates a new layer.
**Order matters!** Put least frequently changed instructions at the top to maximize cache hits.

```dockerfile
# BAD: Re-installs dependencies every time code changes
COPY . .
RUN npm install

# GOOD: Uses cache if package.json hasn't changed
COPY package*.json ./
RUN npm install
COPY . .
```

---

## Multi-Stage Builds

Drastically reduce image size by separating build tools from runtime artifacts.

### Example: Go Application

```dockerfile
# Stage 1: Builder
FROM golang:1.21-alpine AS builder
WORKDIR /app
COPY . .
RUN go build -o myapp main.go

# Stage 2: Runtime
FROM alpine:latest
WORKDIR /root/
# Copy only the binary from the builder stage
COPY --from=builder /app/myapp .
CMD ["./myapp"]
```

**Result**:
- Builder image: ~800MB (contains Go compiler, source code)
- Runtime image: ~15MB (contains only binary and minimal OS)

---

## Building & Tagging

```bash
# Build with default tag (latest)
docker build -t myapp .

# Build with specific tag
docker build -t myapp:1.0 .

# Build with multiple tags
docker build -t myapp:1.0 -t myapp:latest .

# Build from specific file
docker build -f Dockerfile.prod -t myapp:prod .

# Build without cache (if needed)
docker build --no-cache -t myapp:clean .
```

---

## Managing Images

```bash
# List images
docker images

# Remove image
docker rmi myapp:1.0

# Remove dangling images (untagged, <none>)
docker image prune

# Save image to tarball
docker save -o myapp.tar myapp:1.0

# Load image from tarball
docker load -i myapp.tar
```

---

## Best Practices

<AccordionGroup>
  <Accordion title="Use Alpine Images" icon="feather">
    Start with `alpine` based images (e.g., `node:alpine`, `python:alpine`) to keep images small and secure.
  </Accordion>
  
  <Accordion title="Don't Run as Root" icon="user-shield">
    Create a non-root user and switch to it with `USER` instruction.
    ```dockerfile
    RUN addgroup -S appgroup && adduser -S appuser -G appgroup
    USER appuser
    ```
  </Accordion>
  
  <Accordion title="Use .dockerignore" icon="eye-slash">
    Exclude files like `node_modules`, `.git`, and secrets from the build context.
    ```text
    # .dockerignore
    node_modules
    .git
    .env
    Dockerfile
    ```
  </Accordion>
</AccordionGroup>

---

Next: [Docker Networking â†’](/courses/devops-tools/docker-networking)
