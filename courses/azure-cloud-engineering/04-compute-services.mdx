---
title: "Compute Services"
description: "Master Azure VMs, VM Scale Sets, App Service, and compute optimization strategies"
icon: "server"
---

# Compute Services

Azure offers multiple compute options. Choosing the right one impacts cost, performance, and operational overhead.

![Azure Compute Spectrum](/images/azure/04-compute-spectrum.svg)

---

## 1. Compute Decision Tree

<div className="flex justify-center my-4">
  <div className="w-full max-w-4xl">
    ```mermaid
    graph TD
        A[Need Compute?] -->|Yes| B{Full OS Control?}
        B -->|Yes| C[Virtual Machines]
        B -->|No| D{Containerized?}

        D -->|Yes| E{Orchestration Needed?}
        D -->|No| F{Event-Driven?}

        E -->|Yes| G[Azure Kubernetes Service]
        E -->|No| H[Container Instances]

        F -->|Yes| I[Azure Functions]
        F -->|No| J[App Service]

        style C fill:#68217A
        style G fill:#0078D4
        style H fill:#50E6FF
        style I fill:#FFB900
        style J fill:#00A4EF
    ```
  </div>
</div>



> [!WARNING]
> **Gotcha: Spot VM Eviction**
> Spot VMs offer huge discounts (up to 90%), but Azure can take them back with only a **30-second warning**. Never use them for production databases or critical APIs—only for stateless batch jobs that can fail and restart.

> [!TIP]
> **Jargon Alert: SLA (Service Level Agreement)**
> Microsoft's financial guarantee of uptime (e.g., 99.9%). If they miss it, you get a bill credit. Note: Single VMs often have a lower SLA than multiple VMs deployed in an Availability Set or Zone.

---

## 2. Virtual Machines Deep Dive

### VM Size Families

<Tabs>
  <Tab title="General Purpose">
    **B, D, DC, DS series**

    Balanced CPU:Memory ratio (1:4)

    ```
    Use cases:
    - Web servers
    - Small to medium databases
    - Development/test environments
    - Low to medium traffic apps

    Examples:
    - Standard_B2s: 2 vCPU, 4 GB RAM (Burstable)
    - Standard_D4s_v5: 4 vCPU, 16 GB RAM
    ```

    **B-series (Burstable)**:
    - Accumulate CPU credits when idle
    - Burst to 100% when needed
    - Cost-effective for variable workloads
    - Perfect for dev/test
  </Tab>

  <Tab title="Compute Optimized">
    **F, FX series**

    High CPU:Memory ratio (1:2)

    ```
    Use cases:
    - Application servers
    - Batch processing
    - Analytics
    - Gaming servers

    Examples:
    - Standard_F8s_v2: 8 vCPU, 16 GB RAM
    - High CPU performance
    - Lower cost per vCPU
    ```
  </Tab>

  <Tab title="Memory Optimized">
    **E, M series**

    High Memory:CPU ratio (8:1 or higher)

    ```
    Use cases:
    - Relational databases (SQL Server, Oracle)
    - In-memory caches (Redis)
    - Analytics (SAP HANA)

    Examples:
    - Standard_E8s_v5: 8 vCPU, 64 GB RAM
    - Standard_M64s: 64 vCPU, 1 TB RAM
    ```
  </Tab>

  <Tab title="Storage Optimized">
    **L series**

    High local disk throughput

    ```
    Use cases:
    - NoSQL databases (Cassandra, MongoDB)
    - Data warehousing
    - Big data applications

    Examples:
    - Standard_L8s_v3: 8 vCPU, 64 GB RAM, 1.92 TB NVMe
    ```
  </Tab>

  <Tab title="GPU">
    **NC, ND, NV series**

    GPU-accelerated compute

    ```
    Use cases:
    - Machine learning training
    - AI inference
    - Graphics rendering
    - Video encoding

    Examples:
    - Standard_NC6s_v3: 6 vCPU, 112 GB RAM, Tesla V100
    - Standard_ND40rs_v2: 40 vCPU, 672 GB RAM, 8x V100
    ```
  </Tab>
</Tabs>

### VM Pricing Models

<CardGroup cols={2}>
  <Card title="Pay-as-you-go" icon="credit-card">
    **No commitment, highest cost**
    - Billed per second
    - Stop VM = stop compute charges
    - Storage still charged

    **Use for**: Short-term, unpredictable workloads
  </Card>

  <Card title="Reserved Instances" icon="calendar">
    **1 or 3-year commitment**
    - 30-50% discount (1-year)
    - 50-70% discount (3-year)
    - Can exchange for different size

    **Use for**: Stable, long-running workloads
  </Card>

  <Card title="Spot VMs" icon="bolt">
    **Up to 90% discount**
    - Can be evicted anytime
    - 30-second warning
    - No SLA

    **Use for**: Batch jobs, testing, fault-tolerant apps
  </Card>

  <Card title="Azure Hybrid Benefit" icon="server">
    **Use existing Windows licenses**
    - Up to 40% discount
    - Requires Software Assurance
    - Windows Server + SQL Server

    **Use for**: Migrations from on-premises
  </Card>
</CardGroup>

### Managed Disks

<Tabs>
  <Tab title="Disk Types">
    | Disk Type | IOPS | Throughput | Use Case |
    |-----------|------|------------|----------|
    | **Standard HDD** | 500 | 60 MB/s | Backup, non-critical |
    | **Standard SSD** | 500-6,000 | 60-750 MB/s | Web servers, dev/test |
    | **Premium SSD** | 120-20,000 | 25-900 MB/s | Production databases |
    | **Ultra Disk** | Up to 160,000 | Up to 4,000 MB/s | SAP HANA, top-tier SQL |

    **Premium SSD Sizes**:
    ```
    P4:  32 GB,   120 IOPS,  25 MB/s
    P10: 128 GB,  500 IOPS,  100 MB/s
    P30: 1 TB,    5,000 IOPS, 200 MB/s
    P80: 32 TB,   20,000 IOPS, 900 MB/s
    ```
  </Tab>

  <Tab title="Disk Caching">
    **Cache Options**:
    - **ReadOnly**: Cache reads (default for data disks)
    - **ReadWrite**: Cache reads + writes (default for OS disks)
    - **None**: No caching (for write-heavy workloads)

    **When to use**:
    ```
    OS Disk: ReadWrite (best performance)
    Data Disk (read-heavy): ReadOnly
    Data Disk (write-heavy): None
    Temp Disk: Don't store data (ephemeral)
    ```

    **Performance Impact**:
    ```
    With cache: 20,000 IOPS (cache + disk)
    Without cache: 5,000 IOPS (disk only)
    ```
  </Tab>

  <Tab title="Performance Tuning">
    **Maximize IOPS**:
    ```bash
    # 1. Use Premium SSD
    az disk create \
      --name disk-data \
      --resource-group rg-prod \
      --size-gb 1024 \
      --sku Premium_LRS

    # 2. Enable disk bursting (P20-P30)
    az disk update \
      --name disk-data \
      --resource-group rg-prod \
      --enable-bursting true

    # 3. Stripe multiple disks (RAID 0)
    # Windows: Storage Spaces
    # Linux: LVM or mdadm

    # 4. Use Ultra Disk for extreme performance
    az disk create \
      --name disk-ultra \
      --resource-group rg-prod \
      --size-gb 1024 \
      --sku UltraSSD_LRS \
      --disk-iops-read-write 50000 \
      --disk-mbps-read-write 2000
    ```
  </Tab>
</Tabs>

### VM High Availability

<Steps>
  <Step title="Availability Sets">
    **Protect against planned maintenance and hardware failures**

    ```
    Fault Domains: 2-3 (different racks)
    Update Domains: Up to 20 (staggered updates)

    SLA: 99.95% (2+ VMs in availability set)
    ```

    **Use when**: Regional deployment, no zone support
  </Step>

  <Step title="Availability Zones">
    **Protect against datacenter failures**

    ```
    Deploy VMs across 3 zones:
    - Zone 1: VM 1, 4, 7
    - Zone 2: VM 2, 5, 8
    - Zone 3: VM 3, 6, 9

    SLA: 99.99% (2+ VMs across zones)
    ```

    **Use when**: Maximum availability, region supports zones
  </Step>

  <Step title="VM Scale Sets">
    **Autoscaling group of identical VMs**

    ```
    Features:
    - Autoscale (CPU, memory, schedule)
    - Load balancer integration
    - Rolling upgrades
    - Instance protection

    SLA: 99.95% (availability set) or 99.99% (zones)
    ```

    **Use when**: Scalable, stateless applications
  </Step>
</Steps>

---

## 3. VM Scale Sets

**VM Scale Sets (VMSS)** automatically scale identical VMs based on demand.

### VMSS Architecture

<div className="flex justify-center my-4">
  <div className="w-full max-w-4xl">
    ```mermaid
    graph TB
        LB[Load Balancer] --> VMSS[VM Scale Set]

        subgraph "VM Scale Set (Auto-scaling)"
            VMSS --> VM1[VM Instance 1<br/>Zone 1]
            VMSS --> VM2[VM Instance 2<br/>Zone 2]
            VMSS --> VM3[VM Instance 3<br/>Zone 3]
            VMSS -.Scale Out.-> VM4[VM Instance 4<br/>Zone 1]
            VMSS -.Scale Out.-> VM5[VM Instance 5<br/>Zone 2]
        end

        Monitor[Azure Monitor] -.Metrics.-> AutoScale[Autoscale Rules]
        AutoScale -.Trigger.-> VMSS

        style VMSS fill:#0078D4
        style AutoScale fill:#FFB900
    ```
  </div>
</div>

### Create VM Scale Set

```bash
# Create VMSS with autoscaling
az vmss create \
  --name vmss-web \
  --resource-group rg-prod \
  --image UbuntuLTS \
  --vm-sku Standard_D2s_v3 \
  --instance-count 2 \
  --zones 1 2 3 \
  --vnet-name vnet-prod \
  --subnet snet-web \
  --lb lb-web \
  --backend-pool-name pool-web \
  --admin-username azureuser \
  --generate-ssh-keys

# Configure autoscale
az monitor autoscale create \
  --resource-group rg-prod \
  --resource vmss-web \
  --resource-type Microsoft.Compute/virtualMachineScaleSets \
  --name autoscale-web \
  --min-count 2 \
  --max-count 10 \
  --count 2

# Scale out rule (CPU > 75%)
az monitor autoscale rule create \
  --resource-group rg-prod \
  --autoscale-name autoscale-web \
  --condition "Percentage CPU > 75 avg 5m" \
  --scale out 1

# Scale in rule (CPU < 25%)
az monitor autoscale rule create \
  --resource-group rg-prod \
  --autoscale-name autoscale-web \
  --condition "Percentage CPU < 25 avg 5m" \
  --scale in 1
```

### VMSS Rolling Upgrades

```bash
# Update VMSS image
az vmss update \
  --name vmss-web \
  --resource-group rg-prod \
  --set virtualMachineProfile.storageProfile.imageReference.version=latest

# Perform rolling upgrade
az vmss rolling-upgrade start \
  --name vmss-web \
  --resource-group rg-prod

# Monitor upgrade
az vmss rolling-upgrade get-latest \
  --name vmss-web \
  --resource-group rg-prod
```

**Upgrade Policy**:
- **Manual**: You control when to upgrade
- **Rolling**: Upgrade in batches (recommended)
- **Automatic**: Upgrade immediately (risky)

---

## 4. Azure App Service

**App Service** is a fully managed PaaS for hosting web apps, APIs, and mobile backends.

### App Service Plans

<Tabs>
  <Tab title="Pricing Tiers">
    | Tier | Price | Features | Use Case |
    |------|-------|----------|----------|
    | **Free** | $0 | 1 GB RAM, 60 min/day | Learning |
    | **Shared** | $10/month | 1 GB RAM, custom domain | Hobby projects |
    | **Basic** | $55/month | 1.75 GB RAM, SSD | Dev/test |
    | **Standard** | $100/month | Autoscale, slots, VNet | Production |
    | **Premium** | $400/month | More scale, better perf | High-traffic |
    | **Isolated** | $700/month | Dedicated VNet (ASE) | Enterprise |
  </Tab>

  <Tab title="Features by Tier">
    ```
    Free/Shared:
    ❌ No custom SSL
    ❌ No autoscaling
    ❌ No deployment slots
    ❌ No VNet integration

    Basic:
    ✅ Custom SSL
    ❌ No autoscaling
    ❌ No deployment slots
    ❌ No VNet integration

    Standard:
    ✅ Custom SSL
    ✅ Autoscaling (up to 10 instances)
    ✅ Deployment slots (5)
    ✅ VNet integration
    ✅ Backup/restore

    Premium:
    ✅ All Standard features
    ✅ Autoscaling (up to 30 instances)
    ✅ Deployment slots (20)
    ✅ Better performance
    ✅ Zone redundancy

    Isolated (ASE):
    ✅ All Premium features
    ✅ Fully isolated network
    ✅ Internal load balancer
    ✅ Compliance (PCI, HIPAA)
    ```
  </Tab>
</Tabs>

### Deployment Slots

**Deployment Slots** enable zero-downtime deployments.

<div className="flex justify-center my-4">
  <div className="w-full max-w-4xl">
    ```mermaid
    graph LR
        A[Developer] -->|git push| B[Build Pipeline]
        B -->|Deploy| C[Staging Slot]
        C -->|Test| D{Tests Pass?}
        D -->|Yes| E[Swap to Production]
        D -->|No| F[Fix & Redeploy]
        E --> G[Production Slot]

        Users -->|Traffic| G

        style G fill:#00D084
        style C fill:#FFB900
    ```
  </div>
</div>

```bash
# Create deployment slot
az webapp deployment slot create \
  --name mywebapp \
  --resource-group rg-prod \
  --slot staging

# Deploy to staging
az webapp deployment source config \
  --name mywebapp \
  --resource-group rg-prod \
  --slot staging \
  --repo-url https://github.com/user/repo \
  --branch main

# Swap slots (staging → production)
az webapp deployment slot swap \
  --name mywebapp \
  --resource-group rg-prod \
  --slot staging \
  --target-slot production
```

### App Service Best Practices

<AccordionGroup>
  <Accordion title="1. Use Deployment Slots" icon="arrows-spin">
    Deploy to staging, test, then swap to production. Instant rollback if issues.
  </Accordion>

  <Accordion title="2. Enable Always On" icon="power-off">
    Prevents app from unloading after idle time. Critical for production.

    ```bash
    az webapp config set \
      --name mywebapp \
      --resource-group rg-prod \
      --always-on true
    ```
  </Accordion>

  <Accordion title="3. Use VNet Integration" icon="network-wired">
    Connect to private resources (databases, storage) without public endpoints.

    ```bash
    az webapp vnet-integration add \
      --name mywebapp \
      --resource-group rg-prod \
      --vnet vnet-prod \
      --subnet snet-app
    ```
  </Accordion>

  <Accordion title="4. Configure Autoscale" icon="chart-line">
    Scale based on CPU, memory, or custom metrics.

    ```bash
    az monitor autoscale create \
      --resource-group rg-prod \
      --resource mywebapp \
      --resource-type Microsoft.Web/serverfarms \
      --name autoscale-app \
      --min-count 2 \
      --max-count 10 \
      --count 2
    ```
  </Accordion>

  <Accordion title="5. Use Managed Identity" icon="shield">
    No secrets in code. Authenticate to Azure services automatically.

    ```bash
    # Enable managed identity
    az webapp identity assign \
      --name mywebapp \
      --resource-group rg-prod

    # Grant access to Key Vault
    az keyvault set-policy \
      --name myvault \
      --object-id <identity-id> \
      --secret-permissions get list
    ```
  </Accordion>
</AccordionGroup>

---

## 5. Azure Container Instances (ACI)

**ACI** runs containers without managing VMs or orchestrators.

### When to Use ACI

<CardGroup cols={2}>
  <Card title="✅ Use ACI For" icon="check">
    - Quick container execution
    - CI/CD build agents
    - Batch jobs
    - Event-driven tasks
    - Dev/test environments
  </Card>

  <Card title="❌ Don't Use ACI For" icon="xmark">
    - Multi-container orchestration
    - Service discovery
    - Load balancing
    - Health checks
    → Use AKS instead
  </Card>
</CardGroup>

### Deploy Container

```bash
# Deploy single container
az container create \
  --name aci-demo \
  --resource-group rg-demo \
  --image mcr.microsoft.com/azuredocs/aci-helloworld \
  --cpu 1 \
  --memory 1 \
  --ip-address Public \
  --dns-name-label aci-demo-unique \
  --ports 80

# Deploy multi-container group (sidecar pattern)
az container create \
  --resource-group rg-demo \
  --name multi-container \
  --image nginx \
  --cpu 1 \
  --memory 1 \
  --ports 80 \
  --environment-variables LOG_LEVEL=debug

# Get logs
az container logs \
  --name aci-demo \
  --resource-group rg-demo

# Execute command in container
az container exec \
  --name aci-demo \
  --resource-group rg-demo \
  --exec-command "/bin/bash"
```

---

## 6. Interview Questions

### Beginner

<AccordionGroup>
  <Accordion title="Q1: When would you choose App Service over VMs?">
    **App Service (PaaS)**:
    - Less management (Microsoft handles OS, patching)
    - Built-in autoscaling, deployment slots
    - Faster time-to-market
    - Cost-effective for web apps

    **Virtual Machines (IaaS)**:
    - Full control over OS and software
    - Custom configurations
    - Legacy applications
    - Specific compliance requirements

    **Decision**: Use App Service unless you need full OS control.
  </Accordion>

  <Accordion title="Q2: Explain availability sets vs availability zones">
    **Availability Sets**:
    - Protect against hardware failures within a datacenter
    - Fault domains (different racks) + Update domains (staggered updates)
    - SLA: 99.95%

    **Availability Zones**:
    - Protect against entire datacenter failures
    - Physically separate datacenters (separate power, cooling, network)
    - SLA: 99.99%

    **Best Practice**: Use availability zones for production workloads.
  </Accordion>
</AccordionGroup>

### Intermediate

<AccordionGroup>
  <Accordion title="Q3: Design a scalable web application architecture">
    ```
    Architecture:

    Frontend:
    - Azure Front Door (global load balancing, WAF)
    - App Service (autoscale 2-20 instances)
    - Deployment slots (blue-green deployments)

    Backend:
    - VMSS or AKS (for microservices)
    - Autoscaling based on CPU/memory
    - Load balancer (internal)

    Data:
    - Azure SQL (zone-redundant)
    - Redis Cache (session management)
    - Blob Storage (static assets)

    Monitoring:
    - Application Insights (APM)
    - Log Analytics (centralized logs)
    - Autoscale based on custom metrics

    CI/CD:
    - GitHub Actions or Azure DevOps
    - Deploy to staging slot → test → swap

    Cost Optimization:
    - Use B-series VMs for dev/test
    - Reserved Instances for production
    - Autoscale to match demand
    ```
  </Accordion>

  <Accordion title="Q4: How do you minimize VM costs?">
    **Strategies**:

    ```
    1. Right-size VMs:
       - Monitor CPU/memory usage
       - Downsize underutilized VMs
       - Use Azure Advisor recommendations

    2. Use Reserved Instances:
       - 1-year: 30-50% savings
       - 3-year: 50-70% savings
       - For stable, long-running workloads

    3. Spot VMs:
       - Up to 90% discount
       - For fault-tolerant workloads (batch, testing)

    4. Stop VMs when not in use:
       - Dev/test: Stop nights and weekends
       - Use Azure Automation for scheduling

    5. Use B-series (Burstable):
       - For variable workloads
       - Accumulate credits when idle

    6. Azure Hybrid Benefit:
       - Use existing Windows licenses
       - Up to 40% savings

    7. Delete unused resources:
       - Unattached disks
       - Old snapshots
       - Orphaned NICs and public IPs

    8. Use autoscaling:
       - Scale down during low traffic
       - Scale up during high traffic
    ```
  </Accordion>
</AccordionGroup>

### Advanced

<AccordionGroup>
  <Accordion title="Q5: Implement blue-green deployment with zero downtime">
    ```
    Blue-Green Deployment with App Service:

    1. Setup:
       Production slot (blue): Currently serving traffic
       Staging slot (green): New version

    2. Deploy to Green:
       az webapp deployment source config \
         --name mywebapp \
         --slot staging \
         --repo-url https://github.com/user/repo \
         --branch release/v2.0

    3. Test Green:
       - Access staging URL: mywebapp-staging.azurewebsites.net
       - Run smoke tests, integration tests
       - Verify database migrations

    4. Warm Up Green:
       az webapp deployment slot swap \
         --name mywebapp \
         --slot staging \
         --target-slot production \
         --action preview

       # App Service warms up staging before swap

    5. Swap (Zero Downtime):
       az webapp deployment slot swap \
         --name mywebapp \
         --slot staging \
         --target-slot production

       # Traffic instantly switches to green
       # No connection drops

    6. Rollback (if needed):
       az webapp deployment slot swap \
         --name mywebapp \
         --slot production \
         --target-slot staging

       # Instant rollback (just swap again)

    Benefits:
    ✅ Zero downtime
    ✅ Instant rollback
    ✅ Test in production-like environment
    ✅ No infrastructure changes
    ```
  </Accordion>

  <Accordion title="Q6: Optimize VM performance for database workload">
    ```
    SQL Server on Azure VM Optimization:

    1. Choose Right VM Size:
       - Memory-optimized: E-series (8:1 memory:CPU)
       - Example: Standard_E16s_v5 (16 vCPU, 128 GB RAM)

    2. Storage Configuration:
       - OS Disk: Premium SSD P30 (ReadWrite cache)
       - Data Files: Premium SSD P40+ (ReadOnly cache)
       - Log Files: Premium SSD P30 (None cache)
       - TempDB: Local NVMe SSD

    3. Disk Striping:
       # Windows Storage Spaces (RAID 0)
       - Stripe 4x P30 disks → 20,000 IOPS
       - Better than 1x P80 (same IOPS, more expensive)

    4. SQL Server Configuration:
       - Max Server Memory: 80% of VM RAM
       - TempDB on local SSD (D: drive)
       - Multiple data files (8 files for TempDB)
       - Instant File Initialization: Enabled

    5. Network Optimization:
       - Enable Accelerated Networking
       - Private Endpoint for Azure SQL connectivity
       - No public IPs

    6. Backup Strategy:
       - Azure Backup (application-consistent)
       - Backup to Blob Storage (cool tier)
       - Retention: 7 days (daily), 4 weeks (weekly)

    7. Monitoring:
       - Azure Monitor for VMs
       - SQL Insights (database metrics)
       - Alert on CPU > 80%, Memory > 85%

    Result:
    - 20,000+ IOPS
    - &lt;1ms latency (local SSD for TempDB)
    - 99.95% availability (availability zones)
    ```
  </Accordion>
</AccordionGroup>

---

## 7. Key Takeaways

<CardGroup cols={2}>
  <Card title="Choose the Right Compute" icon="server">
    VMs for control, App Service for simplicity, AKS for microservices, Functions for events.
  </Card>

  <Card title="Use Availability Zones" icon="shield">
    Deploy across zones for 99.99% SLA. Critical for production.
  </Card>

  <Card title="Autoscaling is Essential" icon="chart-line">
    Scale based on demand. Save money during low traffic, handle spikes automatically.
  </Card>

  <Card title="Managed Identities" icon="key">
    No secrets in code. Every compute service supports managed identity.
  </Card>

  <Card title="Cost Optimization" icon="dollar-sign">
    Right-size, use reserved instances, stop when not needed, leverage spot VMs.
  </Card>

  <Card title="Deployment Slots" icon="arrows-spin">
    Zero-downtime deployments with instant rollback. Use for all production apps.
  </Card>
</CardGroup>

---

## Next Steps

<Card title="Continue to Chapter 5" icon="arrow-right" href="/courses/azure-cloud-engineering/05-storage-solutions">
  Master Azure Storage: Blob, Files, Disks, and data management strategies
</Card>
