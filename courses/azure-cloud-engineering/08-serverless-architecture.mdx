---
title: "Serverless Architecture"
description: "Master Azure Functions, Logic Apps, and event-driven serverless patterns"
icon: "bolt"
---

# Serverless Architecture

Serverless lets you focus on code without managing infrastructure. Azure handles scaling, availability, and operations.

![Azure Serverless Architecture](/images/azure/08-serverless-flow.svg)

---

## 1. Azure Functions

**Azure Functions** is Azure's serverless compute platform for event-driven code execution.

### Hosting Plans

<Tabs>
  <Tab title="Consumption Plan">
    **Pay per execution (true serverless)**
    - Automatic scaling (0 to 200 instances)
    - Pay only when code runs
    - 5-minute execution limit
    - Cold start (~3-10 seconds)
    - Cost: $0.20 per million executions + $0.000016/GB-s

    **Use for**: Event-driven, unpredictable workloads
  </Tab>

  <Tab title="Premium Plan">
    **Pre-warmed instances (no cold start)**
    - Always-on instances (1+)
    - Unlimited execution time
    - VNet integration
    - Cost: ~$150/month minimum

    **Use for**: Production apps requiring consistent performance
  </Tab>

  <Tab title="Dedicated (App Service)">
    **Run on App Service Plan**
    - Predictable cost
    - Use existing App Service capacity
    - No cold starts

    **Use for**: Long-running functions, existing App Service infrastructure
    **Use for**: Long-running functions, existing App Service infrastructure
  </Tab>
</Tabs>

> [!WARNING]
> **Gotcha: Consumption Plan Timeouts**
> The default timeout for a function is 5 minutes (can increase to 10). If your code takes 11 minutes to run, the platform will kill it mid-execution. For long tasks, use **Durable Functions**.

> [!TIP]
> **Jargon Alert: Cold Start**
> If no one calls your function for 20 minutes, Azure keeps it "cold" (off) to save money. The next person to call it waits 5-10 seconds while Azure boots up a server in the background.

### Triggers and Bindings

<CardGroup cols={2}>
  <Card title="Common Triggers" icon="arrow-right-to-bracket">
    - HTTP (REST APIs)
    - Timer (CRON jobs)
    - Blob Storage (file upload)
    - Queue Storage (messages)
    - Event Hub (streaming)
    - Cosmos DB (change feed)
  </Card>

  <Card title="Output Bindings" icon="arrow-right-from-bracket">
    - HTTP response
    - Queue Storage
    - Blob Storage
    - Cosmos DB
    - Table Storage
    - Event Hub
  </Card>
</CardGroup>

### Example Functions

<Tabs>
  <Tab title="HTTP Trigger">
    ```csharp
    [FunctionName("HttpExample")]
    public static async Task<IActionResult> Run(
        [HttpTrigger(AuthorizationLevel.Function, "get", "post")] HttpRequest req,
        ILogger log)
    {
        log.LogInformation("C# HTTP trigger function processed a request.");

        string name = req.Query["name"];
        return new OkObjectResult($"Hello, {name}");
    }
    ```
  </Tab>

  <Tab title="Blob Trigger">
    ```csharp
    [FunctionName("ProcessImage")]
    public static async Task Run(
        [BlobTrigger("uploads/{name}", Connection = "StorageConnection")] Stream blob,
        string name,
        [Blob("thumbnails/{name}", FileAccess.Write)] Stream thumbnail,
        ILogger log)
    {
        log.LogInformation($"Processing blob: {name}, Size: {blob.Length} bytes");

        // Resize image
        using (var image = Image.Load(blob))
        {
            image.Mutate(x => x.Resize(200, 200));
            image.SaveAsJpeg(thumbnail);
        }
    }
    ```
  </Tab>

  <Tab title="Timer Trigger">
    ```csharp
    [FunctionName("DailyCleanup")]
    public static void Run(
        [TimerTrigger("0 0 2 * * *")] TimerInfo timer,  // 2 AM daily
        ILogger log)
    {
        log.LogInformation($"Cleanup job executed at: {DateTime.Now}");

        // Delete old files, clean cache, etc.
    }
    ```
  </Tab>

  <Tab title="Queue Trigger">
    ```csharp
    [FunctionName("ProcessOrders")]
    public static async Task Run(
        [QueueTrigger("orders", Connection = "StorageConnection")] string orderJson,
        [CosmosDB(
            databaseName: "OrdersDB",
            collectionName: "ProcessedOrders",
            ConnectionStringSetting = "CosmosConnection")] IAsyncCollector<Order> orders,
        ILogger log)
    {
        var order = JsonSerializer.Deserialize<Order>(orderJson);
        log.LogInformation($"Processing order: {order.Id}");

        // Process order
        order.ProcessedAt = DateTime.UtcNow;
        order.Status = "Completed";

        // Save to Cosmos DB
        await orders.AddAsync(order);
    }
    ```
  </Tab>
</Tabs>

---

## 2. Durable Functions

**Durable Functions** enable stateful workflows in serverless.

### Function Chaining

```csharp
[FunctionName("ProcessOrder")]
public static async Task<object> RunOrchestrator(
    [OrchestrationTrigger] IDurableOrchestrationContext context)
{
    var order = context.GetInput<Order>();

    // Sequential workflow
    var payment = await context.CallActivityAsync<Payment>("ProcessPayment", order);
    var inventory = await context.CallActivityAsync<Inventory>("ReserveInventory", order);
    var shipment = await context.CallActivityAsync<Shipment>("CreateShipment", order);

    return new { payment, inventory, shipment };
}

[FunctionName("ProcessPayment")]
public static Payment ProcessPayment([ActivityTrigger] Order order, ILogger log)
{
    log.LogInformation($"Processing payment for order {order.Id}");
    // Payment processing logic
    return new Payment { OrderId = order.Id, Status = "Paid" };
}
```

### Fan-Out/Fan-In

```csharp
[FunctionName("ProcessBatch")]
public static async Task<long> RunOrchestrator(
    [OrchestrationTrigger] IDurableOrchestrationContext context)
{
    var files = context.GetInput<string[]>();

    // Fan-out: Process all files in parallel
    var tasks = new List<Task<long>>();
    foreach (var file in files)
    {
        tasks.Add(context.CallActivityAsync<long>("ProcessFile", file));
    }

    // Fan-in: Wait for all to complete
    var results = await Task.WhenAll(tasks);

    // Return total bytes processed
    return results.Sum();
}
```

---

## 3. Logic Apps

**Logic Apps** provide visual workflow automation with 400+ connectors.

### Use Cases

<CardGroup cols={2}>
  <Card title="Integration" icon="plug">
    Connect SaaS apps (Salesforce, SAP, Office 365)
  </Card>

  <Card title="Automation" icon="robot">
    Automate business processes and approvals
  </Card>

  <Card title="B2B" icon="handshake">
    EDI and enterprise messaging
  </Card>

  <Card title="Scheduled Tasks" icon="clock">
    Recurring workflows (reports, backups)
  </Card>
</CardGroup>

### Example Workflow

```json
{
  "definition": {
    "$schema": "https://schema.management.azure.com/providers/Microsoft.Logic/schemas/2016-06-01/workflowdefinition.json#",
    "triggers": {
      "When_a_blob_is_added": {
        "type": "ApiConnection",
        "inputs": {
          "host": {
            "connection": {
              "name": "@parameters('$connections')['azureblob']['connectionId']"
            }
          },
          "method": "get",
          "path": "/datasets/default/triggers/batch/onupdatedfile"
        },
        "recurrence": {
          "frequency": "Minute",
          "interval": 5
        }
      }
    },
    "actions": {
      "Get_blob_content": {
        "type": "ApiConnection",
        "inputs": {
          "host": {
            "connection": {
              "name": "@parameters('$connections')['azureblob']['connectionId']"
            }
          },
          "method": "get",
          "path": "/datasets/default/files/@{encodeURIComponent(encodeURIComponent(triggerBody()?['Path']))}/content"
        }
      },
      "Parse_JSON": {
        "type": "ParseJson",
        "inputs": {
          "content": "@body('Get_blob_content')",
          "schema": {
            "type": "object",
            "properties": {
              "orderId": { "type": "string" },
              "amount": { "type": "number" }
            }
          }
        },
        "runAfter": {
          "Get_blob_content": ["Succeeded"]
        }
      },
      "Condition": {
        "type": "If",
        "expression": {
          "and": [
            {
              "greater": ["@body('Parse_JSON')?['amount']", 1000]
            }
          ]
        },
        "actions": {
          "Send_approval_email": {
            "type": "ApiConnection",
            "inputs": {
              "host": {
                "connection": {
                  "name": "@parameters('$connections')['office365']['connectionId']"
                }
              },
              "method": "post",
              "body": {
                "To": "manager@company.com",
                "Subject": "Approval Required: Order @{body('Parse_JSON')?['orderId']}",
                "Body": "Order amount: $@{body('Parse_JSON')?['amount']}"
              },
              "path": "/v2/Mail"
            }
          }
        }
      }
    }
  }
}
```

---

## 4. Event Grid

**Event Grid** is Azure's event routing service for reactive programming.

### Event Sources → Event Grid → Event Handlers

<div className="flex justify-center my-4">
  <div className="w-full max-w-4xl">
    ```mermaid
    graph LR
        A[Blob Storage] --> E[Event Grid]
        B[IoT Hub] --> E
        C[Custom App] --> E

        E --> F[Azure Function]
        E --> G[Logic App]
        E --> H[Event Hub]
        E --> I[Webhook]

        style E fill:#FFB900
    ```
  </div>
</div>

### Example: Image Processing Pipeline

```bash
# Create Event Grid subscription
az eventgrid event-subscription create \
  --name process-images \
  --source-resource-id /subscriptions/.../storageAccounts/mystorage \
  --endpoint /subscriptions/.../functions/ProcessImage \
  --included-event-types Microsoft.Storage.BlobCreated \
  --subject-begins-with /blobServices/default/containers/uploads/
```

When image uploaded → Event Grid triggers function → Process image → Save thumbnail

---

## 5. Serverless Patterns

<AccordionGroup>
  <Accordion title="1. Backend for Frontend (BFF)" icon="layer-group">
    ```
    Mobile App → API Management → Azure Functions → Cosmos DB

    Benefits:
    - Pay per use (cost-effective)
    - Auto-scaling (handles traffic spikes)
    - No server management
    ```
  </Accordion>

  <Accordion title="2. Event-Driven Processing" icon="bolt">
    ```
    IoT Device → IoT Hub → Azure Function → Time Series Insights

    Use case: Real-time telemetry processing
    ```
  </Accordion>

  <Accordion title="3. Scheduled Jobs" icon="clock">
    ```
    Timer Trigger → Azure Function → Process Data → Storage

    Use case: Daily report generation, cleanup tasks
    ```
  </Accordion>

  <Accordion title="4. Webhook Handler" icon="webhook">
    ```
    External System → HTTP Function → Process → Database

    Use case: GitHub webhooks, payment notifications
    ```
  </Accordion>
</AccordionGroup>

---

## 6. Best Practices

<CardGroup cols={2}>
  <Card title="Keep Functions Small" icon="minimize">
    Single responsibility, fast execution (&lt;5 seconds)
  </Card>

  <Card title="Use Queues" icon="list">
    Decouple functions with queues for reliability
  </Card>

  <Card title="Handle Idempotency" icon="repeat">
    Functions may execute multiple times, design for it
  </Card>

  <Card title="Monitor Everything" icon="chart-line">
    Application Insights for logging, metrics, traces
  </Card>

  <Card title="Use Managed Identity" icon="key">
    No connection strings in code
  </Card>

  <Card title="Consider Cold Starts" icon="temperature-low">
    Use Premium plan for critical apps
  </Card>
</CardGroup>

---

## 7. Interview Questions

### Beginner Level

<AccordionGroup>
  <Accordion title="Q1: What is a Cold Start in Serverless?">
    **Answer**:
    A delay that occurs when the first request comes in after a period of inactivity. The provider has to provision execution environment/server before running code.
    
    **Mitigation**:
    - Use Premium Plan (pre-warmed instances)
    - Keep alive ping
    - Use Dedicated (App Service) plan
  </Accordion>

  <Accordion title="Q2: What is the difference between a Trigger and a Binding?">
    **Answer**:
    - **Trigger**: Defines *how* a function is invoked (e.g., HTTP request, Timer, Blob uploaded). A function must have exactly one trigger.
    - **Binding**: Connects input/output data resources declaratively (e.g., Read from Cosmos DB, Write to Queue). Optional.
  </Accordion>
</AccordionGroup>

### Intermediate Level

<AccordionGroup>
  <Accordion title="Q3: When should you use Durable Functions?">
    **Answer**:
    When you need stateful workflows in a stateless environment:
    - **Chaining**: Function A -> Function B -> Function C
    - **Fan-out/Fan-in**: Run multiple functions in parallel, wait for all to finish.
    - **Human Interaction**: Wait for approval trigger (email link).
    - **Monitor**: Long-running polling process.
  </Accordion>

  <Accordion title="Q4: Azure Functions vs Logic Apps - how to choose?">
    **Answer**:
    - **Azure Functions**: Code-first. Best for complex logic, custom algorithms, existing libraries.
    - **Logic Apps**: Design-first (GUI). Best for integration, connecting SaaS apps, orchestrating disparate systems without writing code.
  </Accordion>
</AccordionGroup>

### Advanced Level

<AccordionGroup>
  <Accordion title="Q5: Explain the Consumption Plan scaling limits">
    **Answer**:
    - **Scale Controller**: Monitors event rate and adds instances.
    - **Maximum Instances**: usually 200 instances (Windows/Linux).
    - **Execution Time**: Default 5 mins, max 10 mins.
    - **Throughput**: Limited by scale rate (e.g., 1 instance every few seconds).
    
    *If you need longer execution or VNet integration, use Premium.*
  </Accordion>
</AccordionGroup>

---

## 8. Key Takeaways

<CardGroup cols={2}>
  <Card title="Event-Driven" icon="bolt">
    Serverless is reacting to events (HTTP, Timer, Queue). Don't poll; wait for the trigger.
  </Card>
  <Card title="Scaling" icon="chart-line">
    Scaling is automatic and can go to zero (cost = 0) or 200 instances instantly.
  </Card>
  <Card title="Stateless by Default" icon="rotate">
    Functions are ephemeral. Use **Durable Functions** or external storage (Cosmos/Redis) if you need state.
  </Card>
  <Card title="Bindings" icon="plug">
    Use **Input/Output Bindings** to reduce boilerplate code. Focus on business logic, not connection management.
  </Card>
  <Card title="Cost Model" icon="dollar-sign">
    Consumption plan is pay-per-execution. Great for sporadic workloads. Use Premium for predictable, high-performance needs.
  </Card>
</CardGroup>

---

## Next Steps

<Card title="Continue to Chapter 9" icon="arrow-right" href="/courses/azure-cloud-engineering/09-monitoring-observability">
  Master Azure Monitor, Application Insights, and observability
</Card>
