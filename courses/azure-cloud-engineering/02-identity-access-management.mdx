---
title: "Identity & Access Management"
description: "Master Azure Active Directory, RBAC, Conditional Access, and zero-trust security"
icon: "user-shield"
---

# Identity & Access Management

Identity is the **new security perimeter**. In the cloud, your identity system is more important than your firewall. Master Azure Active Directory (Azure AD) and you master Azure security.

![Azure Identity Architecture](/images/azure/02-identity-architecture.svg)

---

## 1. Azure Active Directory Deep Dive

**Azure Active Directory (Azure AD)** is Microsoft's cloud-based identity and access management service. It's NOT the same as on-premises Active Directory.

### Azure AD vs Active Directory (AD DS)

| Feature | Azure AD | Active Directory (AD DS) |
|---------|----------|--------------------------|
| **Protocol** | SAML, OAuth 2.0, OpenID Connect | Kerberos, LDAP |
| **Structure** | Flat (no OUs or GPOs) | Hierarchical (OUs, GPOs) |
| **Authentication** | Cloud-native, MFA-enabled | On-premises, password-based |
| **Management** | REST API, PowerShell, Portal | ADUC, Group Policy |
| **Use Case** | Cloud applications, SaaS | On-premises domain services |
| **Federation** | Built-in SSO | Requires AD FS |

<Warning>
**Common Mistake**: Trying to use Azure AD like on-premises AD

Azure AD is **designed for modern authentication**:
- No LDAP queries (use Microsoft Graph API)
- Different mindset: API-first, cloud-first
</Warning>

> [!TIP]
> **Jargon Alert: Service Principal**
> Think of a **Service Principal** as a "user account for an application." Just like you have a username/password, an app needs an identity to log in.
>
> A **Managed Identity** is just a Service Principal that Azure creates and rotates the password for automatically. (Always use Managed Identities when possible!)

### Azure AD Architecture

<div className="flex justify-center my-4">
  <div className="w-full max-w-4xl">
    ```mermaid
    graph TB
        subgraph "Azure AD Tenant"
            A[Users] --> B[Azure AD]
            C[Groups] --> B
            D[Service Principals] --> B
            E[Managed Identities] --> B
        end

        B --> F[Azure Resources]
        B --> G[Office 365]
        B --> H[Third-Party SaaS]
        B --> I[Custom Apps]

        subgraph "Authentication Methods"
            B --> J[Password + MFA]
            B --> K[Passwordless: FIDO2]
            B --> L[Certificate-based]
            B --> M[Windows Hello]
        end

        style B fill:#0078D4
    ```
  </div>
</div>

### Azure AD Editions

<Tabs>
  <Tab title="Free">
    **Included with Azure subscription**

    Features:
    - User and group management
    - Basic security reports
    - Single Sign-On (SSO) to Azure, Office 365
    - Self-service password change
    - Device registration

    **Best for**: Small businesses, dev/test
  </Tab>

  <Tab title="Premium P1">
    **$6/user/month**

    Everything in Free, plus:
    - Conditional Access
    - Self-service password reset (SSPR)
    - Azure AD Connect Health
    - Dynamic groups
    - Group-based licensing

    **Best for**: Medium businesses, basic security requirements
  </Tab>

  <Tab title="Premium P2">
    **$9/user/month**

    Everything in P1, plus:
    - **Privileged Identity Management (PIM)**
    - **Identity Protection** (risk-based policies)
    - Access Reviews
    - Entitlement Management

    **Best for**: Enterprises, strict compliance requirements

    <Info>
    **Most enterprises use P2** for PIM alone. The ability to have just-in-time admin access is worth the cost.
    </Info>
  </Tab>
</Tabs>

---

## 2. Authentication Protocols

Understanding how Azure AD authenticates users is crucial for troubleshooting and designing secure applications.

### OAuth 2.0 Flow

**OAuth 2.0** is for **authorization**, not authentication (despite common confusion).

<div className="flex justify-center my-4">
  <div className="w-full max-w-4xl">
    ```mermaid
    sequenceDiagram
        participant User
        participant App
        participant AzureAD
        participant API

        User->>App: 1. Access app
        App->>AzureAD: 2. Redirect to login
        AzureAD->>User: 3. Show login page
        User->>AzureAD: 4. Enter credentials + MFA
        AzureAD->>App: 5. Authorization code
        App->>AzureAD: 6. Exchange code for access token
        AzureAD->>App: 7. Access token + refresh token
        App->>API: 8. Call API with access token
        API->>API: 9. Validate token
        API->>App: 10. Return data
    ```
  </div>
</div>

**Key Concepts**:
- **Authorization Code**: Short-lived code exchanged for tokens
- **Access Token**: JWT token with claims (typically 1-hour lifetime)
- **Refresh Token**: Long-lived token to get new access tokens (up to 90 days)
- **Scopes**: Permissions requested (e.g., `User.Read`, `Mail.Send`)

### OpenID Connect (OIDC)

**OIDC** is OAuth 2.0 + authentication. It adds an **ID token** that proves who the user is.

```json
{
  "iss": "https://login.microsoftonline.com/{tenant}/v2.0",
  "aud": "your-client-id",
  "sub": "user-object-id",
  "name": "John Doe",
  "preferred_username": "john@company.com",
  "oid": "00000000-0000-0000-0000-000000000000",
  "tid": "tenant-id",
  "iat": 1642000000,
  "exp": 1642003600
}
```

**ID Token vs Access Token**:
- **ID Token**: Proves user identity (for your app)
- **Access Token**: Grants access to resources (for APIs)

### SAML 2.0

**SAML** is the older protocol, still widely used for enterprise SSO.

<Tabs>
  <Tab title="When to use SAML">
    - Enterprise SSO to legacy apps
    - Applications that don't support OAuth/OIDC
    - Compliance requirements (some regulations mandate SAML)
  </Tab>

  <Tab title="When to use OIDC/OAuth">
    - Modern web/mobile applications
    - API access
    - Single Page Applications (SPAs)
    - Better developer experience
  </Tab>
</Tabs>

---

## 3. Multi-Factor Authentication (MFA)

**MFA is non-negotiable**. Passwords alone are compromised in 80% of breaches.

### MFA Methods in Azure AD

<CardGroup cols={2}>
  <Card title="Microsoft Authenticator" icon="mobile">
    **Best method** (push notification or code)

    - Passwordless authentication supported
    - Number matching (prevents MFA fatigue)
    - Risk-based authentication
  </Card>

  <Card title="FIDO2 Security Keys" icon="key">
    **Most secure** (hardware token)

    - Phishing-resistant
    - Passwordless
    - Hardware-based cryptography
  </Card>

  <Card title="SMS / Voice Call" icon="phone">
    **Least secure** (avoid if possible)

    - Vulnerable to SIM swapping
    - SMS interception
    - Use only as backup
  </Card>

  <Card title="OATH Hardware Tokens" icon="shield">
    **Enterprise standard**

    - YubiKey, RSA tokens
    - Time-based codes
    - No network required
  </Card>
</CardGroup>

### Conditional Access + MFA

**Don't require MFA for everyone, everywhere**. Use Conditional Access for smart MFA:

```
Policy: Smart MFA
Conditions:
  - User is NOT on corporate network
  - User accessing from unknown device
  - Sign-in risk: Medium or High

Actions:
  - Require MFA
  - Require compliant device
```

**Real-World Example**:
```
Scenario 1: Office Network
User: alice@company.com
Location: Corporate network (trusted IP)
Device: Company laptop (Intune-managed)
Action: ‚úÖ No MFA required (trusted environment)

Scenario 2: Home Network
User: alice@company.com
Location: Home (untrusted)
Device: Personal laptop
Action: ‚ö†Ô∏è  Require MFA

Scenario 3: Coffee Shop
User: alice@company.com
Location: Public WiFi (untrusted)
Device: Personal phone
Risk: High (Azure AD detects anomaly)
Action: ‚ùå Block access OR require re-authentication + MFA
```

---

## 4. Role-Based Access Control (RBAC)

RBAC is how you control **who can do what** in Azure.

### The RBAC Formula

```
Who (Security Principal) + What (Role) + Where (Scope) = Permission
```

> [!WARNING]
> **Gotcha: RBAC Propagation Delay**
> After assigning an RBAC role, it can take **up to 30 minutes** for permissions to propagate across all Azure regions. If a user says "I still can't access it," they might just need to wait a few minutes and refresh their token (re-login).

<div className="flex justify-center my-4">
  <div className="w-full max-w-4xl">
    ```mermaid
    graph LR
        A[Security Principal] -->|assigned| B[Role Definition]
        B -->|at| C[Scope]
        C --> D[Permission Granted]

        A --> A1[User: alice@company.com]
        A --> A2[Group: Developers]
        A --> A3[Service Principal]
        A --> A4[Managed Identity]

        B --> B1[Owner]
        B --> B2[Contributor]
        B --> B3[Reader]
        B --> B4[VM Contributor]

        C --> C1[Subscription]
        C --> C2[Resource Group]
        C --> C3[Resource]
    ```
  </div>
</div>

### Built-in Roles Deep Dive

<AccordionGroup>
  <Accordion title="Owner" icon="crown">
    **Full control + can assign roles**

    Permissions:
    - All actions: `*`
    - Can grant access to others
    - Can delete resources

    **Use sparingly**: 2-3 subscription admins maximum

    ```json
    {
      "Name": "Owner",
      "Actions": ["*"],
      "NotActions": [],
      "DataActions": ["*"],
      "AssignableScopes": ["/"]
    }
    ```
  </Accordion>

  <Accordion title="Contributor" icon="user-pen">
    **Can create and manage resources, but NOT assign roles**

    Permissions:
    - All resource operations
    - CANNOT assign roles
    - CANNOT modify IAM

    **Use case**: Developers, operators

    **Important**: Contributor can still cause damage (delete resources)
  </Accordion>

  <Accordion title="Reader" icon="eye">
    **View-only access**

    Permissions:
    - Read all resources
    - CANNOT modify anything
    - CANNOT view secrets/keys

    **Use case**: Auditors, stakeholders, new team members
  </Accordion>

  <Accordion title="Specialized Roles" icon="briefcase">
    Azure has **300+ built-in roles** for specific services:

    **Compute**:
    - Virtual Machine Contributor
    - Virtual Machine Administrator Login
    - Disk Snapshot Contributor

    **Storage**:
    - Storage Blob Data Contributor
    - Storage Blob Data Reader
    - Storage Queue Data Contributor

    **Networking**:
    - Network Contributor
    - DNS Zone Contributor

    **Security**:
    - Key Vault Administrator
    - Security Admin
    - Security Reader

    **Best Practice**: Use specialized roles instead of Contributor when possible
  </Accordion>
</AccordionGroup>

### Scope Hierarchy & Inheritance

```
Management Group (org-wide policies)
    ‚Üì inherits
Subscription (billing boundary)
    ‚Üì inherits
Resource Group (lifecycle boundary)
    ‚Üì inherits
Resource (individual service)
```

**Inheritance Rules**:
- Permissions **accumulate** downward
- Child inherits parent permissions
- Cannot **remove** inherited permissions (only add)
- Explicit **Deny** doesn't exist in Azure RBAC (unlike AWS)

**Example**:
```bash
# Alice has these assignments:
# 1. Reader at Subscription level
# 2. Contributor at "Dev" Resource Group

# Effective permissions:
Subscription scope:
  ‚úÖ Can view all resources
  ‚ùå Cannot modify anything

Dev Resource Group:
  ‚úÖ Can view AND modify resources
  ‚úÖ Can create new resources
  ‚ùå Cannot assign roles (not Owner)

Prod Resource Group:
  ‚úÖ Can view resources (inherited from Subscription)
  ‚ùå Cannot modify (no Contributor role)
```

### Custom RBAC Roles

When built-in roles don't fit, create custom roles.

**Example: Database Administrator Role**

```json
{
  "Name": "SQL Database Administrator",
  "Description": "Manage SQL databases but not delete them",
  "Actions": [
    "Microsoft.Sql/servers/databases/read",
    "Microsoft.Sql/servers/databases/write",
    "Microsoft.Sql/servers/databases/backups/*",
    "Microsoft.Sql/servers/databases/auditingSettings/*",
    "Microsoft.Sql/servers/databases/securityAlertPolicies/*"
  ],
  "NotActions": [
    "Microsoft.Sql/servers/databases/delete"
  ],
  "AssignableScopes": [
    "/subscriptions/{subscription-id}"
  ]
}
```

**Creating Custom Role via CLI**:
```bash
az role definition create --role-definition @custom-role.json
```

**Best Practices for Custom Roles**:
1. Start with built-in role, copy and modify
2. Use least privilege (only required actions)
3. Test in dev before production
4. Document the purpose and use cases
5. Review quarterly (remove unused permissions)

---

## 5. Managed Identities

**Managed Identities** eliminate the need for credentials in code. This is **huge** for security.

### The Problem Managed Identities Solve

<Tabs>
  <Tab title="‚ùå Without Managed Identity">
    **The old way: Service Principal with secret**

    ```csharp
    // BAD: Credentials in code
    var credential = new ClientSecretCredential(
        tenantId: "00000000-0000-0000-0000-000000000000",
        clientId: "your-client-id",
        clientSecret: "your-secret-here" // üö® Secret in code!
    );

    var client = new BlobServiceClient(
        new Uri("https://storage.blob.core.windows.net"),
        credential
    );
    ```

    **Problems**:
    - ‚ùå Secret stored somewhere (code, config, Key Vault)
    - ‚ùå Secret can be stolen (Git commits, logs)
    - ‚ùå Must rotate secrets (manual process)
    - ‚ùå Secrets expire (app breaks)
    - ‚ùå Overhead managing secrets
  </Tab>

  <Tab title="‚úÖ With Managed Identity">
    **The new way: No credentials at all**

    ```csharp
    // GOOD: No credentials needed!
    var credential = new DefaultAzureCredential();

    var client = new BlobServiceClient(
        new Uri("https://storage.blob.core.windows.net"),
        credential
    );

    // That's it! Azure handles authentication automatically
    ```

    **Benefits**:
    - ‚úÖ No secrets in code
    - ‚úÖ No secrets to rotate
    - ‚úÖ Azure manages credentials
    - ‚úÖ Automatic rotation
    - ‚úÖ Cannot be stolen from code
  </Tab>
</Tabs>

### Types of Managed Identities

<CardGroup cols={2}>
  <Card title="System-Assigned" icon="link">
    **Tied to resource lifecycle**

    - Created when resource is created
    - Deleted when resource is deleted
    - One-to-one relationship
    - Cannot be shared

    **Use case**: Single VM accessing storage
  </Card>

  <Card title="User-Assigned" icon="users">
    **Independent lifecycle**

    - Created separately
    - Can be shared across resources
    - Survives resource deletion
    - Reusable

    **Use case**: Multiple VMs accessing same resources
  </Card>
</CardGroup>

### Hands-On: Enable Managed Identity

**Scenario**: VM needs to read from Key Vault

**Step 1: Enable Managed Identity on VM**
```bash
az vm identity assign \
  --name MyVM \
  --resource-group MyRG
```

**Step 2: Grant VM Access to Key Vault**
```bash
# Get VM's identity
IDENTITY=$(az vm identity show \
  --name MyVM \
  --resource-group MyRG \
  --query principalId \
  --output tsv)

# Grant access to Key Vault
az keyvault set-policy \
  --name MyVault \
  --object-id $IDENTITY \
  --secret-permissions get list
```

**Step 3: Access Key Vault from VM (no credentials!)**
```python
from azure.identity import DefaultAzureCredential
from azure.keyvault.secrets import SecretClient

# No credentials in code!
credential = DefaultAzureCredential()
client = SecretClient(
    vault_url="https://myvault.vault.azure.net",
    credential=credential
)

# Get secret
secret = client.get_secret("DatabasePassword")
print(secret.value)
```

### How Managed Identity Works Internally

<div className="flex justify-center my-4">
  <div className="w-full max-w-4xl">
    ```mermaid
    sequenceDiagram
        participant VM
        participant IMDS as Azure IMDS
        participant AzureAD
        participant KeyVault

        VM->>IMDS: 1. Request token (http://169.254.169.254)
        IMDS->>IMDS: 2. Verify caller is legitimate VM
        IMDS->>AzureAD: 3. Request token for VM identity
        AzureAD->>IMDS: 4. Return access token
        IMDS->>VM: 5. Return access token
        VM->>KeyVault: 6. Call API with token
        KeyVault->>KeyVault: 7. Validate token signature
        KeyVault->>VM: 8. Return secret
    ```
  </div>
</div>

**IMDS (Instance Metadata Service)**:
- Special endpoint: `http://169.254.169.254`
- Only accessible from within Azure resources
- Provides metadata + OAuth tokens
- No authentication required (network isolation provides security)

---

## 6. Conditional Access

**Conditional Access** is Azure AD's policy engine for enforcing security controls based on conditions.

### Conditional Access Components

```
IF (Condition)
THEN (Control)
```

<Tabs>
  <Tab title="Conditions">
    **What triggers the policy?**

    - **User/Group**: Specific users or groups
    - **Cloud App**: Which app is being accessed
    - **Device Platform**: Windows, iOS, Android, macOS
    - **Location**: IP ranges, countries
    - **Client App**: Browser, mobile app, legacy auth
    - **Sign-in Risk**: Low, Medium, High (from Identity Protection)
    - **Device State**: Compliant, domain-joined, hybrid-joined
  </Tab>

  <Tab title="Controls">
    **What action to take?**

    **Grant Controls** (allow access with conditions):
    - Require MFA
    - Require compliant device
    - Require hybrid-joined device
    - Require approved client app
    - Require app protection policy

    **Session Controls** (ongoing monitoring):
    - Sign-in frequency (re-auth every X hours)
    - Persistent browser session
    - App enforced restrictions
    - Conditional Access App Control (CASB)
  </Tab>
</Tabs>

### Essential Conditional Access Policies

<AccordionGroup>
  <Accordion title="Policy 1: Require MFA for All Users" icon="shield-halved">
    **Baseline security policy**

    ```
    Name: Require MFA for All Users
    Conditions:
      - Users: All users
      - Cloud apps: All cloud apps

    Grant:
      - Require MFA

    State: Enabled (Report-only first, then enforce)
    ```

    **Why**: Passwords are compromised daily. MFA blocks 99.9% of automated attacks.

    **Exceptions**: Service accounts (use managed identities instead)
  </Accordion>

  <Accordion title="Policy 2: Block Legacy Authentication" icon="ban">
    **Critical security policy**

    ```
    Name: Block Legacy Authentication
    Conditions:
      - Users: All users
      - Cloud apps: All cloud apps
      - Client apps: Exchange ActiveSync, Other clients

    Grant:
      - Block access

    State: Enabled
    ```

    **Why**: Legacy protocols (POP, IMAP, SMTP) don't support MFA. Used in 97% of credential attacks.

    **Before enabling**: Audit sign-in logs to ensure no legitimate legacy auth usage
  </Accordion>

  <Accordion title="Policy 3: Require Compliant Device for Admins" icon="user-shield">
    **Protect privileged accounts**

    ```
    Name: Admins Require Compliant Device
    Conditions:
      - Users: All admin roles
      - Cloud apps: Azure portal, Microsoft 365 admin

    Grant:
      - Require device to be marked as compliant
      - Require MFA
      - Require all selected controls

    State: Enabled
    ```

    **Why**: Admin accounts are high-value targets. Ensure they're only accessed from managed devices.

    **Requires**: Microsoft Intune (device management)
  </Accordion>

  <Accordion title="Policy 4: Block Access from Unknown Locations" icon="location-dot">
    **Geo-based restrictions**

    ```
    Name: Block Access from High-Risk Countries
    Conditions:
      - Users: All users (except break-glass accounts)
      - Cloud apps: All cloud apps
      - Locations: Countries where company doesn't operate

    Grant:
      - Block access

    State: Enabled (after VPN solution for travelers)
    ```

    **Why**: If you don't have employees in certain countries, block them entirely.

    **Caution**: Legitimate users traveling? Provide VPN that routes through approved locations.
  </Accordion>

  <Accordion title="Policy 5: Require MFA for Azure Management" icon="screwdriver-wrench">
    **Protect infrastructure access**

    ```
    Name: Azure Management Requires MFA
    Conditions:
      - Users: All users
      - Cloud apps: Microsoft Azure Management

    Grant:
      - Require MFA

    State: Enabled
    ```

    **Why**: Azure portal, CLI, PowerShell access should always require MFA.

    **Scope**: Applies to portal, Azure CLI, PowerShell, APIs
  </Accordion>
</AccordionGroup>

### Conditional Access Best Practices

<Steps>
  <Step title="Start with Report-Only Mode">
    Enable policies in "Report-only" mode first. Review sign-in logs for 1-2 weeks to see impact.
  </Step>

  <Step title="Create Break-Glass Accounts">
    Create 2 emergency admin accounts excluded from ALL Conditional Access policies.

    Store credentials in physical safe. Test quarterly.
  </Step>

  <Step title="Layer Policies">
    Don't create one massive policy. Create multiple focused policies that layer security.
  </Step>

  <Step title="Monitor Sign-In Logs">
    Review blocked sign-ins weekly. Are legitimate users being blocked?
  </Step>

  <Step title="Document Exceptions">
    If you exclude users/groups from policies, document why and review quarterly.
  </Step>
</Steps>

---

## 7. Privileged Identity Management (PIM)

**PIM** provides just-in-time (JIT) privileged access. Admins are elevated only when needed, for a limited time.

### The Problem PIM Solves

<Tabs>
  <Tab title="‚ùå Without PIM">
    **Permanent admin access**

    ```
    Alice: Owner role on Production subscription (permanent)

    Risks:
    - Alice's account compromised ‚Üí attacker has Owner access
    - Alice doesn't need Owner 99% of the time
    - Can accidentally delete resources
    - No approval workflow
    - Hard to audit (always elevated)

    Blast radius: MAXIMUM
    ```
  </Tab>

  <Tab title="‚úÖ With PIM">
    **Just-in-time admin access**

    ```
    Alice: Eligible for Owner role (not active)

    When Alice needs elevated access:
    1. Requests activation (via portal/API)
    2. Provides justification: "Deploy hotfix for incident #12345"
    3. Optional: Approval from manager
    4. Elevated to Owner for 4 hours (configurable)
    5. All actions logged
    6. Auto-demoted after 4 hours

    Benefits:
    ‚úÖ Reduced attack surface (not always admin)
    ‚úÖ Auditable (who elevated when and why)
    ‚úÖ Time-limited (automatic expiration)
    ‚úÖ Approval workflow (for sensitive roles)

    Blast radius: MINIMAL (only when elevated)
    ```
  </Tab>
</Tabs>

### PIM Configuration

**Step 1: Make Users Eligible (Not Active)**
```bash
# Instead of assigning role permanently:
az role assignment create \
  --assignee alice@company.com \
  --role Owner \
  --scope /subscriptions/{sub-id}

# Make them ELIGIBLE via PIM:
# (Done via Azure Portal: Azure AD > PIM > Azure Resources)
```

**Step 2: Configure Role Settings**
```
Role: Owner
Activation:
  - Maximum duration: 4 hours
  - Require justification: Yes
  - Require approval: Yes (for Owner role)
  - Approvers: Security team
  - Require MFA: Yes

Assignment:
  - Maximum eligible duration: 180 days (then re-justify)
  - Require justification on assignment: Yes
```

**Step 3: User Activates Role**
```
User: Alice
Role: Owner
Duration: 4 hours
Justification: "Deploy emergency hotfix for incident INC-12345"
Approval: Required
Approver: Bob (Security Lead)

Workflow:
1. Alice requests activation (Portal or API)
2. Bob receives notification
3. Bob approves (or denies)
4. Alice elevated for 4 hours
5. After 4 hours: Auto-demotion
6. All logged in Azure AD audit logs
```

### PIM Access Reviews

**Quarterly Access Review**:
```
Review: Owner role eligibility
Scope: All users eligible for Owner
Frequency: Quarterly
Reviewers: Resource owners

Questions:
1. Does this user still need this role?
2. Should we reduce their maximum duration?
3. Should we add more approvers?

Actions:
- Remove access (no longer needed)
- Reduce duration (4 hours ‚Üí 2 hours)
- Add approval requirement
```

**Automation**:
```bash
# Export PIM assignments
az rest --method GET \
  --url "https://management.azure.com/subscriptions/{sub-id}/providers/Microsoft.Authorization/roleEligibilityScheduleInstances?api-version=2020-10-01" \
  --query "value[?roleDefinitionId contains 'Owner']"

# Alert on long-running activations
# (via Log Analytics query)
```

---

## 8. Azure AD Connect (Hybrid Identity)

Most enterprises have on-premises Active Directory. **Azure AD Connect** synchronizes identities to Azure AD.

### Synchronization Methods

<Tabs>
  <Tab title="Password Hash Sync">
    **Most common method**

    How it works:
    1. Azure AD Connect runs on-premises
    2. Reads user objects from AD DS
    3. **Hashes** the password hash (double hash)
    4. Syncs to Azure AD
    5. Users can sign in to cloud apps with AD password

    **Benefits**:
    - Simple to set up
    - No additional infrastructure
    - Works even if on-premises AD is down
    - Supports leaked credential detection

    **Use case**: Most organizations
  </Tab>

  <Tab title="Pass-through Authentication">
    **Authentication happens on-premises**

    How it works:
    1. User signs in to Azure AD
    2. Azure AD sends request to on-premises agent
    3. Agent validates against on-premises AD
    4. Result sent back to Azure AD

    **Benefits**:
    - Passwords never leave on-premises
    - Real-time password validation
    - Supports on-premises password policies

    **Drawbacks**:
    - Requires on-premises availability
    - More complex (agents, high availability)

    **Use case**: Strict compliance (passwords must stay on-prem)
  </Tab>

  <Tab title="Federation (ADFS)">
    **Trust-based authentication**

    How it works:
    1. User signs in to Azure AD
    2. Azure AD redirects to AD FS
    3. AD FS validates credentials
    4. Issues SAML token
    5. User redirected back with token

    **Benefits**:
    - Most control over authentication
    - Custom MFA providers
    - Smart card authentication

    **Drawbacks**:
    - Most complex
    - Requires AD FS infrastructure (HA, WAP)
    - More points of failure

    **Use case**: Legacy requirements, smart cards
  </Tab>
</Tabs>

### Azure AD Connect Best Practices

<CardGroup cols={2}>
  <Card title="High Availability" icon="server">
    - Deploy Azure AD Connect in **staging mode** (second server)
    - Automatic failover if primary fails
    - Regular backups of config
  </Card>

  <Card title="Selective Sync" icon="filter">
    - Don't sync all AD objects
    - Filter by OU (sync only users who need cloud access)
    - Reduces Azure AD clutter
  </Card>

  <Card title="Monitoring" icon="chart-line">
    - Azure AD Connect Health (monitors sync)
    - Alerts on sync errors
    - Export sync logs to Log Analytics
  </Card>

  <Card title="Password Writeback" icon="rotate">
    - Allow self-service password reset (SSPR)
    - Changes in Azure AD written back to AD DS
    - Requires P1 license
  </Card>
</CardGroup>

---

## 9. Hands-On Lab: Implement Zero-Trust Identity

Let's implement a complete zero-trust identity architecture.

### Lab Objectives

- Configure Azure AD with MFA
- Implement Conditional Access policies
- Configure PIM for just-in-time access
- Set up managed identity for app authentication

### Step 1: Enable Security Defaults (Quick Win)

```bash
# Security Defaults enables:
# - MFA for all users
# - Blocks legacy authentication
# - Requires MFA for Azure portal

# Enable via Azure AD Portal:
# Azure AD > Properties > Manage Security Defaults > Enable
```

<Info>
**Security Defaults vs Conditional Access**:
- Security Defaults: Free, basic protection, all-or-nothing
- Conditional Access: Premium P1, granular policies, recommended for production
</Info>

### Step 2: Create Conditional Access Policies

**Policy 1: Require MFA for Azure Portal**
```bash
# Via Portal: Azure AD > Security > Conditional Access > New Policy

Name: Require MFA for Azure Portal
Assignments:
  Users: All users
  Cloud apps: Microsoft Azure Management
Access controls:
  Grant: Require MFA
Enable policy: On
```

**Policy 2: Block Legacy Authentication**
```bash
Name: Block Legacy Authentication
Assignments:
  Users: All users
  Cloud apps: All
  Conditions:
    Client apps: Exchange ActiveSync, Other clients
Access controls:
  Block access
Enable policy: Report-only (test first)
```

### Step 3: Configure PIM

```bash
# Enable PIM (requires Azure AD Premium P2)

# 1. Make user eligible for role (not active)
# Portal: Azure AD > PIM > Azure AD Roles > Add assignments
User: alice@company.com
Role: Global Administrator
Assignment type: Eligible
Duration: 180 days

# 2. Configure role settings
Role: Global Administrator
Activation:
  - Max duration: 4 hours
  - Require justification: Yes
  - Require MFA: Yes
  - Require approval: Yes
```

### Step 4: Create Managed Identity Application

```bash
# Create web app with managed identity
az webapp create \
  --name webapp-demo-$RANDOM \
  --resource-group rg-demo \
  --plan plan-demo \
  --runtime "DOTNETCORE|6.0"

# Enable system-assigned managed identity
az webapp identity assign \
  --name webapp-demo-$RANDOM \
  --resource-group rg-demo

# Create Key Vault
az keyvault create \
  --name kv-demo-$RANDOM \
  --resource-group rg-demo \
  --location eastus

# Grant webapp access to Key Vault
IDENTITY=$(az webapp identity show \
  --name webapp-demo-$RANDOM \
  --resource-group rg-demo \
  --query principalId -o tsv)

az keyvault set-policy \
  --name kv-demo-$RANDOM \
  --object-id $IDENTITY \
  --secret-permissions get list
```

### Step 5: Test Managed Identity

**Application Code** (ASP.NET Core):
```csharp
using Azure.Identity;
using Azure.Security.KeyVault.Secrets;

var builder = WebApplication.CreateBuilder(args);

// No credentials in code!
var credential = new DefaultAzureCredential();
var keyVaultUri = "https://kv-demo-12345.vault.azure.net";
var secretClient = new SecretClient(new Uri(keyVaultUri), credential);

builder.Services.AddSingleton(secretClient);

var app = builder.Build();

app.MapGet("/secret", async (SecretClient client) =>
{
    var secret = await client.GetSecretAsync("DatabasePassword");
    return $"Secret retrieved at {DateTime.UtcNow}";
});

app.Run();
```

### Step 6: Verify Zero-Trust Architecture

<Steps>
  <Step title="Test MFA">
    Sign in to Azure Portal from untrusted location. Verify MFA is required.
  </Step>

  <Step title="Test PIM">
    As Alice, activate Global Admin role. Verify approval workflow and time limit.
  </Step>

  <Step title="Test Managed Identity">
    Access `/secret` endpoint. Verify app can read Key Vault without credentials in code.
  </Step>

  <Step title="Review Logs">
    Check sign-in logs for Conditional Access policy enforcement.
  </Step>
</Steps>

---

## 10. Interview Questions

### Beginner Level

<AccordionGroup>
  <Accordion title="Q1: What's the difference between Azure AD and Active Directory?">
    **Answer**:

    **Azure AD** (modern, cloud-native):
    - Protocol: OAuth 2.0, OIDC, SAML
    - Structure: Flat (no OUs)
    - Use: Cloud apps, SaaS, Azure resources
    - Management: REST API, Graph API

    **Active Directory DS** (traditional, on-premises):
    - Protocol: Kerberos, LDAP
    - Structure: Hierarchical (OUs, GPOs)
    - Use: Domain services, on-prem apps
    - Management: ADUC, Group Policy

    **Key Point**: They serve different purposes. Azure AD is NOT a replacement for AD DS in the cloud.
  </Accordion>

  <Accordion title="Q2: Why use managed identities instead of service principals?">
    **Answer**:

    **Managed Identities**:
    - ‚úÖ No credentials to manage
    - ‚úÖ Automatic rotation by Azure
    - ‚úÖ Cannot be stolen from code
    - ‚úÖ Lifecycle tied to resource

    **Service Principals with Secrets**:
    - ‚ùå Secret stored somewhere (Key Vault, config)
    - ‚ùå Must manually rotate (every 90 days)
    - ‚ùå Can be leaked (Git, logs)
    - ‚ùå Overhead to manage

    **Use Service Principal only when**: Running outside Azure (on-premises, other clouds)
  </Accordion>

  <Accordion title="Q3: What is the purpose of Conditional Access?">
    **Answer**:

    **Conditional Access** enforces security controls based on context:

    **Instead of**: "All users always need MFA"
    **Use**: "Users need MFA WHEN accessing from untrusted location OR unknown device"

    **Benefits**:
    - Better user experience (less MFA fatigue)
    - Stronger security (context-aware)
    - Granular control (per app, user, location)

    **Requires**: Azure AD Premium P1
  </Accordion>
</AccordionGroup>

### Intermediate Level

<AccordionGroup>
  <Accordion title="Q4: Design a secure identity architecture for a healthcare company">
    **Answer**:

    ```
    Healthcare Company (HIPAA Compliance):

    1. Identity Foundation:
       - Azure AD Premium P2 (required for PIM)
       - Hybrid identity: Azure AD Connect with PHS
       - All users synced from on-premises AD

    2. Authentication:
       - MFA required for all users (no exceptions)
       - FIDO2 security keys for admins
       - Passwordless (Windows Hello) for employees
       - Block legacy authentication (HIPAA requirement)

    3. Conditional Access Policies:
       Policy 1: Healthcare Apps Require Compliant Device
         - Apps: EHR system, patient portal
         - Require: Intune-managed device + MFA

       Policy 2: Block Access from Non-US Locations
         - All users (except travelers with VPN)
         - Block: Countries outside US

       Policy 3: Admins Require Privileged Workstation
         - Admin roles only
         - Require: Privileged Access Workstation (PAW)

    4. Privileged Access:
       - PIM for all admin roles
       - Maximum activation: 2 hours
       - Approval required for Global Admin
       - Access reviews every 90 days

    5. Application Authentication:
       - Managed identities for all Azure resources
       - No service principals with secrets
       - Key Vault for any external integrations

    6. Monitoring:
       - Azure AD Identity Protection (risk-based policies)
       - Sign-in logs ‚Üí Log Analytics ‚Üí Sentinel
       - Alert on:
         - MFA failures
         - Legacy auth attempts
         - High-risk sign-ins
         - Admin activations

    7. Compliance:
       - Audit logs retained 1 year (HIPAA requirement)
       - Access reviews documented
       - BAA signed with Microsoft
       - Data encryption at rest + in transit
    ```
  </Accordion>

  <Accordion title="Q5: How do you handle a compromised admin account?">
    **Answer**:

    **Incident Response Playbook**:

    ```
    Phase 1: Detection (0-5 minutes)
    - Alert from Azure AD Identity Protection: High-risk sign-in
    - Unusual admin activity detected
    - User reports suspicious activity

    Phase 2: Contain (5-15 minutes)
    1. Revoke all active sessions:
       az ad user revoke-sign-in-sessions \
         --id compromised-user@company.com

    2. Disable account:
       az ad user update \
         --id compromised-user@company.com \
         --account-enabled false

    3. Revoke PIM activations (if active)

    4. Reset password (generate strong random)

    5. Block sign-ins via Conditional Access:
       - Create policy targeting this user
       - Block all access

    Phase 3: Investigate (15 minutes - 1 hour)
    1. Review sign-in logs:
       - When was account compromised?
       - What actions were taken?
       - What resources were accessed?

    2. Check audit logs:
       - Role assignments changed?
       - Resources deleted?
       - Data exported?

    3. Check Azure Activity logs:
       - What resources were modified?
       - Any backdoor accounts created?

    Phase 4: Eradicate (1-2 hours)
    1. Review all role assignments:
       - Remove any added by attacker
       - Check for new service principals

    2. Scan for backdoors:
       - New admin accounts
       - New managed identities
       - Modified NSG rules (opened RDP/SSH)

    3. Rotate credentials:
       - Any secrets accessed? Rotate them
       - Service principals used? Rotate secrets

    Phase 5: Recover (2-4 hours)
    1. Create new account for user (if needed)
    2. Re-enable with stronger security:
       - Require MFA enrollment
       - Issue FIDO2 security key
       - Shorter PIM activation time

    Phase 6: Post-Incident (1 week)
    1. Root cause analysis (how was account compromised?)
    2. Update Conditional Access policies
    3. Security training for user
    4. Document lessons learned
    5. Update incident response playbook

    Prevention (ongoing):
    - PIM (limits damage window)
    - Conditional Access (trusted devices only)
    - FIDO2 keys (phishing-resistant)
    - Identity Protection (detects compromises)
    ```
  </Accordion>
</AccordionGroup>

### Advanced Level

> [!NOTE]
> Advanced interview questions for Identity Architecture are being updated to reflect the latest Zero Trust standards. Check back soon!

---

## 11. Key Takeaways

<CardGroup cols={2}>
  <Card title="Identity is the Perimeter" icon="shield">
    Focus on identity security above all. MFA, Conditional Access, and PIM are non-negotiable.
  </Card>

  <Card title="Managed Identities" icon="key">
    Never use credentials in code. Always use managed identities for Azure resources.
  </Card>

  <Card title="Least Privilege" icon="user-lock">
    Grant minimum permissions required. Use PIM for just-in-time elevation.
  </Card>

  <Card title="Conditional Access" icon="filter">
    Context-aware security is smarter than blanket rules. Tailor policies to risk.
  </Card>

  <Card title="Monitor Everything" icon="chart-line">
    Log all authentication events. Use Identity Protection for risk detection.
  </Card>

  <Card title="Zero Trust" icon="ban">
    Never trust, always verify. Assume breach and verify every access request.
  </Card>
</CardGroup>

---

## Next Steps

You've mastered Azure identity and access management. Next, we'll dive into **Networking Fundamentals** in Chapter 3a.

<Card title="Continue to Chapter 3a" icon="arrow-right" href="/courses/azure-cloud-engineering/03a-networking-fundamentals">
  Master Azure VNets, NSGs, and Subnetting
</Card>
