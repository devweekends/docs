---
title: "Amazon DynamoDB"
description: "Master DynamoDB data modeling, capacity modes, GSIs, LSIs, transactions, and performance optimization"
icon: "database"
---

<Frame>
  <img src="/images/aws/dynamodb-architecture.svg" alt="DynamoDB Architecture" />
</Frame>

## Module Overview

<Info>
**Estimated Time**: 4-5 hours | **Difficulty**: Intermediate-Advanced | **Prerequisites**: Core Concepts
</Info>

DynamoDB is AWS's fully managed NoSQL database designed for single-digit millisecond performance at any scale. This module covers everything from data modeling to advanced patterns used in production systems.

**What You'll Learn:**
- DynamoDB fundamentals and architecture
- Data modeling and access patterns
- Primary keys, GSIs, and LSIs
- Capacity modes (On-Demand vs Provisioned)
- Transactions and consistency models
- DynamoDB Accelerator (DAX)
- Streams and change data capture
- Performance optimization and cost management

---

## Why DynamoDB?

<CardGroup cols={2}>
  <Card title="Fully Managed" icon="server">
    No servers to manage, automatic scaling, built-in backup and restore
  </Card>
  <Card title="Single-Digit Milliseconds" icon="bolt">
    Consistent performance at any scale, from 1 to millions of requests/second
  </Card>
  <Card title="Serverless" icon="cloud">
    Pay-per-request pricing, no idle capacity charges with On-Demand mode
  </Card>
  <Card title="Global Tables" icon="globe">
    Multi-region, active-active replication for global applications
  </Card>
</CardGroup>

---

## DynamoDB Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DynamoDB Architecture                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚                        DynamoDB Table                            â”‚  â”‚
â”‚   â”‚                                                                  â”‚  â”‚
â”‚   â”‚   Table: Orders                                                  â”‚  â”‚
â”‚   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚  â”‚
â”‚   â”‚                                                                  â”‚  â”‚
â”‚   â”‚   Partition Key (PK): customer_id                               â”‚  â”‚
â”‚   â”‚   Sort Key (SK): order_date#order_id                            â”‚  â”‚
â”‚   â”‚                                                                  â”‚  â”‚
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚   â”‚   â”‚  Partition 1 (customer_id = "C001")                      â”‚  â”‚  â”‚
â”‚   â”‚   â”‚  â”œâ”€â”€ 2024-01-15#ORD001 â†’ {amount: 99.99, status: "done"}â”‚  â”‚  â”‚
â”‚   â”‚   â”‚  â”œâ”€â”€ 2024-01-20#ORD002 â†’ {amount: 149.99, status: "new"}â”‚  â”‚  â”‚
â”‚   â”‚   â”‚  â””â”€â”€ 2024-02-01#ORD003 â†’ {amount: 29.99, status: "done"}â”‚  â”‚  â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚   â”‚                                                                  â”‚  â”‚
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚   â”‚   â”‚  Partition 2 (customer_id = "C002")                      â”‚  â”‚  â”‚
â”‚   â”‚   â”‚  â”œâ”€â”€ 2024-01-10#ORD004 â†’ {amount: 59.99, status: "done"}â”‚  â”‚  â”‚
â”‚   â”‚   â”‚  â””â”€â”€ 2024-01-25#ORD005 â†’ {amount: 199.99, status: "new"}â”‚  â”‚  â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚   â”‚                                                                  â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                         â”‚
â”‚   Data Distribution:                                                    â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚   â”‚ Partition 1 â”‚  â”‚ Partition 2 â”‚  â”‚ Partition N â”‚                   â”‚
â”‚   â”‚ (10 GB max) â”‚  â”‚ (10 GB max) â”‚  â”‚ (10 GB max) â”‚                   â”‚
â”‚   â”‚   3 AZs     â”‚  â”‚   3 AZs     â”‚  â”‚   3 AZs     â”‚                   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚         â”‚                â”‚                â”‚                            â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â”‚
â”‚                          â”‚                                              â”‚
â”‚                  Automatic Replication                                  â”‚
â”‚                  (3 copies, multi-AZ)                                   â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Core Concepts

### Primary Keys

DynamoDB supports two types of primary keys:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Primary Key Types                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚   1. PARTITION KEY (Simple Primary Key)                                â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                â”‚
â”‚   â€¢ Single attribute                                                    â”‚
â”‚   â€¢ Must be unique across all items                                    â”‚
â”‚   â€¢ Used to determine physical partition                               â”‚
â”‚                                                                         â”‚
â”‚   Example: user_id (unique per user)                                   â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚   â”‚ user_id   â”‚ data                       â”‚                           â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                           â”‚
â”‚   â”‚ U001      â”‚ {name: "Alice", age: 30}  â”‚                           â”‚
â”‚   â”‚ U002      â”‚ {name: "Bob", age: 25}    â”‚                           â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â”‚                                                                         â”‚
â”‚   2. COMPOSITE PRIMARY KEY (Partition + Sort Key)                      â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                        â”‚
â”‚   â€¢ Two attributes: partition key + sort key                           â”‚
â”‚   â€¢ Partition key doesn't need to be unique                            â”‚
â”‚   â€¢ Combination must be unique                                         â”‚
â”‚   â€¢ Enables range queries on sort key                                  â”‚
â”‚                                                                         â”‚
â”‚   Example: customer_id (PK) + order_date (SK)                          â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚   â”‚ customer_id â”‚ order_date  â”‚ data                 â”‚                 â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                 â”‚
â”‚   â”‚ C001        â”‚ 2024-01-15  â”‚ {amount: 99.99}     â”‚                 â”‚
â”‚   â”‚ C001        â”‚ 2024-01-20  â”‚ {amount: 149.99}    â”‚                 â”‚
â”‚   â”‚ C002        â”‚ 2024-01-10  â”‚ {amount: 59.99}     â”‚                 â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Data Types

```python
# DynamoDB Attribute Types
data_types = {
    # Scalar Types
    "S": "String",              # "Hello World"
    "N": "Number",              # "123.45" (sent as string)
    "B": "Binary",              # base64-encoded binary
    "BOOL": "Boolean",          # true/false
    "NULL": "Null",             # null
    
    # Document Types
    "M": "Map",                 # {"key": {"S": "value"}}
    "L": "List",                # [{"S": "a"}, {"N": "1"}]
    
    # Set Types (unique elements, same type)
    "SS": "String Set",         # ["a", "b", "c"]
    "NS": "Number Set",         # ["1", "2", "3"]
    "BS": "Binary Set",         # [binary1, binary2]
}

# Example Item
order_item = {
    "PK": {"S": "CUSTOMER#C001"},
    "SK": {"S": "ORDER#2024-01-15#ORD001"},
    "order_id": {"S": "ORD001"},
    "customer_id": {"S": "C001"},
    "amount": {"N": "99.99"},
    "items": {"L": [
        {"M": {"product": {"S": "Widget"}, "qty": {"N": "2"}}},
        {"M": {"product": {"S": "Gadget"}, "qty": {"N": "1"}}}
    ]},
    "status": {"S": "COMPLETED"},
    "tags": {"SS": ["express", "gift-wrapped"]},
    "created_at": {"S": "2024-01-15T10:30:00Z"}
}
```

---

## Data Modeling Patterns

### Single-Table Design

<Warning>
**Best Practice**: Use single-table design for related entities. This enables fetching all related data in a single query, reducing latency and cost.
</Warning>

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Single-Table Design Example                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚   E-Commerce: Customers, Orders, Order Items in ONE table              â”‚
â”‚                                                                         â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚ PK                  â”‚ SK                      â”‚ Attributes      â”‚  â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚   â”‚ CUSTOMER#C001       â”‚ PROFILE                 â”‚ name, email...  â”‚  â”‚
â”‚   â”‚ CUSTOMER#C001       â”‚ ORDER#2024-01-15#O001   â”‚ total, status   â”‚  â”‚
â”‚   â”‚ CUSTOMER#C001       â”‚ ORDER#2024-01-20#O002   â”‚ total, status   â”‚  â”‚
â”‚   â”‚ ORDER#O001          â”‚ ITEM#1                  â”‚ product, qty    â”‚  â”‚
â”‚   â”‚ ORDER#O001          â”‚ ITEM#2                  â”‚ product, qty    â”‚  â”‚
â”‚   â”‚ ORDER#O002          â”‚ ITEM#1                  â”‚ product, qty    â”‚  â”‚
â”‚   â”‚ PRODUCT#P001        â”‚ METADATA                â”‚ name, price     â”‚  â”‚
â”‚   â”‚ PRODUCT#P001        â”‚ INVENTORY               â”‚ stock, location â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                         â”‚
â”‚   Access Patterns Enabled:                                              â”‚
â”‚   â€¢ Get customer profile: PK = "CUSTOMER#C001", SK = "PROFILE"         â”‚
â”‚   â€¢ Get all customer orders: PK = "CUSTOMER#C001", SK begins "ORDER#"  â”‚
â”‚   â€¢ Get order items: PK = "ORDER#O001", SK begins "ITEM#"              â”‚
â”‚   â€¢ Get product info: PK = "PRODUCT#P001"                              â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Access Pattern First Design

```python
# Step 1: Define Access Patterns
access_patterns = [
    "Get customer by ID",
    "Get all orders for a customer",
    "Get order details with items",
    "Get orders by status (e.g., 'pending')",
    "Get orders in date range",
    "Get product inventory",
]

# Step 2: Design Keys Based on Patterns
table_design = {
    "table_name": "EcommerceTable",
    "primary_key": {
        "PK": "Partition Key (entity type + ID)",
        "SK": "Sort Key (relationship + details)"
    },
    "gsi1": {
        "GSI1PK": "For alternate access patterns",
        "GSI1SK": "Enable range queries"
    }
}

# Step 3: Define Key Patterns
key_patterns = {
    "Customer": {
        "PK": "CUSTOMER#<customer_id>",
        "SK": "PROFILE"
    },
    "Order": {
        "PK": "CUSTOMER#<customer_id>",
        "SK": "ORDER#<date>#<order_id>",
        "GSI1PK": "STATUS#<status>",
        "GSI1SK": "<date>#<order_id>"
    },
    "OrderItem": {
        "PK": "ORDER#<order_id>",
        "SK": "ITEM#<item_number>"
    }
}
```

---

## Secondary Indexes

### Global Secondary Index (GSI)

<Frame>
  <img src="/images/aws/dynamodb-gsi.svg" alt="DynamoDB GSI" />
</Frame>

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Global Secondary Index (GSI)                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚   â€¢ Different partition key and/or sort key from base table            â”‚
â”‚   â€¢ Separate throughput capacity (own RCU/WCU)                         â”‚
â”‚   â€¢ Can be created/deleted anytime                                      â”‚
â”‚   â€¢ Eventually consistent reads only                                    â”‚
â”‚   â€¢ Maximum 20 GSIs per table                                          â”‚
â”‚                                                                         â”‚
â”‚   BASE TABLE                           GSI: StatusDateIndex            â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚   PK: CUSTOMER#C001                    GSI-PK: STATUS#pending          â”‚
â”‚   SK: ORDER#2024-01-15#O001            GSI-SK: 2024-01-15#O001         â”‚
â”‚   status: pending                      customer_id: C001               â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                         â”‚
â”‚   Use Case: "Find all pending orders sorted by date"                   â”‚
â”‚   Query: GSI-PK = "STATUS#pending", GSI-SK > "2024-01-01"              â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Local Secondary Index (LSI)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Local Secondary Index (LSI)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚   â€¢ Same partition key, different sort key                             â”‚
â”‚   â€¢ Shares throughput with base table                                  â”‚
â”‚   â€¢ Must be created at table creation time                             â”‚
â”‚   â€¢ Strongly consistent reads available                                â”‚
â”‚   â€¢ Maximum 5 LSIs per table                                           â”‚
â”‚   â€¢ 10 GB limit per partition (includes all LSIs)                      â”‚
â”‚                                                                         â”‚
â”‚   BASE TABLE                           LSI: AmountIndex                â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚   PK: CUSTOMER#C001                    PK: CUSTOMER#C001 (same)        â”‚
â”‚   SK: ORDER#2024-01-15#O001            LSI-SK: 99.99 (amount)          â”‚
â”‚   amount: 99.99                        order_id: O001                  â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                         â”‚
â”‚   Use Case: "Get customer's highest-value orders"                      â”‚
â”‚   Query: PK = "CUSTOMER#C001", ordered by amount (descending)          â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### GSI vs LSI Comparison

| Feature | GSI | LSI |
|---------|-----|-----|
| **Partition Key** | Different from base table | Same as base table |
| **Sort Key** | Different from base table | Different from base table |
| **Capacity** | Separate RCU/WCU | Shared with base table |
| **Creation** | Anytime | Table creation only |
| **Consistency** | Eventually consistent only | Strong or eventual |
| **Limit** | 20 per table | 5 per table |
| **Size Limit** | None | 10 GB per partition |

---

## Capacity Modes

### On-Demand vs Provisioned

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Capacity Mode Comparison                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚   ON-DEMAND MODE                        PROVISIONED MODE               â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€               â”‚
â”‚                                                                         â”‚
â”‚   âœ“ Pay per request                     âœ“ Pay per capacity unit/hour   â”‚
â”‚   âœ“ Auto-scales instantly               âœ“ Reserve capacity (cheaper)   â”‚
â”‚   âœ“ No capacity planning                âœ“ Predictable costs            â”‚
â”‚   âœ“ No throttling (mostly)              âœ“ Auto Scaling available       â”‚
â”‚                                                                         â”‚
â”‚   Best For:                             Best For:                      â”‚
â”‚   â€¢ Unpredictable traffic               â€¢ Predictable, steady traffic  â”‚
â”‚   â€¢ New applications                    â€¢ Cost optimization            â”‚
â”‚   â€¢ Spiky workloads                     â€¢ High-volume applications     â”‚
â”‚   â€¢ Dev/test environments               â€¢ Reserved capacity discount   â”‚
â”‚                                                                         â”‚
â”‚   Pricing (us-east-1):                  Pricing (us-east-1):           â”‚
â”‚   â€¢ $1.25 per million WRU               â€¢ $0.00065 per WCU/hour        â”‚
â”‚   â€¢ $0.25 per million RRU               â€¢ $0.00013 per RCU/hour        â”‚
â”‚                                                                         â”‚
â”‚   Cost Example (1M writes/day):                                        â”‚
â”‚   On-Demand: $1.25/day = $37.50/month                                  â”‚
â”‚   Provisioned: ~12 WCU = $5.62/month (84% savings)                     â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Capacity Units Explained

```python
# Read Capacity Units (RCU)
# 1 RCU = 1 strongly consistent read per second for item up to 4 KB
# 1 RCU = 2 eventually consistent reads per second for item up to 4 KB

def calculate_rcu(item_size_kb: float, reads_per_second: int, 
                  consistent: bool = False) -> int:
    """Calculate required RCUs."""
    # Round up to nearest 4 KB
    size_units = math.ceil(item_size_kb / 4)
    
    if consistent:
        return size_units * reads_per_second
    else:  # Eventually consistent
        return math.ceil(size_units * reads_per_second / 2)

# Write Capacity Units (WCU)
# 1 WCU = 1 write per second for item up to 1 KB

def calculate_wcu(item_size_kb: float, writes_per_second: int) -> int:
    """Calculate required WCUs."""
    # Round up to nearest 1 KB
    size_units = math.ceil(item_size_kb)
    return size_units * writes_per_second

# Examples
print(calculate_rcu(8, 100, consistent=True))   # 200 RCU
print(calculate_rcu(8, 100, consistent=False))  # 100 RCU
print(calculate_wcu(2.5, 50))                   # 150 WCU
```

---

## Operations

### Basic CRUD Operations

```python
import boto3
from boto3.dynamodb.conditions import Key, Attr

dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('EcommerceTable')

# CREATE - PutItem
def create_order(customer_id: str, order_id: str, amount: float):
    table.put_item(
        Item={
            'PK': f'CUSTOMER#{customer_id}',
            'SK': f'ORDER#{datetime.now().isoformat()}#{order_id}',
            'order_id': order_id,
            'customer_id': customer_id,
            'amount': Decimal(str(amount)),
            'status': 'PENDING',
            'created_at': datetime.now().isoformat()
        },
        ConditionExpression='attribute_not_exists(PK)'  # Prevent overwrite
    )

# READ - GetItem (single item, by primary key)
def get_customer(customer_id: str):
    response = table.get_item(
        Key={
            'PK': f'CUSTOMER#{customer_id}',
            'SK': 'PROFILE'
        },
        ConsistentRead=True  # Optional: strongly consistent read
    )
    return response.get('Item')

# READ - Query (multiple items, same partition)
def get_customer_orders(customer_id: str, limit: int = 20):
    response = table.query(
        KeyConditionExpression=Key('PK').eq(f'CUSTOMER#{customer_id}') & 
                              Key('SK').begins_with('ORDER#'),
        ScanIndexForward=False,  # Descending order
        Limit=limit
    )
    return response['Items']

# READ - Query with filter (filter applied AFTER read)
def get_pending_orders(customer_id: str):
    response = table.query(
        KeyConditionExpression=Key('PK').eq(f'CUSTOMER#{customer_id}') & 
                              Key('SK').begins_with('ORDER#'),
        FilterExpression=Attr('status').eq('PENDING')
    )
    return response['Items']

# UPDATE - UpdateItem
def update_order_status(customer_id: str, sk: str, new_status: str):
    response = table.update_item(
        Key={'PK': f'CUSTOMER#{customer_id}', 'SK': sk},
        UpdateExpression='SET #status = :status, updated_at = :updated',
        ExpressionAttributeNames={'#status': 'status'},  # 'status' is reserved
        ExpressionAttributeValues={
            ':status': new_status,
            ':updated': datetime.now().isoformat()
        },
        ConditionExpression='attribute_exists(PK)',  # Ensure item exists
        ReturnValues='ALL_NEW'
    )
    return response['Attributes']

# DELETE - DeleteItem
def delete_order(customer_id: str, sk: str):
    table.delete_item(
        Key={'PK': f'CUSTOMER#{customer_id}', 'SK': sk},
        ConditionExpression='#status <> :completed',
        ExpressionAttributeNames={'#status': 'status'},
        ExpressionAttributeValues={':completed': 'COMPLETED'}
    )
```

### Batch Operations

```python
# BatchWriteItem - Up to 25 items, 16 MB max
def batch_create_items(items: list):
    with table.batch_writer() as batch:
        for item in items:
            batch.put_item(Item=item)
    # Handles retries for unprocessed items automatically

# BatchGetItem - Up to 100 items, 16 MB max
def batch_get_customers(customer_ids: list):
    keys = [
        {'PK': f'CUSTOMER#{cid}', 'SK': 'PROFILE'}
        for cid in customer_ids
    ]
    
    response = dynamodb.batch_get_item(
        RequestItems={
            'EcommerceTable': {
                'Keys': keys,
                'ProjectionExpression': 'customer_id, #name, email',
                'ExpressionAttributeNames': {'#name': 'name'}
            }
        }
    )
    return response['Responses']['EcommerceTable']
```

---

## Transactions

DynamoDB supports ACID transactions across multiple items and tables.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DynamoDB Transactions                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚   TransactWriteItems:                                                   â”‚
â”‚   â€¢ Up to 100 items per transaction                                    â”‚
â”‚   â€¢ All-or-nothing execution                                           â”‚
â”‚   â€¢ Supported actions: Put, Update, Delete, ConditionCheck             â”‚
â”‚                                                                         â”‚
â”‚   TransactGetItems:                                                     â”‚
â”‚   â€¢ Up to 100 items per transaction                                    â”‚
â”‚   â€¢ Serializable isolation                                             â”‚
â”‚                                                                         â”‚
â”‚   Cost: 2x the cost of standard writes (for durability)                â”‚
â”‚                                                                         â”‚
â”‚   Example: Transfer funds between accounts                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚  Transaction:                                                    â”‚  â”‚
â”‚   â”‚  1. Check source balance >= amount (ConditionCheck)             â”‚  â”‚
â”‚   â”‚  2. Deduct from source account (Update)                         â”‚  â”‚
â”‚   â”‚  3. Add to destination account (Update)                         â”‚  â”‚
â”‚   â”‚  4. Create transfer record (Put)                                â”‚  â”‚
â”‚   â”‚                                                                  â”‚  â”‚
â”‚   â”‚  All succeed â†’ Committed                                        â”‚  â”‚
â”‚   â”‚  Any fails â†’ All rolled back                                    â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```python
from boto3.dynamodb.types import TypeSerializer
from decimal import Decimal

def transfer_funds(source_id: str, dest_id: str, amount: Decimal):
    """Transfer funds atomically between accounts."""
    
    client = boto3.client('dynamodb')
    serializer = TypeSerializer()
    
    response = client.transact_write_items(
        TransactItems=[
            # 1. Condition check: source has sufficient balance
            {
                'ConditionCheck': {
                    'TableName': 'Accounts',
                    'Key': {
                        'PK': {'S': f'ACCOUNT#{source_id}'},
                        'SK': {'S': 'BALANCE'}
                    },
                    'ConditionExpression': 'balance >= :amount',
                    'ExpressionAttributeValues': {
                        ':amount': serializer.serialize(amount)
                    }
                }
            },
            # 2. Deduct from source
            {
                'Update': {
                    'TableName': 'Accounts',
                    'Key': {
                        'PK': {'S': f'ACCOUNT#{source_id}'},
                        'SK': {'S': 'BALANCE'}
                    },
                    'UpdateExpression': 'SET balance = balance - :amount',
                    'ExpressionAttributeValues': {
                        ':amount': serializer.serialize(amount)
                    }
                }
            },
            # 3. Add to destination
            {
                'Update': {
                    'TableName': 'Accounts',
                    'Key': {
                        'PK': {'S': f'ACCOUNT#{dest_id}'},
                        'SK': {'S': 'BALANCE'}
                    },
                    'UpdateExpression': 'SET balance = balance + :amount',
                    'ExpressionAttributeValues': {
                        ':amount': serializer.serialize(amount)
                    }
                }
            },
            # 4. Record the transfer
            {
                'Put': {
                    'TableName': 'Transfers',
                    'Item': {
                        'PK': {'S': f'TRANSFER#{uuid.uuid4()}'},
                        'SK': {'S': datetime.now().isoformat()},
                        'source': {'S': source_id},
                        'destination': {'S': dest_id},
                        'amount': serializer.serialize(amount),
                        'status': {'S': 'COMPLETED'}
                    }
                }
            }
        ]
    )
    return response
```

---

## DynamoDB Accelerator (DAX)

<Frame>
  <img src="/images/aws/dax-architecture.svg" alt="DAX Architecture" />
</Frame>

DAX is an in-memory cache for DynamoDB, providing microsecond response times.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DAX (DynamoDB Accelerator)                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚   Application â”€â”€â–º DAX Cluster â”€â”€â–º DynamoDB                             â”‚
â”‚                      â”‚                                                  â”‚
â”‚                      â””â”€â”€ In-memory cache                               â”‚
â”‚                          (microsecond latency)                         â”‚
â”‚                                                                         â”‚
â”‚   Cache Types:                                                          â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                          â”‚
â”‚   â€¢ Item Cache: Individual GetItem results (5-min default TTL)         â”‚
â”‚   â€¢ Query Cache: Query/Scan results (5-min default TTL)                â”‚
â”‚                                                                         â”‚
â”‚   Performance:                                                          â”‚
â”‚   â€¢ DynamoDB: 1-10 milliseconds                                        â”‚
â”‚   â€¢ DAX: ~400 microseconds (up to 10x faster)                          â”‚
â”‚                                                                         â”‚
â”‚   When to Use:                                                          â”‚
â”‚   âœ“ Read-heavy workloads                                               â”‚
â”‚   âœ“ Same items read repeatedly                                          â”‚
â”‚   âœ“ Microsecond response time required                                 â”‚
â”‚   âœ— Write-heavy workloads (no benefit)                                 â”‚
â”‚   âœ— Strongly consistent reads required                                 â”‚
â”‚                                                                         â”‚
â”‚   Pricing:                                                              â”‚
â”‚   â€¢ dax.r5.large: ~$0.269/hour (~$194/month)                           â”‚
â”‚   â€¢ Minimum 3 nodes for production (multi-AZ)                          â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```python
# Using DAX (drop-in replacement for DynamoDB)
import amazondax
import boto3

# Create DAX client (same API as boto3 DynamoDB resource)
dax_endpoint = 'my-dax-cluster.abc123.dax-clusters.us-east-1.amazonaws.com:8111'
dax = amazondax.AmazonDaxClient.resource(endpoint_url=dax_endpoint)
table = dax.Table('EcommerceTable')

# Use exactly like DynamoDB
response = table.get_item(
    Key={'PK': 'CUSTOMER#C001', 'SK': 'PROFILE'}
)
# First call: ~1ms (cache miss, hits DynamoDB)
# Subsequent calls: ~0.4ms (cache hit)
```

---

## DynamoDB Streams

Capture item-level changes for event-driven architectures.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DynamoDB Streams                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚   DynamoDB Table â”€â”€â–º Stream â”€â”€â–º Lambda / Kinesis / Application         â”‚
â”‚                                                                         â”‚
â”‚   Stream Record Types:                                                  â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                  â”‚
â”‚   â€¢ KEYS_ONLY: Only partition and sort key                             â”‚
â”‚   â€¢ NEW_IMAGE: Entire item after modification                          â”‚
â”‚   â€¢ OLD_IMAGE: Entire item before modification                         â”‚
â”‚   â€¢ NEW_AND_OLD_IMAGES: Both before and after                          â”‚
â”‚                                                                         â”‚
â”‚   Use Cases:                                                            â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                          â”‚
â”‚   â€¢ Real-time analytics                                                â”‚
â”‚   â€¢ Cross-region replication                                           â”‚
â”‚   â€¢ Materialized views                                                 â”‚
â”‚   â€¢ Search index synchronization (OpenSearch)                          â”‚
â”‚   â€¢ Audit logging                                                      â”‚
â”‚   â€¢ Event-driven workflows                                             â”‚
â”‚                                                                         â”‚
â”‚   Retention: 24 hours                                                  â”‚
â”‚   Ordering: Per-partition ordering guaranteed                          â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```python
# Lambda function processing DynamoDB Stream
def lambda_handler(event, context):
    for record in event['Records']:
        event_name = record['eventName']  # INSERT, MODIFY, REMOVE
        
        if event_name == 'INSERT':
            new_item = record['dynamodb']['NewImage']
            # Process new item
            print(f"New item: {new_item}")
            
        elif event_name == 'MODIFY':
            old_item = record['dynamodb']['OldImage']
            new_item = record['dynamodb']['NewImage']
            # Compare and process changes
            print(f"Modified: {old_item} -> {new_item}")
            
        elif event_name == 'REMOVE':
            old_item = record['dynamodb']['OldImage']
            # Handle deletion
            print(f"Deleted: {old_item}")
    
    return {'statusCode': 200}
```

---

## Best Practices

### Performance Optimization

<CardGroup cols={2}>
  <Card title="Even Key Distribution" icon="chart-pie">
    Use high-cardinality partition keys to avoid hot partitions
  </Card>
  <Card title="Sparse Indexes" icon="filter">
    Only include items with indexed attributes in GSIs
  </Card>
  <Card title="Projection Carefully" icon="list">
    Only project needed attributes to GSIs (reduce WCU)
  </Card>
  <Card title="Use BatchGetItem" icon="layer-group">
    Batch reads instead of multiple GetItem calls
  </Card>
</CardGroup>

### Cost Optimization

```python
cost_tips = {
    "capacity_mode": [
        "Use On-Demand for unpredictable workloads",
        "Use Provisioned with Auto Scaling for steady traffic",
        "Use Reserved Capacity for 77% savings on provisioned",
    ],
    "data_modeling": [
        "Use single-table design to reduce table count",
        "Project only needed attributes to GSIs",
        "Use sparse GSIs (items without attributes aren't indexed)",
    ],
    "operations": [
        "Use eventually consistent reads (50% cheaper)",
        "Batch operations to reduce request overhead",
        "Enable TTL for auto-expiring data (free deletions)",
    ],
    "storage": [
        "Compress large attributes before storing",
        "Use S3 for objects > 400 KB, store reference in DynamoDB",
        "Delete unused GSIs",
    ]
}
```

---

## ğŸ¯ Interview Questions

<AccordionGroup>
  <Accordion title="Q1: When would you choose DynamoDB over RDS?">
    **Choose DynamoDB when:**
    - Predictable, single-digit millisecond latency at any scale
    - Simple access patterns (key-value or document)
    - Massive scale requirements (millions of requests/second)
    - Serverless architecture
    - Global distribution needed (Global Tables)
    
    **Choose RDS when:**
    - Complex queries with JOINs
    - Strong ACID requirements across tables
    - Existing SQL skills/codebase
    - Complex reporting needs
  </Accordion>
  
  <Accordion title="Q2: How do you handle hot partitions?">
    **Prevention strategies:**
    1. Use high-cardinality partition keys
    2. Add random suffix (write sharding)
    3. Use composite keys to distribute writes
    
    **Example - Order ID with random suffix:**
    ```python
    # Instead of: ORDER#12345
    # Use: ORDER#12345#7 (random 0-9)
    ```
    
    **When reading, query all shards in parallel and merge results.**
  </Accordion>
  
  <Accordion title="Q3: Explain GSI vs LSI trade-offs">
    **GSI:**
    - Flexible (any partition/sort key)
    - Own capacity (no throttling impact on base table)
    - Eventually consistent only
    - Can be added/removed anytime
    
    **LSI:**
    - Must share partition key with base table
    - Shares capacity (can throttle base table)
    - Strongly consistent available
    - Must be defined at table creation
    - 10 GB partition limit
    
    **Recommendation:** Prefer GSIs unless you need strongly consistent reads on alternate sort key.
  </Accordion>
  
  <Accordion title="Q4: How do you implement pagination in DynamoDB?">
    ```python
    def paginated_query(table, pk_value, page_size=20, last_key=None):
        params = {
            'KeyConditionExpression': Key('PK').eq(pk_value),
            'Limit': page_size
        }
        
        if last_key:
            params['ExclusiveStartKey'] = last_key
        
        response = table.query(**params)
        
        return {
            'items': response['Items'],
            'last_key': response.get('LastEvaluatedKey')  # None if no more pages
        }
    ```
    
    **Key points:**
    - Use `Limit` for page size
    - Use `ExclusiveStartKey` for continuation
    - `LastEvaluatedKey` indicates more pages exist
  </Accordion>
  
  <Accordion title="Q5: Design a DynamoDB schema for a social media app">
    **Access patterns:**
    - Get user profile
    - Get user's posts
    - Get user's followers
    - Get user's following
    - Get feed (posts from following)
    
    **Single-table design:**
    ```
    PK                  | SK                  | Data
    --------------------|---------------------|------------------
    USER#alice          | PROFILE             | {name, bio, ...}
    USER#alice          | POST#2024-01-15#001 | {content, likes}
    USER#alice          | FOLLOWER#bob        | {followed_at}
    USER#alice          | FOLLOWING#charlie   | {followed_at}
    
    GSI1:
    GSI1PK              | GSI1SK              | For
    --------------------|---------------------|------------------
    FOLLOWING#charlie   | 2024-01-15#POST#001 | Feed aggregation
    ```
  </Accordion>
</AccordionGroup>

---

## ğŸ§ª Hands-On Lab

<Steps>
  <Step title="Create DynamoDB Table">
    Create a table with composite primary key and enable Streams
  </Step>
  
  <Step title="Implement Single-Table Design">
    Model users, orders, and order items in a single table
  </Step>
  
  <Step title="Create GSI">
    Add a GSI for querying orders by status
  </Step>
  
  <Step title="Implement Transactions">
    Build an atomic order placement with inventory check
  </Step>
  
  <Step title="Process Streams">
    Create Lambda to process DynamoDB Streams for real-time updates
  </Step>
</Steps>

---

## Next Module

<Card title="AWS Lambda" icon="bolt" href="/aws/lambda">
  Master serverless compute with AWS Lambda
</Card>
