---
title: "Case Study: Serverless URL Shortener"
description: "Build a production-ready serverless application with Lambda, API Gateway, and DynamoDB"
icon: "bolt"
---

## Project Overview

<Info>
**Estimated Time**: 2-3 hours | **Difficulty**: Intermediate | **Cost**: ~$5/month for testing
</Info>

In this hands-on project, you'll build a complete serverless URL shortener service. This is a common system design interview question and demonstrates key serverless patterns.

**What You'll Build:**
- REST API with API Gateway
- Lambda functions for business logic
- DynamoDB for data persistence
- CloudFront for caching and performance
- Complete observability with CloudWatch and X-Ray

**Skills Demonstrated:**
- Serverless architecture design
- DynamoDB data modeling
- API design and implementation
- Cost optimization
- Production-ready practices

## Architecture Overview

Let's design a serverless web application for a URL shortener service.

### Requirements

- Handle 10,000+ requests per second
- Sub-100ms latency
- 99.9% availability
- Pay only for actual usage
- Auto-scaling without management

### High-Level Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Serverless URL Shortener                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚   User                                                              â”‚
â”‚     â”‚                                                               â”‚
â”‚     â”‚  1. POST /shorten                                             â”‚
â”‚     â”‚  2. GET /abc123                                               â”‚
â”‚     â–¼                                                               â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚                      CloudFront                              â”‚  â”‚
â”‚   â”‚              (CDN + Edge Caching)                            â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                             â”‚                                       â”‚
â”‚                             â–¼                                       â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚                     API Gateway                              â”‚  â”‚
â”‚   â”‚              (REST API + Throttling)                         â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                             â”‚                                       â”‚
â”‚             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚             â”‚               â”‚               â”‚                      â”‚
â”‚             â–¼               â–¼               â–¼                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚   â”‚ Lambda: Create  â”‚ â”‚ Lambda:     â”‚ â”‚ Lambda:         â”‚         â”‚
â”‚   â”‚ Short URL       â”‚ â”‚ Redirect    â”‚ â”‚ Analytics       â”‚         â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚            â”‚                 â”‚                  â”‚                   â”‚
â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                              â”‚                                      â”‚
â”‚                              â–¼                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚                      DynamoDB                                â”‚  â”‚
â”‚   â”‚                  (URL Mappings Table)                        â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Implementation

### 1. DynamoDB Table Design

```python
# Table: url-shortener
# Partition Key: short_code (String)
# No Sort Key needed

table_schema = {
    "TableName": "url-shortener",
    "KeySchema": [
        {"AttributeName": "short_code", "KeyType": "HASH"}
    ],
    "AttributeDefinitions": [
        {"AttributeName": "short_code", "AttributeType": "S"}
    ],
    "BillingMode": "PAY_PER_REQUEST",  # Auto-scaling
    "TimeToLiveSpecification": {
        "AttributeName": "expires_at",
        "Enabled": True
    }
}

# Item structure
item = {
    "short_code": "abc123",
    "long_url": "https://example.com/very/long/url/path",
    "created_at": "2024-01-15T10:00:00Z",
    "expires_at": 1705312800,  # TTL epoch
    "click_count": 0,
    "user_id": "user_456"  # Optional
}
```

### 2. Lambda: Create Short URL

```python
import json
import boto3
import hashlib
import time

dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('url-shortener')

def generate_short_code(url: str) -> str:
    """Generate 6-character short code from URL hash."""
    hash_object = hashlib.sha256(f"{url}{time.time()}".encode())
    return hash_object.hexdigest()[:6]

def lambda_handler(event, context):
    try:
        body = json.loads(event['body'])
        long_url = body['url']
        
        # Validate URL
        if not long_url.startswith(('http://', 'https://')):
            return {
                'statusCode': 400,
                'body': json.dumps({'error': 'Invalid URL'})
            }
        
        # Generate short code
        short_code = generate_short_code(long_url)
        
        # Store in DynamoDB
        table.put_item(Item={
            'short_code': short_code,
            'long_url': long_url,
            'created_at': int(time.time()),
            'click_count': 0
        })
        
        short_url = f"https://short.ly/{short_code}"
        
        return {
            'statusCode': 201,
            'headers': {'Content-Type': 'application/json'},
            'body': json.dumps({
                'short_url': short_url,
                'short_code': short_code
            })
        }
        
    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'error': str(e)})
        }
```

### 3. Lambda: Redirect

```python
import json
import boto3

dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('url-shortener')

def lambda_handler(event, context):
    short_code = event['pathParameters']['code']
    
    # Get URL from DynamoDB
    response = table.get_item(Key={'short_code': short_code})
    
    if 'Item' not in response:
        return {
            'statusCode': 404,
            'body': json.dumps({'error': 'URL not found'})
        }
    
    long_url = response['Item']['long_url']
    
    # Increment click count (async would be better)
    table.update_item(
        Key={'short_code': short_code},
        UpdateExpression='ADD click_count :inc',
        ExpressionAttributeValues={':inc': 1}
    )
    
    # Return 301 redirect
    return {
        'statusCode': 301,
        'headers': {
            'Location': long_url,
            'Cache-Control': 'max-age=300'  # Cache redirect for 5 min
        }
    }
```

### 4. API Gateway Configuration

```yaml
# serverless.yml (Serverless Framework)
service: url-shortener

provider:
  name: aws
  runtime: python3.11
  region: us-east-1
  
  iam:
    role:
      statements:
        - Effect: Allow
          Action:
            - dynamodb:GetItem
            - dynamodb:PutItem
            - dynamodb:UpdateItem
          Resource: !GetAtt UrlTable.Arn

functions:
  createUrl:
    handler: handlers.create_url
    events:
      - http:
          path: /shorten
          method: post
          cors: true

  redirect:
    handler: handlers.redirect
    events:
      - http:
          path: /{code}
          method: get

resources:
  Resources:
    UrlTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: url-shortener
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: short_code
            AttributeType: S
        KeySchema:
          - AttributeName: short_code
            KeyType: HASH
```

---

## Scaling Considerations

### API Gateway Limits

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    API Gateway Throttling                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚   Default Limits (per region):                                  â”‚
â”‚   â€¢ 10,000 requests/second                                      â”‚
â”‚   â€¢ 5,000 concurrent requests                                   â”‚
â”‚                                                                 â”‚
â”‚   Can request increase for high-traffic apps                    â”‚
â”‚                                                                 â”‚
â”‚   Throttling Strategies:                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚  1. Usage Plans - Per-API key limits                     â”‚  â”‚
â”‚   â”‚  2. Stage throttling - Per-stage limits                  â”‚  â”‚
â”‚   â”‚  3. Method throttling - Per-endpoint limits              â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Lambda Concurrency

```python
# Lambda scales automatically
# Default: 1000 concurrent executions per region

# Reserved concurrency - Guarantee capacity
# Provisioned concurrency - Eliminate cold starts

concurrency_config = {
    "redirect_function": {
        "reserved_concurrency": 500,  # Guarantee 500 concurrent
        "provisioned_concurrency": 100  # Pre-warmed instances
    }
}
```

### DynamoDB Capacity

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  DynamoDB Scaling                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚   On-Demand Mode:                                               â”‚
â”‚   â€¢ Auto-scales instantly                                       â”‚
â”‚   â€¢ Pay per request                                             â”‚
â”‚   â€¢ Best for unpredictable traffic                              â”‚
â”‚                                                                 â”‚
â”‚   Provisioned Mode:                                             â”‚
â”‚   â€¢ Set RCU/WCU capacity                                        â”‚
â”‚   â€¢ Auto-scaling available                                      â”‚
â”‚   â€¢ Better for predictable traffic                              â”‚
â”‚                                                                 â”‚
â”‚   DAX (DynamoDB Accelerator):                                   â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚   â”‚  Lambda  â”‚ â”€â”€â”€â–º â”‚   DAX    â”‚ â”€â”€â”€â–º â”‚ DynamoDB â”‚             â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚ (cache)  â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â”‚   â€¢ Microsecond latency                                         â”‚
â”‚   â€¢ 10x read performance                                        â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Cost Analysis

```python
# Monthly cost estimate for 10M requests/month

costs = {
    "api_gateway": {
        "requests": 10_000_000,
        "cost_per_million": 3.50,
        "total": 35.00  # $35
    },
    "lambda": {
        "requests": 10_000_000,
        "avg_duration_ms": 50,
        "memory_mb": 128,
        "gb_seconds": 10_000_000 * 0.050 * (128/1024),
        "compute_cost": 6.25,  # ~$0.0000166667 per GB-second
        "request_cost": 2.00,  # $0.20 per million
        "total": 8.25  # $8.25
    },
    "dynamodb": {
        "writes": 1_000_000,  # 10% create new
        "reads": 10_000_000,
        "write_cost": 1.25,  # $1.25 per million WRU
        "read_cost": 0.25,   # $0.25 per million RRU
        "storage_gb": 1,
        "storage_cost": 0.25,
        "total": 1.75  # $1.75
    },
    "cloudfront": {
        "requests": 10_000_000,
        "data_transfer_gb": 10,
        "total": 10.00  # ~$10
    },
    "total_monthly": 55.00  # ~$55/month for 10M requests
}
```

---

## Monitoring & Observability

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Monitoring Stack                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚   CloudWatch Metrics                                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚  â€¢ Lambda: Invocations, Duration, Errors, Throttles      â”‚  â”‚
â”‚   â”‚  â€¢ API GW: Count, Latency, 4XX, 5XX                      â”‚  â”‚
â”‚   â”‚  â€¢ DynamoDB: ConsumedRCU, ConsumedWCU, Throttles         â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                 â”‚
â”‚   CloudWatch Alarms                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚  â€¢ Lambda errors > 1% â†’ Alert                            â”‚  â”‚
â”‚   â”‚  â€¢ API Gateway 5XX > 0.1% â†’ Alert                        â”‚  â”‚
â”‚   â”‚  â€¢ DynamoDB throttling â†’ Alert                           â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                 â”‚
â”‚   X-Ray Tracing                                                 â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚  API GW â†’ Lambda â†’ DynamoDB                              â”‚  â”‚
â”‚   â”‚  End-to-end latency visualization                        â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Security Considerations

<CardGroup cols={2}>
  <Card title="API Gateway" icon="shield">
    - WAF integration
    - API keys for rate limiting
    - Request validation
  </Card>
  <Card title="Lambda" icon="lock">
    - Least privilege IAM
    - VPC for private resources
    - Secrets in Secrets Manager
  </Card>
  <Card title="DynamoDB" icon="database">
    - Encryption at rest
    - IAM for access control
    - VPC endpoints
  </Card>
  <Card title="CloudFront" icon="globe">
    - HTTPS only
    - Geo-restrictions if needed
    - Origin Access Identity
  </Card>
</CardGroup>

<Tip>
**Key Takeaway**: Serverless architectures eliminate server management, scale automatically, and cost effectively for variable workloads. Start simple and add complexity (caching, analytics) as needed.
</Tip>

---

## ğŸ¯ Interview Questions for This Case Study

<AccordionGroup>
  <Accordion title="Q1: Why use serverless for a URL shortener?">
    **Advantages:**
    - Variable traffic (pay for actual usage)
    - No server management
    - Auto-scales from 0 to millions
    - Quick time to market
    
    **Trade-offs:**
    - Cold start latency (mitigate with provisioned concurrency)
    - 15-minute function limit (not an issue here)
    - Vendor lock-in
    
    **When NOT serverless:**
    - Predictable, constant high traffic (EC2 cheaper)
    - Long-running processes
    - WebSocket-heavy (API Gateway WS works but pricey)
  </Accordion>
  
  <Accordion title="Q2: How would you handle 1 million concurrent users?">
    **Scaling strategy:**
    
    1. **CloudFront**: Cache redirects at edge
       - 301 with Cache-Control: max-age=300
       - 80%+ cache hit ratio
    
    2. **API Gateway**: Request higher limits
       - Default 10K/sec is usually enough
    
    3. **Lambda**: Reserved concurrency
       - Set to expected peak (e.g., 5000)
    
    4. **DynamoDB**: On-demand mode handles spikes
       - Add DAX for microsecond reads
    
    5. **Monitoring**: Alarms before hitting limits
  </Accordion>
  
  <Accordion title="Q3: How would you prevent abuse?">
    **Defense layers:**
    
    1. **Rate limiting**: API Gateway usage plans
       ```yaml
       usagePlan:
         quota:
           limit: 1000
           period: DAY
         throttle:
           burstLimit: 50
           rateLimit: 10
       ```
    
    2. **WAF**: Block malicious IPs, SQL injection
    
    3. **CAPTCHA**: For create endpoint
    
    4. **URL validation**: Block malicious targets
    
    5. **User authentication**: Cognito for premium features
  </Accordion>
  
  <Accordion title="Q4: How would you add analytics?">
    **Async analytics pipeline:**
    
    ```
    Lambda â†’ Kinesis Data Firehose â†’ S3 â†’ Athena
    ```
    
    1. Log click events to Kinesis (async, non-blocking)
    2. Firehose batches to S3 every 60 seconds
    3. Query with Athena for dashboards
    
    **Metrics to track:**
    - Click count per URL
    - Geographic distribution
    - Referrer analysis
    - Time-based patterns
  </Accordion>
  
  <Accordion title="Q5: What's the total cost at scale?">
    **Cost breakdown at 100M requests/month:**
    
    | Service | Cost |
    |---------|------|
    | API Gateway | $350 |
    | Lambda | $83 |
    | DynamoDB | $35 |
    | CloudFront | $85 |
    | **Total** | **~$550/month** |
    
    **Optimization opportunities:**
    - CloudFront caching (reduces Lambda calls 80%)
    - Reserved concurrency (predictable billing)
    - DynamoDB provisioned (if traffic predictable)
  </Accordion>
</AccordionGroup>

---

## ğŸ§ª Hands-On Implementation Steps

<Steps>
  <Step title="Create DynamoDB Table">
    Create table with on-demand billing and TTL enabled
  </Step>
  
  <Step title="Create Lambda Functions">
    Deploy create and redirect functions with proper IAM roles
  </Step>
  
  <Step title="Set Up API Gateway">
    Create REST API with two endpoints, deploy to prod stage
  </Step>
  
  <Step title="Add CloudFront Distribution">
    Point to API Gateway, configure caching
  </Step>
  
  <Step title="Configure Monitoring">
    Set up CloudWatch alarms and X-Ray tracing
  </Step>
  
  <Step title="Test Load">
    Use Artillery or hey to test performance
  </Step>
</Steps>

---

## Course Complete! ğŸ‰

Congratulations on completing the AWS Cloud Fundamentals course! You've learned:

- âœ… AWS core concepts and regions
- âœ… Compute services (EC2, Lambda, ECS)
- âœ… Storage and databases (S3, RDS, DynamoDB)
- âœ… Networking (VPC, security groups, load balancers)
- âœ… Security (IAM, KMS, encryption)
- âœ… Well-Architected Framework
- âœ… Real-world serverless architecture

**Next Steps:**
1. Practice with hands-on labs
2. Build your own projects
3. Prepare for AWS certification
4. Review interview questions regularly

<Card title="Return to Course Overview" icon="house" href="/aws/overview">
  Review the complete curriculum and resources
</Card>
