---
title: "Messaging & Integration"
description: "Master SQS, SNS, EventBridge, and event-driven architecture patterns"
icon: "arrows-split-up-and-left"
---

## Module Overview

<Info>
**Estimated Time**: 4-5 hours | **Difficulty**: Intermediate-Advanced | **Prerequisites**: Compute, Networking
</Info>

Event-driven architectures enable loose coupling, scalability, and resilience. This module covers AWS messaging and integration services for building modern distributed systems.

**What You'll Learn:**
- SQS queues and message processing patterns
- SNS pub/sub and fan-out architectures
- EventBridge for event-driven applications
- Step Functions for workflow orchestration
- API Gateway advanced patterns
- Choosing the right integration pattern

---

## Integration Patterns Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    AWS Integration Services                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚   SQS (Simple Queue Service)                                           â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                         â”‚
â”‚   â€¢ Point-to-point messaging                                           â”‚
â”‚   â€¢ Decouple producers from consumers                                  â”‚
â”‚   â€¢ Buffer for traffic spikes                                          â”‚
â”‚   â€¢ Guaranteed delivery                                                 â”‚
â”‚                                                                         â”‚
â”‚   SNS (Simple Notification Service)                                    â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                   â”‚
â”‚   â€¢ Pub/sub messaging                                                  â”‚
â”‚   â€¢ Fan-out to multiple subscribers                                    â”‚
â”‚   â€¢ Push-based delivery                                                â”‚
â”‚   â€¢ Mobile push, email, SMS, HTTP                                      â”‚
â”‚                                                                         â”‚
â”‚   EventBridge                                                           â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                         â”‚
â”‚   â€¢ Event bus for event-driven apps                                    â”‚
â”‚   â€¢ Content-based filtering                                            â”‚
â”‚   â€¢ 200+ AWS service integrations                                      â”‚
â”‚   â€¢ Schema registry                                                     â”‚
â”‚                                                                         â”‚
â”‚   Step Functions                                                        â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                         â”‚
â”‚   â€¢ Workflow orchestration                                              â”‚
â”‚   â€¢ Visual workflow designer                                           â”‚
â”‚   â€¢ Error handling & retries                                            â”‚
â”‚   â€¢ Long-running processes                                              â”‚
â”‚                                                                         â”‚
â”‚   API Gateway                                                           â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                         â”‚
â”‚   â€¢ REST & WebSocket APIs                                               â”‚
â”‚   â€¢ Request transformation                                              â”‚
â”‚   â€¢ Authorization & throttling                                          â”‚
â”‚   â€¢ Direct service integrations                                         â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## SQS Deep Dive

### Queue Types

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SQS Queue Types                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚   STANDARD QUEUE                  â”‚  FIFO QUEUE                        â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€              â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                â”‚
â”‚   â€¢ Unlimited throughput          â”‚  â€¢ 3,000 msg/sec (batching)       â”‚
â”‚   â€¢ At-least-once delivery        â”‚  â€¢ Exactly-once processing        â”‚
â”‚   â€¢ Best-effort ordering          â”‚  â€¢ Strict ordering                 â”‚
â”‚   â€¢ Lower cost                    â”‚  â€¢ Higher cost (~20% more)        â”‚
â”‚                                   â”‚  â€¢ Deduplication                   â”‚
â”‚                                                                         â”‚
â”‚   Use Standard for:               â”‚  Use FIFO for:                     â”‚
â”‚   â€¢ High throughput needs         â”‚  â€¢ Order-sensitive workflows       â”‚
â”‚   â€¢ Duplicate handling OK         â”‚  â€¢ Financial transactions          â”‚
â”‚   â€¢ General decoupling            â”‚  â€¢ Sequential processing           â”‚
â”‚                                                                         â”‚
â”‚   MESSAGE LIFECYCLE:                                                    â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚                                                                  â”‚  â”‚
â”‚   â”‚   Producer â”€â”€â–¶ Queue â”€â”€â–¶ Consumer â”€â”€â–¶ Delete                    â”‚  â”‚
â”‚   â”‚       â”‚          â”‚           â”‚                                   â”‚  â”‚
â”‚   â”‚       â”‚          â”‚           â–¼                                   â”‚  â”‚
â”‚   â”‚       â”‚          â”‚   Visibility Timeout                         â”‚  â”‚
â”‚   â”‚       â”‚          â”‚   (Message invisible                         â”‚  â”‚
â”‚   â”‚       â”‚          â”‚    while processing)                          â”‚  â”‚
â”‚   â”‚       â”‚          â”‚           â”‚                                   â”‚  â”‚
â”‚   â”‚       â”‚          â”‚           â–¼                                   â”‚  â”‚
â”‚   â”‚       â”‚          â”‚   Not deleted in time?                        â”‚  â”‚
â”‚   â”‚       â”‚          â”‚   Message reappears                           â”‚  â”‚
â”‚   â”‚       â”‚          â”‚           â”‚                                   â”‚  â”‚
â”‚   â”‚       â”‚          â–¼           â–¼                                   â”‚  â”‚
â”‚   â”‚       â”‚   Max receives exceeded â†’ Dead Letter Queue             â”‚  â”‚
â”‚   â”‚       â”‚                                                          â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### SQS Implementation

```python
import boto3
import json
from typing import List, Optional

sqs = boto3.client('sqs')

class SQSProcessor:
    def __init__(self, queue_url: str, dlq_url: Optional[str] = None):
        self.queue_url = queue_url
        self.dlq_url = dlq_url
    
    def send_message(self, body: dict, delay_seconds: int = 0, 
                     group_id: Optional[str] = None) -> str:
        """
        Send message to SQS queue.
        For FIFO queues, group_id is required for ordering.
        """
        params = {
            'QueueUrl': self.queue_url,
            'MessageBody': json.dumps(body),
            'DelaySeconds': delay_seconds
        }
        
        # FIFO queue parameters
        if group_id:
            params['MessageGroupId'] = group_id
            # Deduplication - use content-based or explicit ID
            params['MessageDeduplicationId'] = str(hash(json.dumps(body)))
        
        response = sqs.send_message(**params)
        return response['MessageId']
    
    def send_batch(self, messages: List[dict]) -> dict:
        """
        Send up to 10 messages in batch for efficiency.
        """
        entries = [
            {
                'Id': str(i),
                'MessageBody': json.dumps(msg['body']),
                'DelaySeconds': msg.get('delay', 0)
            }
            for i, msg in enumerate(messages)
        ]
        
        response = sqs.send_message_batch(
            QueueUrl=self.queue_url,
            Entries=entries
        )
        
        return {
            'successful': len(response.get('Successful', [])),
            'failed': response.get('Failed', [])
        }
    
    def receive_messages(self, max_messages: int = 10, 
                         wait_time: int = 20,
                         visibility_timeout: int = 30) -> List[dict]:
        """
        Long polling for efficient message retrieval.
        WaitTimeSeconds enables long polling (reduces API calls).
        """
        response = sqs.receive_message(
            QueueUrl=self.queue_url,
            MaxNumberOfMessages=min(max_messages, 10),  # Max is 10
            WaitTimeSeconds=wait_time,  # Long polling
            VisibilityTimeout=visibility_timeout,
            AttributeNames=['All'],
            MessageAttributeNames=['All']
        )
        
        return response.get('Messages', [])
    
    def process_message(self, message: dict) -> bool:
        """Process a single message. Return True if successful."""
        try:
            body = json.loads(message['Body'])
            
            # Your processing logic here
            print(f"Processing: {body}")
            
            # Delete message after successful processing
            sqs.delete_message(
                QueueUrl=self.queue_url,
                ReceiptHandle=message['ReceiptHandle']
            )
            return True
            
        except Exception as e:
            print(f"Error processing message: {e}")
            # Message will return to queue after visibility timeout
            return False
    
    def extend_visibility(self, receipt_handle: str, 
                          additional_seconds: int = 30):
        """
        Extend visibility timeout for long-running processing.
        Call this periodically for long tasks.
        """
        sqs.change_message_visibility(
            QueueUrl=self.queue_url,
            ReceiptHandle=receipt_handle,
            VisibilityTimeout=additional_seconds
        )
    
    def process_loop(self):
        """Continuous processing loop."""
        while True:
            messages = self.receive_messages()
            for message in messages:
                self.process_message(message)


# Lambda handler for SQS trigger
def lambda_handler(event, context):
    """
    Lambda processes SQS messages in batches.
    Failed messages are retried or sent to DLQ.
    """
    batch_item_failures = []
    
    for record in event['Records']:
        try:
            body = json.loads(record['body'])
            # Process message
            process_order(body)
            
        except Exception as e:
            print(f"Error: {e}")
            # Report partial batch failure
            batch_item_failures.append({
                'itemIdentifier': record['messageId']
            })
    
    return {
        'batchItemFailures': batch_item_failures
    }
```

---

## SNS Deep Dive

### Fan-Out Pattern

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SNS Fan-Out Architecture                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚                         Order Service                                   â”‚
â”‚                              â”‚                                          â”‚
â”‚                              â”‚ Publish                                  â”‚
â”‚                              â–¼                                          â”‚
â”‚                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                 â”‚
â”‚                      â”‚  SNS Topic    â”‚                                 â”‚
â”‚                      â”‚ order-events  â”‚                                 â”‚
â”‚                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                 â”‚
â”‚                              â”‚                                          â”‚
â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚           â–¼                  â–¼                  â–¼                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚   â”‚   SQS Queue   â”‚  â”‚   SQS Queue   â”‚  â”‚    Lambda     â”‚            â”‚
â”‚   â”‚  Inventory    â”‚  â”‚   Shipping    â”‚  â”‚  Analytics    â”‚            â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚           â”‚                  â”‚                  â”‚                      â”‚
â”‚           â–¼                  â–¼                  â–¼                      â”‚
â”‚   Update inventory    Ship order        Stream to                     â”‚
â”‚                                         data lake                      â”‚
â”‚                                                                         â”‚
â”‚   SUBSCRIBER TYPES:                                                    â”‚
â”‚   â€¢ SQS queues (most common)                                           â”‚
â”‚   â€¢ Lambda functions                                                   â”‚
â”‚   â€¢ HTTP/HTTPS endpoints                                               â”‚
â”‚   â€¢ Email addresses                                                    â”‚
â”‚   â€¢ SMS (text messages)                                                â”‚
â”‚   â€¢ Mobile push (iOS, Android)                                         â”‚
â”‚   â€¢ Kinesis Data Firehose                                              â”‚
â”‚                                                                         â”‚
â”‚   FILTERING:                                                            â”‚
â”‚   Subscribers can filter by message attributes:                        â”‚
â”‚   {                                                                     â”‚
â”‚     "order_type": ["premium"],                                         â”‚
â”‚     "amount": [{"numeric": [">=", 1000]}]                             â”‚
â”‚   }                                                                     â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### SNS Implementation

```python
import boto3
import json

sns = boto3.client('sns')

class SNSPublisher:
    def __init__(self, topic_arn: str):
        self.topic_arn = topic_arn
    
    def publish(self, message: dict, 
                subject: str = None,
                attributes: dict = None) -> str:
        """
        Publish message to SNS topic.
        Attributes enable message filtering.
        """
        params = {
            'TopicArn': self.topic_arn,
            'Message': json.dumps(message)
        }
        
        if subject:
            params['Subject'] = subject
        
        # Message attributes for filtering
        if attributes:
            params['MessageAttributes'] = {
                key: {
                    'DataType': 'String',
                    'StringValue': str(value)
                }
                for key, value in attributes.items()
            }
        
        response = sns.publish(**params)
        return response['MessageId']
    
    def publish_batch(self, messages: list) -> dict:
        """Publish up to 10 messages in batch."""
        entries = [
            {
                'Id': str(i),
                'Message': json.dumps(msg['body']),
                'MessageAttributes': {
                    key: {'DataType': 'String', 'StringValue': str(value)}
                    for key, value in msg.get('attributes', {}).items()
                }
            }
            for i, msg in enumerate(messages)
        ]
        
        response = sns.publish_batch(
            TopicArn=self.topic_arn,
            PublishBatchRequestEntries=entries
        )
        
        return response


# Terraform: SNS with SQS subscription and filtering
sns_sqs_fanout = """
resource "aws_sns_topic" "orders" {
  name = "order-events"
}

resource "aws_sqs_queue" "inventory" {
  name = "inventory-updates"
}

resource "aws_sqs_queue" "shipping" {
  name = "shipping-orders"
}

# Subscription with filter
resource "aws_sns_topic_subscription" "inventory_sub" {
  topic_arn     = aws_sns_topic.orders.arn
  protocol      = "sqs"
  endpoint      = aws_sqs_queue.inventory.arn
  
  filter_policy = jsonencode({
    event_type = ["order_created", "order_updated"]
  })
}

# High-value orders only
resource "aws_sns_topic_subscription" "premium_sub" {
  topic_arn     = aws_sns_topic.orders.arn
  protocol      = "sqs"
  endpoint      = aws_sqs_queue.shipping.arn
  
  filter_policy = jsonencode({
    order_value = [{"numeric": [">=", 1000]}]
    shipping_type = ["express", "priority"]
  })
  
  filter_policy_scope = "MessageAttributes"
}

# SQS policy to allow SNS to send messages
resource "aws_sqs_queue_policy" "inventory_policy" {
  queue_url = aws_sqs_queue.inventory.id
  
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Effect    = "Allow"
      Principal = { Service = "sns.amazonaws.com" }
      Action    = "sqs:SendMessage"
      Resource  = aws_sqs_queue.inventory.arn
      Condition = {
        ArnEquals = {
          "aws:SourceArn" = aws_sns_topic.orders.arn
        }
      }
    }]
  })
}
"""
```

---

## EventBridge Deep Dive

### Event-Driven Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    EventBridge Architecture                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚   EVENT SOURCES                    EVENT TARGETS                        â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                        â”‚
â”‚   â€¢ AWS Services (100+)            â€¢ Lambda                             â”‚
â”‚   â€¢ Custom applications            â€¢ Step Functions                     â”‚
â”‚   â€¢ SaaS integrations              â€¢ SQS/SNS                            â”‚
â”‚   â€¢ Scheduled (cron)               â€¢ API Gateway                        â”‚
â”‚                                    â€¢ ECS tasks                          â”‚
â”‚                                    â€¢ Kinesis                            â”‚
â”‚                                                                         â”‚
â”‚   ARCHITECTURE:                                                         â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚                                                                  â”‚  â”‚
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                               â”‚  â”‚
â”‚   â”‚   â”‚ EC2 Events  â”‚â”€â”€â”€â”                                           â”‚  â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚                                           â”‚  â”‚
â”‚   â”‚                     â”‚                                            â”‚  â”‚
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚  â”‚
â”‚   â”‚   â”‚ S3 Events   â”‚â”€â”€â”€â”¼â”€â”€â”€â”€â”€â–¶â”‚  Event Bus  â”‚                      â”‚  â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚      â”‚  (default)  â”‚                      â”‚  â”‚
â”‚   â”‚                     â”‚      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                      â”‚  â”‚
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚             â”‚                             â”‚  â”‚
â”‚   â”‚   â”‚Custom Eventsâ”‚â”€â”€â”€â”˜             â”‚                             â”‚  â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚                             â”‚  â”‚
â”‚   â”‚                                   â”‚                             â”‚  â”‚
â”‚   â”‚                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚  â”‚
â”‚   â”‚                     â–¼             â–¼             â–¼               â”‚  â”‚
â”‚   â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚  â”‚
â”‚   â”‚              â”‚  Rule 1  â”‚  â”‚  Rule 2  â”‚  â”‚  Rule 3  â”‚          â”‚  â”‚
â”‚   â”‚              â”‚ Pattern  â”‚  â”‚ Pattern  â”‚  â”‚ Schedule â”‚          â”‚  â”‚
â”‚   â”‚              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜          â”‚  â”‚
â”‚   â”‚                   â”‚             â”‚             â”‚                 â”‚  â”‚
â”‚   â”‚                   â–¼             â–¼             â–¼                 â”‚  â”‚
â”‚   â”‚              Lambda         SQS Queue     Step Func            â”‚  â”‚
â”‚   â”‚                                                                  â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                         â”‚
â”‚   VS SNS:                                                               â”‚
â”‚   â€¢ Content-based filtering (not just attributes)                      â”‚
â”‚   â€¢ Schema discovery and validation                                    â”‚
â”‚   â€¢ 200+ AWS service integrations built-in                             â”‚
â”‚   â€¢ Scheduled events (cron)                                            â”‚
â”‚   â€¢ Archive and replay events                                          â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### EventBridge Implementation

```python
import boto3
import json
from datetime import datetime

events = boto3.client('events')

class EventBridgePublisher:
    def __init__(self, event_bus_name: str = 'default'):
        self.event_bus_name = event_bus_name
    
    def put_event(self, source: str, detail_type: str, 
                  detail: dict) -> str:
        """
        Publish custom event to EventBridge.
        """
        response = events.put_events(
            Entries=[
                {
                    'Source': source,
                    'DetailType': detail_type,
                    'Detail': json.dumps(detail),
                    'EventBusName': self.event_bus_name,
                    'Time': datetime.utcnow()
                }
            ]
        )
        
        if response['FailedEntryCount'] > 0:
            raise Exception(f"Failed to put event: {response['Entries']}")
        
        return response['Entries'][0]['EventId']
    
    def put_events_batch(self, events_list: list) -> dict:
        """Publish up to 10 events in batch."""
        entries = [
            {
                'Source': event['source'],
                'DetailType': event['detail_type'],
                'Detail': json.dumps(event['detail']),
                'EventBusName': self.event_bus_name,
                'Time': datetime.utcnow()
            }
            for event in events_list
        ]
        
        response = events.put_events(Entries=entries)
        return {
            'successful': len(entries) - response['FailedEntryCount'],
            'failed': response['FailedEntryCount']
        }


# Event patterns for rules
event_patterns = {
    # Match specific EC2 state changes
    "ec2_instance_stopped": {
        "source": ["aws.ec2"],
        "detail-type": ["EC2 Instance State-change Notification"],
        "detail": {
            "state": ["stopped", "terminated"]
        }
    },
    
    # Match custom order events over $1000
    "high_value_orders": {
        "source": ["com.myapp.orders"],
        "detail-type": ["OrderCreated"],
        "detail": {
            "amount": [{"numeric": [">=", 1000]}],
            "status": ["confirmed"]
        }
    },
    
    # Match S3 object creation in specific prefix
    "s3_uploads": {
        "source": ["aws.s3"],
        "detail-type": ["Object Created"],
        "detail": {
            "bucket": {"name": ["my-bucket"]},
            "object": {
                "key": [{"prefix": "uploads/"}]
            }
        }
    }
}

# Terraform: EventBridge rule with Lambda target
eventbridge_rule = """
resource "aws_cloudwatch_event_rule" "order_processing" {
  name        = "high-value-orders"
  description = "Route high-value orders to premium processing"
  
  event_pattern = jsonencode({
    source      = ["com.myapp.orders"]
    detail-type = ["OrderCreated"]
    detail = {
      amount = [{ numeric = [">=", 1000] }]
    }
  })
}

resource "aws_cloudwatch_event_target" "lambda" {
  rule      = aws_cloudwatch_event_rule.order_processing.name
  target_id = "ProcessHighValueOrder"
  arn       = aws_lambda_function.premium_processor.arn
  
  # Transform event before sending to target
  input_transformer {
    input_paths = {
      orderId = "$.detail.orderId"
      amount  = "$.detail.amount"
    }
    input_template = <<EOF
{
  "order_id": <orderId>,
  "amount": <amount>,
  "priority": "high"
}
EOF
  }
}

# Scheduled rule (cron)
resource "aws_cloudwatch_event_rule" "daily_report" {
  name                = "daily-sales-report"
  description         = "Trigger daily sales report generation"
  schedule_expression = "cron(0 8 * * ? *)"  # 8 AM UTC daily
}
"""
```

---

## Step Functions

### Workflow Orchestration

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Step Functions Workflow                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚   ORDER PROCESSING WORKFLOW:                                            â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                            â”‚
â”‚                                                                         â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                      â”‚
â”‚   â”‚   Start     â”‚                                                      â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                                                      â”‚
â”‚          â”‚                                                              â”‚
â”‚          â–¼                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                      â”‚
â”‚   â”‚  Validate   â”‚â”€â”€â”€â”€ Error â”€â”€â”€â”€â–¶ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚   â”‚   Order     â”‚                  â”‚   Notify    â”‚                     â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                  â”‚   Failure   â”‚                     â”‚
â”‚          â”‚ Success                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚          â–¼                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”‚
â”‚   â”‚         Parallel Processing          â”‚                              â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚                              â”‚
â”‚   â”‚  â”‚  Check    â”‚    â”‚  Reserve  â”‚     â”‚                              â”‚
â”‚   â”‚  â”‚ Inventory â”‚    â”‚  Payment  â”‚     â”‚                              â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚                              â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â”‚
â”‚                          â”‚                                              â”‚
â”‚                          â–¼                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     Choice                                           â”‚
â”‚   â”‚Ship Express â”‚â—€â”€â”€â”€â”€ Premium? â”€â”€â”€â”€â–¶â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â”‚          â”‚Ship Standardâ”‚                   â”‚
â”‚          â”‚                â”‚          â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                           â–¼                                             â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                     â”‚
â”‚                    â”‚   Wait 5s   â”‚                                     â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                                     â”‚
â”‚                           â–¼                                             â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                     â”‚
â”‚                    â”‚   Notify    â”‚                                     â”‚
â”‚                    â”‚  Customer   â”‚                                     â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                                     â”‚
â”‚                           â–¼                                             â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                     â”‚
â”‚                    â”‚    End      â”‚                                     â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                     â”‚
â”‚                                                                         â”‚
â”‚   WORKFLOW TYPES:                                                       â”‚
â”‚   â€¢ Standard: Long-running, exactly-once, audit history               â”‚
â”‚   â€¢ Express: High-volume, at-least-once, short duration (<5min)       â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Step Functions ASL Definition

```json
{
  "Comment": "Order Processing Workflow",
  "StartAt": "ValidateOrder",
  "States": {
    "ValidateOrder": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:us-east-1:123456789:function:ValidateOrder",
      "Catch": [{
        "ErrorEquals": ["ValidationError"],
        "Next": "NotifyFailure"
      }],
      "Retry": [{
        "ErrorEquals": ["Lambda.ServiceException"],
        "IntervalSeconds": 2,
        "MaxAttempts": 3,
        "BackoffRate": 2.0
      }],
      "Next": "ParallelProcessing"
    },
    
    "ParallelProcessing": {
      "Type": "Parallel",
      "Branches": [
        {
          "StartAt": "CheckInventory",
          "States": {
            "CheckInventory": {
              "Type": "Task",
              "Resource": "arn:aws:lambda:us-east-1:123456789:function:CheckInventory",
              "End": true
            }
          }
        },
        {
          "StartAt": "ReservePayment",
          "States": {
            "ReservePayment": {
              "Type": "Task",
              "Resource": "arn:aws:lambda:us-east-1:123456789:function:ReservePayment",
              "End": true
            }
          }
        }
      ],
      "Next": "ChooseShipping"
    },
    
    "ChooseShipping": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.order.isPremium",
          "BooleanEquals": true,
          "Next": "ShipExpress"
        }
      ],
      "Default": "ShipStandard"
    },
    
    "ShipExpress": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:us-east-1:123456789:function:ShipExpress",
      "Next": "WaitForProcessing"
    },
    
    "ShipStandard": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:us-east-1:123456789:function:ShipStandard",
      "Next": "WaitForProcessing"
    },
    
    "WaitForProcessing": {
      "Type": "Wait",
      "Seconds": 5,
      "Next": "NotifyCustomer"
    },
    
    "NotifyCustomer": {
      "Type": "Task",
      "Resource": "arn:aws:states:::sns:publish",
      "Parameters": {
        "TopicArn": "arn:aws:sns:us-east-1:123456789:order-notifications",
        "Message.$": "States.Format('Order {} shipped!', $.orderId)"
      },
      "End": true
    },
    
    "NotifyFailure": {
      "Type": "Task",
      "Resource": "arn:aws:states:::sns:publish",
      "Parameters": {
        "TopicArn": "arn:aws:sns:us-east-1:123456789:order-failures",
        "Message.$": "$.error"
      },
      "End": true
    }
  }
}
```

---

## API Gateway Integration

### Direct Service Integrations

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    API Gateway Direct Integrations                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚   Skip Lambda for simple operations:                                   â”‚
â”‚                                                                         â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚                                                                  â”‚  â”‚
â”‚   â”‚   API Gateway â”€â”€â–¶ SQS (SendMessage)                             â”‚  â”‚
â”‚   â”‚   API Gateway â”€â”€â–¶ SNS (Publish)                                 â”‚  â”‚
â”‚   â”‚   API Gateway â”€â”€â–¶ Step Functions (StartExecution)               â”‚  â”‚
â”‚   â”‚   API Gateway â”€â”€â–¶ DynamoDB (PutItem, GetItem, Query)            â”‚  â”‚
â”‚   â”‚   API Gateway â”€â”€â–¶ EventBridge (PutEvents)                       â”‚  â”‚
â”‚   â”‚   API Gateway â”€â”€â–¶ Kinesis (PutRecord)                           â”‚  â”‚
â”‚   â”‚                                                                  â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                         â”‚
â”‚   BENEFITS:                                                             â”‚
â”‚   â€¢ No Lambda cold starts                                               â”‚
â”‚   â€¢ Lower cost (no Lambda execution)                                   â”‚
â”‚   â€¢ Lower latency                                                       â”‚
â”‚   â€¢ Simpler architecture                                                â”‚
â”‚                                                                         â”‚
â”‚   LIMITATIONS:                                                          â”‚
â”‚   â€¢ Limited transformation logic                                       â”‚
â”‚   â€¢ VTL templating required                                            â”‚
â”‚   â€¢ Complex error handling                                              â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### API Gateway to SQS Direct Integration

```yaml
# OpenAPI with API Gateway extensions
openapi: 3.0.0
info:
  title: Order API
  version: 1.0.0

paths:
  /orders:
    post:
      summary: Submit order to queue
      x-amazon-apigateway-integration:
        type: aws
        httpMethod: POST
        uri: arn:aws:apigateway:us-east-1:sqs:path/123456789012/orders-queue
        credentials: arn:aws:iam::123456789012:role/APIGatewaySQSRole
        requestParameters:
          integration.request.header.Content-Type: "'application/x-www-form-urlencoded'"
        requestTemplates:
          application/json: |
            Action=SendMessage&MessageBody=$util.urlEncode($input.body)&MessageAttribute.1.Name=source&MessageAttribute.1.Value.StringValue=api&MessageAttribute.1.Value.DataType=String
        responses:
          "200":
            statusCode: 202
            responseTemplates:
              application/json: |
                {
                  "messageId": "$input.path('$.SendMessageResponse.SendMessageResult.MessageId')",
                  "status": "queued"
                }
```

---

## ğŸ¯ Interview Questions

<AccordionGroup>
  <Accordion title="Q1: SQS vs SNS vs EventBridge - when to use each?">
    **SQS:**
    - Point-to-point messaging
    - Decoupling with buffering
    - One consumer per message
    - Need message persistence
    
    **SNS:**
    - Fan-out to multiple subscribers
    - Push-based delivery
    - Simple attribute filtering
    - Mobile push, email, SMS
    
    **EventBridge:**
    - Event-driven architectures
    - Content-based filtering (JSON path)
    - AWS service integration
    - Schema registry
    - Event archive/replay
    
    **Combined pattern:** Event â†’ EventBridge â†’ SNS â†’ Multiple SQS queues
  </Accordion>
  
  <Accordion title="Q2: How do you handle poison messages in SQS?">
    **Dead Letter Queue (DLQ) pattern:**
    
    1. Configure `maxReceiveCount` on source queue
    2. After N failed processing attempts, message moves to DLQ
    3. Set up CloudWatch alarm on DLQ depth
    4. Process DLQ separately:
       - Manual review
       - Automated retry with fixes
       - Archive for analysis
    
    **Best practices:**
    - DLQ retention longer than source (14 days)
    - Same queue type (Standard/FIFO)
    - Monitor `ApproximateNumberOfMessagesVisible`
  </Accordion>
  
  <Accordion title="Q3: Explain SQS visibility timeout and how to set it.">
    **Visibility timeout:**
    - Time a message is hidden after being received
    - Prevents other consumers from processing same message
    - If not deleted in time, message reappears
    
    **Setting it correctly:**
    - Should be longer than processing time
    - Too short = duplicate processing
    - Too long = delayed retry on failure
    
    **Dynamic extension:**
    ```python
    # For long-running tasks
    sqs.change_message_visibility(
        QueueUrl=url,
        ReceiptHandle=handle,
        VisibilityTimeout=additional_seconds
    )
    ```
  </Accordion>
  
  <Accordion title="Q4: How do you ensure exactly-once processing with SQS?">
    **For FIFO queues:**
    - Built-in deduplication (5-minute window)
    - Message deduplication ID
    - Content-based deduplication
    
    **For Standard queues (at-least-once):**
    - Idempotent consumers
    - Store processed message IDs in DynamoDB
    - Use conditional writes
    
    ```python
    # Idempotency check
    try:
        dynamodb.put_item(
            TableName='processed-messages',
            Item={'messageId': message_id},
            ConditionExpression='attribute_not_exists(messageId)'
        )
        # Process message
    except ConditionalCheckFailedException:
        # Already processed, skip
        pass
    ```
  </Accordion>
  
  <Accordion title="Q5: Design a saga pattern using Step Functions.">
    **Saga for distributed transactions:**
    
    ```
    Order Saga:
    1. Reserve Inventory â†’ Success â†’ Continue
                        â†’ Fail â†’ End
    
    2. Charge Payment â†’ Success â†’ Continue
                      â†’ Fail â†’ Compensate: Release Inventory
    
    3. Ship Order â†’ Success â†’ End
                  â†’ Fail â†’ Compensate: Refund Payment
                         â†’ Compensate: Release Inventory
    ```
    
    **Step Functions features:**
    - Catch blocks for compensation
    - Parallel branches for concurrent steps
    - Wait states for human approval
    - Express workflows for high-volume
    
    **Key pattern:** Each step has a compensating transaction
  </Accordion>
</AccordionGroup>

---

## ğŸ§ª Hands-On Lab: Event-Driven Order System

<Steps>
  <Step title="Create SNS Topic">
    Topic for order events with filter policies
  </Step>
  
  <Step title="Create SQS Queues">
    Inventory queue, shipping queue with DLQs
  </Step>
  
  <Step title="Set Up Fan-Out">
    Subscribe queues to SNS with filters
  </Step>
  
  <Step title="Create EventBridge Rule">
    High-value order detection with Lambda target
  </Step>
  
  <Step title="Build Step Functions Workflow">
    Order processing with parallel steps and error handling
  </Step>
  
  <Step title="Test End-to-End">
    Publish events, verify all systems receive appropriate messages
  </Step>
</Steps>

---

## Next Module

<Card title="DevOps & CI/CD" icon="code-branch" href="/aws/devops-cicd">
  Master CodePipeline, CloudFormation, CDK, and infrastructure automation
</Card>
